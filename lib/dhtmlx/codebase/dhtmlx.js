///<jscompress sourcefile="dhtmlxcommon.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/* dhtmlx.com */

if (typeof(window.dhx) == "undefined") {
	
	window.dhx = window.dhx4 = {
		
		version: "5.0.8",
		
		skin: null, // allow to be set by user
		
		skinDetect: function(comp) {
			var i = Math.floor(dhx4.readFromCss(comp+"_skin_detect")/10)*10;
			return {10:"dhx_skyblue",20:"dhx_web",30:"dhx_terrace",40:"material"}[i]||null;
		},
		
		// read value from css
		readFromCss: function(className, property, innerHTML) {
			var t = document.createElement("DIV");
			t.className = className;
			if (document.body.firstChild != null) document.body.insertBefore(t, document.body.firstChild); else document.body.appendChild(t);
			if (typeof(innerHTML) == "string") t.innerHTML = innerHTML;
			var w = t[property||"offsetWidth"];
			t.parentNode.removeChild(t);
			t = null;
			return w;
		},
		
		// id manager
		lastId: 1,
		newId: function() {
			return this.lastId++;
		},
		
		// z-index manager
		zim: {
			data: {},
			step: 5,
			first: function() {
				return 100;
			},
			last: function() {
				var t = this.first();
				for (var a in this.data) t = Math.max(t, this.data[a]);
				return t;
			},
			reserve: function(id) {
				this.data[id] = this.last()+this.step;
				return this.data[id];
			},
			clear: function(id) {
				if (this.data[id] != null) {
					this.data[id] = null;
					delete this.data[id];
				}
			}
		},
		
		// string to boolean
		s2b: function(r) {
			if (typeof(r) == "string") r = r.toLowerCase();
			return (r == true || r == 1 || r == "true" || r == "1" || r == "yes" || r == "y" || r == "on");
		},
		
		// string to json
		s2j: function(s) {
			var obj = null;
			dhx4.temp = null;
			try { eval("dhx4.temp="+s); } catch(e) { dhx4.temp = null; }
			obj = dhx4.temp;
			dhx4.temp = null;
			return obj;
		},
		
		// absolute top/left position on screen
		absLeft: function(obj) {
			if (typeof(obj) == "string") obj = document.getElementById(obj);
			return this.getOffset(obj).left;
		},
		absTop: function(obj) {
			if (typeof(obj) == "string") obj = document.getElementById(obj);
			return this.getOffset(obj).top;
		},
		_aOfs: function(elem) {
			var top = 0, left = 0;
			while (elem) {
				top = top + parseInt(elem.offsetTop);
				left = left + parseInt(elem.offsetLeft);
				elem = elem.offsetParent;
			}
			return {top: top, left: left};
		},
		_aOfsRect: function(elem) {
			var box = elem.getBoundingClientRect();
			var body = document.body;
			var docElem = document.documentElement;
			var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
			var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
			var clientTop = docElem.clientTop || body.clientTop || 0;
			var clientLeft = docElem.clientLeft || body.clientLeft || 0;
			var top  = box.top +  scrollTop - clientTop;
			var left = box.left + scrollLeft - clientLeft;
			return { top: Math.round(top), left: Math.round(left) };
		},
		getOffset: function(elem) {
			if (elem.getBoundingClientRect) {
				return this._aOfsRect(elem);
			} else {
				return this._aOfs(elem);
			}
		},
		
		// copy obj
		_isObj: function(k) {
			return (k != null && typeof(k) == "object" && typeof(k.length) == "undefined");
		},
		_copyObj: function(r) {
			if (this._isObj(r)) {
				var t = {};
				for (var a in r) {
					if (typeof(r[a]) == "object" && r[a] != null) t[a] = this._copyObj(r[a]); else t[a] = r[a];
				}
			} else {
				var t = [];
				for (var a=0; a<r.length; a++) {
					if (typeof(r[a]) == "object" && r[a] != null) t[a] = this._copyObj(r[a]); else t[a] = r[a];
				}
			}
			return t;
		},
		
		// screen dim
		screenDim: function() {
			var isIE = (navigator.userAgent.indexOf("MSIE") >= 0);
			var dim = {};
			dim.left = document.body.scrollLeft;
			dim.right = dim.left+(window.innerWidth||document.body.clientWidth);
			dim.top = Math.max((isIE?document.documentElement:document.getElementsByTagName("html")[0]).scrollTop, document.body.scrollTop);
			dim.bottom = dim.top+(isIE?Math.max(document.documentElement.clientHeight||0,document.documentElement.offsetHeight||0):window.innerHeight);
			return dim;
		},
		
		// input/textarea range selection
		selectTextRange: function(inp, start, end) {
			
			inp = (typeof(inp)=="string"?document.getElementById(inp):inp);
			
			var len = inp.value.length;
			start = Math.max(Math.min(start, len), 0);
			end = Math.min(end, len);
			
			if (inp.setSelectionRange) {
				try {inp.setSelectionRange(start, end);} catch(e){}; // combo in grid under IE requires try/catch
			} else if (inp.createTextRange) {
				var range = inp.createTextRange();
				range.moveStart("character", start);
				range.moveEnd("character", end-len);
				try {range.select();} catch(e){};
			}
		},
		// transition
		transData: null,
		transDetect: function() {
			
			if (this.transData == null) {
				
				this.transData = {transProp: false, transEv: null};
				
				// transition, MozTransition, WebkitTransition, msTransition, OTransition
				var k = {
					"MozTransition": "transitionend",
					"WebkitTransition": "webkitTransitionEnd",
					"OTransition": "oTransitionEnd",
					"msTransition": "transitionend",
					"transition": "transitionend"
				};
				
				for (var a in k) {
					if (this.transData.transProp == false && document.documentElement.style[a] != null) {
						this.transData.transProp = a;
						this.transData.transEv = k[a];
					}
				}
				k = null;
			}
			
			return this.transData;
			
		},
		
		// xml parser
		_xmlNodeValue: function(node) {
			var value = "";
			for (var q=0; q<node.childNodes.length; q++) {
				value += (node.childNodes[q].nodeValue!=null?node.childNodes[q].nodeValue.toString().replace(/^[\n\r\s]{0,}/,"").replace(/[\n\r\s]{0,}$/,""):"");
			}
			return value;
		}
		
	};
	
	// browser
	window.dhx4.isIE = (navigator.userAgent.indexOf("MSIE") >= 0 || navigator.userAgent.indexOf("Trident") >= 0);
	window.dhx4.isIE6 = (window.XMLHttpRequest == null && navigator.userAgent.indexOf("MSIE") >= 0);
	window.dhx4.isIE7 = (navigator.userAgent.indexOf("MSIE 7.0") >= 0 && navigator.userAgent.indexOf("Trident") < 0);
	window.dhx4.isIE8 = (navigator.userAgent.indexOf("MSIE 8.0") >= 0 && navigator.userAgent.indexOf("Trident") >= 0);
	window.dhx4.isIE9 = (navigator.userAgent.indexOf("MSIE 9.0") >= 0 && navigator.userAgent.indexOf("Trident") >= 0);
	window.dhx4.isIE10 = (navigator.userAgent.indexOf("MSIE 10.0") >= 0 && navigator.userAgent.indexOf("Trident") >= 0 && window.navigator.pointerEnabled != true);
	window.dhx4.isIE11 = (navigator.userAgent.indexOf("Trident") >= 0 && window.navigator.pointerEnabled == true);
	window.dhx4.isEdge = (navigator.userAgent.indexOf("Edge") >= 0);
	window.dhx4.isOpera = (navigator.userAgent.indexOf("Opera") >= 0);
	window.dhx4.isChrome = (navigator.userAgent.indexOf("Chrome") >= 0) && !window.dhx4.isEdge;
	window.dhx4.isKHTML = (navigator.userAgent.indexOf("Safari") >= 0 || navigator.userAgent.indexOf("Konqueror") >= 0) && !window.dhx4.isEdge;
	window.dhx4.isFF = (navigator.userAgent.indexOf("Firefox") >= 0);
	window.dhx4.isIPad = (navigator.userAgent.search(/iPad/gi) >= 0);
	
	// dnd data
	window.dhx4.dnd = {
		evs: {},
		p_en: ((window.dhx4.isIE || window.dhx4.isEdge) && (window.navigator.pointerEnabled || window.navigator.msPointerEnabled)), // touch/pointer
		_mTouch: function(e) {
			// mouse touch type in ie10/11/Edge
			return (window.dhx4.isIE10 && e.pointerType == e.MSPOINTER_TYPE_MOUSE || window.dhx4.isIE11 && e.pointerType == "mouse" || window.dhx4.isEdge && e.pointerType == "mouse");
		},
		_touchOn: function(obj) {
			if (obj == null) obj = document.body;
			obj.style.touchAction = obj.style.msTouchAction = "";
			obj = null;
		},
		_touchOff: function(obj) {
			if (obj == null) obj = document.body;
			obj.style.touchAction = obj.style.msTouchAction = "none";
			obj = null;
		}
	};
	
	// dnd events
	if (window.navigator.pointerEnabled == true) { // edge/ie11
		window.dhx4.dnd.evs = {start: "pointerdown", move: "pointermove", end: "pointerup"};
	} else if (window.navigator.msPointerEnabled == true) { // ie10-
		window.dhx4.dnd.evs = {start: "MSPointerDown", move: "MSPointerMove", end: "MSPointerUp"};
	} else if (typeof(window.addEventListener) != "undefined") { // rest touch devices
		window.dhx4.dnd.evs = {start: "touchstart", move: "touchmove", end: "touchend"};
	};
	
};

if (typeof(window.dhx4.template) == "undefined") {
	
	// trim
	window.dhx4.trim = function(t) {
		return String(t).replace(/^\s{1,}/,"").replace(/\s{1,}$/,"");
	};
	
	// template parsing
	window.dhx4.template = function(tpl, data, trim) {
		
		// tpl - template text, #value|func:param0:param1:paramX#
		// data - object with key-value
		// trim - true/false, trim values
		return tpl.replace(/#([a-z0-9_-]{1,})(\|([^#]*))?#/gi, function(){
			
			var key = arguments[1];
			
			var t = window.dhx4.trim(arguments[3]);
			var func = null;
			var args = [data[key]];
			
			if (t.length > 0) {
				
				t = t.split(":");
				var k = [];
				
				// check escaped colon
				for (var q=0; q<t.length; q++) {
					if (q > 0 && k[k.length-1].match(/\\$/) != null) {
						k[k.length-1] = k[k.length-1].replace(/\\$/,"")+":"+t[q];
					} else {
						k.push(t[q]);
					}
				}
				
				func = k[0];
				for (var q=1; q<k.length; q++) args.push(k[q]);
				
			}
			
			// via inner function
			if (typeof(func) == "string" && typeof(window.dhx4.template[func]) == "function") {
				return window.dhx4.template[func].apply(window.dhx4.template, args);
			}
			
			// value only
			if (key.length > 0 && typeof(data[key]) != "undefined") {
				if (trim == true) return window.dhx4.trim(data[key]);
				return String(data[key]);
			}
			
			// key not found
			return "";
			
		});
		
	};
	
	window.dhx4.template.date = function(value, format) {
		// Date obj + format	=> convert to string
		// timestamp + format	=> convert to string
		// string		=> no convert
		// any other value	=> empty string
		if (value != null) {
			if (value instanceof Date) {
				return window.dhx4.date2str(value, format);
			} else {
				value = value.toString();
				if (value.match(/^\d*$/) != null) return window.dhx4.date2str(new Date(parseInt(value)), format);
				return value;
			}
		}
		return "";
	};
	
	window.dhx4.template.maxlength = function(value, limit) {
		return String(value).substr(0, limit);
	};
	
	window.dhx4.template.number_format = function(value, format, group_sep, dec_sep) {
		var fmt = window.dhx4.template._parseFmt(format, group_sep, dec_sep);
		if (fmt == false) return value;
		return window.dhx4.template._getFmtValue(value, fmt);
	};
	
	window.dhx4.template.lowercase = function(value) {
		if (typeof(value) == "undefined" || value == null) value = "";
		return String(value).toLowerCase();
	};
	window.dhx4.template.uppercase = function(value) {
		if (typeof(value) == "undefined" || value == null) value = "";
		return String(value).toUpperCase();
	};
	
	// number format helpers
	window.dhx4.template._parseFmt = function(format, group_sep, dec_sep) {
		
		var t = format.match(/^([^\.\,0-9]*)([0\.\,]*)([^\.\,0-9]*)/);
		if (t == null || t.length != 4) return false; // invalid format
		
		var fmt = {
			// int group
			i_len: false,
			i_sep: (typeof(group_sep)=="string"?group_sep:","),
			// decimal
			d_len: false,
			d_sep: (typeof(dec_sep)=="string"?dec_sep:"."),
			// chars before and after
			s_bef: (typeof(t[1])=="string"?t[1]:""),
			s_aft: (typeof(t[3])=="string"?t[3]:"")
		};
		
		var f = t[2].split(".");
		if (f[1] != null) fmt.d_len = f[1].length;
		
		var r = f[0].split(",");
		if (r.length > 1) fmt.i_len = r[r.length-1].length;
		
		return fmt;
		
	};
	
	window.dhx4.template._getFmtValue = function(value, fmt) {
		
		var r = String(value).match(/^(-)?([0-9]{1,})(\.([0-9]{1,}))?$/); // r = [complete value, minus sign, integer, full decimal, decimal]
		
		if (r != null && r.length == 5) {
			var v0 = "";
			// minus sign
			if (r[1] != null) v0 += r[1];
			// chars before
			v0 += fmt.s_bef;
			// int part
			if (fmt.i_len !== false) {
				var i = 0; var v1 = "";
				for (var q=r[2].length-1; q>=0; q--) {
					v1 = ""+r[2].charAt(q)+v1;
					if (++i == fmt.i_len && q > 0) { v1=fmt.i_sep+v1; i=0; }
				}
				v0 += v1;
			} else {
				v0 += r[2];
			}
			// dec part
			if (fmt.d_len !== false) {
				if (r[4] == null) r[4] = "";
				while (r[4].length < fmt.d_len) r[4] += "0";
				eval("dhx4.temp = new RegExp(/\\d{"+fmt.d_len+"}/);");
				var t1 = (r[4]).match(dhx4.temp);
				if (t1 != null) v0 += fmt.d_sep+t1;
				dhx4.temp = t1 = null;
			}
			// chars after
			v0 += fmt.s_aft;
			
			return v0;
		}
		
		return value;
	};
	
};

if (typeof(window.dhx4.dateLang) == "undefined") {
	
	window.dhx4.dateLang = "en";
	window.dhx4.dateStrings = {
		en: {
			monthFullName:	["January","February","March","April","May","June","July","August","September","October","November","December"],
			monthShortName:	["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],
			dayFullName:	["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
			dayShortName:	["Su","Mo","Tu","We","Th","Fr","Sa"]
		}
	};
	window.dhx4.dateFormat = {
		en: "%Y-%m-%d"
	};
	
	window.dhx4.date2str = function(val, format, strings) {
		
		if (format == null || typeof(format) == "undefined") format = window.dhx4.dateFormat[window.dhx4.dateLang];
		if (strings == null || typeof(strings) == "undefined") strings = window.dhx4.dateStrings[window.dhx4.dateLang];
		
		if (val instanceof Date) {
			var z = function(t) {
				return (String(t).length==1?"0"+String(t):t);
			}
			var k = function(t) {
				switch(t) {
					case "%d": return z(val.getDate());
					case "%j": return val.getDate();
					case "%D": return strings.dayShortName[val.getDay()];
					case "%l": return strings.dayFullName[val.getDay()];
					case "%m": return z(val.getMonth()+1);
					case "%n": return val.getMonth()+1;
					case "%M": return strings.monthShortName[val.getMonth()];
					case "%F": return strings.monthFullName[val.getMonth()];
					case "%y": return z(val.getYear()%100);
					case "%Y": return val.getFullYear();
					case "%g": return (val.getHours()+11)%12+1;
					case "%h": return z((val.getHours()+11)%12+1);
					case "%G": return val.getHours();
					case "%H": return z(val.getHours());
					case "%i": return z(val.getMinutes());
					case "%s": return z(val.getSeconds());
					case "%a": return (val.getHours()>11?"pm":"am");
					case "%A": return (val.getHours()>11?"PM":"AM");
					case "%%": return "%";
					case "%u": return val.getMilliseconds();
					case "%P":
						if (window.dhx4.temp_calendar != null && window.dhx4.temp_calendar.tz != null) return window.dhx4.temp_calendar.tz;
						var ofs = val.getTimezoneOffset();
						var h = Math.abs(Math.floor(ofs/60));
						var m = Math.abs(ofs)-h*60;
						return (ofs>0?"-":"+")+z(h)+":"+z(m);
					default: return t;
				}
			}
			var t = String(format||window.dhx4.dateFormat).replace(/%[a-zA-Z]/g, k);
		}
		
		return (t||String(val));
		
	};
	
	window.dhx4.str2date = function(val, format, strings) {
		
		if (format == null || typeof(format) == "undefined") format = window.dhx4.dateFormat[window.dhx4.dateLang];
		if (strings == null || typeof(strings) == "undefined") strings = window.dhx4.dateStrings[window.dhx4.dateLang];
		
		// escape custom chars
		format = format.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\\:|]/g, "\\$&");
		
		var v = [];
		var f = [];
		
		// escape required chars
		format = format.replace(/%[a-z]/gi, function(t){
			switch (t) {
				case "%d": case "%m": case "%y": case "%h": case "%H": case "%i": case "%s": f.push(t); return "(\\d{2})"; // 2 digits
				case "%D": case "%l": case "%M": case "%F": f.push(t); return "([a-zéûä\u0430-\u044F\u0451]{1,})"; // chars
				case "%j": case "%n": case "%g": case "%G": f.push(t); return "(\\d{1,2})"; // 1-2 digits
				case "%Y": f.push(t); return "(\\d{4})"; // 4 digits
				case "%a": f.push(t); return "([a|p]m)"; // am/pm
				case "%A": f.push(t); return "([A|P]M)"; // AM/PM
				case "%u": f.push(t); return "(\\d{1,6})"; // 1-6 digits, micro/milliseconds
				case "%P": f.push(t); return "([+-]\\d{1,2}:\\d{1,2})"; // zone offset
			}
			return t;
		});
		
		var re = new RegExp(format, "i");
		var e = val.match(re);
		
		if (e == null || e.length-1 != f.length) return "Invalid Date";
		
		// sorting
		/*
		Year	y,Y	1
		Month	n,m,M,F	2
		Day	d,j	3
		AM/PM	a,A	4
		Hours	H,G,h,g	5
		Minutes	i	6
		Seconds	s	7
		MSec	u	7
		Zone 	P	7
		*/
		
		for (var q=1; q<e.length; q++) v.push(e[q]);
		
		var p = {"%y":1,"%Y":1,"%n":2,"%m":2,"%M":2,"%F":2,"%d":3,"%j":3,"%a":4,"%A":4,"%H":5,"%G":5,"%h":5,"%g":5,"%i":6,"%s":7,"%u":7,"%P":7};
		var v2 = {};
		var f2 = {};
		for (var q=0; q<f.length; q++) {
			if (typeof(p[f[q]]) != "undefined") {
				var ind = p[f[q]];
				if (!v2[ind]){v2[ind]=[];f2[ind]=[];}
				v2[ind].push(v[q]);
				f2[ind].push(f[q]);
			}
		}
		v = [];
		f = [];
		for (var q=1; q<=7; q++) {
			if (v2[q] != null) {
				for (var w=0; w<v2[q].length; w++) {
					v.push(v2[q][w]);
					f.push(f2[q][w]);
				}
			}
		}
		
		// parsing date
		var r = new Date();
		r.setDate(1); // fix for 31th
		r.setHours(0);
		r.setMinutes(0);
		r.setSeconds(0);
		r.setMilliseconds(0);
		
		// get index by value
		var getInd = function(val, ar) {
			for (var q=0; q<ar.length; q++) if (ar[q].toLowerCase() == val) return q;
			return -1;
		}
		
		for (var q=0; q<v.length; q++) {
			switch (f[q]) {
				case "%d": case "%j": case "%n": case "%m": case "%Y": case "%H": case "%G": case "%i": case "%s": case "%u":
					if (!isNaN(v[q])) r[{"%d":"setDate","%j":"setDate","%n":"setMonth","%m":"setMonth","%Y":"setFullYear","%H":"setHours","%G":"setHours","%i":"setMinutes","%s":"setSeconds","%u":"setMilliseconds"}[f[q]]](Number(v[q])+(f[q]=="%m"||f[q]=="%n"?-1:0));
					break;
				//
				case "%M": case "%F":
					var k = getInd(v[q].toLowerCase(),strings[{"%M":"monthShortName","%F":"monthFullName"}[f[q]]]);
					if (k >= 0) r.setMonth(k);
					break;
				//
				case "%y":
					if (!isNaN(v[q])) {
						var v0 = Number(v[q]);
						r.setFullYear(v0+(v0>50?1900:2000));
					}
					break;
				//
				case "%g": case "%h":
					if (!isNaN(v[q])) {
						var v0 = Number(v[q]);
						if (v0 <= 12 && v0 >= 0) r.setHours(v0+(getInd("pm",v)>=0?(v0==12?0:12):(v0==12?-12:0))); // 12:00 AM -> midnight, 12:00 PM -> noon
					}
					break;
				//
				case "%P":
					if (window.dhx4.temp_calendar != null) {
						window.dhx4.temp_calendar.tz = v[q];
					}
					break;
			}
		}
		return r;
	};
	
};

if (typeof(window.dhx4.ajax) == "undefined") {
	
	window.dhx4.ajax = {
		
		// if false - dhxr param will added to prevent caching on client side (default),
		// if true - do not add extra params
		cache: false,
		
		// default method for load/loadStruct, post/get allowed
		// get - since 4.1.1, this should fix 412 error for macos safari
		method: "get",
		
		parse: function(data) {
			if (typeof data !== "string") return data;
			
			data = data.replace(/^[\s]+/,"");
			if (window.DOMParser && !dhx4.isIE) { // ff,ie9
				var obj = (new window.DOMParser()).parseFromString(data, "text/xml");
			} else if (window.ActiveXObject !== window.undefined) {
				var obj = new window.ActiveXObject("Microsoft.XMLDOM");
				obj.async = "false";
				obj.loadXML(data);
			}
			return obj;
		},
		xmltop: function(tagname, xhr, obj) {
			if (typeof xhr.status == "undefined" || xhr.status < 400) {
				xml = (!xhr.responseXML) ? dhx4.ajax.parse(xhr.responseText || xhr) : (xhr.responseXML || xhr);
				if (xml && xml.documentElement !== null) {
					try {
						if (!xml.getElementsByTagName("parsererror").length)
							return xml.getElementsByTagName(tagname)[0];
					} catch(e){}
				}
			}
			if (obj !== -1) dhx4.callEvent("onLoadXMLError",["Incorrect XML", arguments[1], obj]);
			return document.createElement("DIV");
		},
		xpath: function(xpathExp, docObj) {
			if (!docObj.nodeName) docObj = docObj.responseXML || docObj;
			if (dhx4.isIE) {
				try {
					return docObj.selectNodes(xpathExp)||[];
				} catch(e){ return []; }
			} else {
				var rows = [];
				var first;
				var col = (docObj.ownerDocument||docObj).evaluate(xpathExp, docObj, null, XPathResult.ANY_TYPE, null);
				while (first = col.iterateNext()) rows.push(first);
				return rows;
			}
		},
		query: function(config) {
			dhx4.ajax._call(
				(config.method || "GET"),
				config.url,
				config.data || "",
				(config.async || true),
				config.callback,
				null,
				config.headers
			);
		},
		get: function(url, onLoad) {
			return this._call("GET", url, null, true, onLoad);
		},
		getSync: function(url) {
			return this._call("GET", url, null, false);
		},
		put: function(url, postData, onLoad) {
			return this._call("PUT", url, postData, true, onLoad);
		},
		del: function(url, postData, onLoad) {
			return this._call("DELETE", url, postData, true, onLoad);
		},
		post: function(url, postData, onLoad) {
			if (arguments.length == 1) {
				postData = "";
			} else if (arguments.length == 2 && (typeof(postData) == "function" || typeof(window[postData]) == "function")) {
				onLoad = postData;
				postData = "";
			} else {
				postData = String(postData);
			}
			return this._call("POST", url, postData, true, onLoad);
		},
		postSync: function(url, postData) {
			postData = (postData == null ? "" : String(postData));
			return this._call("POST", url, postData, false);
		},
		getLong: function(url, onLoad) {
			this._call("GET", url, null, true, onLoad, {url:url});
		},
		postLong: function(url, postData, onLoad) {
			if (arguments.length == 2 && (typeof(postData) == "function" || typeof(window[postData]))) {
				onLoad = postData;
				postData = "";
			}
			this._call("POST", url, postData, true, onLoad, {url:url, postData:postData});
		},
		_call: function(method, url, postData, async, onLoad, longParams, headers) {
			
			var t = (window.XMLHttpRequest && !dhx4.isIE ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP"));
			var isQt = (navigator.userAgent.match(/AppleWebKit/) != null && navigator.userAgent.match(/Qt/) != null && navigator.userAgent.match(/Safari/) != null);
			
			if (async == true) {
				t.onreadystatechange = function() {
					if ((t.readyState == 4) || (isQt == true && t.readyState == 3)) { // what for long response and status 404?
						if (t.status != 200 || t.responseText == "")
							if (!dhx4.callEvent("onAjaxError", [{xmlDoc:t, filePath:url, async:async}])) return;

						window.setTimeout(function(){
							if (typeof(onLoad) == "function") {
								onLoad.apply(window, [{xmlDoc:t, filePath:url, async:async}]); // dhtmlx-compat, response.xmlDoc.responseXML/responseText
							}
							if (longParams != null) {
								if (typeof(longParams.postData) != "undefined") {
									dhx4.ajax.postLong(longParams.url, longParams.postData, onLoad);
								} else {
									dhx4.ajax.getLong(longParams.url, onLoad);
								}
							}
							onLoad = null;
							t = null;
						},1);
					}
				}
			}
			
			if (method == "GET") {
				url += this._dhxr(url);
			}
			
			t.open(method, url, async);
			
			if (headers != null) {
				for (var key in headers) t.setRequestHeader(key, headers[key]);
			} else if (method == "POST" || method == "PUT" || method == "DELETE") {
				t.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
			} else if (method == "GET") {
				postData = null;
			}
			
			t.setRequestHeader("X-Requested-With", "XMLHttpRequest");
			
			t.send(postData);
			
			if (async != true) {
				if ((t.readyState == 4) || (isQt == true && t.readyState == 3)) {
					if (t.status != 200 || t.responseText == "") dhx4.callEvent("onAjaxError", [{xmlDoc:t, filePath:url, async:async}]);
				}
			}
			
			return {xmlDoc:t, filePath:url, async:async}; // dhtmlx-compat, response.xmlDoc.responseXML/responseText
			
		},
		
		_dhxr: function(sign, value) {
			if (this.cache != true) {
				if (sign.match(/^[\?\&]$/) == null) sign = (sign.indexOf("?")>=0?"&":"?");
				if (typeof(value) == "undefined") value = true;
				return sign+"dhxr"+new Date().getTime()+(value==true?"=1":"");
			}
			return "";
		}
	};
	
};

if (typeof(window.dhx4._enableDataLoading) == "undefined") {
	
	window.dhx4._enableDataLoading = function(obj, initObj, xmlToJson, xmlRootTag, mode) {
		
		if (mode == "clear") {
			
			// clear attached functionality
			
			for (var a in obj._dhxdataload) {
				obj._dhxdataload[a] = null;
				delete obj._dhxdataload[a];
			};
			
			obj._loadData = null;
			obj._dhxdataload = null;
			obj.load = null;
			obj.loadStruct = null;
			
			obj = null;
			
			return;
			
		}
		
		obj._dhxdataload = { // move to obj.conf?
			initObj: initObj,
			xmlToJson: xmlToJson,
			xmlRootTag: xmlRootTag,
			onBeforeXLS: null
		};
		
		obj._loadData = function(data, loadParams, onLoad) {
			
			if (arguments.length == 2) {
				onLoad = loadParams;
				loadParams = null;
			}
			
			var obj = null;
			
			// deprecated from 4.0, compatability with version (url, type[json|xml], onLoad)
			if (arguments.length == 3) onLoad = arguments[2];
			
			if (typeof(data) == "string") {
				
				var k = data.replace(/^\s{1,}/,"").replace(/\s{1,}$/,"");
				
				var tag = new RegExp("^<"+this._dhxdataload.xmlRootTag);
				
				// xml
				if (tag.test(k.replace(/^<\?xml[^\?]*\?>\s*/, ""))) { // remove leading <?xml ...?> if any, \n can be also present
					obj = dhx4.ajax.parse(data);
					if (obj != null) obj = this[this._dhxdataload.xmlToJson].apply(this, [obj]); // xml to json
				}
				
				if (obj == null && (k.match(/^[\s\S]*{[.\s\S]*}[\s\S]*$/) != null || k.match(/^[\s\S]*\[[.\s\S]*\][\s\S]*$/) != null)) { // check for '{...}' or '[...]', cut leading/trailing \n\r with \s\S
					obj = dhx4.s2j(k);
				}
				
				if (obj == null) {
					
					this.callEvent("onXLS",[]);
					
					var params = [];
					
					// allow to modify url and add params
					if (typeof(this._dhxdataload.onBeforeXLS) == "function") {
						var k = this._dhxdataload.onBeforeXLS.apply(this,[data]);
						if (k != null && typeof(k) == "object") {
							if (k.url != null) data = k.url;
							if (k.params != null) { for (var a in k.params) params.push(a+"="+encodeURIComponent(k.params[a])); }
						}
					}
					
					var t = this;
					var callBack = function(r) {
						
						var obj = null;
						
						if ((r.xmlDoc.getResponseHeader("Content-Type")||"").search(/xml/gi) >= 0 || (r.xmlDoc.responseText.replace(/^\s{1,}/,"")).match(/^</) != null) {
							obj = t[t._dhxdataload.xmlToJson].apply(t,[r.xmlDoc.responseXML]);
						} else {
							obj = dhx4.s2j(r.xmlDoc.responseText);
						}
						
						// init
						if (obj != null) t[t._dhxdataload.initObj].apply(t,[obj,data]); // data => url
						
						t.callEvent("onXLE",[]);
						
						if (onLoad != null) {
							if (typeof(onLoad) == "function") {
								onLoad.apply(t,[]);
							} else if (typeof(window[onLoad]) == "function") {
								window[onLoad].apply(t,[]);
							}
						}
						
						callBack = onLoad = null;
						obj = r = t = null;
						
					};
					
					params = params.join("&")+(typeof(loadParams)=="string"?"&"+loadParams:"");
					
					if (dhx4.ajax.method == "post") {
						dhx4.ajax.post(data, params, callBack);
					} else if (dhx4.ajax.method == "get") {
						dhx4.ajax.get(data+(params.length>0?(data.indexOf("?")>0?"&":"?")+params:""), callBack);
					}
					
					return;
				}
				
			} else {
				if (typeof(data.documentElement) == "object" || (typeof(data.tagName) != "undefined" && typeof(data.getElementsByTagName) != "undefined" && data.getElementsByTagName(this._dhxdataload.xmlRootTag).length > 0)) { // xml
					obj = this[this._dhxdataload.xmlToJson].apply(this, [data]);
				} else { // json
					obj = window.dhx4._copyObj(data);
				}
				
			}
			
			// init
			if (obj != null) this[this._dhxdataload.initObj].apply(this,[obj]);
			
			if (onLoad != null) {
				if (typeof(onLoad) == "function") {
					onLoad.apply(this, []);
				} else if (typeof(window[onLoad]) == "function") {
					window[onLoad].apply(this, []);
				}
				onLoad = null;
			}
			
		};
		
		// loadStruct for hdr/conf
		// load for data
		if (mode != null) {
			var k = {struct: "loadStruct", data: "load"};
			for (var a in mode) {
				if (mode[a] == true) obj[k[a]] = function() {return this._loadData.apply(this, arguments);}
			}
		}
		
		obj = null;
		
	};
};

if (typeof(window.dhx4._eventable) == "undefined") {
	
	window.dhx4._eventable = function(obj, mode) {
		
		if (mode == "clear") {
			
			obj.detachAllEvents();
			
			obj.dhxevs = null;
			
			obj.attachEvent = null;
			obj.detachEvent = null;
			obj.checkEvent = null;
			obj.callEvent = null;
			obj.detachAllEvents = null;
			
			obj = null;
			
			return;
			
		}
		
		obj.dhxevs = { data: {} };
		
		obj.attachEvent = function(name, func) {
			name = String(name).toLowerCase();
			if (!this.dhxevs.data[name]) this.dhxevs.data[name] = {};
			var eventId = window.dhx4.newId();
			this.dhxevs.data[name][eventId] = func;
			return eventId;
		}
		
		obj.detachEvent = function(eventId) {
			for (var a in this.dhxevs.data) {
				var k = 0;
				for (var b in this.dhxevs.data[a]) {
					if (b == eventId) {
						this.dhxevs.data[a][b] = null;
						delete this.dhxevs.data[a][b];
					} else {
						k++;
					}
				}
				if (k == 0) {
					this.dhxevs.data[a] = null;
					delete this.dhxevs.data[a];
				}
			}
		}
		
		obj.checkEvent = function(name) {
			name = String(name).toLowerCase();
			return (this.dhxevs.data[name] != null);
		}
		
		obj.callEvent = function(name, params) {
			name = String(name).toLowerCase();
			if (this.dhxevs.data[name] == null) return true;
			var r = true;
			for (var a in this.dhxevs.data[name]) {
				r = this.dhxevs.data[name][a].apply(this, params) && r;
			}
			return r;
		}
		
		obj.detachAllEvents = function() {
			for (var a in this.dhxevs.data) {
				for (var b in this.dhxevs.data[a]) {
					this.dhxevs.data[a][b] = null;
					delete this.dhxevs.data[a][b];
				}
				this.dhxevs.data[a] = null;
				delete this.dhxevs.data[a];
			}
		}
		
		obj = null;
	};
	
	dhx4._eventable(dhx4);
	
};

// validation
// all purpose set of rules, based on http://code.google.com/p/validation-js
if (!window.dhtmlxValidation) {
	dhtmlxValidation = function(){};
	dhtmlxValidation.prototype = {
		isEmpty: function(value) {
			return value == '';
		},
		isNotEmpty: function(value) {
			return (value instanceof Array?value.length>0:!value == ''); // array in case of multiselect
		},
		isValidBoolean: function(value) {
			return !!value.toString().match(/^(0|1|true|false)$/);
		},
		isValidEmail: function(value) {
			return !!value.toString().match(/(^[a-z0-9]([0-9a-z\-_\.]*)@([0-9a-z_\-\.]*)([.][a-z]{3})$)|(^[a-z]([0-9a-z_\.\-]*)@([0-9a-z_\-\.]*)(\.[a-z]{2,5})$)/i);
		},
		isValidInteger: function(value) {
			return !!value.toString().match(/(^-?\d+$)/);
		},
		isValidNumeric: function(value) {
			return !!value.toString().match(/(^-?\d\d*[\.|,]\d*$)|(^-?\d\d*$)|(^-?[\.|,]\d\d*$)/);
		},
		isValidAplhaNumeric: function(value) {
			return !!value.toString().match(/^[_\-a-z0-9]+$/gi);
		},
		// 0000-00-00 00:00:00 to 9999:12:31 59:59:59 (no it is not a "valid DATE" function)
		isValidDatetime: function(value) {
			var dt = value.toString().match(/^(\d{4})-(\d{2})-(\d{2})\s(\d{2}):(\d{2}):(\d{2})$/);
			return dt && !!(dt[1]<=9999 && dt[2]<=12 && dt[3]<=31 && dt[4]<=59 && dt[5]<=59 && dt[6]<=59) || false;
		},
		// 0000-00-00 to 9999-12-31
		isValidDate: function(value) {
			var d = value.toString().match(/^(\d{4})-(\d{2})-(\d{2})$/);
			return d && !!(d[1]<=9999 && d[2]<=12 && d[3]<=31) || false;
		},
		// 00:00:00 to 59:59:59
		isValidTime: function(value) {
			var t = value.toString().match(/^(\d{1,2}):(\d{1,2}):(\d{1,2})$/);
			return t && !!(t[1]<=24 && t[2]<=59 && t[3]<=59) || false;
		},
		// 0.0.0.0 to 255.255.255.255
		isValidIPv4: function(value) { 
			var ip = value.toString().match(/^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/);
			return ip && !!(ip[1]<=255 && ip[2]<=255 && ip[3]<=255 && ip[4]<=255) || false;
		},
		isValidCurrency: function(value) { // Q: Should I consider those signs valid too ? : ¢|€|₤|₦|¥
			return value.toString().match(/^\$?\s?\d+?([\.,\,]?\d+)?\s?\$?$/) && true || false;
		},
		// Social Security Number (999-99-9999 or 999999999)
		isValidSSN: function(value) {
			return value.toString().match(/^\d{3}\-?\d{2}\-?\d{4}$/) && true || false;
		},
		// Social Insurance Number (999999999)
		isValidSIN: function(value) {
			return value.toString().match(/^\d{9}$/) && true || false;
		}
	};
	dhtmlxValidation = new dhtmlxValidation();
};


if (typeof(window.dhtmlx) == "undefined") {
	window.dhtmlx={
		extend:function(a, b){
			for (var key in b)
				if (!a[key])
					a[key]=b[key];
			return a;
		},
		extend_api:function(name,map,ext){
			var t = window[name];
			if (!t) return; //component not defined
			window[name]=function(obj){
				if (obj && typeof obj == "object" && !obj.tagName){
					var that = t.apply(this,(map._init?map._init(obj):arguments));
					//global settings
					for (var a in dhtmlx)
						if (map[a]) this[map[a]](dhtmlx[a]);			
					//local settings
					for (var a in obj){
						if (map[a]) this[map[a]](obj[a]);
						else if (a.indexOf("on")===0){
							this.attachEvent(a,obj[a]);
						}
					}
				} else
					var that = t.apply(this,arguments);
				if (map._patch) map._patch(this);
				return that||this;
			};
			window[name].prototype=t.prototype;
			if (ext)
				dhtmlx.extend(window[name].prototype,ext);
		},
		url:function(str){
			if (str.indexOf("?") != -1)
				return "&";
			else
				return "?";
		}
	};
};

/**  
*     @desc: find out what symbol to use as url param delimiters in further params
*     @type: private
*     @param: str - current url string
*     @topic: 0  
*/


function dhtmlDragAndDropObject(){
	if (window.dhtmlDragAndDrop)
		return window.dhtmlDragAndDrop;

	this.lastLanding=0;
	this.dragNode=0;
	this.dragStartNode=0;
	this.dragStartObject=0;
	this.tempDOMU=null;
	this.tempDOMM=null;
	this.waitDrag=0;
	window.dhtmlDragAndDrop=this;

	return this;
};

dhtmlDragAndDropObject.prototype.removeDraggableItem=function(htmlNode){
	htmlNode.onmousedown=null;
	htmlNode.dragStarter=null;
	htmlNode.dragLanding=null;
}
dhtmlDragAndDropObject.prototype.addDraggableItem=function(htmlNode, dhtmlObject){
	htmlNode.onmousedown=this.preCreateDragCopy;
	htmlNode.dragStarter=dhtmlObject;
	this.addDragLanding(htmlNode, dhtmlObject);
}
dhtmlDragAndDropObject.prototype.addDragLanding=function(htmlNode, dhtmlObject){
	htmlNode.dragLanding=dhtmlObject;
}
dhtmlDragAndDropObject.prototype.preCreateDragCopy=function(e){
	if ((e||window.event) && (e||event).button == 2)
		return;

	if (window.dhtmlDragAndDrop.waitDrag){
		window.dhtmlDragAndDrop.waitDrag=0;
		document.body.onmouseup=window.dhtmlDragAndDrop.tempDOMU;
		document.body.onmousemove=window.dhtmlDragAndDrop.tempDOMM;
		return false;
	}
	
	if (window.dhtmlDragAndDrop.dragNode)
		window.dhtmlDragAndDrop.stopDrag(e);	

	window.dhtmlDragAndDrop.waitDrag=1;
	window.dhtmlDragAndDrop.tempDOMU=document.body.onmouseup;
	window.dhtmlDragAndDrop.tempDOMM=document.body.onmousemove;
	window.dhtmlDragAndDrop.dragStartNode=this;
	window.dhtmlDragAndDrop.dragStartObject=this.dragStarter;
	document.body.onmouseup=window.dhtmlDragAndDrop.preCreateDragCopy;
	document.body.onmousemove=window.dhtmlDragAndDrop.callDrag;
	window.dhtmlDragAndDrop.downtime = new Date().valueOf();
	

	if ((e)&&(e.preventDefault)){
		e.preventDefault();
		return false;
	}
	return false;
};
dhtmlDragAndDropObject.prototype.callDrag=function(e){
	if (!e)
		e=window.event;
	dragger=window.dhtmlDragAndDrop;
	if ((new Date()).valueOf()-dragger.downtime<100) return;

	//if ((e.button == 0)&&(_isIE))
	//	return dragger.stopDrag();

	if (!dragger.dragNode){
		if (dragger.waitDrag){
			dragger.dragNode=dragger.dragStartObject._createDragNode(dragger.dragStartNode, e);
	
			if (!dragger.dragNode)
				return dragger.stopDrag();
	
			dragger.dragNode.onselectstart=function(){return false;}
			dragger.gldragNode=dragger.dragNode;
			document.body.appendChild(dragger.dragNode);
			document.body.onmouseup=dragger.stopDrag;
			dragger.waitDrag=0;
			dragger.dragNode.pWindow=window;
			dragger.initFrameRoute();
		} 
		else return dragger.stopDrag(e, true);
	}

	if (dragger.dragNode.parentNode != window.document.body && dragger.gldragNode){
		var grd = dragger.gldragNode;

		if (dragger.gldragNode.old)
			grd=dragger.gldragNode.old;

		//if (!document.all) dragger.calculateFramePosition();
		grd.parentNode.removeChild(grd);
		var oldBody = dragger.dragNode.pWindow;

		if (grd.pWindow &&	grd.pWindow.dhtmlDragAndDrop.lastLanding)
			grd.pWindow.dhtmlDragAndDrop.lastLanding.dragLanding._dragOut(grd.pWindow.dhtmlDragAndDrop.lastLanding);	
			
		//		var oldp=dragger.dragNode.parentObject;
		if (_isIE){
			var div = document.createElement("Div");
			div.innerHTML=dragger.dragNode.outerHTML;
			dragger.dragNode=div.childNodes[0];
		} else
			dragger.dragNode=dragger.dragNode.cloneNode(true);

		dragger.dragNode.pWindow=window;
		//		dragger.dragNode.parentObject=oldp;

		dragger.gldragNode.old=dragger.dragNode;
		document.body.appendChild(dragger.dragNode);
		oldBody.dhtmlDragAndDrop.dragNode=dragger.dragNode;
	}

	dragger.dragNode.style.left=e.clientX+15+(dragger.fx
		? dragger.fx*(-1)
		: 0)
		+(document.body.scrollLeft||document.documentElement.scrollLeft)+"px";
	dragger.dragNode.style.top=e.clientY+3+(dragger.fy
		? dragger.fy*(-1)
		: 0)
		+(document.body.scrollTop||document.documentElement.scrollTop)+"px";

	if (!e.srcElement)
		var z = e.target;
	else
		z=e.srcElement;
	dragger.checkLanding(z, e);
}

dhtmlDragAndDropObject.prototype.calculateFramePosition=function(n){
	//this.fx = 0, this.fy = 0;
	if (window.name){
		var el = parent.frames[window.name].frameElement.offsetParent;
		var fx = 0;
		var fy = 0;

		while (el){
			fx+=el.offsetLeft;
			fy+=el.offsetTop;
			el=el.offsetParent;
		}

		if ((parent.dhtmlDragAndDrop)){
			var ls = parent.dhtmlDragAndDrop.calculateFramePosition(1);
			fx+=ls.split('_')[0]*1;
			fy+=ls.split('_')[1]*1;
		}

		if (n)
			return fx+"_"+fy;
		else
			this.fx=fx;
		this.fy=fy;
	}
	return "0_0";
}
dhtmlDragAndDropObject.prototype.checkLanding=function(htmlObject, e){
	if ((htmlObject)&&(htmlObject.dragLanding)){
		if (this.lastLanding)
			this.lastLanding.dragLanding._dragOut(this.lastLanding);
		this.lastLanding=htmlObject;
		this.lastLanding=this.lastLanding.dragLanding._dragIn(this.lastLanding, this.dragStartNode, e.clientX,
			e.clientY, e);
		this.lastLanding_scr=(_isIE ? e.srcElement : e.target);
	} else {
		if ((htmlObject)&&(htmlObject.tagName != "BODY"))
			this.checkLanding(htmlObject.parentNode, e);
		else {
			if (this.lastLanding)
				this.lastLanding.dragLanding._dragOut(this.lastLanding, e.clientX, e.clientY, e);
			this.lastLanding=0;

			if (this._onNotFound)
				this._onNotFound();
		}
	}
}
dhtmlDragAndDropObject.prototype.stopDrag=function(e, mode){
	dragger=window.dhtmlDragAndDrop;

	if (!mode){
		dragger.stopFrameRoute();
		var temp = dragger.lastLanding;
		dragger.lastLanding=null;

		if (temp)
			temp.dragLanding._drag(dragger.dragStartNode, dragger.dragStartObject, temp, (_isIE
				? event.srcElement
				: e.target));
	}
	dragger.lastLanding=null;

	if ((dragger.dragNode)&&(dragger.dragNode.parentNode == document.body))
		dragger.dragNode.parentNode.removeChild(dragger.dragNode);
	dragger.dragNode=0;
	dragger.gldragNode=0;
	dragger.fx=0;
	dragger.fy=0;
	dragger.dragStartNode=0;
	dragger.dragStartObject=0;
	document.body.onmouseup=dragger.tempDOMU;
	document.body.onmousemove=dragger.tempDOMM;
	dragger.tempDOMU=null;
	dragger.tempDOMM=null;
	dragger.waitDrag=0;
}

dhtmlDragAndDropObject.prototype.stopFrameRoute=function(win){
	if (win)
		window.dhtmlDragAndDrop.stopDrag(1, 1);

	for (var i = 0; i < window.frames.length; i++){
		try{
		if ((window.frames[i] != win)&&(window.frames[i].dhtmlDragAndDrop))
			window.frames[i].dhtmlDragAndDrop.stopFrameRoute(window);
		} catch(e){}
	}

	try{
	if ((parent.dhtmlDragAndDrop)&&(parent != window)&&(parent != win))
		parent.dhtmlDragAndDrop.stopFrameRoute(window);
	} catch(e){}
}
dhtmlDragAndDropObject.prototype.initFrameRoute=function(win, mode){
	if (win){
		window.dhtmlDragAndDrop.preCreateDragCopy();
		window.dhtmlDragAndDrop.dragStartNode=win.dhtmlDragAndDrop.dragStartNode;
		window.dhtmlDragAndDrop.dragStartObject=win.dhtmlDragAndDrop.dragStartObject;
		window.dhtmlDragAndDrop.dragNode=win.dhtmlDragAndDrop.dragNode;
		window.dhtmlDragAndDrop.gldragNode=win.dhtmlDragAndDrop.dragNode;
		window.document.body.onmouseup=window.dhtmlDragAndDrop.stopDrag;
		window.waitDrag=0;

		if (((!_isIE)&&(mode))&&((!_isFF)||(_FFrv < 1.8)))
			window.dhtmlDragAndDrop.calculateFramePosition();
	}
	try{
	if ((parent.dhtmlDragAndDrop)&&(parent != window)&&(parent != win))
		parent.dhtmlDragAndDrop.initFrameRoute(window);
	}catch(e){}

	for (var i = 0; i < window.frames.length; i++){
		try{
		if ((window.frames[i] != win)&&(window.frames[i].dhtmlDragAndDrop))
			window.frames[i].dhtmlDragAndDrop.initFrameRoute(window, ((!win||mode) ? 1 : 0));
		} catch(e){}
	}
}

 _isFF = false;
 _isIE = false;
 _isOpera = false;
 _isKHTML = false;
 _isMacOS = false;
 _isChrome = false;
 _FFrv = false;
 _KHTMLrv = false;
 _OperaRv = false;

if (navigator.userAgent.indexOf('Macintosh') != -1)
	_isMacOS=true;


if (navigator.userAgent.toLowerCase().indexOf('chrome')>-1)
	_isChrome=true;

if ((navigator.userAgent.indexOf('Safari') != -1)||(navigator.userAgent.indexOf('Konqueror') != -1)){
	 _KHTMLrv = parseFloat(navigator.userAgent.substr(navigator.userAgent.indexOf('Safari')+7, 5));

	if (_KHTMLrv > 525){ //mimic FF behavior for Safari 3.1+
		_isFF=true;
		 _FFrv = 1.9;
	} else
		_isKHTML=true;
} else if (navigator.userAgent.indexOf('Opera') != -1){
	_isOpera=true;
	_OperaRv=parseFloat(navigator.userAgent.substr(navigator.userAgent.indexOf('Opera')+6, 3));
}


else if (navigator.appName.indexOf("Microsoft") != -1){
	_isIE=true;
	if ((navigator.appVersion.indexOf("MSIE 8.0")!= -1 || 
		 navigator.appVersion.indexOf("MSIE 9.0")!= -1 || 
		 navigator.appVersion.indexOf("MSIE 10.0")!= -1 ||
		 document.documentMode > 7) && 
			document.compatMode != "BackCompat"){
		_isIE=8;
	}
} else if (navigator.appName  == 'Netscape' && navigator.userAgent.indexOf("Trident") != -1){
	//ie11
	_isIE=8;
} else {
	_isFF=true;
	 _FFrv = parseFloat(navigator.userAgent.split("rv:")[1])
}

if (typeof(window.dhtmlxEvent) == "undefined") {
	
	function dhtmlxEvent(el, event, handler){
		if (el.addEventListener)
			el.addEventListener(event, handler, false);
	
		else if (el.attachEvent)
			el.attachEvent("on"+event, handler);
	}
};

if (dhtmlxEvent.touchDelay == null) {
	dhtmlxEvent.touchDelay = 2000;
};

if (typeof(dhtmlxEvent.initTouch) == "undefined") {
	
	dhtmlxEvent.initTouch = function(){
		var longtouch;
		var target;
		var tx, ty;
	
		dhtmlxEvent(document.body, "touchstart", function(ev){
			target = ev.touches[0].target;
			tx = ev.touches[0].clientX;
			ty = ev.touches[0].clientY;
			longtouch = window.setTimeout(touch_event, dhtmlxEvent.touchDelay);
		});
		function touch_event(){
			if (target){
				var ev = document.createEvent("HTMLEvents"); // for chrome and firefox
				ev.initEvent("dblclick", true, true);
				target.dispatchEvent(ev);
				longtouch = target = null;
			}
		};
		dhtmlxEvent(document.body, "touchmove", function(ev){
			if (longtouch){
				if (Math.abs(ev.touches[0].clientX - tx) > 50 || Math.abs(ev.touches[0].clientY - ty) > 50 ){
					window.clearTimeout(longtouch);
					longtouch = target = false;
				}
			}
		});
		dhtmlxEvent(document.body, "touchend", function(ev){
			if (longtouch){
				window.clearTimeout(longtouch);
				longtouch = target = false;
			}
		});
	
		dhtmlxEvent.initTouch = function(){};
	};
};
;
///<jscompress sourcefile="dhtmlxcore.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
Copyright DHTMLX LTD. http://www.dhtmlx.com
You allowed to use this component or parts of it under GPL terms
To use it on other terms or get Professional edition of the component please contact us at sales@dhtmlx.com
*/
/*
2014 March 19
*/



/* DHX DEPEND FROM FILE 'assert.js'*/


if (!window.dhtmlx) 
	dhtmlx={};

//check some rule, show message as error if rule is not correct
dhtmlx.assert = function(test, message){
	if (!test)	dhtmlx.error(message);
};
dhtmlx.assert_enabled=function(){ return false; };

//register names of event, which can be triggered by the object
dhtmlx.assert_event = function(obj, evs){
	if (!obj._event_check){
		obj._event_check = {};
		obj._event_check_size = {};
	}
		
	for (var a in evs){
		obj._event_check[a.toLowerCase()]=evs[a];
		var count=-1; for (var t in evs[a]) count++;
		obj._event_check_size[a.toLowerCase()]=count;
	}
};
dhtmlx.assert_method_info=function(obj, name, descr, rules){
	var args = [];
	for (var i=0; i < rules.length; i++) {
		args.push(rules[i][0]+" : "+rules[i][1]+"\n   "+rules[i][2].describe()+(rules[i][3]?"; optional":""));
	}
	return obj.name+"."+name+"\n"+descr+"\n Arguments:\n - "+args.join("\n - ");
};
dhtmlx.assert_method = function(obj, config){
	for (var key in config)
		dhtmlx.assert_method_process(obj, key, config[key].descr, config[key].args, (config[key].min||99), config[key].skip);
};
dhtmlx.assert_method_process = function (obj, name, descr, rules, min, skip){
	var old = obj[name];
	if (!skip)
		obj[name] = function(){
			if (arguments.length !=	rules.length && arguments.length < min) 
				dhtmlx.log("warn","Incorrect count of parameters\n"+obj[name].describe()+"\n\nExpecting "+rules.length+" but have only "+arguments.length);
			else
				for (var i=0; i<rules.length; i++)
					if (!rules[i][3] && !rules[i][2](arguments[i]))
						dhtmlx.log("warn","Incorrect method call\n"+obj[name].describe()+"\n\nActual value of "+(i+1)+" parameter: {"+(typeof arguments[i])+"} "+arguments[i]);
			
			return old.apply(this, arguments);
		};
	obj[name].describe = function(){	return dhtmlx.assert_method_info(obj, name, descr, rules);	};
};
dhtmlx.assert_event_call = function(obj, name, args){
	if (obj._event_check){
		if (!obj._event_check[name])
			dhtmlx.log("warn","Not expected event call :"+name);
		else if (dhtmlx.isNotDefined(args))
			dhtmlx.log("warn","Event without parameters :"+name);
		else if (obj._event_check_size[name] != args.length)
			dhtmlx.log("warn","Incorrect event call, expected "+obj._event_check_size[name]+" parameter(s), but have "+args.length +" parameter(s), for "+name+" event");
	}		
};
dhtmlx.assert_event_attach = function(obj, name){
	if (obj._event_check && !obj._event_check[name]) 
			dhtmlx.log("warn","Unknown event name: "+name);
};
//register names of properties, which can be used in object's configuration
dhtmlx.assert_property = function(obj, evs){
	if (!obj._settings_check)
		obj._settings_check={};
	dhtmlx.extend(obj._settings_check, evs);		
};
//check all options in collection, against list of allowed properties
dhtmlx.assert_check = function(data,coll){
	if (typeof data == "object"){
		for (var key in data){
			dhtmlx.assert_settings(key,data[key],coll);
		}
	}
};
//check if type and value of property is the same as in scheme
dhtmlx.assert_settings = function(mode,value,coll){
	coll = coll || this._settings_check;

	//if value is not in collection of defined ones
	if (coll){
		if (!coll[mode])	//not registered property
			return dhtmlx.log("warn","Unknown propery: "+mode);
			
		var descr = "";
		var error = "";
		var check = false;
		for (var i=0; i<coll[mode].length; i++){
			var rule = coll[mode][i];
			if (typeof rule == "string")
				continue;
			if (typeof rule == "function")
				check = check || rule(value);
			else if (typeof rule == "object" && typeof rule[1] == "function"){
				check = check || rule[1](value);
				if (check && rule[2])
					dhtmlx["assert_check"](value, rule[2]); //temporary fix , for sources generator
			}
			if (check) break;
		}
		if (!check )
			dhtmlx.log("warn","Invalid configuration\n"+dhtmlx.assert_info(mode,coll)+"\nActual value: {"+(typeof value)+"} "+value);
	}
};

dhtmlx.assert_info=function(name, set){ 
	var ruleset = set[name];
	var descr = "";
	var expected = [];
	for (var i=0; i<ruleset.length; i++){
		if (typeof rule == "string")
			descr = ruleset[i];
		else if (ruleset[i].describe)
			expected.push(ruleset[i].describe());
		else if (ruleset[i][1] && ruleset[i][1].describe)
			expected.push(ruleset[i][1].describe());
	}
	return "Property: "+name+", "+descr+" \nExpected value: \n - "+expected.join("\n - ");
};


if (dhtmlx.assert_enabled()){
	
	dhtmlx.assert_rule_color=function(check){
		if (typeof check != "string") return false;
		if (check.indexOf("#")!==0) return false;
		if (check.substr(1).replace(/[0-9A-F]/gi,"")!=="") return false;
		return true;
	};
	dhtmlx.assert_rule_color.describe = function(){
		return "{String} Value must start from # and contain hexadecimal code of color";
	};
	
	dhtmlx.assert_rule_template=function(check){
		if (typeof check == "function") return true;
		if (typeof check == "string") return true;
		return false;
	};
	dhtmlx.assert_rule_template.describe = function(){
		return "{Function},{String} Value must be a function which accepts data object and return text string, or a sting with optional template markers";
	};
	
	dhtmlx.assert_rule_boolean=function(check){
		if (typeof check == "boolean") return true;
		return false;
	};
	dhtmlx.assert_rule_boolean.describe = function(){
		return "{Boolean} true or false";
	};
	
	dhtmlx.assert_rule_object=function(check, sub){
		if (typeof check == "object") return true;
		return false;
	};
	dhtmlx.assert_rule_object.describe = function(){
		return "{Object} Configuration object";
	};
	
	
	dhtmlx.assert_rule_string=function(check){
		if (typeof check == "string") return true;
		return false;
	};
	dhtmlx.assert_rule_string.describe = function(){
		return "{String} Plain string";
	};
	
	
	dhtmlx.assert_rule_htmlpt=function(check){
		return !!dhtmlx.toNode(check);
	};
	dhtmlx.assert_rule_htmlpt.describe = function(){
		return "{Object},{String} HTML node or ID of HTML Node";
	};
	
	dhtmlx.assert_rule_notdocumented=function(check){
		return false;
	};
	dhtmlx.assert_rule_notdocumented.describe = function(){
		return "This options wasn't documented";
	};
	
	dhtmlx.assert_rule_key=function(obj){
		var t = function (check){
			return obj[check];
		};
		t.describe=function(){
			var opts = [];
			for(var key in obj)
				opts.push(key);
			return  "{String} can take one of next values: "+opts.join(", ");
		};
		return t;
	};
	
	dhtmlx.assert_rule_dimension=function(check){
		if (check*1 == check && !isNaN(check) && check >= 0) return true;
		return false;
	};
	dhtmlx.assert_rule_dimension.describe=function(){
		return "{Integer} value must be a positive number";
	};
	
	dhtmlx.assert_rule_number=function(check){
		if (typeof check == "number") return true;
		return false;
	};
	dhtmlx.assert_rule_number.describe=function(){
		return "{Integer} value must be a number";
	};
	
	dhtmlx.assert_rule_function=function(check){
		if (typeof check == "function") return true;
		return false;
	};
	dhtmlx.assert_rule_function.describe=function(){
		return "{Function} value must be a custom function";
	};
	
	dhtmlx.assert_rule_any=function(check){
		return true;
	};
	dhtmlx.assert_rule_any.describe=function(){
		return "Any value";
	};
	
	dhtmlx.assert_rule_mix=function(a,b){
		var t = function(check){
			if (a(check)||b(check)) return true;
			return false;
		};
		t.describe = function(){
			return a.describe();
		};
		return t;
	};

}


/* DHX DEPEND FROM FILE 'dhtmlx.js'*/


/*DHX:Depend assert.js*/

/*
	Common helpers
*/
dhtmlx.codebase="./";

//coding helpers

dhtmlx.copy = function(source){
	var f = dhtmlx.copy._function;
	f.prototype = source;
	return new f();
};
dhtmlx.copy._function = function(){};

//copies methods and properties from source to the target
dhtmlx.extend = function(target, source){
	for (var method in source)
		target[method] = source[method];
		
	//applying asserts
	if (dhtmlx.assert_enabled() && source._assert){
		target._assert();
		target._assert=null;
	}
	
	dhtmlx.assert(target,"Invalid nesting target");
	dhtmlx.assert(source,"Invalid nesting source");
	//if source object has init code - call init against target
	if (source._init)	
		target._init();
				
	return target;	
};
dhtmlx.proto_extend = function(){
	var origins = arguments;
	var compilation = origins[0];
	var construct = [];
	
	for (var i=origins.length-1; i>0; i--) {
		if (typeof origins[i]== "function")
			origins[i]=origins[i].prototype;
		for (var key in origins[i]){
			if (key == "_init") 
				construct.push(origins[i][key]);
			else if (!compilation[key])
				compilation[key] = origins[i][key];
		}
	};
	
	if (origins[0]._init)
		construct.push(origins[0]._init);
	
	compilation._init = function(){
		for (var i=0; i<construct.length; i++)
			construct[i].apply(this, arguments);
	};
	compilation.base = origins[1];
	var result = function(config){
		this._init(config);
		if (this._parseSettings)
			this._parseSettings(config, this.defaults);
	};
	result.prototype = compilation;
	
	compilation = origins = null;
	return result;
};
//creates function with specified "this" pointer
dhtmlx.bind=function(functor, object){ 
	return function(){ return functor.apply(object,arguments); };  
};

//loads module from external js file
dhtmlx.require=function(module){
	if (!dhtmlx._modules[module]){
		dhtmlx.assert(dhtmlx.ajax,"load module is required");
		
		//load and exec the required module
		dhtmlx.exec( dhtmlx.ajax().sync().get(dhtmlx.codebase+module).responseText );
		dhtmlx._modules[module]=true;	
	}
};
dhtmlx._modules = {};	//hash of already loaded modules

//evaluate javascript code in the global scoope
dhtmlx.exec=function(code){
	if (window.execScript)	//special handling for IE
		window.execScript(code);
	else window.eval(code);
};

/*
	creates method in the target object which will transfer call to the source object
	if event parameter was provided , each call of method will generate onBefore and onAfter events
*/
dhtmlx.methodPush=function(object,method,event){
	return function(){
		var res = false;
		//if (!event || this.callEvent("onBefore"+event,arguments)){ //not used anymore, probably can be removed
			res=object[method].apply(object,arguments);
		//	if (event) this.callEvent("onAfter"+event,arguments);
		//}
		return res;	//result of wrapped method
	};
};
//check === undefined
dhtmlx.isNotDefined=function(a){
	return typeof a == "undefined";
};
//delay call to after-render time
dhtmlx.delay=function(method, obj, params, delay){
	setTimeout(function(){
		var ret = method.apply(obj,params);
		method = obj = params = null;
		return ret;
	},delay||1);
};

//common helpers

//generates unique ID (unique per window, nog GUID)
dhtmlx.uid = function(){
	if (!this._seed) this._seed=(new Date).valueOf();	//init seed with timestemp
	this._seed++;
	return this._seed;
};
//resolve ID as html object
dhtmlx.toNode = function(node){
	if (typeof node == "string") return document.getElementById(node);
	return node;
};
//adds extra methods for the array
dhtmlx.toArray = function(array){ 
	return dhtmlx.extend((array||[]),dhtmlx.PowerArray);
};
//resolve function name
dhtmlx.toFunctor=function(str){ 
	return (typeof(str)=="string") ? eval(str) : str; 
};

//dom helpers

//hash of attached events
dhtmlx._events = {};
//attach event to the DOM element
dhtmlx.event=function(node,event,handler,master){
	node = dhtmlx.toNode(node);
	
	var id = dhtmlx.uid();
	dhtmlx._events[id]=[node,event,handler];	//store event info, for detaching
	
	if (master) 
		handler=dhtmlx.bind(handler,master);	
		
	//use IE's of FF's way of event's attaching
	if (node.addEventListener)
		node.addEventListener(event, handler, false);
	else if (node.attachEvent)
		node.attachEvent("on"+event, handler);

	return id;	//return id of newly created event, can be used in eventRemove
};

//remove previously attached event
dhtmlx.eventRemove=function(id){
	
	if (!id) return;
	dhtmlx.assert(this._events[id],"Removing non-existing event");
		
	var ev = dhtmlx._events[id];
	//browser specific event removing
	if (ev[0].removeEventListener)
		ev[0].removeEventListener(ev[1],ev[2],false);
	else if (ev[0].detachEvent)
		ev[0].detachEvent("on"+ev[1],ev[2]);
		
	delete this._events[id];	//delete all traces
};


//debugger helpers
//anything starting from error or log will be removed during code compression

//add message in the log
dhtmlx.log = function(type,message,details){
	if (window.console && console.log){
		type=type.toLowerCase();
		if (window.console[type])
			window.console[type](message||"unknown error");
		else
			window.console.log(type +": "+message);
		if (details) 
			window.console.log(details);
	}	
};
//register rendering time from call point 
dhtmlx.log_full_time = function(name){
	dhtmlx._start_time_log = new Date();
	dhtmlx.log("Info","Timing start ["+name+"]");
	window.setTimeout(function(){
		var time = new Date();
		dhtmlx.log("Info","Timing end ["+name+"]:"+(time.valueOf()-dhtmlx._start_time_log.valueOf())/1000+"s");
	},1);
};
//register execution time from call point
dhtmlx.log_time = function(name){
	var fname = "_start_time_log"+name;
	if (!dhtmlx[fname]){
		dhtmlx[fname] = new Date();
		dhtmlx.log("Info","Timing start ["+name+"]");
	} else {
		var time = new Date();
		dhtmlx.log("Info","Timing end ["+name+"]:"+(time.valueOf()-dhtmlx[fname].valueOf())/1000+"s");
		dhtmlx[fname] = null;
	}
};
//log message with type=error
dhtmlx.error = function(message,details){
	dhtmlx.log("error",message,details);
};
//event system
dhtmlx.EventSystem={
	_init:function(){
		this._events = {};		//hash of event handlers, name => handler
		this._handlers = {};	//hash of event handlers, ID => handler
		this._map = {};
	},
	//temporary block event triggering
	block : function(){
		this._events._block = true;
	},
	//re-enable event triggering
	unblock : function(){
		this._events._block = false;
	},
	mapEvent:function(map){
		dhtmlx.extend(this._map, map);
	},
	//trigger event
	callEvent:function(type,params){
		if (this._events._block) return true;
		
		type = type.toLowerCase();
		dhtmlx.assert_event_call(this, type, params);
		
		var event_stack =this._events[type.toLowerCase()];	//all events for provided name
		var return_value = true;

		if (dhtmlx.debug)	//can slowdown a lot
			dhtmlx.log("info","["+this.name+"] event:"+type,params);
		
		if (event_stack)
			for(var i=0; i<event_stack.length; i++)
				/*
					Call events one by one
					If any event return false - result of whole event will be false
					Handlers which are not returning anything - counted as positive
				*/
				if (event_stack[i].apply(this,(params||[]))===false) return_value=false;
				
		if (this._map[type] && !this._map[type].callEvent(type,params))
			return_value =	false;
			
		return return_value;
	},
	//assign handler for some named event
	attachEvent:function(type,functor,id){
		type=type.toLowerCase();
		dhtmlx.assert_event_attach(this, type);
		
		id=id||dhtmlx.uid(); //ID can be used for detachEvent
		functor = dhtmlx.toFunctor(functor);	//functor can be a name of method

		var event_stack=this._events[type]||dhtmlx.toArray();
		//save new event handler
		event_stack.push(functor);
		this._events[type]=event_stack;
		this._handlers[id]={ f:functor,t:type };
		
		return id;
	},
	//remove event handler
	detachEvent:function(id){
		if(this._handlers[id]){
			var type=this._handlers[id].t;
			var functor=this._handlers[id].f;
			
			//remove from all collections
			var event_stack=this._events[type];
			event_stack.remove(functor);
			delete this._handlers[id];
		}
	} 
};

//array helper
//can be used by dhtmlx.toArray()
dhtmlx.PowerArray={
	//remove element at specified position
	removeAt:function(pos,len){
		if (pos>=0) this.splice(pos,(len||1));
	},
	//find element in collection and remove it 
	remove:function(value){
		this.removeAt(this.find(value));
	},	
	//add element to collection at specific position
	insertAt:function(data,pos){
		if (!pos && pos!==0) 	//add to the end by default
			this.push(data);
		else {	
			var b = this.splice(pos,(this.length-pos));
  			this[pos] = data;
  			this.push.apply(this,b); //reconstruct array without loosing this pointer
  		}
  	},  	
  	//return index of element, -1 if it doesn't exists
  	find:function(data){ 
  		for (i=0; i<this.length; i++) 
  			if (data==this[i]) return i; 	
  		return -1; 
  	},
  	//execute some method for each element of array
  	each:function(functor,master){
		for (var i=0; i < this.length; i++)
			functor.call((master||this),this[i]);
	},
	//create new array from source, by using results of functor 
	map:function(functor,master){
		for (var i=0; i < this.length; i++)
			this[i]=functor.call((master||this),this[i]);
		return this;
	}
};

dhtmlx.env = {};

//environment detection
if (navigator.userAgent.indexOf('Opera') != -1)
	dhtmlx._isOpera=true;
else{
	//very rough detection, but it is enough for current goals
	dhtmlx._isIE=!!document.all;
	dhtmlx._isFF=!document.all;
	dhtmlx._isWebKit=(navigator.userAgent.indexOf("KHTML")!=-1);
	if (navigator.appVersion.indexOf("MSIE 8.0")!= -1 && document.compatMode != "BackCompat") 
		dhtmlx._isIE=8;
	if (navigator.appVersion.indexOf("MSIE 9.0")!= -1 && document.compatMode != "BackCompat") 
		dhtmlx._isIE=9;
}

dhtmlx.env = {};

// dhtmlx.env.transform 
// dhtmlx.env.transition
(function(){
	dhtmlx.env.transform = false;
	dhtmlx.env.transition = false;
	var options = {};
	options.names = ['transform', 'transition'];
	options.transform = ['transform', 'WebkitTransform', 'MozTransform', 'oTransform','msTransform'];
	options.transition = ['transition', 'WebkitTransition', 'MozTransition', 'oTransition'];
	
	var d = document.createElement("DIV");
	var property;
	for(var i=0; i<options.names.length; i++) {
		while (p = options[options.names[i]].pop()) {
			if(typeof d.style[p] != 'undefined')
				dhtmlx.env[options.names[i]] = true;
		}
	}
})();
dhtmlx.env.transform_prefix = (function(){
		var prefix;
		if(dhtmlx._isOpera)
			prefix = '-o-';
		else {
			prefix = ''; // default option
			if(dhtmlx._isFF) 
				prefix = '-moz-';
			if(dhtmlx._isWebKit) 
					prefix = '-webkit-';
		}
		return prefix;
})();
dhtmlx.env.svg = (function(){
		return document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
})();

//store maximum used z-index
dhtmlx.zIndex={ drag : 10000 };

//html helpers
dhtmlx.html={
	create:function(name,attrs,html){
		attrs = attrs || {};
		var node = document.createElement(name);
		for (var attr_name in attrs)
			node.setAttribute(attr_name, attrs[attr_name]);
		if (attrs.style)
			node.style.cssText = attrs.style;
		if (attrs["class"])
			node.className = attrs["class"];
		if (html)
			node.innerHTML=html;
		return node;
	},
	//return node value, different logic for different html elements
	getValue:function(node){
		node = dhtmlx.toNode(node);
		if (!node) return "";
		return dhtmlx.isNotDefined(node.value)?node.innerHTML:node.value;
	},
	//remove html node, can process an array of nodes at once
	remove:function(node){
		if (node instanceof Array)
			for (var i=0; i < node.length; i++)
				this.remove(node[i]);
		else
			if (node && node.parentNode)
				node.parentNode.removeChild(node);
	},
	//insert new node before sibling, or at the end if sibling doesn't exist
	insertBefore: function(node,before,rescue){
		if (!node) return;
		if (before)
			before.parentNode.insertBefore(node, before);
		else
			rescue.appendChild(node);
	},
	//return custom ID from html element 
	//will check all parents starting from event's target
	locate:function(e,id){
		e=e||event;
		var trg=e.target||e.srcElement;
		while (trg){
			if (trg.getAttribute){	//text nodes has not getAttribute
				var test = trg.getAttribute(id);
				if (test) return test;
			}
			trg=trg.parentNode;
		}	
		return null;
	},
	//returns position of html element on the page
	offset:function(elem) {
		if (elem.getBoundingClientRect) { //HTML5 method
			var box = elem.getBoundingClientRect();
			var body = document.body;
			var docElem = document.documentElement;
			var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
			var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
			var clientTop = docElem.clientTop || body.clientTop || 0;
			var clientLeft = docElem.clientLeft || body.clientLeft || 0;
			var top  = box.top +  scrollTop - clientTop;
			var left = box.left + scrollLeft - clientLeft;
			return { y: Math.round(top), x: Math.round(left) };
		} else { //fallback to naive approach
			var top=0, left=0;
			while(elem) {
				top = top + parseInt(elem.offsetTop,10);
				left = left + parseInt(elem.offsetLeft,10);
				elem = elem.offsetParent;
			}
			return {y: top, x: left};
		}
	},
	//returns position of event
	pos:function(ev){
		ev = ev || event;
        if(ev.pageX || ev.pageY)	//FF, KHTML
            return {x:ev.pageX, y:ev.pageY};
        //IE
        var d  =  ((dhtmlx._isIE)&&(document.compatMode != "BackCompat"))?document.documentElement:document.body;
        return {
                x:ev.clientX + d.scrollLeft - d.clientLeft,
                y:ev.clientY + d.scrollTop  - d.clientTop
        };
	},
	//prevent event action
	preventEvent:function(e){
		if (e && e.preventDefault) e.preventDefault();
		dhtmlx.html.stopEvent(e);
	},
	//stop event bubbling
	stopEvent:function(e){
		(e||event).cancelBubble=true;
		return false;
	},
	//add css class to the node
	addCss:function(node,name){
        node.className+=" "+name;
    },
    //remove css class from the node
    removeCss:function(node,name){
        node.className=node.className.replace(RegExp(name,"g"),"");
    }
};

//autodetect codebase folder
(function(){
	var temp = document.getElementsByTagName("SCRIPT");	//current script, most probably
	dhtmlx.assert(temp.length,"Can't locate codebase");
	if (temp.length){
		//full path to script
		temp = (temp[temp.length-1].getAttribute("src")||"").split("/");
		//get folder name
		temp.splice(temp.length-1, 1);
		dhtmlx.codebase = temp.slice(0, temp.length).join("/")+"/";
	}
})();

if (!dhtmlx.ui)
	dhtmlx.ui={};


/* DHX DEPEND FROM FILE 'destructor.js'*/


/*
	Behavior:Destruction
	
	@export
		destructor
*/

/*DHX:Depend dhtmlx.js*/

dhtmlx.Destruction = {
	_init:function(){
		//register self in global list of destructors
		dhtmlx.destructors.push(this);
	},
	//will be called automatically on unload, can be called manually
	//simplifies job of GC
	destructor:function(mode){
		this.destructor=function(){}; //destructor can be called only once
		
		//html collection
		this._htmlmap  = null;
		this._htmlrows = null;
		
		//temp html element, used by toHTML
		if (this._html)
			document.body.appendChild(this._html);	//need to attach, for IE's GC

		this._html = null;
		if (this._obj) {
			this._obj.innerHTML="";
			this._obj._htmlmap = null;
		}
		this._obj = this._dataobj = null;
		this.data = null;
		this._events = this._handlers = {};
		this.canvases = [];
		if(this.render)
			this.render = function(){};//need in case of delayed method calls (virtual render case)

		// not effective, need to remove all event listeners as well
		//
		// if (mode != -1)
		// 	for (var i=0; i<dhtmlx.destructors.length; i++)
		// 		if (dhtmlx.destructors[i] == this){
		// 			dhtmlx.destructors.splice(i,1);
		// 			break;
		// 		}
	}
};
//global list of destructors
dhtmlx.destructors = [];
dhtmlx.event(window,"unload",function(){
	//call all registered destructors
	if (dhtmlx.destructors){
		for (var i=0; i<dhtmlx.destructors.length; i++)
			dhtmlx.destructors[i].destructor(-1);
		dhtmlx.destructors = [];
	}
	
	//detach all known DOM events
	for (var a in dhtmlx._events){
		var ev = dhtmlx._events[a];
		if (ev[0].removeEventListener)
			ev[0].removeEventListener(ev[1],ev[2],false);
		else if (ev[0].detachEvent)
			ev[0].detachEvent("on"+ev[1],ev[2]);
		delete dhtmlx._events[a];
	}
});





/* DHX DEPEND FROM FILE 'load.js'*/


/* 
	ajax operations 
	
	can be used for direct loading as
		dhtmlx.ajax(ulr, callback)
	or
		dhtmlx.ajax().item(url)
		dhtmlx.ajax().post(url)

*/

/*DHX:Depend dhtmlx.js*/

dhtmlx.ajax = function(url,call,master){
	//if parameters was provided - made fast call
	if (arguments.length!==0){
		var http_request = new dhtmlx.ajax();
		if (master) http_request.master=master;
		http_request.get(url,null,call);
	}
	if (!this.getXHR) return new dhtmlx.ajax(); //allow to create new instance without direct new declaration
	
	return this;
};
dhtmlx.ajax.prototype={
	//creates xmlHTTP object
	getXHR:function(){
		if (dhtmlx._isIE)
		 return new ActiveXObject("Microsoft.xmlHTTP");
		else 
		 return new XMLHttpRequest();
	},
	/*
		send data to the server
		params - hash of properties which will be added to the url
		call - callback, can be an array of functions
	*/
	send:function(url,params,call){
		var x=this.getXHR();
		if (typeof call == "function")
		 call = [call];
		//add extra params to the url
		if (typeof params == "object"){
			var t=[];
			for (var a in params){
				var value = params[a];
				if (value === null || value === dhtmlx.undefined)
					value = "";
				t.push(a+"="+encodeURIComponent(value));// utf-8 escaping
		 	}
			params=t.join("&");
		}
		if (params && !this.post){
			url=url+(url.indexOf("?")!=-1 ? "&" : "?")+params;
			params=null;
		}
		
		x.open(this.post?"POST":"GET",url,!this._sync);
		if (this.post)
		 x.setRequestHeader('Content-type','application/x-www-form-urlencoded');
		 
		//async mode, define loading callback
		//if (!this._sync){
		 var self=this;
		 x.onreadystatechange= function(){
			if (!x.readyState || x.readyState == 4){
				//dhtmlx.log_full_time("data_loading");	//log rendering time
				if (call && self) 
					for (var i=0; i < call.length; i++)	//there can be multiple callbacks
					 if (call[i])
						call[i].call((self.master||self),x.responseText,x.responseXML,x);
				self.master=null;
				call=self=null;	//anti-leak
			}
		 };
		//}
		
		x.send(params||null);
		return x; //return XHR, which can be used in case of sync. mode
	},
	//GET request
	get:function(url,params,call){
		this.post=false;
		return this.send(url,params,call);
	},
	//POST request
	post:function(url,params,call){
		this.post=true;
		return this.send(url,params,call);
	}, 
	sync:function(){
		this._sync = true;
		return this;
	}
};


dhtmlx.AtomDataLoader={
	_init:function(config){
		//prepare data store
		this.data = {}; 
		if (config){
			this._settings.datatype = config.datatype||"json";
			this._after_init.push(this._load_when_ready);
		}
	},
	_load_when_ready:function(){
		this._ready_for_data = true;
		
		if (this._settings.url)
			this.url_setter(this._settings.url);
		if (this._settings.data)
			this.data_setter(this._settings.data);
	},
	url_setter:function(value){
		if (!this._ready_for_data) return value;
		this.load(value, this._settings.datatype);	
		return value;
	},
	data_setter:function(value){
		if (!this._ready_for_data) return value;
		this.parse(value, this._settings.datatype);
		return true;
	},
	//loads data from external URL
	load:function(url,call){
		this.callEvent("onXLS",[]);
		if (typeof call == "string"){	//second parameter can be a loading type or callback
			this.data.driver = dhtmlx.DataDriver[call];
			call = arguments[2];
		}
		else
			this.data.driver = dhtmlx.DataDriver[this._settings.datatype||"xml"];
		//load data by async ajax call
		if (window.dhx4){
			dhx4.ajax.get(url,dhtmlx.bind(function(x){
				var loader = x.xmlDoc;
				var text = loader.responseText;
				var xml = loader.responseXML;

				if (this._onLoad)
					this._onLoad.call(this, text, xml, loader);
				if (call)
					call.call(this, text, xml, loader);
			},this));
		} else
			dhtmlx.ajax(url,[this._onLoad,call],this);
	},
	//loads data from object
	parse:function(data,type){
		this.callEvent("onXLS",[]);
		this.data.driver = dhtmlx.DataDriver[type||"xml"];
		this._onLoad(data,null);
	},
	//default after loading callback
	_onLoad:function(text,xml,loader){
		var driver = this.data.driver;
		var top = driver.getRecords(driver.toObject(text,xml))[0];
		this.data=(driver?driver.getDetails(top):text);
		this.callEvent("onXLE",[]);
	},
	_check_data_feed:function(data){
		if (!this._settings.dataFeed || this._ignore_feed || !data) return true;
		var url = this._settings.dataFeed;
		if (typeof url == "function")
			return url.call(this, (data.id||data), data);
		url = url+(url.indexOf("?")==-1?"?":"&")+"action=get&id="+encodeURIComponent(data.id||data);
		this.callEvent("onXLS",[]);
		dhtmlx.ajax(url, function(text,xml){
			this._ignore_feed=true;
			this.setValues(dhtmlx.DataDriver.json.toObject(text)[0]);
			this._ignore_feed=false;
			this.callEvent("onXLE",[]);
		}, this);
		return false;
	}
};

/*
	Abstraction layer for different data types
*/

dhtmlx.DataDriver={};
dhtmlx.DataDriver.json={
	//convert json string to json object if necessary
	toObject:function(data){
		if (!data) data="[]";
		if (typeof data == "string"){
		 eval ("dhtmlx.temp="+data);
		 return dhtmlx.temp;
		}
		return data;
	},
	//get array of records
	getRecords:function(data){
		if (data && data.data)
			data = data.data;
		if (data && !(data instanceof Array))
		 return [data];
		return data;
	},
	//get hash of properties for single record
	getDetails:function(data){
		return data;
	},
	//get count of data and position at which new data need to be inserted
	getInfo:function(data){
		return { 
		 _size:(data.total_count||0),
		 _from:(data.pos||0),
		 _key:(data.dhx_security)
		};
	}
};

dhtmlx.DataDriver.json_ext={
	//convert json string to json object if necessary
	toObject:function(data){
		if (!data) data="[]";
		if (typeof data == "string"){
			var temp;
			eval ("temp="+data);
			dhtmlx.temp = [];
			var header  = temp.header;
			for (var i = 0; i < temp.data.length; i++) {
				var item = {};
				for (var j = 0; j < header.length; j++) {
					if (typeof(temp.data[i][j]) != "undefined")
						item[header[j]] = temp.data[i][j];
				}
				dhtmlx.temp.push(item);
			}
			return dhtmlx.temp;
		}
		return data;
	},
	//get array of records
	getRecords:function(data){
		if (data && !(data instanceof Array))
		 return [data];
		return data;
	},
	//get hash of properties for single record
	getDetails:function(data){
		return data;
	},
	//get count of data and position at which new data need to be inserted
	getInfo:function(data){
		return {
		 _size:(data.total_count||0),
		 _from:(data.pos||0)
		};
	}
};

dhtmlx.DataDriver.html={
	/*
		incoming data can be
		 - collection of nodes
		 - ID of parent container
		 - HTML text
	*/
	toObject:function(data){
		if (typeof data == "string"){
		 var t=null;
		 if (data.indexOf("<")==-1)	//if no tags inside - probably its an ID
			t = dhtmlx.toNode(data);
		 if (!t){
			t=document.createElement("DIV");
			t.innerHTML = data;
		 }
		 
		 return t.getElementsByTagName(this.tag);
		}
		return data;
	},
	//get array of records
	getRecords:function(data){
		if (data.tagName)
		 return data.childNodes;
		return data;
	},
	//get hash of properties for single record
	getDetails:function(data){
		return dhtmlx.DataDriver.xml.tagToObject(data);
	},
	//dyn loading is not supported by HTML data source
	getInfo:function(data){
		return { 
		 _size:0,
		 _from:0
		};
	},
	tag: "LI"
};

dhtmlx.DataDriver.jsarray={
	//eval jsarray string to jsarray object if necessary
	toObject:function(data){
		if (typeof data == "string"){
		 eval ("dhtmlx.temp="+data);
		 return dhtmlx.temp;
		}
		return data;
	},
	//get array of records
	getRecords:function(data){
		return data;
	},
	//get hash of properties for single record, in case of array they will have names as "data{index}"
	getDetails:function(data){
		var result = {};
		for (var i=0; i < data.length; i++) 
		 result["data"+i]=data[i];
		 
		return result;
	},
	//dyn loading is not supported by js-array data source
	getInfo:function(data){
		return { 
		 _size:0,
		 _from:0
		};
	}
};

dhtmlx.DataDriver.csv={
	//incoming data always a string
	toObject:function(data){
		return data;
	},
	//get array of records
	getRecords:function(data){
		return data.split(this.row);
	},
	//get hash of properties for single record, data named as "data{index}"
	getDetails:function(data){
		data = this.stringToArray(data);
		var result = {};
		for (var i=0; i < data.length; i++) 
		 result["data"+i]=data[i];
		 
		return result;
	},
	//dyn loading is not supported by csv data source
	getInfo:function(data){
		return { 
		 _size:0,
		 _from:0
		};
	},
	//split string in array, takes string surrounding quotes in account
	stringToArray:function(data){
		data = data.split(this.cell);
		for (var i=0; i < data.length; i++)
		 data[i] = data[i].replace(/^[ \t\n\r]*(\"|)/g,"").replace(/(\"|)[ \t\n\r]*$/g,"");
		return data;
	},
	row:"\n",	//default row separator
	cell:","	//default cell separator
};

dhtmlx.DataDriver.xml={
	//convert xml string to xml object if necessary
	toObject:function(text,xml){
		if (xml && (xml=this.checkResponse(text,xml)))	//checkResponse - fix incorrect content type and extra whitespaces errors
		 return xml;
		if (typeof text == "string"){
		 return this.fromString(text);
		}
		return text;
	},
	//get array of records
	getRecords:function(data){
		return this.xpath(data,this.records);
	},
	records:"/*/item",
	//get hash of properties for single record
	getDetails:function(data){
		return this.tagToObject(data,{});
	},
	//get count of data and position at which new data_loading need to be inserted
	getInfo:function(data){
		return { 
		 _size:(data.documentElement.getAttribute("total_count")||0),
		 _from:(data.documentElement.getAttribute("pos")||0),
		 _key:(data.documentElement.getAttribute("dhx_security"))
		};
	},
	//xpath helper
	xpath:function(xml,path){
		if (window.XPathResult){	//FF, KHTML, Opera
		 var node=xml;
		 if(xml.nodeName.indexOf("document")==-1)
		 xml=xml.ownerDocument;
		 var res = [];
		 var col = xml.evaluate(path, node, null, XPathResult.ANY_TYPE, null);
		 var temp = col.iterateNext();
		 while (temp){ 
			res.push(temp);
			temp = col.iterateNext();
		}
		return res;
		}	
		else {
			var test = true;
			try {
				if (typeof(xml.selectNodes)=="undefined")
					test = false;
			} catch(e){ /*IE7 and below can't operate with xml object*/ }
			//IE
			if (test)
				return xml.selectNodes(path);
			else {
				//Google hate us, there is no interface to do XPath
				//use naive approach
				var name = path.split("/").pop();
				return xml.getElementsByTagName(name);
			}
		}
	},
	//convert xml tag to js object, all subtags and attributes are mapped to the properties of result object
	tagToObject:function(tag,z){
		z=z||{};
		var flag=false;
		

		//map subtags
		var b=tag.childNodes;
		var state = {};
		for (var i=0; i<b.length; i++){
			if (b[i].nodeType==1){
				var name = b[i].tagName;
				if (typeof z[name] != "undefined"){
					if (!(z[name] instanceof Array))
						z[name]=[z[name]];
					z[name].push(this.tagToObject(b[i],{}));
				}
				else
					z[b[i].tagName]=this.tagToObject(b[i],{});	//sub-object for complex subtags
				flag=true;
			}
		}

		//map attributes
		var a=tag.attributes;
		if(a && a.length){
			for (var i=0; i<a.length; i++)
		 		z[a[i].name]=a[i].value;
		 	flag = true;
	 	}
		
		if (!flag)
			return this.nodeValue(tag);
		//each object will have its text content as "value" property
		z.value = this.nodeValue(tag);
		return z;
	},
	//get value of xml node 
	nodeValue:function(node){
		if (node.firstChild)
			return node.firstChild.wholeText||node.firstChild.data;
		return "";
	},
	//convert XML string to XML object
	fromString:function(xmlString){
		if (window.DOMParser && !dhtmlx._isIE)		// FF, KHTML, Opera
		 return (new DOMParser()).parseFromString(xmlString,"text/xml");
		if (window.ActiveXObject){	// IE, utf-8 only 
		 var temp=new ActiveXObject("Microsoft.xmlDOM");
		 temp.loadXML(xmlString);
		 return temp;
		}
		dhtmlx.error("Load from xml string is not supported");
	},
	//check is XML correct and try to reparse it if its invalid
	checkResponse:function(text,xml){ 
		if (xml && ( xml.firstChild && xml.firstChild.tagName != "parsererror") )
			return xml;
		//parsing as string resolves incorrect content type
		//regexp removes whitespaces before xml declaration, which is vital for FF
		var a=this.fromString(text.replace(/^[\s]+/,""));
		if (a) return a;
		
		dhtmlx.error("xml can't be parsed",text);
	}
};




/* DHX DEPEND FROM FILE 'datastore.js'*/


/*DHX:Depend load.js*/
/*DHX:Depend dhtmlx.js*/

/*
	Behavior:DataLoader - load data in the component
	
	@export
		load
		parse
*/
dhtmlx.DataLoader={
	_init:function(config){
		//prepare data store
		config = config || "";
		this.name = "DataStore";
		this.data = (config.datastore)||(new dhtmlx.DataStore());
		this._readyHandler = this.data.attachEvent("onStoreLoad",dhtmlx.bind(this._call_onready,this));
	},
	//loads data from external URL
	load:function(url,call){
		dhtmlx.AtomDataLoader.load.apply(this, arguments);
		//prepare data feed for dyn. loading
		if (!this.data.feed)
		 this.data.feed = function(from,count){
			//allow only single request at same time
			if (this._load_count)
				return this._load_count=[from,count];	//save last ignored request
			else
				this._load_count=true;
				
			this.load(url+((url.indexOf("?")==-1)?"?":"&")+"posStart="+from+"&count="+count,function(){
				//after loading check if we have some ignored requests
				var temp = this._load_count;
				this._load_count = false;
				if (typeof temp =="object")
					this.data.feed.apply(this, temp);	//load last ignored request
			});
		};
	},
	//default after loading callback
	_onLoad:function(text,xml,loader){
		this.data._parse(this.data.driver.toObject(text,xml));
		this.callEvent("onXLE",[]);
		if(this._readyHandler){
			this.data.detachEvent(this._readyHandler);
			this._readyHandler = null;
		}
	},
	dataFeed_setter:function(value){
		this.data.attachEvent("onBeforeFilter", dhtmlx.bind(function(text, value){
			if (this._settings.dataFeed){
				var filter = {};
				if (!text && !filter) return;
				if (typeof text == "function"){
					if (!value) return;
					text(value, filter);
				} else 
					filter = { text:value };

				this.clearAll();
				var url = this._settings.dataFeed;
				if (typeof url == "function")
					return url.call(this, value, filter);
				var urldata = [];
				for (var key in filter)
					urldata.push("dhx_filter["+key+"]="+encodeURIComponent(filter[key]));
				this.load(url+(url.indexOf("?")<0?"?":"&")+urldata.join("&"), this._settings.datatype);
				return false;
			}
		},this));
		return value;
	},
	_call_onready:function(){
		if (this._settings.ready){
			var code = dhtmlx.toFunctor(this._settings.ready);
			if (code && code.call) code.apply(this, arguments);
		}
	}
};


/*
	DataStore is not a behavior, it standalone object, which represents collection of data.
	Call provideAPI to map data API

	@export
		exists
		idByIndex
		indexById
		get
		set
		refresh
		dataCount
		sort
		filter
		next
		previous
		clearAll
		first
		last
*/
dhtmlx.DataStore = function(){
	this.name = "DataStore";
	
	dhtmlx.extend(this, dhtmlx.EventSystem);
	
	this.setDriver("xml");	//default data source is an XML
	this.pull = {};						//hash of IDs
	this.order = dhtmlx.toArray();		//order of IDs
};

dhtmlx.DataStore.prototype={
	//defines type of used data driver
	//data driver is an abstraction other different data formats - xml, json, csv, etc.
	setDriver:function(type){
		dhtmlx.assert(dhtmlx.DataDriver[type],"incorrect DataDriver");
		this.driver = dhtmlx.DataDriver[type];
	},
	//process incoming raw data
	_parse:function(data){
		this.callEvent("onParse", [this.driver, data]);
		if (this._filter_order)
			this.filter();
			
		//get size and position of data
		var info = this.driver.getInfo(data);
		if (info._key)
			dhtmlx.security_key = info._key;
		//get array of records

		var recs = this.driver.getRecords(data);
		var from = (info._from||0)*1;
		
		if (from === 0 && this.order[0]) //update mode
			from = this.order.length;
		
		var j=0;
		for (var i=0; i<recs.length; i++){
			//get has of details for each record
			var temp = this.driver.getDetails(recs[i]);
			var id = this.id(temp); 	//generate ID for the record
			if (!this.pull[id]){		//if such ID already exists - update instead of insert
				this.order[j+from]=id;	
				j++;
			}
			this.pull[id]=temp;
			//if (this._format)	this._format(temp);
			
			if (this.extraParser)
				this.extraParser(temp);
			if (this._scheme){ 
				if (this._scheme.$init)
					this._scheme.$update(temp);
				else if (this._scheme.$update)
					this._scheme.$update(temp);
			}
		}

		//for all not loaded data
		for (var i=0; i < info._size; i++)
			if (!this.order[i]){
				var id = dhtmlx.uid();
				var temp = {id:id, $template:"loading"};	//create fake records
				this.pull[id]=temp;
				this.order[i]=id;
			}

		this.callEvent("onStoreLoad",[this.driver, data]);
		//repaint self after data loading
		this.refresh();
	},
	//generate id for data object
	id:function(data){
		return data.id||(data.id=dhtmlx.uid());
	},
	changeId:function(old, newid){
		dhtmlx.assert(this.pull[old],"Can't change id, for non existing item: "+old);
		this.pull[newid] = this.pull[old];
		this.pull[newid].id = newid;
		this.order[this.order.find(old)]=newid;
		if (this._filter_order)
			this._filter_order[this._filter_order.find(old)]=newid;
		this.callEvent("onIdChange", [old, newid]);
		if (this._render_change_id)
			this._render_change_id(old, newid);
	},
	get:function(id){
		return this.item(id);
	},
	set:function(id, data){
		return this.update(id, data);
	},
	//get data from hash by id
	item:function(id){
		return this.pull[id];
	},
	//assigns data by id
	update:function(id,data){
		if (this._scheme && this._scheme.$update)
			this._scheme.$update(data);
		if (this.callEvent("onBeforeUpdate", [id, data]) === false) return false;
		this.pull[id]=data;
		this.refresh(id);
	},
	//sends repainting signal
	refresh:function(id){
		if (this._skip_refresh) return; 
		
		if (id)
			this.callEvent("onStoreUpdated",[id, this.pull[id], "update"]);
		else
			this.callEvent("onStoreUpdated",[null,null,null]);
	},
	silent:function(code){
		this._skip_refresh = true;
		code.call(this);
		this._skip_refresh = false;
	},
	//converts range IDs to array of all IDs between them
	getRange:function(from,to){		
		//if some point is not defined - use first or last id
		//BEWARE - do not use empty or null ID
		if (from)
			from = this.indexById(from);
		else 
			from = this.startOffset||0;
		if (to)
			to = this.indexById(to);
		else {
			to = Math.min((this.endOffset||Infinity),(this.dataCount()-1));
			if (to<0) to = 0; //we have not data in the store
		}

		if (this.min)
			from = this.min;
		if (this.max)
			to = this.max;

		if (from>to){ //can be in case of backward shift-selection
			var a=to; to=from; from=a;
		}
				
		return this.getIndexRange(from,to);
	},
	//converts range of indexes to array of all IDs between them
	getIndexRange:function(from,to){
		to=Math.min((to||Infinity),this.dataCount()-1);
		
		var ret=dhtmlx.toArray(); //result of method is rich-array
		for (var i=(from||0); i <= to; i++)
			ret.push(this.item(this.order[i]));
		return ret;
	},
	//returns total count of elements
	dataCount:function(){
		return this.order.length;
	},
	//returns truy if item with such ID exists
	exists:function(id){
		return !!(this.pull[id]);
	},
	//nextmethod is not visible on component level, check DataMove.move
	//moves item from source index to the target index
	move:function(sindex,tindex){
		if (sindex<0 || tindex<0){
			dhtmlx.error("DataStore::move","Incorrect indexes");
			return;
		}
		
		var id = this.idByIndex(sindex);
		var obj = this.item(id);
		
		this.order.removeAt(sindex);	//remove at old position
		//if (sindex<tindex) tindex--;	//correct shift, caused by element removing
		this.order.insertAt(id,Math.min(this.order.length, tindex));	//insert at new position
		
		//repaint signal
		this.callEvent("onStoreUpdated",[id,obj,"move"]);
	},
	scheme:function(config){
		/*
			some.scheme({
				order:1,
				name:"dummy",
				title:""
			})
		*/
		this._scheme = config;
		
	},
	sync:function(source, filter, silent){
		if (typeof filter != "function"){
			silent = filter;
			filter = null;
		}
		
		if (dhtmlx.debug_bind){
			this.debug_sync_master = source; 
			dhtmlx.log("[sync] "+this.debug_bind_master.name+"@"+this.debug_bind_master._settings.id+" <= "+this.debug_sync_master.name+"@"+this.debug_sync_master._settings.id);
		}
		
		var topsource = source;
		if (source.name != "DataStore")
			source = source.data;

		var sync_logic = dhtmlx.bind(function(id, data, mode){
			if (mode != "update" || filter) 
				id = null;

			if (!id){
				this.order = dhtmlx.toArray([].concat(source.order));
				this._filter_order = null;
				this.pull = source.pull;
				
				if (filter)
					this.silent(filter);
				
				if (this._on_sync)
					this._on_sync();
			}

			if (dhtmlx.debug_bind)
				dhtmlx.log("[sync:request] "+this.debug_sync_master.name+"@"+this.debug_sync_master._settings.id + " <= "+this.debug_bind_master.name+"@"+this.debug_bind_master._settings.id);
			if (!silent) 
				this.refresh(id);
			else
				silent = false;
		}, this);
		
		source.attachEvent("onStoreUpdated", sync_logic);
		this.feed = function(from, count){
			topsource.loadNext(count, from);
		};
		sync_logic();
	},
	//adds item to the store
	add:function(obj,index){
		
		if (this._scheme){
			obj = obj||{};
			for (var key in this._scheme)
				obj[key] = obj[key]||this._scheme[key];
			if (this._scheme){ 
				if (this._scheme.$init)
					this._scheme.$update(obj);
				else if (this._scheme.$update)
					this._scheme.$update(obj);
			}
		}
		
		//generate id for the item
		var id = this.id(obj);
		
		//by default item is added to the end of the list
		var data_size = this.dataCount();
		
		if (dhtmlx.isNotDefined(index) || index < 0)
			index = data_size; 
		//check to prevent too big indexes			
		if (index > data_size){
			dhtmlx.log("Warning","DataStore:add","Index of out of bounds");
			index = Math.min(this.order.length,index);
		}
		if (this.callEvent("onBeforeAdd", [id, obj, index]) === false) return false;

		if (this.exists(id)) return dhtmlx.error("Not unique ID");
		
		this.pull[id]=obj;
		this.order.insertAt(id,index);
		if (this._filter_order){	//adding during filtering
			//we can't know the location of new item in full dataset, making suggestion
			//put at end by default
			var original_index = this._filter_order.length;
			//put at start only if adding to the start and some data exists
			if (!index && this.order.length)
				original_index = 0;
			
			this._filter_order.insertAt(id,original_index);
		}
		this.callEvent("onafterAdd",[id,index]);
		//repaint signal
		this.callEvent("onStoreUpdated",[id,obj,"add"]);
		return id;
	},
	
	//removes element from datastore
	remove:function(id){
		//id can be an array of IDs - result of getSelect, for example
		if (id instanceof Array){
			for (var i=0; i < id.length; i++)
				this.remove(id[i]);
			return;
		}
		if (this.callEvent("onBeforeDelete",[id]) === false) return false;
		if (!this.exists(id)) return dhtmlx.error("Not existing ID",id);
		var obj = this.item(id);	//save for later event
		//clear from collections
		this.order.remove(id);
		if (this._filter_order) 
			this._filter_order.remove(id);
			
		delete this.pull[id];
		this.callEvent("onafterdelete",[id]);
		//repaint signal
		this.callEvent("onStoreUpdated",[id,obj,"delete"]);
	},
	//deletes all records in datastore
	clearAll:function(){
		//instead of deleting one by one - just reset inner collections
		this.pull = {};
		this.order = dhtmlx.toArray();
		this.feed = null;
		this._filter_order = null;
		this.callEvent("onClearAll",[]);
		this.refresh();
	},
	//converts id to index
	idByIndex:function(index){
		if (index>=this.order.length || index<0)
			dhtmlx.log("Warning","DataStore::idByIndex Incorrect index");
			
		return this.order[index];
	},
	//converts index to id
	indexById:function(id){
		var res = this.order.find(id);	//slower than idByIndex
		
		//if (!this.pull[id])
		//	dhtmlx.log("Warning","DataStore::indexById Non-existing ID: "+ id);
			
		return res;
	},
	//returns ID of next element
	next:function(id,step){
		return this.order[this.indexById(id)+(step||1)];
	},
	//returns ID of first element
	first:function(){
		return this.order[0];
	},
	//returns ID of last element
	last:function(){
		return this.order[this.order.length-1];
	},
	//returns ID of previous element
	previous:function(id,step){
		return this.order[this.indexById(id)-(step||1)];
	},
	/*
		sort data in collection
			by - settings of sorting
		
		or
		
			by - sorting function
			dir - "asc" or "desc"
			
		or
		
			by - property
			dir - "asc" or "desc"
			as - type of sortings
		
		Sorting function will accept 2 parameters and must return 1,0,-1, based on desired order
	*/
	sort:function(by, dir, as){
		var sort = by;	
		if (typeof by == "function")
			sort = {as:by, dir:dir};
		else if (typeof by == "string")
			sort = {by:by, dir:dir, as:as};		
		
		
		var parameters = [sort.by, sort.dir, sort.as];
		if (!this.callEvent("onbeforesort",parameters)) return;	
		
		if (this.order.length){
			var sorter = dhtmlx.sort.create(sort);
			//get array of IDs
			var neworder = this.getRange(this.first(), this.last());
			neworder.sort(sorter);
			this.order = neworder.map(function(obj){ return this.id(obj); },this);
		}
		
		//repaint self
		this.refresh();
		
		this.callEvent("onaftersort",parameters);
	},
	/*
		Filter datasource
		
		text - property, by which filter
		value - filter mask
		
		or
		
		text  - filter method
		
		Filter method will receive data object and must return true or false
	*/
	filter:function(text,value){
		if (!this.callEvent("onBeforeFilter", [text, value])) return;
		
		//remove previous filtering , if any
		if (this._filter_order){
			this.order = this._filter_order;
			delete this._filter_order;
		}
		
		if (!this.order.length) return;
		
		//if text not define -just unfilter previous state and exit
		if (text){
			var filter = text;
			value = value||"";
			if (typeof text == "string"){
				text = dhtmlx.Template.fromHTML(text);
				value = value.toString().toLowerCase();
				filter = function(obj,value){	//default filter - string start from, case in-sensitive
					return text(obj).toLowerCase().indexOf(value)!=-1;
				};
			}
			
					
			var neworder = dhtmlx.toArray();
			for (var i=0; i < this.order.length; i++){
				var id = this.order[i];
				if (filter(this.item(id),value))
					neworder.push(id);
			}
			//set new order of items, store original
			this._filter_order = this.order;
			this.order = neworder;
		}
		//repaint self
		this.refresh();
		
		this.callEvent("onAfterFilter", []);
	},
	/*
		Iterate through collection
	*/
	each:function(method,master){
		for (var i=0; i<this.order.length; i++)
			method.call((master||this), this.item(this.order[i]));
	},
	/*
		map inner methods to some distant object
	*/
	provideApi:function(target,eventable){
		this.debug_bind_master = target;
			
		if (eventable){
			this.mapEvent({
				onbeforesort:	target,
				onaftersort:	target,
				onbeforeadd:	target,
				onafteradd:		target,
				onbeforedelete:	target,
				onafterdelete:	target,
				onbeforeupdate: target/*,
				onafterfilter:	target,
				onbeforefilter:	target*/
			});
		}
			
		var list = ["get","set","sort","add","remove","exists","idByIndex","indexById","item","update","refresh","dataCount","filter","next","previous","clearAll","first","last","serialize"];
		for (var i=0; i < list.length; i++)
			target[list[i]]=dhtmlx.methodPush(this,list[i]);
			
		if (dhtmlx.assert_enabled())		
			this.assert_event(target);
	},
	/*
		serializes data to a json object
	*/
	serialize: function(){
		var ids = this.order;
		var result = [];
		for(var i=0; i< ids.length;i++)
			result.push(this.pull[ids[i]]); 
		return result;
	}
};

dhtmlx.sort = {
	create:function(config){
		return dhtmlx.sort.dir(config.dir, dhtmlx.sort.by(config.by, config.as));
	},
	as:{
		"int":function(a,b){
			a = a*1; b=b*1;
			return a>b?1:(a<b?-1:0);
		},
		"string_strict":function(a,b){
			a = a.toString(); b=b.toString();
			return a>b?1:(a<b?-1:0);
		},
		"string":function(a,b){
			a = a.toString().toLowerCase(); b=b.toString().toLowerCase();
			return a>b?1:(a<b?-1:0);
		}
	},
	by:function(prop, method){
		if (!prop)
			return method;
		if (typeof method != "function")
			method = dhtmlx.sort.as[method||"string"];
		prop = dhtmlx.Template.fromHTML(prop);
		return function(a,b){
			return method(prop(a),prop(b));
		};
	},
	dir:function(prop, method){
		if (prop == "asc")
			return method;
		return function(a,b){
			return method(a,b)*-1;
		};
	}
};



/* DHX DEPEND FROM FILE 'key.js'*/


/*
	Behavior:KeyEvents - hears keyboard 
*/
dhtmlx.KeyEvents = {
	_init:function(){
		//attach handler to the main container
		dhtmlx.event(this._obj,"keypress",this._onKeyPress,this);
	},
	//called on each key press , when focus is inside of related component
	_onKeyPress:function(e){
		e=e||event;
		var code = e.which||e.keyCode; //FIXME  better solution is required
		this.callEvent((this._edit_id?"onEditKeyPress":"onKeyPress"),[code,e.ctrlKey,e.shiftKey,e]);
	}
};


/* DHX DEPEND FROM FILE 'mouse.js'*/


/*
	Behavior:MouseEvents - provides inner evnets for  mouse actions
*/
dhtmlx.MouseEvents={
	_init: function(){
		//attach dom events if related collection is defined
		if (this.on_click){
			dhtmlx.event(this._obj,"click",this._onClick,this);
			dhtmlx.event(this._obj,"contextmenu",this._onContext,this);
		}
		if (this.on_dblclick)
			dhtmlx.event(this._obj,"dblclick",this._onDblClick,this);
		if (this.on_mouse_move){
			dhtmlx.event(this._obj,"mousemove",this._onMouse,this);
			dhtmlx.event(this._obj,(dhtmlx._isIE?"mouseleave":"mouseout"),this._onMouse,this);
		}

	},
	//inner onclick object handler
	_onClick: function(e) {
		return this._mouseEvent(e,this.on_click,"ItemClick");
	},
	//inner ondblclick object handler
	_onDblClick: function(e) {
		return this._mouseEvent(e,this.on_dblclick,"ItemDblClick");
	},
	//process oncontextmenu events
	_onContext: function(e) {
		var id = dhtmlx.html.locate(e, this._id);
		if (id && !this.callEvent("onBeforeContextMenu", [id,e]))
			return dhtmlx.html.preventEvent(e);
	},
	/*
		event throttler - ignore events which occurs too fast
		during mouse moving there are a lot of event firing - we need no so much
		also, mouseout can fire when moving inside the same html container - we need to ignore such fake calls
	*/
	_onMouse:function(e){
		if (dhtmlx._isIE)	//make a copy of event, will be used in timed call
			e = document.createEventObject(event);
			
		if (this._mouse_move_timer)	//clear old event timer
			window.clearTimeout(this._mouse_move_timer);
				
		//this event just inform about moving operation, we don't care about details
		this.callEvent("onMouseMoving",[e]);
		//set new event timer
		this._mouse_move_timer = window.setTimeout(dhtmlx.bind(function(){
			//called only when we have at least 100ms after previous event
			if (e.type == "mousemove")
				this._onMouseMove(e);
			else
				this._onMouseOut(e);
		},this),500);
	},
	//inner mousemove object handler
	_onMouseMove: function(e) {
		if (!this._mouseEvent(e,this.on_mouse_move,"MouseMove"))
			this.callEvent("onMouseOut",[e||event]);
	},
	//inner mouseout object handler
	_onMouseOut: function(e) {
		this.callEvent("onMouseOut",[e||event]);
	},
	//common logic for click and dbl-click processing
	_mouseEvent:function(e,hash,name){
		e=e||event;
		var trg=e.target||e.srcElement;
		var css = "";
		var id = null;
		var found = false;
		//loop through all parents
		while (trg && trg.parentNode){
			if (!found && trg.getAttribute){													//if element with ID mark is not detected yet
				id = trg.getAttribute(this._id);							//check id of current one
				if (id){
					if (trg.getAttribute("userdata"))
						this.callEvent("onLocateData",[id,trg,e]);
					if (!this.callEvent("on"+name,[id,e,trg])) return;		//it will be triggered only for first detected ID, in case of nested elements
					found = true;											//set found flag
				}
			}
			css=trg.className;
			if (css){		//check if pre-defined reaction for element's css name exists
				css = css.split(" ");
				css = css[0]||css[1]; //FIXME:bad solution, workaround css classes which are starting from whitespace
				if (hash[css])
					return  hash[css].call(this,e,id||dhtmlx.html.locate(e, this._id),trg);
			}
			trg=trg.parentNode;
		}		
		return found;	//returns true if item was located and event was triggered
	}
};




/* DHX DEPEND FROM FILE 'config.js'*/


/*
	Behavior:Settings
	
	@export
		customize
		config
*/

/*DHX:Depend template.js*/
/*DHX:Depend dhtmlx.js*/

dhtmlx.Settings={
	_init:function(){
		/* 
			property can be accessed as this.config.some
			in same time for inner call it have sense to use _settings
			because it will be minified in final version
		*/
		this._settings = this.config= {}; 
	},
	define:function(property, value){
		if (typeof property == "object")
			return this._parseSeetingColl(property);
		return this._define(property, value);
	},
	_define:function(property,value){
		dhtmlx.assert_settings.call(this,property,value);
		
		//method with name {prop}_setter will be used as property setter
		//setter is optional
		var setter = this[property+"_setter"];
		return this._settings[property]=setter?setter.call(this,value):value;
	},
	//process configuration object
	_parseSeetingColl:function(coll){
		if (coll){
			for (var a in coll)				//for each setting
				this._define(a,coll[a]);		//set value through config
		}
	},
	//helper for object initialization
	_parseSettings:function(obj,initial){
		//initial - set of default values
		var settings = dhtmlx.extend({},initial);
		//code below will copy all properties over default one
		if (typeof obj == "object" && !obj.tagName)
			dhtmlx.extend(settings,obj);	
		//call config for each setting
		this._parseSeetingColl(settings);
	},
	_mergeSettings:function(config, defaults){
		for (var key in defaults)
			switch(typeof config[key]){
				case "object": 
					config[key] = this._mergeSettings((config[key]||{}), defaults[key]);
					break;
				case "undefined":
					config[key] = defaults[key];
					break;
				default:	//do nothing
					break;
			}
		return config;
	},
	//helper for html container init
	_parseContainer:function(obj,name,fallback){
		/*
			parameter can be a config object, in such case real container will be obj.container
			or it can be html object or ID of html object
		*/
		if (typeof obj == "object" && !obj.tagName) 
			obj=obj.container;
		this._obj = this.$view = dhtmlx.toNode(obj);
		if (!this._obj && fallback)
			this._obj = fallback(obj);
			
		dhtmlx.assert(this._obj, "Incorrect html container");
		
		this._obj.className+=" "+name;
		this._obj.onselectstart=function(){return false;};	//block selection by default
		this._dataobj = this._obj;//separate reference for rendering modules
	},
	//apply template-type
	_set_type:function(name){
		//parameter can be a hash of settings
		if (typeof name == "object")
			return this.type_setter(name);
		
		dhtmlx.assert(this.types, "RenderStack :: Types are not defined");
		dhtmlx.assert(this.types[name],"RenderStack :: Inccorect type name",name);
		//or parameter can be a name of existing template-type	
		this.type=dhtmlx.extend({},this.types[name]);
		this.customize();	//init configs
	},
	customize:function(obj){
		//apply new properties
		if (obj) dhtmlx.extend(this.type,obj);
		
		//init tempaltes for item start and item end
		this.type._item_start = dhtmlx.Template.fromHTML(this.template_item_start(this.type));
		this.type._item_end = this.template_item_end(this.type);
		
		//repaint self
		this.render();
	},
	//config.type - creates new template-type, based on configuration object
	type_setter:function(value){
		this._set_type(typeof value == "object"?dhtmlx.Type.add(this,value):value);
		return value;
	},
	//config.template - creates new template-type with defined template string
	template_setter:function(value){
		return this.type_setter({template:value});
	},
	//config.css - css name for top level container
	css_setter:function(value){
		this._obj.className += " "+value;
		return value;
	}
};



/* DHX DEPEND FROM FILE 'template.js'*/


/*
	Template - handles html templates
*/

/*DHX:Depend dhtmlx.js*/

dhtmlx.Template={
	_cache:{
	},
	empty:function(){	
		return "";	
	},
	setter:function(value){
		return dhtmlx.Template.fromHTML(value);
	},
	obj_setter:function(value){
		var f = dhtmlx.Template.setter(value);
		var obj = this;
		return function(){
			return f.apply(obj, arguments);
		};
	},
	fromHTML:function(str){
		if (typeof str == "function") return str;
		if (this._cache[str])
			return this._cache[str];
			
	//supported idioms
	// {obj} => value
	// {obj.attr} => named attribute or value of sub-tag in case of xml
	// {obj.attr?some:other} conditional output
	// {-obj => sub-template
		str=(str||"").toString();		
		str=str.replace(/[\r\n]+/g,"\\n");
		str=str.replace(/\{obj\.([^}?]+)\?([^:]*):([^}]*)\}/g,"\"+(obj.$1?\"$2\":\"$3\")+\"");
		str=str.replace(/\{common\.([^}\(]*)\}/g,"\"+common.$1+\"");
		str=str.replace(/\{common\.([^\}\(]*)\(\)\}/g,"\"+(common.$1?common.$1(obj):\"\")+\"");
		str=str.replace(/\{obj\.([^}]*)\}/g,"\"+obj.$1+\"");
		str=str.replace(/#([a-z0-9_]+)#/gi,"\"+obj.$1+\"");
		str=str.replace(/\{obj\}/g,"\"+obj+\"");
		str=str.replace(/\{-obj/g,"{obj");
		str=str.replace(/\{-common/g,"{common");
		str="return \""+str+"\";";
		return this._cache[str]= Function("obj","common",str);
	}
};

dhtmlx.Type={
	/*
		adds new template-type
		obj - object to which template will be added
		data - properties of template
	*/
	add:function(obj, data){ 
		//auto switch to prototype, if name of class was provided
		if (!obj.types && obj.prototype.types)
			obj = obj.prototype;
		//if (typeof data == "string")
		//	data = { template:data };
			
		if (dhtmlx.assert_enabled())
			this.assert_event(data);
		
		var name = data.name||"default";
		
		//predefined templates - autoprocessing
		this._template(data);
		this._template(data,"edit");
		this._template(data,"loading");
		
		obj.types[name]=dhtmlx.extend(dhtmlx.extend({},(obj.types[name]||this._default)),data);	
		return name;
	},
	//default template value - basically empty box with 5px margin
	_default:{
		css:"default",
		template:function(){ return ""; },
		template_edit:function(){ return ""; },
		template_loading:function(){ return "..."; },
		width:150,
		height:80,
		margin:5,
		padding:0
	},
	//template creation helper
	_template:function(obj,name){ 
		name = "template"+(name?("_"+name):"");
		var data = obj[name];
		//if template is a string - check is it plain string or reference to external content
		if (data && (typeof data == "string")){
			if (data.indexOf("->")!=-1){
				data = data.split("->");
				switch(data[0]){
					case "html": 	//load from some container on the page
						data = dhtmlx.html.getValue(data[1]).replace(/\"/g,"\\\"");
						break;
					case "http": 	//load from external file
						data = new dhtmlx.ajax().sync().get(data[1],{uid:(new Date()).valueOf()}).responseText;
						break;
					default:
						//do nothing, will use template as is
						break;
				}
			}
			obj[name] = dhtmlx.Template.fromHTML(data);
		}
	}
};


/* DHX DEPEND FROM FILE 'single_render.js'*/


/*
	REnders single item. 
	Can be used for elements without datastore, or with complex custom rendering logic
	
	@export
		render
*/

/*DHX:Depend template.js*/

dhtmlx.SingleRender={
	_init:function(){
	},
	//convert item to the HTML text
	_toHTML:function(obj){
			/*
				this one doesn't support per-item-$template
				it has not sense, because we have only single item per object
			*/
			return this.type._item_start(obj,this.type)+this.type.template(obj,this.type)+this.type._item_end;
	},
	//render self, by templating data object
	render:function(){
		if (!this.callEvent || this.callEvent("onBeforeRender",[this.data])){
			if (this.data)
				this._dataobj.innerHTML = this._toHTML(this.data);
			if (this.callEvent) this.callEvent("onAfterRender",[]);
		}
	}
};


/* DHX DEPEND FROM FILE 'tooltip.js'*/


/*
	UI: Tooltip
	
	@export
		show
		hide
*/

/*DHX:Depend tooltip.css*/
/*DHX:Depend template.js*/
/*DHX:Depend single_render.js*/

dhtmlx.ui.Tooltip=function(container){
	this.name = "Tooltip";
	
	if (dhtmlx.assert_enabled()) this._assert();

	if (typeof container == "string"){
		container = { template:container };
	}
		
	dhtmlx.extend(this, dhtmlx.Settings);
	dhtmlx.extend(this, dhtmlx.SingleRender);
	this._parseSettings(container,{
		type:"default",
		dy:0,
		dx:20
	});
	
	//create  container for future tooltip
	this._dataobj = this._obj = document.createElement("DIV");
	this._obj.className="dhx_tooltip";
	dhtmlx.html.insertBefore(this._obj,document.body.firstChild);
};
dhtmlx.ui.Tooltip.prototype = {
	//show tooptip
	//pos - object, pos.x - left, pox.y - top
	show:function(data,pos){
		if (this._disabled) return;
		//render sefl only if new data was provided
		if (this.data!=data){
			this.data=data;
			this.render(data);
		}
		//show at specified position
		this._obj.style.top = pos.y+this._settings.dy+"px";
		this._obj.style.left = pos.x+this._settings.dx+"px";
		this._obj.style.display="block";
	},
	//hide tooltip
	hide:function(){
		this.data=null; //nulify, to be sure that on next show it will be fresh-rendered
		this._obj.style.display="none";
	},
	disable:function(){
		this._disabled = true;	
	},
	enable:function(){
		this._disabled = false;
	},
	types:{
		"default":dhtmlx.Template.fromHTML("{obj.id}")
	},
	template_item_start:dhtmlx.Template.empty,
	template_item_end:dhtmlx.Template.empty
};



/* DHX DEPEND FROM FILE 'autotooltip.js'*/


/*
	Behavior: AutoTooltip - links tooltip to data driven item
*/

/*DHX:Depend tooltip.js*/

dhtmlx.AutoTooltip = {
	tooltip_setter:function(value){
		var t = new dhtmlx.ui.Tooltip(value);
		this.attachEvent("onMouseMove",function(id,e){	//show tooltip on mousemove
			t.show(this.get(id),dhtmlx.html.pos(e));
		});
		this.attachEvent("onMouseOut",function(id,e){	//hide tooltip on mouseout
			t.hide();
		});
		this.attachEvent("onMouseMoving",function(id,e){	//hide tooltip just after moving start
			t.hide();
		});
		return t;
	}
};


/* DHX DEPEND FROM FILE 'compatibility.js'*/


/*
	Collection of compatibility hacks
*/

/*DHX:Depend dhtmlx.js*/

dhtmlx.compat=function(name, obj){
	//check if name hash present, and applies it when necessary
	if (dhtmlx.compat[name])
		dhtmlx.compat[name](obj);
};


/* DHX DEPEND FROM FILE 'compatibility_layout.js'*/


/*DHX:Depend dhtmlx.js*/
/*DHX:Depend compatibility.js*/

if (!dhtmlx.attaches)
	dhtmlx.attaches = {};
	
dhtmlx.attaches.attachAbstract=function(name, conf){
	var obj = document.createElement("DIV");
	obj.id = "CustomObject_"+dhtmlx.uid();
	obj.style.width = "100%";
	obj.style.height = "100%";
	obj.cmp = "grid";
	document.body.appendChild(obj);
	this.attachObject(obj.id);
	
	conf.container = obj.id;
	
	var that = this.vs[this.av];
	that.grid = new window[name](conf);
	
	that.gridId = obj.id;
	that.gridObj = obj;
	
		
	that.grid.setSizes = function(){
		if (this.resize) this.resize();
		else this.render();
	};
	
	var method_name="_viewRestore";
	return this.vs[this[method_name]()].grid;
};
dhtmlx.attaches.attachDataView = function(conf){
	return this.attachAbstract("dhtmlXDataView",conf);
};
dhtmlx.attaches.attachChart = function(conf){
	return this.attachAbstract("dhtmlXChart",conf);
};

dhtmlx.compat.layout = function(){};




;
///<jscompress sourcefile="dhtmlxcontainer.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXCellObject(idd, css) {
	
	this.cell = document.createElement("DIV");
	this.cell.className = "dhx_cell"+(css||"");
	
	this._idd = idd;
	this._isCell = true;
	
	this.conf = {
		borders: true,
		idx: {},
		css: css||"",
		idx_data: {
			cont: "dhx_cell_cont",
			pr1: "dhx_cell_progress_bar",
			pr2: "dhx_cell_progress_img",
			pr3: "dhx_cell_progress_svg",
			menu: "dhx_cell_menu",
			toolbar: "dhx_cell_toolbar",
			ribbon: "dhx_cell_ribbon",
			sb: "dhx_cell_statusbar",
			cover: "dhx_cell_cover"
		},
		ofs_nodes: { t:{}, b:{} }	// attached dataNodes (menu/toolbar/status), can be true, false;
						// in case of layout - "func" for header
	}
	
	this.dataNodes = {}; // menu/toolbar/status
	
	this.views = {};
	
	// cont
	var p = document.createElement("DIV");
	p.className = "dhx_cell_cont"+this.conf.css;
	this.cell.appendChild(p);
	p = null;
	
	this._updateIdx = function() {
		for (var a in this.conf.idx) {
			this.conf.idx[a] = null;
			delete this.conf.idx[a];
		}
		for (var q=0; q<this.cell.childNodes.length; q++) {
			var css = this.cell.childNodes[q].className;
			for (var a in this.conf.idx_data) {
				var r = new RegExp(this.conf.idx_data[a]);
				if (css.match(r) != null) this.conf.idx[a] = q;
			}
		}
		
		this.callEvent("_onIdxUpdated",[]);
	}
	
	this._adjustAttached = function() {
		// mtb/ribbon
		for (var a in this.dataNodes) {
			if (this.dataNodes[a] != null && typeof(this.dataNodes[a].setSizes) == "function") {
				this.dataNodes[a].setSizes();
			}
		}
		// attached node
		if (this.dataObj != null && typeof(this.dataObj.setSizes) == "function") {
			// check if dataObj is layuot which was attached separately
			if (this.dataType == "layout" && typeof(window.dhtmlXLayoutCell) == "function" && this instanceof window.dhtmlXLayoutCell && this.dataObj._getMainInst() != this.layout._getMainInst()) {
				this.dataObj.setSizes();
				return;
			}
			this.dataObj.setSizes.apply(this.dataObj, arguments);
		}
	}
	
	this._setSize = function(x, y, w, h, parentIdd, noCalcCont, actionType, customProps) {
		
		if (this.conf.size == null) this.conf.size = {};
		if (customProps == null) customProps = {}; // ability to use margin-left instead of left
		
		var styleProps = {left: "x", top: "y", width: "w", height: "h"};
		
		this.conf.size.x = x;
		this.conf.size.y = y;
		this.conf.size.w = Math.max(w,0);
		this.conf.size.h = Math.max(h,0);
		
		for (var a in styleProps) {
			var name = (customProps[a]||a);
			this.cell.style[name] = this.conf.size[styleProps[a]]+"px";
		}
		
		this.callEvent("_onSetSize",[]);
		
		if (noCalcCont !== true) {
			this._adjustCont(parentIdd, actionType);
		} else {
			this._adjustAttached(parentIdd);
		}
		
		this._adjustProgress();
	}
	
	this._adjustCont = function(parentIdd, actionType) {
		
		var t = this.cell.childNodes[this.conf.idx.cont];
		
		// attempt to adjust cell in collapsed layout
		if (typeof(window.dhtmlXLayoutCell) == "function" && this instanceof window.dhtmlXLayoutCell && this.conf.collapsed == true) {
			t.style.left = t.style.top = "0px";
			t.style.width = t.style.height = "200px";
			t = null;
			return;
		}
		
		// header height, menu, toolbar if any
		var ht = 0;
		for (var a in this.conf.ofs_nodes.t) {
			var k = this.conf.ofs_nodes.t[a];
			ht += (k=="func"?this[a]():(k==true?this.cell.childNodes[this.conf.idx[a]].offsetHeight:0));
		}
		
		// bottom offset (height reduce if status attached)
		var hb = 0;
		for (var a in this.conf.ofs_nodes.b) {
			var k = this.conf.ofs_nodes.b[a];
			hb += (k=="func"?this[a]():(k==true?this.cell.childNodes[this.conf.idx[a]].offsetHeight:0));
		}
		
		t.style.left = "0px";
		t.style.top = ht+"px";
		
		if (this.conf.cells_cont == null) {
			this.conf.cells_cont = {};
			t.style.width = this.cell.offsetWidth+"px";
			t.style.height = Math.max(this.cell.offsetHeight-ht-hb,0)+"px";
			this.conf.cells_cont.w = parseInt(t.style.width)-t.offsetWidth;
			this.conf.cells_cont.h = parseInt(t.style.height)-t.offsetHeight;
		}
		
		t.style.left = "0px";
		t.style.top = ht+"px";
		t.style.width = Math.max(this.cell.offsetWidth+this.conf.cells_cont.w,0)+"px";
		t.style.height = Math.max(this.conf.size.h-ht-hb+this.conf.cells_cont.h,0)+"px";
		t = null;
		
		// move out?
		this._adjustAttached(parentIdd); // for layout only 1 arg should be here
		
		// editor adjust cont here, browser check needed ( !!make some tests :)
		if (actionType == "expand" && this.dataType == "editor" && this.dataObj != null) {
			this.dataObj._prepareContent(true);
		}
	}
	
	this._mtbUpdBorder = function() {
		
		var t = ["menu","toolbar","ribbon"];
		for (var q=0; q<t.length; q++) {
			if (this.conf.idx[t[q]] != null) {
				var p = this.cell.childNodes[this.conf.idx[t[q]]];
				var c1 = "dhx_cell_"+t[q]+"_no_borders";
				var c2 = "dhx_cell_"+t[q]+"_def";
				p.className = p.className.replace(new RegExp(this.conf.borders?c1:c2), this.conf.borders?c2:c1);
				p = null;
			}
		}
	}
	
	this._resetSizeState = function() {
		// delete autosize settings, autocalc for cell_cont borders, paddings, useful on skinchange
		this.conf.cells_cont = null;
	}
	
	/* views */
	
	// test with url and getFrame()
	
	// current view
	this.conf.view = "def";
	
	// views loaded at least once
	this.conf.views_loaded = {};
	this.conf.views_loaded[this.conf.view] = true;
	
	// move current data to archive
	this._viewSave = function(name) {
		
		this.views[name] = {
			borders: this.conf.borders,
			ofs_nodes: {t:{},b:{}},
			url_data: this.conf.url_data,
			dataType: this.dataType,
			dataObj: this.dataObj,
			cellCont: [],
			dataNodes: {},
			dataNodesCont: {}
		};
		
		// attached cont
		var cellCont = this.cell.childNodes[this.conf.idx.cont];
		while (cellCont.childNodes.length > 0) {
			this.views[name].cellCont.push(cellCont.firstChild);
			cellCont.removeChild(cellCont.firstChild);
		}
		cellCont = null;
		
		this.dataType = null;
		this.dataObj = null;
		this.conf.url_data = null;
		
		// menu/toolbar/status
		for (var a in this.dataNodes) {
			
			for (var b in this.conf.ofs_nodes) {
				if (typeof(this.conf.ofs_nodes[b][a]) != "undefined") {
					this.views[name].ofs_nodes[b][a] = this.conf.ofs_nodes[b][a];
					this.conf.ofs_nodes[b][a] = null;
					delete this.conf.ofs_nodes[b][a];
				}
			}
			
			this.views[name].dataNodesCont[a] = this.cell.childNodes[this.conf.idx[a]];
			this.cell.removeChild(this.cell.childNodes[this.conf.idx[a]]);
			
			this.views[name].dataNodes[a] = this.dataNodes[a];
			this.dataNodes[a] = null;
			delete this.dataNodes[a];
			
			this._updateIdx();
		}
		
		this.callEvent("_onViewSave", [name]);
		
	}
	
	this._viewRestore = function(name) {
		
		if (this.views[name] == null) return;
		
		// content
		this.dataObj = this.views[name].dataObj;
		this.dataType = this.views[name].dataType;
		this.conf.url_data = this.views[name].url_data;
		for (var q=0; q<this.views[name].cellCont.length; q++) this.cell.childNodes[this.conf.idx.cont].appendChild(this.views[name].cellCont[q]);
		
		// data nodes (menu/toolbar/status)
		for (var a in this.views[name].dataNodes) {
			
			this.dataNodes[a] = this.views[name].dataNodes[a];
			// below is not very universal solution for extending
			if (a == "menu") this.cell.insertBefore(this.views[name].dataNodesCont[a], this.cell.childNodes[this.conf.idx.toolbar||this.conf.idx.cont]);
			if (a == "toolbar") this.cell.insertBefore(this.views[name].dataNodesCont[a], this.cell.childNodes[this.conf.idx.cont]);
			if (a == "ribbon") this.cell.insertBefore(this.views[name].dataNodesCont[a], this.cell.childNodes[this.conf.idx.cont]);
			if (a == "sb") this.cell.appendChild(this.views[name].dataNodesCont[a]);
			
			this._updateIdx();
		}
		
		// ofs_nodes
		for (var a in this.views[name].ofs_nodes) {
			for (var b in this.views[name].ofs_nodes[a]) this.conf.ofs_nodes[a][b] = this.views[name].ofs_nodes[a][b];
		}
		
		if (this.conf.borders != this.views[name].borders) {
			this[this.views[name].borders?"_showBorders":"_hideBorders"](true);
		}
		
		// reload url attache dwith POST
		if (this.dataType == "url" && this.conf.url_data != null && this.conf.url_data.ajax == false && this.conf.url_data.post_data != null) {
			this.reloadURL();
		}
		
		this.callEvent("_onViewRestore", [name]);
		
		this._viewDelete(name);
		
	}
	
	this._viewDelete = function(name) {
		
		if (this.views[name] == null) return;
		
		this.views[name].borders = null;
		
		for (var a in this.views[name].ofs_nodes) {
			for (var b in this.views[name].ofs_nodes[a]) this.views[name].ofs_nodes[a][b] = null;
			this.views[name].ofs_nodes[a] = null;
		}
		
		this.views[name].dataType = null;
		this.views[name].dataObj = null;
		this.views[name].url_data = null;
		
		for (var q=0; q<this.views[name].cellCont.length; q++) this.views[name].cellCont[q] = null;
		this.views[name].cellCont = null;
		
		for (var a in this.views[name].dataNodes) {
			this.views[name].dataNodes[a] = null;
			this.views[name].dataNodesCont[a] = null;
		}
		
		this.views[name].dataNodes = this.views[name].dataNodesCont = null;
		
		this.views[name] = null;
		delete this.views[name];
		
	}
	
	/* views end */
	
	window.dhx4._eventable(this);
	this._updateIdx();
	
	return this;
	
};

// views
dhtmlXCellObject.prototype.showView = function(name) {
	
	if (this.conf.view == name) return false; // alredy visible
	
	// save current view
	this._viewSave(this.conf.view);
	
	// restore requested view if exists
	this._viewRestore(name);
	
	// update cell rendering
	this._updateIdx();
	this._adjustCont();
	
	this.conf.view = name;
	
	var t = (typeof(this.conf.views_loaded[this.conf.view]) == "undefined");
	this.conf.views_loaded[this.conf.view] = true;
	
	return t;
	
};

dhtmlXCellObject.prototype.getViewName = function() {
	return this.conf.view;
};

dhtmlXCellObject.prototype.unloadView = function(name) {
	// hidden view, unload menu/toolbar/status, etc
	
	// unload actve view
	if (name == this.conf.view) {
		
		// set unloading flag to prevent some adjust operations
		var t = this.conf.unloading;
		this.conf.unloading = true;
		
		// remove content
		if (typeof(this.detachMenu) == "function") this.detachMenu();
		if (typeof(this.detachToolbar) == "function") this.detachToolbar();
		if (typeof(this.detachRibbon) == "function") this.detachRibbon();
		this.detachStatusBar();
		this._detachObject(null, true);
		
		// restore unloading flag
		this.conf.unloading = t;
		if (!this.conf.unloading) this._adjustCont(this._idd);
		
		return;
	}
	
	if (this.views[name] == null) return;
	
	var v = this.views[name];
	for (var a in v.dataNodes) {
		if (typeof(v.dataNodes[a].unload) == "function") v.dataNodes[a].unload();
		v.dataNodes[a] = null;
		v.dataNodesCont[a] = null;
	}
	if (v.dataType == "url") {
		if (v.cellCont != null && v.cellCont[0] != "null") {
			this._detachURLEvents(v.cellCont[0]);
		}
	} else if (v.dataObj != null) {
		if (typeof(v.dataObj.unload) == "function") {
			v.dataObj.unload();
		} else if (typeof(v.dataObj.destructor) == "function") {
			v.dataObj.destructor();
		}
		v.dataObj = null;
	}
	v = null;
	
	this._viewDelete(name);
	
	if (typeof(this.conf.views_loaded[name]) != "undefined") {
		delete this.conf.views_loaded[name];
	}
	
};


// id
dhtmlXCellObject.prototype.getId = function() {
	return this._idd;
};

// progress
dhtmlXCellObject.prototype.progressOn = function() {
	
	if (this.conf.progress == true) return;
	
	this.conf.progress = true;
	
	// cover
	var t1 = document.createElement("DIV");
	t1.className = this.conf.idx_data.pr1;
	
	// image/animation
	var t2 = document.createElement("DIV");
	if (this.conf.skin == "material" && (window.dhx4.isFF || window.dhx4.isChrome || window.dhx4.isOpera || window.dhx4.isEdge)) {
		t2.className = this.conf.idx_data.pr3;
		t2.innerHTML = '<svg class="dhx_cell_prsvg" viewBox="25 25 50 50"><circle class="dhx_cell_prcircle" cx="50" cy="50" r="20"/></svg>';
	} else {
		t2.className = this.conf.idx_data.pr2;
	}
	
	if (this.conf.idx.cover != null) {
		this.cell.insertBefore(t2, this.cell.childNodes[this.conf.idx.cover]);
	} else {
		this.cell.appendChild(t2);
	}
	this.cell.insertBefore(t1, t2);
	
	t1 = t2 = null;
	
	this._updateIdx();
	this._adjustProgress();
	
};

dhtmlXCellObject.prototype.progressOff = function() {
	
	if (this.conf.progress != true) return;
	
	for (var a in {pr3:3,pr2:2,pr1:1}) {
		var node = this.cell.childNodes[this.conf.idx[a]];
		if (node != null) node.parentNode.removeChild(node);
		node = null;
	}
	
	this.conf.progress = false;
	
	this._updateIdx();
};

dhtmlXCellObject.prototype._adjustProgress = function() {
	
	if (this.conf.idx.pr1 == null) return;
	
	if (!this.conf.pr) this.conf.pr = {};
	
	var p1 = this.cell.childNodes[this.conf.idx.pr1]; // half-transparent cover
	var p2 = this.cell.childNodes[this.conf.idx.pr2]||this.cell.childNodes[this.conf.idx.pr3]; // image/svg
	
	if (!this.conf.pr.ofs) {
		p2.style.width = p1.offsetWidth + "px";
		p2.style.height = p1.offsetHeight + "px";
		this.conf.pr.ofs = {
			w: p2.offsetWidth-p2.clientWidth,
			h: p2.offsetHeight-p2.clientHeight
		};
	}
	
	p2.style.width = p1.offsetWidth - this.conf.pr.ofs.w + "px";
	p2.style.height = p1.offsetHeight - this.conf.pr.ofs.h + "px";
	
	p1 = p2 = null;
};

// content cover
dhtmlXCellObject.prototype._showCellCover = function() {
	
	if (this.conf.cover == true) return;
	this.conf.cover = true;
	
	var t = document.createElement("DIV");
	t.className = this.conf.idx_data.cover;
	this.cell.appendChild(t);
	t = null;
	
	this._updateIdx();
};

dhtmlXCellObject.prototype._hideCellCover = function() {
	
	if (this.conf.cover != true) return;
	
	this.cell.removeChild(this.cell.childNodes[this.conf.idx.cover]);
	this._updateIdx();
	
	this.conf.cover = false;
	
};

// borders
dhtmlXCellObject.prototype._showBorders = function(noAdjust) {
	
	if (this.conf.borders) return;
	
	this.conf.borders = true;
	
	this.cell.childNodes[this.conf.idx.cont].className = "dhx_cell_cont"+this.conf.css;
	
	this.conf.cells_cont = null;
	this._mtbUpdBorder();
	
	this.callEvent("_onBorderChange",[true]);
	
	if (noAdjust !== true) this._adjustCont(this._idd);
	
};
	
dhtmlXCellObject.prototype._hideBorders = function(noAdjust) {
	
	if (!this.conf.borders) return;
	
	this.conf.borders = false;
	
	this.cell.childNodes[this.conf.idx.cont].className = "dhx_cell_cont"+this.conf.css+" dhx_cell_cont_no_borders";
	this.conf.cells_cont = null;
	this._mtbUpdBorder();
	
	this.callEvent("_onBorderChange",[false]);
	
	if (noAdjust !== true) this._adjustCont(this._idd);
	
};

// basic width/height
dhtmlXCellObject.prototype._getWidth = function() {
	return this.cell.offsetWidth;
};

dhtmlXCellObject.prototype._getHeight = function() {
	return this.cell.offsetHeight;
};


dhtmlXCellObject.prototype.showInnerScroll = function() {
	this.cell.childNodes[this.conf.idx.cont].style.overflow = "auto";
};

/* unload */
dhtmlXCellObject.prototype._unload = function() {
	
	this.conf.unloading = true;
	
	this.callEvent("_onCellUnload",[]);
	
	this.progressOff();
	
	// unload current view (remove attached content)
	this.unloadView(this.conf.view);
	
	this.dataNodes = null;
	
	this.cell.parentNode.removeChild(this.cell);
	this.cell = null;
	
	window.dhx4._eventable(this, "clear");
	
	// views
	for (var a in this.views) this.unloadView(a);
	
	this.conf = null;
	
	// others
	for (var a in this) this[a] = null; // no mercy
	
};


dhtmlXCellObject.prototype.attachObject = function(obj, adjust) {
	
	// adjust - for windows only
	if (window.dhx4.s2b(adjust) && !(typeof(window.dhtmlXWindowsCell) == "function" && this instanceof window.dhtmlXWindowsCell)) {
		adjust = false;
	}
	
	if (typeof(obj) == "string") obj = document.getElementById(obj);
	
	// already attached
	if (obj.parentNode == this.cell.childNodes[this.conf.idx.cont]) {
		obj = null;
		return;
	}
	
	if (adjust) {
		obj.style.display = "";
		var w = obj.offsetWidth;
		var h = obj.offsetHeight;
	}
	
	this._attachObject(obj);
	this.dataType = "obj";
	obj.style.display = "";
	obj = null;
	
	if (adjust) this._adjustByCont(w,h);
	
};

dhtmlXCellObject.prototype.appendObject = function(obj) {
	
	if (typeof(obj) == "string") obj = document.getElementById(obj);
	
	// already attached
	if (obj.parentNode == this.cell.childNodes[this.conf.idx.cont]) {
		obj = null;
		return;
	}
	
	
	if (!this.conf.append_mode) {
		this.cell.childNodes[this.conf.idx.cont].style.overflow = "auto";
		this.conf.append_mode = true;
	}
	
	this._attachObject(obj, null, null, true);
	this.dataType = "obj";
	obj.style.display = "";
	obj = null;
	
};

dhtmlXCellObject.prototype.detachObject = function(remove, moveTo) {
	this._detachObject(null, remove, moveTo);
};

dhtmlXCellObject.prototype.getAttachedStatusBar = function() {
	return this.dataNodes.sb;
};
dhtmlXCellObject.prototype.getAttachedObject = function() {
	if (this.dataType == "obj" || this.dataType == "url" || this.dataType == "url-ajax") {
		return this.cell.childNodes[this.conf.idx.cont].firstChild;
	} else {
		return this.dataObj;
	}
};

dhtmlXCellObject.prototype.attachURL = function(url, useAjax, postData) {
	
	// prepare POST if any, postData should be true or {} otherwise GET
	if (postData == true) postData = {};
	var postReq = (typeof(postData) != "undefined" && postData != false && postData != null);
	
	if (this.conf.url_data == null) this.conf.url_data = {};
	this.conf.url_data.url = url;
	this.conf.url_data.ajax = (useAjax == true);
	this.conf.url_data.post_data = (postData==true?{}:(postData||null)); // true or object
	
	if (this.conf.url_data.xml_doc != null) {
		try {this.conf.url_data.xml_doc.xmlDoc.abort();}catch(e){};
		this.conf.url_data.xml_doc.xmlDoc = null;
		this.conf.url_data.xml_doc = null;
	}
	
	if (useAjax == true) {
		
		var t = this;
		if (postReq) {
			var params = "";
			for (var a in postData) params += "&"+encodeURIComponent(a)+"="+encodeURIComponent(postData[a]);

			this.conf.url_data.xml_doc = dhx4.ajax.post(url, params, function(r){
				if (t.attachHTMLString != null && typeof(r.xmlDoc.responseText) == "string") {
					t.attachHTMLString("<div style='position:relative;width:100%;height:100%;overflow:auto;'>"+r.xmlDoc.responseText+"</div>");
					if (typeof(t._doOnFrameContentLoaded) == "function") t._doOnFrameContentLoaded();
					t.dataType = "url-ajax";
				}
				t = r = null;
			});
		} else {
			this.conf.url_data.xml_doc = dhx4.ajax.get(url, function(r){
				if (t.attachHTMLString != null && typeof(r.xmlDoc.responseText) == "string") {
					t.attachHTMLString("<div style='position:relative;width:100%;height:100%;overflow:auto;'>"+r.xmlDoc.responseText+"</div>");
					if (typeof(t._doOnFrameContentLoaded) == "function") t._doOnFrameContentLoaded();
					t.dataType = "url-ajax";
				}
				t = r = null;
			});
		}
		
	} else {
		if (this.dataType == "url") {
			var fr = this.getFrame();
		} else {
			var fr = document.createElement("IFRAME");
			fr.frameBorder = 0;
			fr.border = 0;
			fr.style.width = "100%";
			fr.style.height = "100%";
			fr.style.position = "relative";
			this._attachObject(fr);
			this.dataType = "url";
			this._attachURLEvents();
		}
		if (postReq) {
			var firstLoad = (typeof(this.conf.url_data.post_ifr) == "undefined");
			this.conf.url_data.post_ifr = true; // load later
			if (firstLoad) this._attachURLEvents();
			fr.src = "about:blank";
		} else {
			fr.src = url+window.dhx4.ajax._dhxr(url);
		}
		fr = null;
	}
	
	fr = null;
};

dhtmlXCellObject.prototype.reloadURL = function() {
	if (!(this.dataType == "url" || this.dataType == "url-ajax")) return;
	if (this.conf.url_data == null) return;
	this.attachURL(this.conf.url_data.url, this.conf.url_data.ajax, this.conf.url_data.post_data);
};

dhtmlXCellObject.prototype.attachHTMLString = function(str) {
	this._attachObject(null, null, str);
	// esec script
	var z = str.match(/<script[^>]*>[^\f]*?<\/script>/g)||[];
	for (var i=0; i<z.length; i++) {
		var s = z[i].replace(/<([\/]{0,1})script[^>]*>/gi,"");
		if (s) {
			if (window.execScript) window.execScript(s); else window.eval(s);
		}
	}
};

dhtmlXCellObject.prototype.attachScheduler = function(day, mode, cont_id, scheduler) {
	
	scheduler = scheduler || window.scheduler;
	
	var ready = false;
	if (cont_id) {
		var obj = document.getElementById(cont_id);
		if (obj) ready = true;
	}
	if (!ready) {
		var tabs = cont_id || '<div class="dhx_cal_tab" name="day_tab" style="right:204px;"></div><div class="dhx_cal_tab" name="week_tab" style="right:140px;"></div><div class="dhx_cal_tab" name="month_tab" style="right:76px;"></div>';
		var obj = document.createElement("DIV");
		obj.id = "dhxSchedObj_"+new Date().getTime();
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.style.position = "relative";
		obj.style.overflow = "hidden";
		obj.className = "dhx_cal_container";
		obj.innerHTML = '<div class="dhx_cal_navline"><div class="dhx_cal_prev_button">&nbsp;</div><div class="dhx_cal_next_button">&nbsp;</div><div class="dhx_cal_today_button"></div><div class="dhx_cal_date"></div>'+tabs+'</div><div class="dhx_cal_header"></div><div class="dhx_cal_data"></div>';
	}
	
	this._attachObject(obj);
	
	this.dataType = "scheduler";
	this.dataObj = scheduler;
	this.dataObj.setSizes = function(){
		this.update_view();
	}
	
	scheduler.init(obj.id, day, mode);
	
	obj = null;
	
	this.callEvent("_onContentAttach",[]);
	
	return this.dataObj;
};

dhtmlXCellObject.prototype.attachMap = function(opts) {
	
	var obj = document.createElement("DIV");
	obj.style.width = "100%";
	obj.style.height = "100%";
	obj.style.position = "relative";
	obj.style.overflow = "hidden";
	this._attachObject(obj);
	
	if (!opts) opts = {center: new google.maps.LatLng(40.719837,-73.992348), zoom: 11, mapTypeId: google.maps.MapTypeId.ROADMAP};
	
	this.dataType = "maps";
	this.dataObj = new google.maps.Map(obj, opts);
	
	this.dataObj.setSizes = function() {
		google.maps.event.trigger(this, "resize");
	}
	
	obj = null;
	
	this.callEvent("_onContentAttach",[]);
	
	return this.dataObj;
	
};

// status bar
dhtmlXCellObject.prototype._createNode_sb = function(obj, type, htmlString, append, node) {
	// type -> (object) conf={text:string,height:number}
	if (typeof(node) != "undefined") {
		obj = node;
	} else {
		var conf = type||{};
		var text = (typeof(conf.text)=="string" && conf.text.length > 0 ? conf.text : "&nbsp;");
		var h = (typeof(conf.height) == "number" ? conf.height : false);
		var obj = document.createElement("DIV");
		
		obj.className = "dhx_cell_statusbar_def";
		obj.innerHTML = "<div class='"+(conf.paging==true?"dhx_cell_statusbar_paging":"dhx_cell_statusbar_text")+"'>"+text+"</div>";
		
		// height, optional
		if (h != false) obj.firstChild.style.height = obj.firstChild.style.lineHeight = h+"px";
	}
	
	// before progress or last
	if (this.conf.idx.pr1 != null) {
		this.cell.insertBefore(obj, this.cell.childNodes[this.conf.idx.pr1]);
	} else {
		this.cell.appendChild(obj);
	}
	
	this.conf.ofs_nodes.b.sb = true;
	this._updateIdx();
	this._adjustCont(this._idd);
	
	return obj;
};

dhtmlXCellObject.prototype.attachStatusBar = function(conf) { // args-optinal, new in version
	
	if (this.dataNodes.sb) return;  // return this.dataNodes.sb?
	
	if (conf != null && window.dhx4.s2b(conf.paging) == true) conf.height = null; // will set by css
	
	if (this.conf.skin == "dhx_skyblue" && typeof(window.dhtmlXWindowsCell) == "function" && this instanceof window.dhtmlXWindowsCell) {
		 this.cell.childNodes[this.conf.idx.cont].className += " dhx_cell_statusbar_attached";
	}
	this.dataNodes.sb = this._attachObject("sb", conf);
	
	this.dataNodes.sb.setText = function(text) { this.childNodes[0].innerHTML = text; }
	this.dataNodes.sb.getText = function() { return this.childNodes[0].innerHTML; }
	this.dataNodes.sb.onselectstart = function(e) { return false; }
	
	return this.dataNodes.sb;
	
};

dhtmlXCellObject.prototype.detachStatusBar = function() {
	
	if (!this.dataNodes.sb) return;
	
	if (this.conf.skin == "dhx_skyblue"  && typeof(window.dhtmlXWindowsCell)== "function" && this instanceof window.dhtmlXWindowsCell) {
		 this.cell.childNodes[this.conf.idx.cont].className = this.cell.childNodes[this.conf.idx.cont].className.replace(/\s{0,}dhx_cell_statusbar_attached/,"");
	}
	
	this.dataNodes.sb.setText = this.dataNodes.sb.getText = this.dataNodes.sb.onselectstart = null;
	this.dataNodes.sb = null;
	delete this.dataNodes.sb;
	
	this._detachObject("sb");
	
};

dhtmlXCellObject.prototype.showStatusBar = function() {
	this._mtbShowHide("sb", "");
};

dhtmlXCellObject.prototype.hideStatusBar = function() {
	this._mtbShowHide("sb", "none");
};

dhtmlXCellObject.prototype._mtbShowHide = function(name, disp) {
	if (!this.dataNodes[name]) return;
	this.cell.childNodes[this.conf.idx[name]].style.display = disp;
	this._adjustCont();
};


/* private logic */

// !!! fix
dhtmlXCellObject.prototype.getFrame = dhtmlXCellObject.prototype._getFrame = function() { // _getFrame deprecated, use getFrame
	if (this.dataType != "url") return null;
	return this.cell.childNodes[this.conf.idx.cont].firstChild;
};

dhtmlXCellObject.prototype._attachURLEvents = function() {
	
	if (this.dataType != "url") return;
	
	var t = this;
	var cId = this._idd;
	var fr = this.cell.childNodes[this.conf.idx.cont].firstChild;
	
	if (typeof(this._doOnFrameMouseDown) != "function") {
		this._doOnFrameMouseDown = function(e) {
			// console.log("frame mouse down"); // needed for windows to activate window
			t.callEvent("_onContentMouseDown", [cId,e||event]);
		}
	}
	
	if (typeof(window.addEventListener) == "function") {
		fr.onload = function() {
			try { if (typeof(t._doOnFrameMouseDown) == "function") this.contentWindow.document.body.addEventListener("mousedown", t._doOnFrameMouseDown, false); } catch(e) {};
			try { if (typeof(t._doOnFrameContentLoaded) == "function") t._doOnFrameContentLoaded(); } catch(e) {};
		}
	} else {
		// ie8-
		fr.onreadystatechange = function(a) {
			if (this.readyState == "complete") {
				try { if (typeof(t._doOnFrameMouseDown) == "function") this.contentWindow.document.body.attachEvent("onmousedown", t._doOnFrameMouseDown); } catch(e) {};
				try { if (typeof(t._doOnFrameContentLoaded) == "function") t._doOnFrameContentLoaded(); } catch(e) {};
			}
		}
	}
	//fr = null;
};


dhtmlXCellObject.prototype._doOnFrameContentLoaded = function() {
	if (this.conf.url_data.post_ifr == true) {
		var d = this.getFrame().contentWindow.document;
		var f = d.createElement("FORM");
		f.method = "POST";
		f.action = this.conf.url_data.url;
		d.body.appendChild(f);
		var postData = {};
		if (window.dhx4.ajax.cache != true) postData["dhxr"+new Date().getTime()] = "1";
		for (var a in this.conf.url_data.post_data) postData[a] = this.conf.url_data.post_data[a];
		for (var a in postData) {
			var k = d.createElement("INPUT");
			k.type = "hidden";
			k.name = a;
			k.value = postData[a];
			f.appendChild(k);
			k = null;
		}
		this.conf.url_data.post_ifr = false;
		f.submit();
	} else {
		this.callEvent("_onContentLoaded", [this._idd]);
	}
};

dhtmlXCellObject.prototype._detachURLEvents = function(fr) {
	if (fr == null) {
		if (this.dataType != "url") return;
		fr = this.cell.childNodes[this.conf.idx.cont].firstChild;
	}
	if (!fr) return;

	if (typeof(window.addEventListener) == "function") {
		fr.onload = null;
		try { fr.contentWindow.document.body.removeEventListener("mousedown", this._doOnFrameMouseDown, false); } catch(e) {/* console.log("error: url detach mousedown event fail"); */};
	} else {
		fr.onreadystatechange = null;
		try { fr.contentWindow.document.body.detachEvent("onmousedown", this._doOnFrameMouseDown); } catch(e) { };
	}
	fr = null;
};




dhtmlXCellObject.prototype._attachObject = function(obj, type, htmlString, append, node) {
	
	if (typeof(obj) == "string" && {menu:1,toolbar:1,ribbon:1,sb:1}[obj] == 1) {
		return this["_createNode_"+obj].apply(this, arguments);
	}
	
	if (append != true) this._detachObject(null, true, null);
	
	if (typeof(htmlString) == "string") {
		this.cell.childNodes[this.conf.idx.cont].innerHTML = htmlString;
	} else {
		this.cell.childNodes[this.conf.idx.cont].appendChild(obj);
	}
	
	obj = null;
};
	
dhtmlXCellObject.prototype._detachObject = function(obj, remove, moveTo) {
	
	this.callEvent("_onBeforeContentDetach",[]);
	
	if (obj == "menu" || obj == "toolbar" || obj == "ribbon" || obj == "sb") {
		
		var p = this.cell.childNodes[this.conf.idx[obj]];
		p.parentNode.removeChild(p);
		p = null;
		
		this.conf.ofs_nodes[obj=="sb"?"b":"t"][obj] = false;
		
		this._updateIdx();
		if (!this.conf.unloading) this._adjustCont(this._idd);
		
		return;
	}
	
	if (remove == true) {
		moveTo = false;
	} else {
		if (typeof(moveTo) == "undefined") {
			moveTo = document.body;
		} else {
			if (typeof(moveTo) == "string") moveTo = document.getElementById(moveTo);
		}
	}
	
	// clear obj
	if (moveTo === false) {
		// cancel ajax-request if unloading
		if (this.conf.unloading == true && String(this.dataType).match(/ajax/) != null) {
			if (this.conf.url_data != null && this.conf.url_data.xml_doc != null) {
				try {this.conf.url_data.xml_doc.xmlDoc.abort();}catch(e){};
				this.conf.url_data.xml_doc.xmlDoc = null;
				this.conf.url_data.xml_doc = null;
			}
		}
		//
		if (this.dataType == "url") {
			this._detachURLEvents();
		} else if (this.dataObj != null) {
			if (typeof(this.dataObj.unload) == "function") {
				this.dataObj.unload();
			} else if (typeof(this.dataObj.destructor) == "function") {
				this.dataObj.destructor(); // at least for grid
			}
		}
	}
	
	// clear cell cont
	var p = this.cell.childNodes[this.conf.idx.cont];
	while (p.childNodes.length > 0) {
		if (moveTo === false) {
			p.removeChild(p.lastChild);
		} else {
			p.firstChild.style.display = "none"; // replace with/add - visibility:hidden?
			moveTo.appendChild(p.firstChild);
		}
	}
	
	if (this.conf.append_mode) {
		p.style.overflow = "";
		this.conf.append_mode = false;
	}
	
	var resetHdrBrd = (this.dataType == "tabbar");
	
	this.dataObj = null;
	this.dataType = null;
	
	moveTo = p = null;
	
	if (this.conf.unloading != true && resetHdrBrd) {
		this.showHeader(true);
		this._showBorders();
	}
	
};

// for dock/undock
dhtmlXCellObject.prototype._attachFromCell = function(cell) {
	
	// clear existing
	this.detachObject(true);
	
	var mode = "layout";
	if (typeof(window.dhtmlXWindowsCell) == "function" && this instanceof window.dhtmlXWindowsCell) {
		mode = "window";
	}
	
	// check opacity:
	// 1) detach from window cell, opacity set to 0.4
	if (typeof(window.dhtmlXWindowsCell) == "function" && cell instanceof window.dhtmlXWindowsCell && cell.wins.w[cell._idd].conf.parked == true) {
		cell.wins._winCellSetOpacity(cell._idd, "open", false);
	}
	// 2) acc-cell collapsed
	if (typeof(window.dhtmlXAccordionCell) == "function" && cell instanceof window.dhtmlXAccordionCell && cell.conf.opened == false) {
		cell._cellSetOpacity("open", false);
	}
	
	// menu, toolbar, status
	for (var a in cell.dataNodes) {
		
		this._attachObject(a, null, null, null, cell.cell.childNodes[cell.conf.idx[a]]);
		this.dataNodes[a] = cell.dataNodes[a];
		
		cell.dataNodes[a] = null;
		cell.conf.ofs_nodes[a=="sb"?"b":"t"][a] = false;
		cell._updateIdx();
		
	}
	
	this._mtbUpdBorder();
	
	if (cell.dataType != null && cell.dataObj != null) {
		this.dataType = cell.dataType;
		this.dataObj = cell.dataObj;
		while (cell.cell.childNodes[cell.conf.idx.cont].childNodes.length > 0) {
			this.cell.childNodes[this.conf.idx.cont].appendChild(cell.cell.childNodes[cell.conf.idx.cont].firstChild);
		}
		cell.dataType = null;
		cell.dataObj = null;
		
		// fixes
		if (this.dataType == "grid") {
			if (mode == "window" && this.conf.skin == "dhx_skyblue") {
				this.dataObj.entBox.style.border = "1px solid #a4bed4";
				this.dataObj._sizeFix = 0;
			} else {
				this.dataObj.entBox.style.border = "0px solid white";
				this.dataObj._sizeFix = 2;
			}
		}
	} else {
		// for attached urls and objects simple move them
		while (cell.cell.childNodes[cell.conf.idx.cont].childNodes.length > 0) {
			this.cell.childNodes[this.conf.idx.cont].appendChild(cell.cell.childNodes[cell.conf.idx.cont].firstChild);
		}
	}
	
	this.conf.view = cell.conf.view;
	cell.conf.view = "def";
	for (var a in cell.views) {
		this.views[a] = cell.views[a];
		cell.views[a] = null;
		delete cell.views[a];
	}
	
	cell._updateIdx();
	cell._adjustCont();
	
	this._updateIdx();
	this._adjustCont();
	
	// save progress state
	if (cell.conf.progress == true) {
		cell.progressOff();
		this.progressOn();
	} else {
		this.progressOff();
	}
	
	// check opacity, set opacity to 0.4
	// 1) attach to window cell, window parked
	if (mode == "window" && this.wins.w[this._idd].conf.parked) {
		this.wins._winCellSetOpacity(this._idd, "close", false);
	}
	
};

/*

 +--------------------------------------------------------+
 |  base                                                  |
 |                                                        |
 |   +-----------------------------------------------+    |
 |   |  header                                       |    |
 |   +-----------------------------------------------+    |
 |                                                        |
 |   +-----------------------------------------------+    |
 |   |  mtb                                          |    |
 |   +-----------------------------------------------+    |
 |                                                        |
 |   +-----------------------------------------------+    |
 |   |  cont                                         |    |
 |   |                                               |    |
 |   |                                               |    |
 |   +-----------------------------------------------+    |
 |                                                        |
 |   +-----------------------------------------------+    |
 |   |  sb                                           |    |
 |   +-----------------------------------------------+    |
 |                                                        |
 |   +-----------------------------------------------+    |
 |   |  footer                                       |    |
 |   +-----------------------------------------------+    |
 |                                                        |
 +--------------------------------------------------------+
 
*/

function dhtmlXCellTop(base, offsets) {
	
	if (arguments.length == 0 || typeof(base) == "undefined") return;
	
	var that = this;
	
	this.dataNodes = {}; // menu/toolbar/ribbon/sb/hdr/ftr
	
	this.conf.ofs = {t:0, b:0, l:0, r:0}; // base outer offset (fullscreen margins)
	this.conf.ofs_nodes = {t:{}, b:{}}; // attached menu/toolbar/sb/hdr/ftr
	this.conf.progress = false;
	
	this.conf.fs_mode = false; // fullscreen mode
	this.conf.fs_tm = null; // fullscreen resize timeout
	this.conf.fs_resize = false; // fullscreen resize
	
	if (base == document.body) {
		
		this.conf.fs_mode = true;
		
		// fullscreen init
		this.base = base;
		
		// custom offset for body
		if (this.base == document.body) {
			var ofsDef = {
				dhx_skyblue: {t: 2, b: 2, l: 2, r: 2},
				dhx_web:     {t: 8, b: 8, l: 8, r: 8},
				dhx_terrace: {t: 9, b: 9, l: 8, r: 8},
				material:    {t: 9, b: 9, l: 8, r: 8}
			};
			this.conf.ofs = (ofsDef[this.conf.skin] != null ? ofsDef[this.conf.skin] : ofsDef.dhx_skyblue);
		}
		
	} else {
		this.base = (typeof(base)=="string"?document.getElementById(base):base);
	}
	
	this.base.className += " "+this.conf.css+"_base_"+this.conf.skin;
	
	this.cont = document.createElement("DIV");
	this.cont.className = this.conf.css+"_cont";
	this.base.appendChild(this.cont);
	
	// conf-offsets override (attachObject usualy)
	if (offsets != null) {
		this.setOffsets(offsets, false);
	} else if (this.base._ofs != null) {
		this.setOffsets(this.base._ofs, false);
		this.base._ofs = null;
		try {delete this.base._ofs;}catch(e){}; // IE6/IE7 fix
	}
	
	this._adjustCont = function() {
		
		var ofsYT = this.conf.ofs.t;
		for (var a in this.conf.ofs_nodes.t) ofsYT += (this.conf.ofs_nodes.t[a]==true ? this.dataNodes[a].offsetHeight:0);
		
		var ofsYB = this.conf.ofs.b;
		for (var a in this.conf.ofs_nodes.b) ofsYB += (this.conf.ofs_nodes.b[a]==true ? this.dataNodes[a].offsetHeight:0);
		
		this.cont.style.left = this.conf.ofs.l + "px";
		this.cont.style.width = this.base.clientWidth - this.conf.ofs.l - this.conf.ofs.r + "px";
		
		this.cont.style.top = ofsYT + "px";
		this.cont.style.height = this.base.clientHeight - ofsYT - ofsYB + "px";
		
	}
	
	this._setBaseSkin = function(skin) {
		this.base.className = this.base.className.replace(new RegExp(this.conf.css+"_base_"+this.conf.skin,"gi"), this.conf.css+"_base_"+skin);
	}
	
	this._initFSResize = function() {
		
		if (this.conf.fs_resize == true) return; // already inited
		
		this._doOnResizeStart = function() {
			window.clearTimeout(that.conf.fs_tm);
			that.conf.fs_tm = window.setTimeout(that._doOnResizeEnd, 200);
		}
		
		this._doOnResizeEnd = function() {
			that.setSizes();
		}
		
		if (typeof(window.addEventListener) == "function") {
			window.addEventListener("resize", this._doOnResizeStart, false);
		} else {
			window.attachEvent("onresize", this._doOnResizeStart);
		}
		
		this.conf.fs_resize = true;
	}
	
	// resize events
	if (this.conf.fs_mode == true) this._initFSResize();
	
	this._unloadTop = function() {
		
		this._mtbUnload();
		this.detachHeader();
		this.detachFooter();
		
		if (this.conf.fs_mode == true) {
			if (typeof(window.addEventListener) == "function") {
				window.removeEventListener("resize", this._doOnResizeStart, false);
			} else {
				window.detachEvent("onresize", this._doOnResizeStart);
			}
		}
		
		this.base.removeChild(this.cont);
		var r = new RegExp("\s{0,}"+this.conf.css+"_base_"+this.conf.skin, "gi");
		this.base.className = this.base.className.replace(r, "");
		this.cont = this.base = null;
		
		that = null;
	}
	
	base = null;
};

// outer offsets
dhtmlXCellTop.prototype.setOffsets = function(data, upd) { // set 'upd' to false to prevent adjusting (useful on init stage)
	var t = false;
	for (var a in data) {
		var k = a.charAt(0);
		if (typeof(this.conf.ofs[k]) != "undefined" && !isNaN(data[a])) {
			this.conf.ofs[k] = parseInt(data[a]);
			t = true;
		}
	}
	if (upd !== false && typeof(this.setSizes) == "function" && t == true) this.setSizes();
};


// top-level menu/toolbar/ribbon/status

// menu
dhtmlXCellTop.prototype.attachMenu = function(conf) {
	
	if (this.dataNodes.menu != null) return;
	
	this.dataNodes.menuObj = document.createElement("DIV");
	this.dataNodes.menuObj.className = "dhxcelltop_menu";
	
	this.base.insertBefore(this.dataNodes.menuObj, this.dataNodes.toolbarObj||this.dataNodes.ribbonObj||this.cont);
	
	if (typeof(conf) != "object" || conf == null) conf = {};
	conf.skin = this.conf.skin;
	conf.parent = this.dataNodes.menuObj;
	
	this.dataNodes.menu = new dhtmlXMenuObject(conf);
	
	this.dataNodes.menuEv = this.attachEvent("_onSetSizes", function(){
		if (this.dataNodes.menuObj.style.display == "none") return;
		if (this.conf.ofs_menu == null) {
			this.dataNodes.menuObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r+"px";
			this.conf.ofs_menu = {w: this.dataNodes.menuObj.offsetWidth-parseInt(this.dataNodes.menuObj.style.width)};
		}
		this.dataNodes.menuObj.style.left = this.conf.ofs.l+"px";
		this.dataNodes.menuObj.style.marginTop = (this.dataNodes.haObj!=null?0:this.conf.ofs.t)+"px";
		this.dataNodes.menuObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r-this.conf.ofs_menu.w+"px";
		
	});
	
	this.conf.ofs_nodes.t.menuObj = true;
	
	this.setSizes();
	
	conf.parnt = null;
	conf = null;
	
	return this.dataNodes.menu;
};

dhtmlXCellTop.prototype.detachMenu = function() {
	
	if (this.dataNodes.menu == null) return;
	
	this.dataNodes.menu.unload();
	this.dataNodes.menu = null;
	
	this.dataNodes.menuObj.parentNode.removeChild(this.dataNodes.menuObj);
	this.dataNodes.menuObj = null;
	
	this.detachEvent(this.dataNodes.menuEv);
	this.dataNodes.menuEv = null;
	
	delete this.dataNodes.menu;
	delete this.dataNodes.menuObj;
	delete this.dataNodes.menuEv;
	
	this.conf.ofs_nodes.t.menuObj = false;
	
	if (!this.conf.unloading) this.setSizes();
};

// toolbar
dhtmlXCellTop.prototype.attachToolbar = function(conf) {
	
	if (!(this.dataNodes.ribbon == null && this.dataNodes.toolbar == null)) return;
	
	this.dataNodes.toolbarObj = document.createElement("DIV");
	this.dataNodes.toolbarObj.className = "dhxcelltop_toolbar";
	this.base.insertBefore(this.dataNodes.toolbarObj, this.cont);
	this.dataNodes.toolbarObj.appendChild(document.createElement("DIV"));
	
	if (typeof(conf) != "object" || conf == null) conf = {};
	conf.skin = this.conf.skin;
	conf.parent = this.dataNodes.toolbarObj.firstChild;
	
	this.dataNodes.toolbar = new dhtmlXToolbarObject(conf);
	
	this.dataNodes.toolbarEv = this.attachEvent("_onSetSizes", function() {
		if (this.dataNodes.toolbarObj.style.display == "none") return;
		this.dataNodes.toolbarObj.style.left = this.conf.ofs.l+"px";
		this.dataNodes.toolbarObj.style.marginTop = (this.dataNodes.haObj!=null||this.dataNodes.menuObj!=null?0:this.conf.ofs.t)+"px";
		this.dataNodes.toolbarObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r+"px";
	});
	
	this.dataNodes.toolbar._masterCell = this;
	this.dataNodes.toolbar.attachEvent("_onIconSizeChange", function(){
		this._masterCell.setSizes();
	});
	
	this.conf.ofs_nodes.t.toolbarObj = true;
	
	this.setSizes();
	
	conf.parnt = null;
	conf = null;
	
	return this.dataNodes.toolbar;
};

dhtmlXCellTop.prototype.detachToolbar = function() {
	
	if (this.dataNodes.toolbar == null) return;
	
	this.dataNodes.toolbar._masterCell = null; // link to this
	this.dataNodes.toolbar.unload();
	this.dataNodes.toolbar = null;
	
	this.dataNodes.toolbarObj.parentNode.removeChild(this.dataNodes.toolbarObj);
	this.dataNodes.toolbarObj = null;
	
	this.detachEvent(this.dataNodes.toolbarEv);
	this.dataNodes.toolbarEv = null;
	
	this.conf.ofs_nodes.t.toolbarObj = false;
	
	delete this.dataNodes.toolbar;
	delete this.dataNodes.toolbarObj;
	delete this.dataNodes.toolbarEv;
	
	if (!this.conf.unloading) this.setSizes();
};

// ribbon
dhtmlXCellTop.prototype.attachRibbon = function(conf) {
	
	if (!(this.dataNodes.ribbon == null && this.dataNodes.toolbar == null)) return;
	
	this.dataNodes.ribbonObj = document.createElement("DIV");
	this.dataNodes.ribbonObj.className = "dhxcelltop_ribbon";
	this.base.insertBefore(this.dataNodes.ribbonObj, this.cont);
	this.dataNodes.ribbonObj.appendChild(document.createElement("DIV"));
	
	if (typeof(conf) != "object" || conf == null) conf = {};
	conf.skin = this.conf.skin;
	conf.parent = this.dataNodes.ribbonObj.firstChild;
	
	this.dataNodes.ribbon = new dhtmlXRibbon(conf);
	
	this.dataNodes.ribbonEv = this.attachEvent("_onSetSizes", function() {
		if (this.dataNodes.ribbonObj.style.display == "none") return;
		this.dataNodes.ribbonObj.style.left = this.conf.ofs.l+"px";
		this.dataNodes.ribbonObj.style.marginTop = (this.dataNodes.haObj!=null||this.dataNodes.menuObj!=null?0:this.conf.ofs.t)+"px";
		this.dataNodes.ribbonObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r+"px";
		this.dataNodes.ribbon.setSizes();
	});
	
	this.conf.ofs_nodes.t.ribbonObj = true;
	
	var t = this;
	this.dataNodes.ribbon.attachEvent("_onHeightChanged", function(){
		t.setSizes();
	});
	
	this.setSizes();
	
	conf.parnt = null;
	conf = null;
	
	return this.dataNodes.ribbon;
};

dhtmlXCellTop.prototype.detachRibbon = function() {
	
	if (this.dataNodes.ribbon == null) return;
	
	this.dataNodes.ribbon.unload();
	this.dataNodes.ribbon = null;
	
	this.dataNodes.ribbonObj.parentNode.removeChild(this.dataNodes.ribbonObj);
	this.dataNodes.ribbonObj = null;
	
	this.detachEvent(this.dataNodes.ribbonEv);
	this.dataNodes.ribbonEv = null;
	
	this.conf.ofs_nodes.t.ribbonObj = false;
	
	delete this.dataNodes.ribbon;
	delete this.dataNodes.ribbonObj;
	delete this.dataNodes.ribbonEv;
	
	if (!this.conf.unloading) this.setSizes();
};


// status
dhtmlXCellTop.prototype.attachStatusBar = function(conf) { // arg-optional, new in version
	
	if (this.dataNodes.sbObj) return;
	
	if (typeof(conf) == "undefined") conf = {};
	
	this.dataNodes.sbObj = document.createElement("DIV");
	this.dataNodes.sbObj.className = "dhxcelltop_statusbar";
	
	if (this.cont.nextSibling != null) {
		this.base.insertBefore(this.dataNodes.sbObj, this.cont.nextSibling);
	} else {
		this.base.appendChild(this.dataNodes.sbObj);
	}
	
	this.dataNodes.sbObj.innerHTML = "<div class='dhxcont_statusbar'>"+(typeof(conf.text)=="string" && conf.text.length > 0 ? conf.text:"&nbsp;")+"</div>";
	if (typeof(conf.height) == "number") this.dataNodes.sbObj.firstChild.style.height = this.dataNodes.sbObj.firstChild.style.lineHeight = conf.height+"px";
	
	this.dataNodes.sbObj.setText = function(text) { this.childNodes[0].innerHTML = text; }
	this.dataNodes.sbObj.getText = function() { return this.childNodes[0].innerHTML; }
	this.dataNodes.sbObj.onselectstart = function(e) { return false; }
	
	
	this.dataNodes.sbEv = this.attachEvent("_onSetSizes", function(){
		if (this.dataNodes.sbObj.style.display == "none") return;
		this.dataNodes.sbObj.style.left = this.conf.ofs.l+"px";
		this.dataNodes.sbObj.style.bottom = (this.dataNodes.faObj != null?this.dataNodes.faObj.offsetHeight:0)+this.conf.ofs.t+"px";
		this.dataNodes.sbObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r+"px";
	});
	
	this.conf.ofs_nodes.b.sbObj = true;
	
	this.setSizes();
	
	return this.dataNodes.sbObj;
	
};

dhtmlXCellTop.prototype.detachStatusBar = function() {
	
	if (!this.dataNodes.sbObj) return;
	
	this.dataNodes.sbObj.setText = this.dataNodes.sbObj.getText = this.dataNodes.sbObj.onselectstart = null;
	this.dataNodes.sbObj.parentNode.removeChild(this.dataNodes.sbObj);
	this.dataNodes.sbObj = null;
	
	this.detachEvent(this.dataNodes.sbEv);
	this.dataNodes.sbEv = null;
	
	this.conf.ofs_nodes.b.sbObj = false;
	
	delete this.dataNodes.sb;
	delete this.dataNodes.sbObj;
	delete this.dataNodes.sbEv;
	
	if (!this.conf.unloading) this.setSizes();
	
};

// show/hide
dhtmlXCellTop.prototype.showMenu = function() {
	this._mtbShowHide("menuObj", "");
};

dhtmlXCellTop.prototype.hideMenu = function() {
	this._mtbShowHide("menuObj", "none");
};

dhtmlXCellTop.prototype.showToolbar = function(){
	this._mtbShowHide("toolbarObj", "");
};

dhtmlXCellTop.prototype.hideToolbar = function(){
	this._mtbShowHide("toolbarObj", "none");
};

dhtmlXCellTop.prototype.showRibbon = function(){
	this._mtbShowHide("ribbonObj", "");
};

dhtmlXCellTop.prototype.hideRibbon = function(){
	this._mtbShowHide("ribbonObj", "none");
};

dhtmlXCellTop.prototype.showStatusBar = function() {
	this._mtbShowHide("sbObj", "");
};

dhtmlXCellTop.prototype.hideStatusBar = function(){
	this._mtbShowHide("sbObj", "none");
};

dhtmlXCellTop.prototype._mtbShowHide = function(name, disp) {
	if (this.dataNodes[name] == null) return;
	this.dataNodes[name].style.display = disp;
	this.setSizes();
};

dhtmlXCellTop.prototype._mtbUnload = function(name, disp) {
	this.detachMenu();
	this.detachToolbar();
	this.detachStatusBar();
	this.detachRibbon();
};

// getters
dhtmlXCellTop.prototype.getAttachedMenu = function() {
	return this.dataNodes.menu;
};
dhtmlXCellTop.prototype.getAttachedToolbar = function() {
	return this.dataNodes.toolbar;
};
dhtmlXCellTop.prototype.getAttachedRibbon = function() {
	return this.dataNodes.ribbon;
};
dhtmlXCellTop.prototype.getAttachedStatusBar = function() {
	return this.dataNodes.sbObj;
};

// top-level progress
dhtmlXCellTop.prototype.progressOn = function() {
	
	if (this.conf.progress) return;
	
	this.conf.progress = true;
	
	var t1 = document.createElement("DIV");
	t1.className = "dhxcelltop_progress";
	this.base.appendChild(t1);
	
	var t2 = document.createElement("DIV");
	if (this.conf.skin == "material" && (window.dhx4.isFF || window.dhx4.isChrome || window.dhx4.isOpera || window.dhx4.isEdge)) {
		t2.className = "dhxcelltop_progress_svg";
		t2.innerHTML = '<svg class="dhx_cell_prsvg" viewBox="25 25 50 50"><circle class="dhx_cell_prcircle" cx="50" cy="50" r="20"/></svg>';
	} else {
		var t2 = document.createElement("DIV");
		t2.className = "dhxcelltop_progress_img";
	}
	this.base.appendChild(t2);
	
	t1 = t2 = null;
	
};

dhtmlXCellTop.prototype.progressOff = function() {
	
	if (!this.conf.progress) return;
	
	var p = {dhxcelltop_progress: true, dhxcelltop_progress_img: true, dhxcelltop_progress_svg: true};
	for (var q=0; q<this.base.childNodes.length; q++) {
		if (typeof(this.base.childNodes[q].className) != "undefined" && p[this.base.childNodes[q].className] == true) {
			p[this.base.childNodes[q].className] = this.base.childNodes[q];
		}
	}
	
	for (var a in p) {
		if (p[a] != true) this.base.removeChild(p[a]);
		p[a] = null;
	}
	
	this.conf.progress = false;
	p = null;
	
};

// fullscreen header-footer

// top margin (2px for skyblue) for fullscreen will always adjusted automatcaly
// bottom margin - can be generated by user-content, write in documentstion
// same for footer

dhtmlXCellTop.prototype.attachHeader = function(obj, height) {

	if (this.dataNodes.haObj != null) return; // already attached
	
	if (typeof(obj) != "object") obj = document.getElementById(obj);
	
	this.dataNodes.haObj = document.createElement("DIV");
	this.dataNodes.haObj.className = "dhxcelltop_hdr";
	this.dataNodes.haObj.style.height = (height||obj.offsetHeight)+"px";
	
	this.base.insertBefore(this.dataNodes.haObj, this.dataNodes.menuObj||this.dataNodes.toolbarObj||this.cont);
	
	this.dataNodes.haObj.appendChild(obj);
	obj.style.visibility = "visible";
	obj = null;
	
	this.dataNodes.haEv = this.attachEvent("_onSetSizes", function(){
		this.dataNodes.haObj.style.left = this.conf.ofs.l+"px";
		this.dataNodes.haObj.style.marginTop = this.conf.ofs.t+"px";
		this.dataNodes.haObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r+"px";
	});
	
	this.conf.ofs_nodes.t.haObj = true;
	
	this.setSizes();
	
};

dhtmlXCellTop.prototype.detachHeader = function() {
	
	if (!this.dataNodes.haObj) return;
	
	while (this.dataNodes.haObj.childNodes.length > 0) {
		this.dataNodes.haObj.lastChild.style.visibility = "hidden";
		document.body.appendChild(this.dataNodes.haObj.lastChild);
	}
	this.dataNodes.haObj.parentNode.removeChild(this.dataNodes.haObj);
	this.dataNodes.haObj = null;
	
	this.detachEvent(this.dataNodes.haEv);
	this.dataNodes.haEv = null;
	
	this.conf.ofs_nodes.t.haObj = false;
	
	delete this.dataNodes.haEv;
	delete this.dataNodes.haObj;
	
	if (!this.conf.unloading) this.setSizes();

};

dhtmlXCellTop.prototype.attachFooter = function(obj, height) {
	
	if (this.dataNodes.faObj != null) return;
	
	if (typeof(obj) != "object") obj = document.getElementById(obj);
	
	this.dataNodes.faObj = document.createElement("DIV");
	this.dataNodes.faObj.className = "dhxcelltop_ftr";
	this.dataNodes.faObj.style.height = (height||obj.offsetHeight)+"px";
	
	var p = (this.dataNodes.sbObj||this.cont);
	if (this.base.lastChild == p) {
		this.base.appendChild(this.dataNodes.faObj);
	} else {
		this.base.insertBefore(this.dataNodes.faObj, p.nextSibling);
	}
	
	this.dataNodes.faEv = this.attachEvent("_onSetSizes", function(){
		this.dataNodes.faObj.style.left = this.conf.ofs.l+"px";
		this.dataNodes.faObj.style.bottom = this.conf.ofs.b+"px";
		this.dataNodes.faObj.style.width = this.base.offsetWidth-this.conf.ofs.l-this.conf.ofs.r+"px";
	});
	
	this.dataNodes.faObj.appendChild(obj);
	obj.style.visibility = "visible";
	p = obj = null;
	
	this.conf.ofs_nodes.b.faObj = true;
	
	this.setSizes();
	
};

dhtmlXCellTop.prototype.detachFooter = function() {
	
	if (!this.dataNodes.faObj) return;
	
	while (this.dataNodes.faObj.childNodes.length > 0) {
		this.dataNodes.faObj.lastChild.style.visibility = "hidden";
		document.body.appendChild(this.dataNodes.faObj.lastChild);
	}
	this.dataNodes.faObj.parentNode.removeChild(this.dataNodes.faObj);
	this.dataNodes.faObj = null;
	
	this.detachEvent(this.dataNodes.faEv);
	this.dataNodes.faEv = null;
	
	this.conf.ofs_nodes.b.faObj = false;
	
	delete this.dataNodes.faEv;
	delete this.dataNodes.faObj;
	
	if (!this.conf.unloading) this.setSizes();
	
};

;
///<jscompress sourcefile="dhtmlxcombo.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXCombo(parentId, formName, width, optionType, tabIndex) {
	
	// console.info("allow html in options?");
	// console.info("add placeholder?");
	// console.info("iframe for IE6");
	
	var that = this;
	var apiObj = null;
	var skin = null;
	if (typeof(parentId) == "object" && !parentId.tagName) {
		apiObj = parentId;
		parentId = apiObj.parent;
		width = apiObj.width;
		formName = apiObj.name;
		optionType = apiObj.mode;
		skin = apiObj.skin;
	}
	
	this.cont = (typeof(parentId)=="string"?document.getElementById(parentId):parentId);
	
	this.conf = {
		skin: null,
		form_name: formName||"dhxcombo",
		combo_width: (parseInt(width)||this.cont.offsetWidth||120)-(dhx4.isFF||dhx4.isIE||dhx4.isChrome||dhx4.isOpera?2:0),
		combo_image: false,
		combo_focus: false,
		opts_type: (typeof(optionType)=="string" && typeof(this.modes[optionType]) !="undefined" ? optionType : "option"),
		opts_count: 8, // count of visible items
		opts_count_min: 3, // min count of visible items (when near screen edge)
		opts_width: null,
		item_h: null,
		list_zi_id: window.dhx4.newId(), // "dhxcombo_list_"+window.dhx4.newId(), // z-index id
		allow_free_text: true,
		allow_empty_value: true, // allow empty value in combo (when free_text not allowed)
		free_text_empty: false, // when free text not allowed and incorrect value entered restore last selected value or reset to empty
		enabled: true,
		btn_left: ((window.dhx4.isIE6||window.dhx4.isIE7||window.dhx4.isIE8) && typeof(window.addEventListener) == "undefined" ? 1:0), // 1 for IE8-
		// search in r/o mode
		ro_mode: false,
		ro_text: "",
		ro_tm: null,
		ro_tm_time: 750,
		// images
		img_path: "",
		img_def: "",
		img_def_dis: true, // if set to true - img_def used for disabled
		// templates
		template: {
			header: true,    // render header in multicolumn mode, added in 4.5.1
			input:  "#text#",// template for top-input
			option: "#text#" // template for option text
		},
		// filtering
		f_func: null,
		f_mode: false, // "start", "between"
		f_url: false,
		f_cache: false,
		f_cache_data: {},
		f_dyn: false,
		f_dyn_end: false, // check if last response have opts
		f_mask: "", // last loaded mask from server
		f_ac: true, // autocomplete if f_mode:"start" filtering mode
		f_ac_text: "",
		f_server_tm: null,
		f_server_last: "",
		f_loading: false,
		// scroll tm
		s_tm: null,
		s_time: 200,
		s_mode: "select", // type of subload request calling, 'select' last item or 'scroll' to last item
		// hover-selected
		last_hover: null,
		last_selected: null,
		last_match: null,
		last_text: "",
		last_value: "",
		tm_hover: null,
		tm_confirm_blur: null,
		// nav settings
		clear_click: false,
		clear_blur: false,
		clear_bsp: false,
		clear_key: false,
		// skin params
		i_ofs: 23, // top-image offset
		sp: {
			dhx_skyblue: {list_ofs: 1, hdr_ofs: 1, scr_ofs: 1},
			dhx_web: {list_ofs: 0, hdr_ofs: 1, scr_ofs: 0},
			dhx_terrace: {list_ofs: 1, hdr_ofs: 1, scr_ofs: 1},
			material: {list_ofs: 0, hdr_ofs: 1, scr_ofs: 1}
		},
		// autowidth for columns mode
		col_w: null
	};
	
	this.conf.combo_image = (this.modes[this.conf.opts_type].image==true);
	
	this.t = {}; // options will here
	
	this.base = document.createElement("DIV");
	//this.base.className = "dhxcombo_"+this.conf.skin;
	
	this.base.style.width = this.conf.combo_width+"px";
	this.base.innerHTML = "<input type='text' class='dhxcombo_input' style='width:"+(this.conf.combo_width-(this.conf.i_ofs+1)-(this.conf.combo_image?this.conf.i_ofs:0))+"px;"+(this.conf.combo_image?"margin-left:"+this.conf.i_ofs+"px;":"")+"' autocomplete='off'>"+
				"<input type='hidden' value=''>"+ // value
				"<input type='hidden' value='false'>"+ // new_value
				"<div class='dhxcombo_select_button'><div class='dhxcombo_select_img'></div></div>"+
				(this.conf.combo_image?"<div class='dhxcombo_top_image'>"+this.modes[this.conf.opts_type].getTopImage(null, this.conf.enabled)+"</div>":"");
	this.cont.appendChild(this.base);
	
	this.list = document.createElement("DIV");
	this.list._listId = window.dhx4.newId(); // used when combo attached to popup
	this.list.style.display = "none";
	document.body.insertBefore(this.list, document.body.firstChild);
	
	// auto-subload logic
	this._doOnListScroll = function() {
		if (that.conf.s_tm != null) window.clearTimeout(that.conf.s_tm);
		that.conf.s_tm = window.setTimeout(that._doOnListScrollAction, that.conf.s_time);
	}
	this._doOnListScrollAction = function() {
		that.conf.s_tm = null;
		if (that.conf.s_mode == "scroll" && that.list.scrollHeight - that.list.scrollTop - 10 < that.list.clientHeight) {
			that._subloadRequest();
		}
	}
	if (typeof(window.addEventListener) == "function") {
		this.list.addEventListener("scroll", this._doOnListScroll, false);
	} else {
		this.list.attachEvent("onscroll", this._doOnListScroll);
	}
	
	// apply skin
	this.setSkin(skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxcombo")||"material");
	
	this._updateTopImage = function(id) {
		
		if (!this.conf.combo_image) return;
		
		if (id != null) {
			this.base.lastChild.innerHTML = this.t[id].obj.getTopImage(this.t[id].item, this.conf.enabled);
		} else {
			this.base.lastChild.innerHTML = this.modes[this.conf.opts_type].getTopImage(null, this.conf.enabled);
		}
		 
	}
	
	/* filtering */
	
	this._filterOpts = function(hiddenMode) {
		if (this.conf.f_server_tm) window.clearTimeout(this.conf.f_server_tm);
		
		var k = String(this.base.firstChild.value).replace(new RegExp(this._fixRE(this.conf.f_ac_text)+"$","i"),"");
		
		
		if (this.conf.f_server_last == k.toLowerCase()) {
			this._checkForMatch();
			return;
		}
		
		// check if user-filter specified
		if (this.conf.f_url != null && this.checkEvent("onDynXLS")) {
			this.conf.f_server_last = k.toLowerCase();
			this.callEvent("onDynXLS", [k]);
			return;
		}
		
		if (this.conf.f_url != null) {
			// server
			if (k.length == 0) {
				this.conf.f_server_last = k.toLowerCase();
				this.clearAll();
				return;
			}
			// check cache
			if (this.conf.f_cache == true && this.conf.f_cache_data[k] != null) {
				// load from cache
				this.clearAll();
				this.conf.f_server_last = k.toLowerCase();
				for (var q=0; q<this.conf.f_cache_data[k].data.length; q++) {
					this.load(this.conf.f_cache_data[k].data[q]);
				}
				if (this.conf.f_dyn) {
					this.conf.f_dyn_end = this.conf.f_cache_data[k].dyn_end;
					this.conf.f_mask = this.conf.f_cache_data[k].mask;
				}
				if (hiddenMode !== true) {
					this._showList(true);
					this._checkForMatch();
				}
			} else {
				this.conf.f_server_tm = window.setTimeout(function(){
					that.conf.f_server_last = k.toLowerCase();
					that.conf.f_mask = k;
					var params = "mask="+encodeURIComponent(k);
					if (that.conf.f_dyn) {
						params += "&pos=0";
						that.conf.f_dyn_end = false;
					}
					var callBack = function(r) {
						// cache
						if (that.conf.f_cache) {
							if (!that.conf.f_cache_data[k]) that.conf.f_cache_data[k] = {data:[],dyn_end:false,mask:k};
							that.conf.f_cache_data[k].data.push(r.xmlDoc.responseXML);
						}
						// load opts
						that.clearAll();
						that.load(r.xmlDoc.responseXML);
						
						var v = (that.base.offsetWidth > 0 && that.base.offsetHeight > 0);
						if (v == true && that.conf.enabled == true && that.conf.combo_focus == true && hiddenMode !== true) {
							// autocomplete if any
							if (that.conf.f_ac && that.conf.f_mode == "start" && that.conf.clear_bsp == false && that.list.firstChild != null) {
								// autocomplete
								var sid = that.list.firstChild._optId;
								var text = String(that.t[sid].obj.getText(that.list.firstChild, true));
								if (k == that.base.firstChild.value && String(text).toLowerCase().indexOf(String(k).toLowerCase()) === 0) {
									that.base.firstChild.value = text;
									that.conf.f_ac_text = text.substr(k.length);
									that._selectRange(k.length, text.length);
								}
							}
							that._showList(true);
							that._checkForMatch();
						}
						callBack = null;
					}
					if (window.dhx4.ajax.method == "post") {
						window.dhx4.ajax.post(that.conf.f_url, params, callBack);
					} else if (window.dhx4.ajax.method == "get") {
						window.dhx4.ajax.get(that.conf.f_url+(String(that.conf.f_url).indexOf("?")>=0?"&":"?")+params, callBack);
					}
				},200);
			}
		} else {
			// client
			this.conf.f_server_last = k.toLowerCase();
			
			var r = (k.length==0?true:new RegExp((this.conf.f_mode=="start"?"^":"")+this._fixRE(k),"i"));
			
			var acText = null;
			
			for (var a in this.t) {
				var t = false;
				if (r !== true) {
					if (this.conf.f_func != null) {
						var option = this._getOption(this.t[a].item._optId, q);
						t = (this.conf.f_func.apply(window, [k, option]) == true);
					} else {
						var text = this.t[a].obj.getText(this.t[a].item, true);
						t = (r.test(text) == true);
					}
				}
				if (r === true || t == true) {
					this.t[a].item.style.display = "";
					if (acText == null && k.length > 0) acText = String(this.t[a].obj.getText(this.t[a].item, true));
				} else {
					this.t[a].item.style.display = "none";
				}
			}
			
			if (this.conf.f_ac && this.conf.f_mode == "start" && this.conf.clear_bsp == false && acText != null) {
				this.conf.f_ac_text = acText.replace(new RegExp("^"+k,"i"),"");
				this.base.firstChild.value = acText;
				this._selectRange(this.conf.f_server_last.length, this.base.firstChild.value.length);
			}
			
			// if any text selected and backspace pressed - clear highlight
			// usefull for "between" mode
			if (this.conf.f_mode == "between" && this.conf.clear_bsp == true) {
				this._checkForMatch(true);
			}
			
			if (hiddenMode !== true) {
				this._showList(true);
				this._checkForMatch();
			}
		}
	}
	
	this._searchRO = function(s) {
		if (this.conf.ro_tm) window.clearTimeout(this.conf.ro_tm);
		this.conf.ro_text += s;
		this._showList();
		for (var q=0; q<this.list.childNodes.length; q++) {
			var sid = this.list.childNodes[q]._optId;
			var text = String(this.t[sid].obj.getText(this.list.childNodes[q], true)).toLowerCase();
			if (text.indexOf(this.conf.ro_text) === 0) {
				this._setSelected(sid, true, true);
				this._confirmSelect("script", false);
				break;
			}
		}
		this.conf.ro_tm = window.setTimeout(function(){that.conf.ro_text="";}, this.conf.ro_tm_time);
	}
	
	this._fixRE = function(t) {
		return String(t).replace(/[\\\^\$\*\+\?\.\(\)\|\{\}\[\]]/gi, "\\$&");
	}
	
	// data loading
	this._initObj = function(data) {
		if (typeof(data.template) != "undefined") this.setTemplate(data.template);
		if (data.add != true && this.conf.f_loading != true) this.clearAll(false);
		this.addOption(data.options);
	}
	
	this._xmlToObj = function(data, selectToObj, selectedIndex) {
		
		/*
		xml format:
		<complete add="true">
			<template>
				<input>...</input>
				<option>...</option>
				<header>false</header> <!-- do not render header for multi-column mode, in 4.5.1 -->
				<columns>
					<column width="..." css="option css optional">
						<header>text in header</header>
						<option>template for text in option cell</option>
					</column>
				</columns>
			</template>
			<option value="xx" selected="1" img_src="icon_url" checked="1" css="some text">option text</option>
		</complete>
		
		img_src - also add the 4th parameter to combobox constructor - "image"
		checked - checkbox state, for combo with "checkbox" type, 0 by default
		*/
		
		var t = {add:false,options:[]};
		
		var root = (selectToObj==true?data:data.getElementsByTagName("complete"));
		
		if (root.length > 0) {
			if (window.dhx4.s2b(root[0].getAttribute("add")) == true) t.add = true;
			var nodes = root[0].childNodes;
			for (var q=0; q<nodes.length; q++) {
				if (typeof(nodes[q].tagName) != "undefined") {
					
					// template
					if (String(nodes[q].tagName).toLowerCase() == "template") {
						
						var template = {};
						
						for (var w=0; w<nodes[q].childNodes.length; w++) {
							
							var n = nodes[q].childNodes[w];
							
							if (n.tagName != null) {
								
								// default values
								var k = n.tagName;
								if (typeof(this.conf.template[k]) != "undefined") {
									template[k] = window.dhx4._xmlNodeValue(n);
								}
								
								// columns if any
								if (k == "columns") {
									for (var e=0; e<n.childNodes.length; e++) {
										
										var col = n.childNodes[e];
										
										if (col.tagName != null && col.tagName == "column") {
											
											var colData = {};
											
											// attrs
											// <column width="xx" css="xx" header="xx" option="xx"/>
											for (var a in {width:1, css:1, header:1, option:1}) {
												if (col.getAttribute(a) != null) colData[a] = col.getAttribute(a);
											}
											
											// extra header and option if any
											// <column><option><header>..</header><option>..</option></column>
											for (var a in {header:1, option:1}) {
												var h = col.getElementsByTagName(a);
												if (h[0] != null && h[0].firstChild != null) colData[a] = window.dhx4._xmlNodeValue(h[0]);
											}
											
											if (template.columns == null) template.columns = [];
											template.columns.push(colData);
											
										}
										
										col = null;
										
									}
									
								}
							}
							n = null;
						}
						this.setTemplate(template);
					}
					// option
					if (String(nodes[q].tagName).toLowerCase() == "option") {
						var optSelected = false;
						if (selectToObj == true) {
							optSelected = (t.options.length==selectedIndex);
						} else {
							optSelected = window.dhx4.s2b(nodes[q].getAttribute("selected"));
						}
						var opt = {
							value: nodes[q].getAttribute("value"),
							text: window.dhx4._xmlNodeValue(nodes[q]),
							selected: optSelected,
							checked: window.dhx4.s2b(nodes[q].getAttribute("checked"))
						};
						// images
						for (var a in {img:1,img_dis:1,img_src:1,img_src_dis:1,css:1}) {
							if (nodes[q].getAttribute(a) != null) opt[a] = nodes[q].getAttribute(a);
						}
						// text
						for (var w=0; w<nodes[q].childNodes.length; w++) {
							if (nodes[q].childNodes[w].tagName != null && String(nodes[q].childNodes[w].tagName).toLowerCase() == "text") {
								opt.text = {};
								var n = nodes[q].childNodes[w];
								for (var e=0; e<n.childNodes.length; e++) {
									if (n.childNodes[e].tagName != null) {
										opt.text[n.childNodes[e].tagName] = window.dhx4._xmlNodeValue(n.childNodes[e]);
									}
								}
							}
						}
						t.options.push(opt);
					}
				}
			}
			root = nodes = null;
		}
		return t;
	}
	
	window.dhx4._enableDataLoading(this, "_initObj", "_xmlToObj", "complete", {data:true});
	window.dhx4._eventable(this);
	
	
	this._getNearItem = function(item, dir) {
		// return nearest next/prev visible item or null
		var sid = null;
		while (item != null) {
			item = item[dir<0?"previousSibling":"nextSibling"];
			if (sid == null && item != null && item.style.display == "" && item._optId != null) {
				sid = item;
				item = null;
			}
		}
		return sid;
	}
	
	this.setName(this.conf.form_name);
	
	// list hightlight/select
	this._doOnListMouseMove = function(e) {
		e = e||event;
		var t = e.target||e.srcElement;
		while (t != null && t != this) {
			if (typeof(t._optId) != "undefined") {
				if (that.conf.tm_hover) window.clearTimeout(that.conf.tm_hover);
				that._setSelected(t._optId, false, false, true);
			}
			t = t.parentNode;
		}
		t = null;
	}
	
	this._doOnListMouseDown = function(e) {
		e = e||event;
		e.cancelBubble = true;
		that.conf.clear_click = true;
		window.setTimeout(function(){that.base.firstChild.focus();},1);
	}
	
	this._doOnListMouseUp = function(e) {
		// select new item
		e = e||event;
		if (e.button != that.conf.btn_left) return;
		var t = e.target||e.srcElement;
		while (t != null && t != this) {
			if (typeof(t._optId) != "undefined") {
				var r = true;
				if (typeof(that.t[t._optId].obj.optionClick) == "function" && that.t[t._optId].obj.optionClick(t, e, that) !== true) r = false;
				if (r) {
					that._setSelected(t._optId, null, true);
					that._confirmSelect("click");
				}
			}
			t = t.parentNode;
		}
		t = null;
	}
	
	this._doOnListMouseOut = function(e) {
		// when cursor out of item - clear hover or highlight selected
		if (that.conf.tm_hover) window.clearTimeout(that.conf.tm_hover);
		that.conf.tm_hover = window.setTimeout(function(){
			// select last selected
			var sId = that.conf.last_match||that.conf.last_selected;
			if (that.conf.last_match == null && that.t[sId] != null) {
				// but if no match found, check if entered text is same as in option
				if (that.base.firstChild.value != that.t[sId].obj.getText(that.t[sId].item, true)) sId = null;
			}
			that._setSelected(sId, null, true, true);
		},1);
	}
	
	this._doOnBaseMouseDown = function(e) {
		
		if (!that.conf.enabled) return;
		
		that.conf.clear_click = true;
		
		e = e||event;
		if (e.button != that.conf.btn_left) return;
		
		var t = e.target||e.srcElement;
		if (t != this.firstChild) {
			// focus input if list opened by clicking on arrow
			window.setTimeout(function(){that.base.firstChild.focus();},1);
			
			// top-image click?
			var p = t;
			while (p != this && p != null) {
				if (p == this.lastChild) {
					if (typeof(that.modes[that.conf.opts_type].topImageClick) == "function") {
						var t_id = (that.conf.last_hover||that.conf.last_selected);
						var t_item = (t_id != null?that.t[t_id].item:null);
						if (that.modes[that.conf.opts_type].topImageClick(t_item, that) !== true) {
							t_id = t_item = null;
							return;
						}
					}
					p = null;
				} else {
					p = p.parentNode;
				}
			}
			
		}
		
		if (that._isListVisible()) {
			that._hideList();
		} else {
			if (t != this.firstChild) that.conf.clear_blur = true;
			that._showList();
			that._setSelected(that.conf.last_selected, true, true);
		}
		t = null;
	}
	
	// body click -> hide list if any
	this._doOnBodyMouseDown = function() {
		if (that.conf.clear_click) {
			that.conf.clear_click = false;
			return;
		}
		that._confirmSelect("blur");
	}
	
	// input focus/blur
	this._doOnInputFocus = function() {
		that.conf.clear_blur = false;
		// if forus back to input - cancel confirm (occured when user clicked on arrow while list opened)
		if (that.conf.tm_confirm_blur) window.clearTimeout(that.conf.tm_confirm_blur);
		// ev
		if (that.conf.combo_focus == false) {
			that.conf.combo_focus = true;
			if (that.conf.skin == "material" && that.base.className.match(/dhxcombo_actv/) == null) {
				that.base.className += " dhxcombo_actv";
			}
			that.callEvent("onFocus",[]);
		}
	}
	this._doOnInputBlur = function() {
		if (that.conf.clear_blur == true) {
			that.conf.clear_blur = false;
			return;
		}
		// start confirm tm
		if (that.conf.tm_confirm_blur) window.clearTimeout(that.conf.tm_confirm_blur);
		that.conf.tm_confirm_blur = window.setTimeout(function(){
			if (that.conf.clear_click == false) {
				// if (that._isListVisible()) that._hideList();
				that._confirmSelect("blur");
				that.conf.combo_focus = false;
				if (that.conf.skin == "material" && that.base.className.match(/dhxcombo_actv/) != null) {
					that.base.className = that.base.className.replace(/\s*dhxcombo_actv/gi, "");
				}
				that.callEvent("onBlur",[]);
			}
		},20);
	}
	
	// input events, typing/filtering
	this._doOnInputKeyUp = function(e) {
		
		e = e||event;
		
		if (that.conf.f_mode != false) {
		    that.conf.clear_bsp = (e.keyCode == 8 || e.keyCode == 46); // backspace(8) and delete(46)
		    if (e.keyCode == 9 || e.keyCode == 13 || e.keyCode == 37 || e.keyCode == 38 || e.keyCode == 39 || e.keyCode == 40) return; //回车键、方向键不进行过滤操作
			that._filterOpts();
			return;
		} else {
			that._checkForMatch();
		}
	}
	
	this._doOnInputKeyDown = function(e) {
		
		e = e||event;
		
		// console.log("onkeypress ", e.keyCode, " ", e.charCode)
		
		// up (38) /down (40)
		if ((e.keyCode == 38 || e.keyCode == 40) && !e.ctrlKey && !e.shiftKey && !e.altKey) {
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			e.cancelBubble = true;
			that._keyOnUpDown(e.keyCode==38?-1:1);
		}
		
		// F2
		if (e.keyCode == 113) {
			if (!that._isListVisible()) {
				that._showList();
				if (that.base.firstChild.value == that.conf.last_text) {
					that._setSelected(that.conf.last_selected, true, true);
					that.base.firstChild.value = that.conf.last_text;
					that.conf.f_server_last = that.base.firstChild.value.toLowerCase();
				} else {
					that.conf.f_server_last = that.base.firstChild.value.toLowerCase();
					if (that.conf.f_mode == false) that._checkForMatch();
				}
			} else {
				
			}
		}
		
		// esc
		if (e.keyCode == 27) {
			// cancel operation, restore last value
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			e.cancelBubble = true;
			that._cancelSelect();
		}
		
		// enter
		if (e.keyCode == 13) {
			if (e.preventDefault) e.preventDefault(); // if combo attached to form
			that._confirmSelect("kbd");
		}
		
		// selection in r/o mode
		if (that.conf.ro_mode == true && ((e.keyCode >= 48 && e.keyCode <= 57) || (e.keyCode >= 65 && e.keyCode <= 90))) {
			that._searchRO(String.fromCharCode(e.keyCode).toLowerCase());
			e.cancelBubble = true;
		}
		
		that.conf.clear_key = true;
		that.callEvent("onKeyPressed",[e.keyCode||e.charCode]);
	}
	
	this._doOnInputKeyPress = function(e) {
		if (that.conf.clear_key) {
			that.conf.clear_key = false;
			return;
		}
		e = e||event;
		that.callEvent("onKeyPressed",[e.keyCode||e.charCode]);
	}
	
	this._keyOnUpDown = function(dir) {
		
		// select(just hover) next/prev item in a list
		
		var item = null;
		if (this.conf.last_hover) {
			item = this.t[this.conf.last_hover].item;
		} else if (this.conf.last_selected) {
			item = this.t[this.conf.last_selected].item;
		}
		
		if (!item && this._getListVisibleCount() == 0) return;
		if (item != null && item.style.display != "") item = null;
		
		this._showList();
		
		if (item != null) {
			// check if item highlighted
			if (this.t[item._optId].obj.isSelected(item)) item = this._getNearItem(item, dir);
		} else {
			item = this.list.firstChild;
			if (item.style.display != "") item = this._getNearItem(item, 1);
		}
		
		if (item == null) return; // first/last
		
		this._setSelected(item._optId, true, true);
		
		if (this.conf.f_mode == false) {
			this.base.firstChild.value = this.t[item._optId].obj.getText(item, true);
		} else {
			var text = String(this.t[item._optId].obj.getText(item, true));
			if (this.conf.f_mode == "start" && this.conf.f_ac == true) {
				if (text.toLowerCase().indexOf(this.conf.f_server_last) === 0) {
					// try to find match and select part of text
					this.conf.f_ac_text = text.substring(this.conf.f_server_last.length, text.length);
					this.base.firstChild.value = text;
					this._selectRange(this.conf.f_server_last.length, this.base.firstChild.value.length);
				} else {
					// insert all text and select
					this.base.firstChild.value = text;
					this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
					this._selectRange(0, this.base.firstChild.value.length);
				}
			} else {
				// just insert text into main input
				this.base.firstChild.value = text;
				this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
			}
		}
		
		//
		item = null;
	}
	
	this.conf.evs_nodes = [
		{node: document.body, evs: {mousedown: "_doOnBodyMouseDown"}},
		{node: this.base, evs: {mousedown: "_doOnBaseMouseDown"}},
		{node: this.base.firstChild, evs: {keyup: "_doOnInputKeyUp", keydown: "_doOnInputKeyDown", keypress: "_doOnInputKeyPress", focus: "_doOnInputFocus", blur: "_doOnInputBlur"}},
		{node: this.list, evs: {mousemove: "_doOnListMouseMove", mousedown: "_doOnListMouseDown", mouseup: "_doOnListMouseUp", mouseout: "_doOnListMouseOut"}}
	];
	for (var q=0; q<this.conf.evs_nodes.length; q++) {
		for (var a in this.conf.evs_nodes[q].evs) {
			if (typeof(window.addEventListener) == "function") {
				this.conf.evs_nodes[q].node.addEventListener(a, this[this.conf.evs_nodes[q].evs[a]], false);
			} else {
				this.conf.evs_nodes[q].node.attachEvent("on"+a, this[this.conf.evs_nodes[q].evs[a]]);
			}
		}
	}
	
	
	this.unload = function() {
		
		// remove options
		this.clearAll();
		this.t = null;
		
		// detach dom events
		for (var q=0; q<this.conf.evs_nodes.length; q++) {
			for (var a in this.conf.evs_nodes[q].evs) {
				if (typeof(window.addEventListener) == "function") {
					this.conf.evs_nodes[q].node.removeEventListener(a, this[this.conf.evs_nodes[q].evs[a]], false);
				} else {
					this.conf.evs_nodes[q].node.detachEvent("on"+a, this[this.conf.evs_nodes[q].evs[a]]);
				}
				this.conf.evs_nodes[q].evs[a] = null;
				delete this.conf.evs_nodes[q].evs[a];
			}
			this.conf.evs_nodes[q].node = null;
			this.conf.evs_nodes[q].evs = null;
			delete this.conf.evs_nodes[q].node;
			delete this.conf.evs_nodes[q].evs;
			this.conf.evs_nodes[q] = null;
		}
		
		window.dhx4._eventable(this, "clear");
		window.dhx4._enableDataLoading(this, null, null, null, "clear");
		
		this._mcDetachHeader();
		
		// depr
		this.DOMelem_input = this.DOMelem_button = this.DOMlist = this.DOMelem = this.DOMParent = null;
		
		for (var a in this.conf) {
			this.conf[a] = null;
			delete this.conf[a];
		}
		this.conf = null;
		
		if (typeof(window.addEventListener) == "function") {
			this.list.removeEventListener("scroll", this._doOnListScroll, false);
		} else {
			this.list.detachEvent("onscroll", this._doOnListScroll);
		}
		
		this.base.parentNode.removeChild(this.base);
		this.list.parentNode.removeChild(this.list);
		this.base = this.list = this.cont = null;
		
		this.modes = null;
		
		for (var a in this) {
			if (typeof(this[a]) == "function") this[a] = null;
		}
		
		that = null;
		
	};
	
	// DEPRECATED props
	this.DOMelem_input = this.base.firstChild; // 3.6 compat, use getInput()
	this.DOMelem_button = this.base.childNodes[this.base.childNodes.length-(this.conf.combo_image?2:1)]; // 3.6 compat, use getButton()
	this.DOMlist = this.list; // 3.6 compat, use getList()
	this.DOMelem = this.base; // 3.6 compat, use getBase()
	this.DOMParent = parentId; // 3.0 compat, use getParent()
	parentId = null;
	
	// check for object api init details
	if (apiObj != null) {
		// filter
		if (apiObj.filter != null) {
			if (typeof(apiObj.filter) == "string") {
				this.enableFilteringMode(true, apiObj.filter, window.dhx4.s2b(apiObj.filter_cache), window.dhx4.s2b(apiObj.filter_sub_load));
			} else {
				this.enableFilteringMode(true);
			}
		}
		// imgs
		if (apiObj.image_path != null) this.setImagePath(apiObj.image_path);
		if (apiObj.default_image != null || apiObj.default_image_dis != null) this.setDefaultImage(apiObj.default_image, apiObj.default_image_dis);
		// opts
		if (apiObj.items || apiObj.options) this.addOption(apiObj.items||apiObj.options);
		if (apiObj.xml || apiObj.json) this.load(apiObj.xml||apiObj.json);
		// misc
		if (typeof(apiObj.readonly) != "undefined") this.readonly(apiObj.readonly);
		//
		apiObj = null;
	}
	
	return this;
	
};

function dhtmlXComboFromSelect(selectId) {
	
	// <select mode="checkbox">
	
	if (typeof(selectId) == "string") selectId = document.getElementById(selectId);
	
	// collect params
	var comboWidth = selectId.offsetWidth;
	var formName = selectId.getAttribute("name")||null;
	
	// add node
	var comboNode = document.createElement("SPAN");
	selectId.parentNode.insertBefore(comboNode, selectId);
	
	// combo mode
	var comboMode = selectId.getAttribute("mode")||selectId.getAttribute("opt_type")||"option";
	
	// init combo
	var combo = new dhtmlXCombo(comboNode, formName, comboWidth, comboMode);
	comboNode = null;
	
	var imagePath = selectId.getAttribute("imagePath");
	if (imagePath) combo.setImagePath(imagePath);
	
	var defImg = selectId.getAttribute("defaultImage");
	var defImgDis = selectId.getAttribute("defaultImageDis");
	if (window.dhx4.s2b(defImgDis) == true) defImgDis = true;
	if (defImg != null || defImgDis != null) combo.setDefaultImage(defImg, defImgDis);
	
	// options
	var opts = combo._xmlToObj([selectId], true, selectId.selectedIndex);
	if (opts.options.length > 0) combo.addOption(opts.options);
	opts = null;
	
	// remove select
	selectId.parentNode.removeChild(selectId);
	selectId = null;
	
	return combo;
};

/* common funcs */
dhtmlXCombo.prototype.setName = function(name) { // change name for form
	this.conf.form_name = name;
	this.base.childNodes[1].name = name;
	this.base.childNodes[2].name = name.replace(/(\[.*)?$/, "_new_value$1");
};

dhtmlXCombo.prototype.readonly = function(mode) { // enable/disable readonly mode
	if (window.dhx4.s2b(mode)) {
		this.base.firstChild.setAttribute("readOnly", "true");
		this.conf.ro_mode = true;
	} else {
		this.base.firstChild.removeAttribute("readOnly");
		this.conf.ro_mode = false;
	}
};

dhtmlXCombo.prototype.setPlaceholder = function(text) { // new in 4.0, limited support
	if (typeof(text) == "undefined" || text == null) text = "";
	this.base.firstChild.setAttribute("placeholder", String(text));
};

dhtmlXCombo.prototype.setTemplate = function(tpl) {
	for (var a in tpl) {
		if (typeof(this.conf.template[a]) != "undefined") {
			if (a == "header") {
				this.conf.template[a] = window.dhx4.s2b(tpl[a]);
			} else {
				this.conf.template[a] = String(tpl[a]);
			}
		}
	};
	
	// columns
	if (tpl.columns != null) {
		this._mcMakeTemplate(tpl.columns);
	} else {
		this._mcDetachHeader();
	}
	
	// template changed, update combo text and update rendered options
	for (var a in this.t) {
		this.t[a].obj.setText(this.t[a].item, this.t[a].item._conf.text);
	};
	this._confirmSelect();
};

dhtmlXCombo.prototype.setSkin = function(skin) {
	if (skin == this.conf.skin) return;
	this.conf.skin = skin;
	this.base.className = "dhxcombo_"+this.conf.skin+(this.conf.enabled?"":" dhxcombo_disabled");
	this.list.className = "dhxcombolist_"+this.conf.skin+(this.hdr!=null?" dhxcombolist_multicolumn":"");
	if (this.hdr != null) this.hdr.className = "dhxcombolist_"+this.conf.skin+" dhxcombolist_hdr";
	this.conf.i_ofs = (skin == "material"?26:23);
	this._adjustBase();
};

dhtmlXCombo.prototype.getInput = function() { // returns input, new in 4.0
	return this.base.firstChild;
};
dhtmlXCombo.prototype.getButton = function() { // returns button, new in 4.0
	return this.base.childNodes[this.base.childNodes.length-(this.conf.combo_image?2:1)];
};
dhtmlXCombo.prototype.getList = function() { // do we need it?
	return this.list;
};
dhtmlXCombo.prototype.getBase = function() { // do we need it?
	return this.base;
};

dhtmlXCombo.prototype.getParent = function() { // do we need it?
	return this.DOMParent;
};

dhtmlXCombo.prototype.forEachOption = function(handler) { // iterator, new in 4.0
	for (var q=0; q<this.list.childNodes.length; q++) {
		handler.apply(window, [this._getOption(this.list.childNodes[q]._optId, q)]);
	}
};

dhtmlXCombo.prototype.setFocus = function() {
	if (this.conf.enabled) this.base.firstChild.focus();
};
dhtmlXCombo.prototype.setFontSize = function(sizeInp, sizeList) {
	// "11px" or" "0.9em"
	if (sizeInp != null) this.base.firstChild.style.fontSize = sizeInp;
	if (sizeList != null) this.list.style.fontSize = sizeList;
};

/* options */
dhtmlXCombo.prototype.getOption = function(value) { // option by value
	var id = null;
	var index = null;
	for (var q=0; q<this.list.childNodes.length; q++) {
		if (id == null) {
			var a = this.list.childNodes[q]._optId;
			if (this.t[a].obj.getValue(this.t[a].item) == value) { id = a; index = q; }
		}
	}
	return (id==null?null:this._getOption(id, index));
};

dhtmlXCombo.prototype.getOptionByIndex = function(index) { // option by index
	if (index < 0) return null;
	if (this.list.childNodes[index] == null) return null;
	return this._getOption(this.list.childNodes[index]._optId, index);
};

dhtmlXCombo.prototype.getOptionByLabel = function(text) { // rename to getOptionByText ?
	// option by label
	var id = null;
	var index = null;
	for (var q=0; q<this.list.childNodes.length; q++) {
		if (id == null) {
			var a = this.list.childNodes[q]._optId;
			if (this.t[a].obj.getText(this.t[a].item, true) == text) { id = a; index = q; }
		}
	}
	return (id==null?null:this._getOption(id, index));
};

dhtmlXCombo.prototype.getSelectedIndex = function() { // gets index of selected option
	return this._getOptionProp(this.conf.last_selected, "index", -1);
};

dhtmlXCombo.prototype.getSelectedText = function() { // gets text of selected option
	return this._getOptionProp(this.conf.last_selected, "text", "");
};

dhtmlXCombo.prototype.getSelectedValue = function() { // gets value of selected item
	return this._getOptionProp(this.conf.temp_selected||this.conf.last_selected, "value", null);
};

dhtmlXCombo.prototype.getActualValue = function() { // gets value which will be sent with form
	return this.base.childNodes[1].value;
};
dhtmlXCombo.prototype.getComboText = function() { // gets current text in combobox
	return this.base.childNodes[0].value;
};

dhtmlXCombo.prototype.getIndexByValue = function(value) { // returns index of item by value
	var t = this.getOption(value);
	return (t!=null?t.index:-1);
};

dhtmlXCombo.prototype.setComboText = function(text) {
	// sets text in combobox, reset selected option
	if (this.conf.allow_free_text != true) return;
	
	this.unSelectOption();
	this.conf.last_text = this.base.firstChild.value = text;
	this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
	
};

dhtmlXCombo.prototype.setComboValue = function(value) {
	// sets text in combobox, only text
	var t = this.getOption(value);
	if (t != null) {
		this.selectOption(t.index);
	} else {
		this.conf.last_value = value;
		this.base.childNodes[1].value = this.conf.last_value;
		this.base.childNodes[2].value = "true";
	}
};

dhtmlXCombo.prototype.selectOption = function(index, filter, conf) { // selects option
	if (index < 0 || index >= this.list.childNodes.length) return;
	var id = this.list.childNodes[index]._optId;
	this._setSelected(id, this._isListVisible(), true);
	this._confirmSelect("script");
};

dhtmlXCombo.prototype.unSelectOption = function() { // unselects option
	
	if (this.conf.last_hover != null) {
		this.t[this.conf.last_hover].obj.setSelected(this.t[this.conf.last_hover].item, false);
		this.conf.last_hover = null;
	}
	
	this.base.firstChild.value = "";
	
	if (this.conf.f_mode != false) {
		this._filterOpts(true);
	}
	this._hideList();
	this._updateTopImage(null);
	
	this._confirmSelect("script");
	
};

dhtmlXCombo.prototype.confirmValue = function() {
	this._confirmSelect("script");
};

/* enable/disable */
dhtmlXCombo.prototype.enable = function(mode) {
	
	mode = (typeof(mode)=="undefined"?true:window.dhx4.s2b(mode));
	if (this.conf.enabled == mode) return;
	
	this.conf.enabled = mode;
	
	if (mode) {
		this.base.className = "dhxcombo_"+this.conf.skin;
		this.base.firstChild.removeAttribute("disabled");
	} else {
		this._hideList();
		this.base.className = "dhxcombo_"+this.conf.skin+" dhxcombo_disabled";
		this.base.firstChild.setAttribute("disabled","true");
	}
	
	// update disabled image if any
	this._updateTopImage(this.conf.last_selected);
};

dhtmlXCombo.prototype.disable = function(mode) {
	mode = (typeof(mode)=="undefined"?true:window.dhx4.s2b(mode));
	this.enable(!mode);
};

dhtmlXCombo.prototype.isEnabled = function() {
	return (this.conf.enabled==true);
};

/* visibility */
dhtmlXCombo.prototype.show = function(mode) {
	if (typeof(mode) == "undefined") mode = true; else mode = window.dhx4.s2b(mode);
	this.base.style.display = (mode==true?"":"none");
};

dhtmlXCombo.prototype.hide = function(mode) {
	if (typeof(mode) == "undefined") mode = true;
	this.show(!mode);
};

dhtmlXCombo.prototype.isVisible = function() {
	return (this.base.style.display=="");
};


/* filtering */
dhtmlXCombo.prototype.setFilterHandler = function(f) {
	if (typeof(f) == "function") {
		this.conf.f_func = f;
		this.conf.f_mode = true;
		this.conf.f_dyn = this.conf.f_cache = this.conf.f_url = null;
	} else if (typeof(f) == "string" && typeof(window[f]) == "function") {
		this.conf.f_func = window[f];
		this.conf.f_mode = true;
		this.conf.f_dyn = this.conf.f_cache = this.conf.f_url = null;
	} else {
		this.conf.f_func = null;
	}
};
dhtmlXCombo.prototype.enableFilteringMode = function(mode, url, cache, dyn) {
	if (mode == true || mode == "between") {
		this.conf.f_mode = (mode==true?"start":"between");
		if (url) {
			this.conf.f_url = url;
			this.conf.f_cache = window.dhx4.s2b(cache);
			this.conf.f_dyn = window.dhx4.s2b(dyn);
		} else {
			this.conf.f_url = null;
			this.conf.f_cache = false;
			this.conf.f_dyn = false;
		}
	} else {
		this.conf.f_mode = false;
		this.conf.f_url = null;
		this.conf.f_cache = false;
		this.conf.f_dyn = false;
	}
};

dhtmlXCombo.prototype.filter = function(handler, showList) { // new in 4.0
	for (var q=0; q<this.list.childNodes.length; q++) {
		var k = handler.apply(window, [this._getOption(this.list.childNodes[q]._optId,q)]);
		this.list.childNodes[q].style.display = (k===true?"":"none");
	}
	if (typeof(showList) == "undefined" || showList == true) {
		this._showList(true);
	}
};

dhtmlXCombo.prototype.sort = function(mode) { // new in 4.0
	var r = [];
	for (var q=0; q<this.list.childNodes.length; q++) {
		var id = this.list.childNodes[q]._optId;
		r.push([id, this._getOption(id, q)]);
	}
	// sort
	if (mode == "asc" || mode == "desc") {
		k = true;
		r.sort(function(a,b){
			a = a[1].text_option.toLowerCase();
			b = b[1].text_option.toLowerCase();
			var r = (mode=="asc"?1:-1);
			return (a>b?r:-1*r);
		});
	} else if (typeof(mode) == "function" || typeof(window[mode]) == "function") {
		if (typeof(window[mode]) == "function") mode = window[mode];
		r.sort(function(a,b){
			return mode.apply(window, [a[1],b[1]]);
		});
	}
	// reorder
	while (this.list.childNodes.length > 0) this.list.removeChild(this.list.lastChild);
	for (var q=0; q<r.length; q++) this.list.appendChild(this.t[r[q][0]].item);
};

dhtmlXCombo.prototype.enableAutocomplete = function(mode) { // autocomplete for f_mode:start, enabled by default
	if (typeof(mode) == "undefined") mode = true; else mode = window.dhx4.s2b(mode);
	this.conf.f_ac = mode;
};
dhtmlXCombo.prototype.disableAutocomplete = function(mode) {
	if (typeof(mode) == "undefined") mode = true; else mode = window.dhx4.s2b(mode);
	this.enableAutocomplete(!mode);
};

dhtmlXCombo.prototype.allowFreeText = function(mode, resetToEmpty) { // new in 4.0
	this.conf.allow_free_text = (typeof(mode)=="undefined"?true:window.dhx4.s2b(mode));
	this.conf.free_text_empty = (typeof(resetToEmpty)=="undefined"?false:window.dhx4.s2b(resetToEmpty)); // 4.5.1
};

dhtmlXCombo.prototype._checkForMatch = function(forceClear) {
	// check if text matched to any opt_text for opt_hover while user entered text
	var k = window.dhx4.trim(this.base.firstChild.value).toLowerCase();
	var id = null;
	var item = this.list.firstChild;
	while (item != null) {
		if (item.style.display == "" && item._optId != null) {
			var text = window.dhx4.trim(this.t[item._optId].obj.getText(item, true)).toLowerCase();
			if (k == text) {
				id = item._optId;
				item = null;
			}
		}
		if (item != null) item = item.nextSibling;
	}
	// match found, hover item
	if (this.conf.last_match == null) {
		if (id != null) {
			// 1st match
			this._setSelected(id, true, true);
			this.conf.last_match = id;
		} else {
			// nothing found
			// clear current selection if any
			if (this.conf.f_mode != "between" || forceClear == true) {
				this._setSelected(null, true, true);
				this.conf.last_match = null;
			}
		}
	} else {
		if (id != null) {
			// another match, check if same or new
			if (id != this.conf.last_match) {
				this._setSelected(id, true, true);
				this.conf.last_match = id;
			}
		} else {
			// nothing found clear last match if hovered and selection not changed
			this._setSelected(null, true, true);
			this.conf.last_match = null;
		}
	}
	
};

dhtmlXCombo.prototype._selectRange = function(from, to) {
	if (this.conf.combo_focus == true) window.dhx4.selectTextRange(this.base.firstChild, from, to);
};

/* show/hide select list */
dhtmlXCombo.prototype.openSelect = function() { // opens list of options
	if (!this._isListVisible()) this._showList();
};

dhtmlXCombo.prototype.closeAll = function() {
	this._hideList();
};

dhtmlXCombo.prototype._showList = function(autoHide) {
	
	if (this._getListVisibleCount() == 0) {
		if (autoHide && this._isListVisible()) this._hideList();
		return;
	}
	
	if (this._isListVisible()) {
		this._checkListHeight();
		return;
	}
	
	this.list.style.zIndex = window.dhx4.zim.reserve(this.conf.list_zi_id); // get new z-index
	if (this.hdr != null && this.conf.template.header == true) this.hdr.style.zIndex = Number(this.list.style.zIndex)+1;
	
	this.list.style.visibility = "hidden";
	this.list.style.display = "";
	if (this.hdr != null && this.conf.template.header == true) {
		this.hdr.style.visibility = this.list.style.visibility;
		this.hdr.style.display = this.list.style.display;
	}
	
	// position
	var h0 = (this.hdr != null && this.conf.template.header == true ? this.hdr.offsetHeight : 0);
	
	this.list.style.width = Math.max(this.conf.opts_width||this.conf.col_w||0, this.conf.combo_width)+"px";
	this.list.style.top = window.dhx4.absTop(this.base)+h0+this.base.offsetHeight-1+"px";
	this.list.style.left = window.dhx4.absLeft(this.base)+"px";
	
	if (this.hdr != null && this.conf.template.header == true) {
		this.hdr.style.width = this.list.style.width;
		this.hdr.style.left = this.list.style.left;
		this.hdr.style.top = parseInt(this.list.style.top)-h0+"px";
	}
	
	// height
	this._checkListHeight();
	
	// check bottom overlay
	this.list.style.visibility = "visible";
	if (this.hdr != null && this.conf.template.header == true) this.hdr.style.visibility = "visible";
	
	this.callEvent("onOpen",[]);
	
};

dhtmlXCombo.prototype._hideList = function() {
	
	if (!this._isListVisible()) return;
	
	window.dhx4.zim.clear(this.conf.list_zi_id); // clear z-index
	this.list.style.display = "none";
	if (this.hdr != null && this.conf.template.header == true) this.hdr.style.display = "none";
	
	this.conf.clear_click = false;
	
	this.callEvent("onClose",[]);
	
};

dhtmlXCombo.prototype._isListVisible = function() {
	return (this.list.style.display=="");
};

dhtmlXCombo.prototype._getListVisibleCount = function() {
	var k = 0;
	for (var q=0; q<this.list.childNodes.length; q++) k += (this.list.childNodes[q].style.display==""?1:0);
	return k;
};

dhtmlXCombo.prototype._checkListHeight = function() {
	
	if (!this._isListVisible()) return;
	
	if (this.conf.item_h == null) {
		var item = this.list.firstChild;
		while (item != null) {
			if (item.style.display == "") {
				this.conf.item_h = item.offsetHeight + (this.hdr != null ? -1 : 0); // multicol rows have -1px margin
				item = null;
			} else {
				item = item.nextSibling;
			}
		}
		item = null;
	}
	
	var s = window.dhx4.screenDim();
	var by = window.dhx4.absTop(this.base);
	var bh = this.base.offsetHeight;
	var hh = (this.hdr!=null&&this.conf.template.header==true?this.hdr.offsetHeight:0); // header_height
	
	var onTop = Math.max(0, Math.floor((by-hh-s.top)/this.conf.item_h));
	var onBottom = Math.max(0, Math.floor((s.bottom-(by+bh+hh))/this.conf.item_h));
	
	var itemsCount = this._getListVisibleCount();
	
	// top/bottom detect
	if (onBottom < Math.min(this.conf.opts_count_min, itemsCount) && onTop > onBottom) onBottom = null;
	
	var itemsToShow = Math.min((onBottom==null?onTop:onBottom), this.conf.opts_count, itemsCount);
	var h = (itemsToShow<itemsCount?(itemsToShow*this.conf.item_h)+"px":"");
	
	var ofs = this.conf.sp[this.conf.skin][this.hdr!=null&&this.conf.template.header==true?"hdr_ofs":"list_ofs"];
	
	this.list.style.height = h;
	this.list.style.top = (onBottom==null?by-this.list.offsetHeight+ofs:by+bh+hh-ofs)+"px";
	if (this.hdr != null && this.conf.template.header == true) this.hdr.style.top = (onBottom==null?by-hh-this.list.offsetHeight+ofs:by+bh-ofs)+"px";
	
};

dhtmlXCombo.prototype._scrollToItem = function(id) {
	
	var y1 = this.t[id].item.offsetTop;
	var y2 = y1+this.t[id].item.offsetHeight;
	var a1 = this.list.scrollTop;
	var a2 = a1+this.list.clientHeight;
	
	if (y1 < a1) {
		// on top
		this.list.scrollTop = y1+(this.hdr!=null&&this.conf.template.header==true?1:0);
	} else if (y2 > a2) {
		// on bottom
		this.list.scrollTop = y2-this.list.clientHeight+(this.hdr!=null&&this.conf.template.header==true?-this.conf.sp[this.conf.skin].scr_ofs:0);
	}
	
};

/* in-list selection/highlighting */
dhtmlXCombo.prototype._setSelected = function(id, scrollToItem, updateImg, mouseMove) {
	
	this.conf.temp_selected = null;
	
	if (updateImg) this._updateTopImage(id);
	
	if (id != null && this.conf.last_hover == id) {
		if (scrollToItem) this._scrollToItem(id);
		return;
	}
	
	if (this.conf.last_hover != null) {
		this.t[this.conf.last_hover].obj.setSelected(this.t[this.conf.last_hover].item, false);
		this.conf.last_hover = null;
		if (id == null) this.callEvent("onSelectionChange", []);
	}
	
	if (id != null) {
		
		this.t[id].obj.setSelected(this.t[id].item, true);
		this.conf.last_hover = id;
		
		if (mouseMove != true) {
			this.conf.temp_selected = id;
			this.callEvent("onSelectionChange", []);
		}
		
		// last item selected, try subload
		if (this.conf.s_mode == "select" && this.t[id].item == this.t[id].item.parentNode.lastChild) this._subloadRequest();
		
		if (scrollToItem) this._scrollToItem(id);
		
	}
	
};

// auto-subload
dhtmlXCombo.prototype._subloadRequest = function() {
	
	if (this.conf.f_url != null && this.conf.f_dyn == true && this.conf.f_dyn_end == false) {
		
		var params = "mask="+encodeURIComponent(this.conf.f_mask)+"&pos="+this.list.childNodes.length;
		var t = this;
		var callBack = function(r){
			
			// cache
			if (t.conf.f_cache) t.conf.f_cache_data[t.conf.f_mask].data.push(r.xmlDoc.responseXML);
			var k = t.list.childNodes.length;
			
			// skip clear opts w/o add='true'
			t.conf.f_loading = true;
			t.load(r.xmlDoc.responseXML);
			t.conf.f_loading = false;
			
			// if no more opts left on server, stop dyn requests
			if (k == t.list.childNodes.length) {
				t.conf.f_dyn_end = true;
				if (t.conf.f_cache) t.conf.f_cache_data[t.conf.f_mask].dyn_end = true;
			}
			callBack = t = null;
		}
		if (window.dhx4.ajax.method == "post") {
			window.dhx4.ajax.post(this.conf.f_url, params, callBack);
		} else if (window.dhx4.ajax.method == "get") {
			window.dhx4.ajax.get(this.conf.f_url+(String(this.conf.f_url).indexOf("?")>=0?"&":"?")+params, callBack);
		}
	}
};

/* add / remove options */
dhtmlXCombo.prototype.addOption = function(value, text, css, img, selected) {
	
	// selected added in 4.0
	
	/*
	
	single option, 4 params
	z.addOption(value, text, css, img_src);
	value, text, css (css string attached to the option, optional), img_src (path to the option icon image, just for "image" combo type)
	
	several options, array of array (in this case you can't use 4th parameter img_src - improve?)
	z.addOption([["a","option A", "color:red;"],[],[],...]);
	
	several options, as an array of objects (you can use 4 parameters)
	z.addOption([{value: "a", text: "option A", img_src: "../images/blue.gif", css:"color:red;"},{},{}...]);
	
	*/
	
	var toSelect = null;
	
	if (!(value instanceof Array)) {
		// single option
		var id = this._renderOption({value:value, text:text, css:css, img:img});
		if (toSelect == null && window.dhx4.s2b(selected) == true) toSelect = id;
		
	} else {
		// array with opts
		for (var q=0; q<value.length; q++) {
			if (typeof(value[q]) == "undefined") continue;
			if (value[q] instanceof Array) {
				id = this._renderOption({value:value[q][0], text:value[q][1], css:value[q][2], img:value[q][3]});
				if (toSelect == null && window.dhx4.s2b(value[q][4]) == true) toSelect = id;
			} else {
				var id = this._renderOption(value[q]);
				if (toSelect == null && window.dhx4.s2b(value[q].selected) == true) toSelect = id;
			}
		}
	}
	
	if (toSelect != null) {
		this._setSelected(toSelect, this._isListVisible(), true);
		this._confirmSelect("onInit");
	}
};

dhtmlXCombo.prototype.updateOption = function(oldValue, newValue, newText, newCss) {
	var id = this._getOptionId(oldValue);
	if (id == null) return;
	this.t[id].obj.update(this.t[id].item, {value: newValue, text: newText, css: newCss});
	if (this.conf.last_selected == id) {
		this.conf.last_text = this.base.firstChild.value = this.t[id].obj.getText(this.t[id].item, true);
		this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
	}
};

dhtmlXCombo.prototype.deleteOption = function(value) { // deletes option by value
	
	for (var a in this.t) {
		var v = this.t[a].obj.getValue(this.t[a].item);
		if (v == value) this._removeOption(a);
	}
	
	if (this._isListVisible()) this._showList(true); // resize if any or hide if no more items left
	
};

dhtmlXCombo.prototype.clearAll = function(hideList) { // remove all options
	
	hideList = (typeof(hideList)=="undefined"?true:window.dhx4.s2b(hideList));
	for (var a in this.t) this._removeOption(a);
	
	// props
	if (this.conf.tm_hover) window.clearTimeout(this.conf.tm_hover);
	this.conf.last_hover = null;
	this.conf.last_selected = null;
	
	this.list.scrollTop = 0;
	if (hideList == true) this._hideList();
	
};

dhtmlXCombo.prototype._renderOption = function(data) {
	
	var id = window.dhx4.newId();
	var item = document.createElement("DIV");
	
	item._optId = id;
	item._tpl = this.conf.template;
	
	// wrapper for img_src/img_src_dis
	if (typeof(data.img) == "undefined" && typeof(data.img_src) != "undefined") {
		data.img = data.img_src;
		delete data.img_src;
	}
	if (typeof(data.img_dis) == "undefined" && typeof(data.img_src_dis) != "undefined") {
		data.img_dis = data.img_src_dis;
		delete data.img_src_dis;
	}
	
	data.img_path = this.conf.img_path;
	data.img_def = this.conf.img_def;
	data.img_def_dis = this.conf.img_def_dis;
	
	this.list.appendChild(item);
	
	var v = (this._isListVisible() && window.dhx4.isFF == true);
	if (v == true) {
		var k = this.list.scrollTop;
		this.list.scrollTop -= 1;
	}
	
	// if multicolumn
	if (this.hdr != null) data.multicol = true;
	
	this.t[item._optId] = {
		obj: this.modes[this.conf.opts_type].render(item, data),
		item: item,
		conf: {
			type: this.conf.opts_type
		}
	};
	item = null;
	
	if (v == true) this.list.scrollTop += 1;
	
	return id;
};

dhtmlXCombo.prototype._removeOption = function(id) {
	this.t[id].obj.destruct(this.t[id].item);
	this.t[id].obj = null;
	this.t[id].item.parentNode.removeChild(this.t[id].item);
	this.t[id].item = null;
	this.t[id].conf = null;
	this.t[id] = null;
	delete this.t[id];
	
	if (this.conf.last_hover == id) this.conf.last_hover = null;
	if (this.conf.last_selected == id) {
		this.conf.last_selected = null;
		this._confirmSelect("onDelete");
	}
};

dhtmlXCombo.prototype._confirmSelect = function(mode, hideList) {
	
	var wasChanged = false;
	if (typeof(hideList) == "undefined") hideList = true;
	
	if (this.conf.f_server_tm) window.clearTimeout(this.conf.f_server_tm);
	
	// confirm selection
	// if any item hovered - select, if not - just apply entered value
	if (this.conf.last_hover != null) {
		// select value
		wasChanged = wasChanged||(this.conf.last_value != this._getOptionValue(this.conf.last_hover));
		this.conf.last_match = this.conf.last_selected = this.conf.last_hover;
		this.conf.last_value = this._getOptionValue(this.conf.last_selected);
		this.conf.last_text = this.base.firstChild.value = this.t[this.conf.last_selected].obj.getText(this.t[this.conf.last_selected].item, true);
		this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
		// inputs
		this.base.childNodes[1].value = this.conf.last_value;
		this.base.childNodes[2].value = "false";
	} else {
		// just a text,
		// check if free text allowed
		if (this.conf.allow_free_text || (this.base.firstChild.value == "" && this.conf.allow_empty_value)) {
			wasChanged = wasChanged||(this.conf.last_text != this.base.firstChild.value);
			this.conf.last_match = this.conf.last_value = this.conf.last_selected = null;
			this.conf.last_text = this.base.firstChild.value;
			this.conf.f_server_last = this.base.firstChild.value.toLowerCase();
			// inputs
			this.base.childNodes[1].value = this.conf.last_text;
			this.base.childNodes[2].value = "true";
		} else {
			this._cancelSelect(true);
			this._updateTopImage(this.conf.last_selected);
			return;
		}
	}
	
	if (this.conf.f_ac && this.conf.f_mode == "start") {
		this.conf.f_ac_text = "";
		if (mode != "blur") {
			this._selectRange(this.base.firstChild.value.length, this.base.firstChild.value.length);
		}
	}
	
	if (hideList) this._hideList();
	
	if (wasChanged == true && mode != "onInit" && mode != "onDelete") {
		this.callEvent("onSelectionChange", []);
		this.callEvent("onChange", [this.conf.last_value, this.conf.last_text]);
	}
	
};

dhtmlXCombo.prototype._cancelSelect = function(freeTextReset) {
	
	this._hideList();
	
	if (freeTextReset == true && this.conf.allow_free_text == false && this.conf.free_text_empty == true) {
		this.conf.f_server_last = this.conf.last_match = this.conf.last_value = this.conf.last_selected = null;
		this.base.childNodes[1].value = this.conf.last_text = this.base.firstChild.value = "";
		this.base.childNodes[2].value = "false";
	} else {
		this.base.firstChild.value = this.conf.last_text;
	}
	
	// restore filters if any
	if (this.conf.f_mode != false) {
		this._filterOpts(true);
	}
	
};


/* option object operations */
dhtmlXCombo.prototype._getOption = function(id, index) {
	
	if (!this.t[id]) return null;
	
	// autodetect index if any
	if (typeof(index) == "undefined") index = -1;
	if (index < 0) {
		for (var q=0; q<this.list.childNodes.length; q++) {
			if (index < 0 && this.list.childNodes[q]._optId == id) index = q;
		}
	}
	
	// comon data
	var t = {
		value: this.t[id].obj.getValue(this.t[id].item),
		text: this.t[id].obj.getText(this.t[id].item),
		text_input: this.t[id].obj.getText(this.t[id].item, true),
		text_option: this.t[id].obj.getText(this.t[id].item, null, true),
		css: this.t[id].obj.getCss(this.t[id].item),
		selected: (id==this.conf.last_selected),
		index: index
	};
	
	// extra data if any, for example "checked" for checkbox
	if (typeof(this.t[id].obj.getExtraData) == "function") {
		var k = this.t[id].obj.getExtraData(this.t[id].item);
		for (var a in k) { if (typeof(t[a]) == "undefined") t[a] = k[a]; }
	}
	
	return t;
};

dhtmlXCombo.prototype._getOptionProp = function(id, prop, def) { // get any property of any option
	if (id != null) {
		var t = this._getOption(id);
		if (t != null) return t[prop];
	}
	return def;
};
dhtmlXCombo.prototype._getOptionId = function(value) {
	var id = null;
	for (var q=0; q<this.list.childNodes.length; q++) {
		if (id == null) {
			var p = this.list.childNodes[q]._optId;
			if (value == this.t[p].obj.getValue(this.t[p].item)) id = p;
		}
	}
	return id;
};
dhtmlXCombo.prototype._getOptionValue = function(id) {
	return this._getOptionProp(id, "value", null);
};


dhtmlXCombo.prototype.setSize = function(width) { // changes control size
	this.conf.combo_width = parseInt(width)-(dhx4.isFF||dhx4.isIE||dhx4.isChrome||dhx4.isOpera?2:0);
	this.base.style.width = Math.max(0, this.conf.combo_width)+"px";
	this._adjustBase();
};

dhtmlXCombo.prototype._adjustBase = function() {
	this.base.firstChild.style.width = Math.max(0, (this.conf.combo_width-(this.conf.i_ofs+1)-(this.conf.combo_image?this.conf.i_ofs:0)))+"px";
	this.base.firstChild.style.marginLeft = (this.conf.combo_image?this.conf.i_ofs+"px":"0px");
};

dhtmlXCombo.prototype.setOptionWidth = function(w) { // sets width of combo list
	this.conf.opts_width = (parseInt(w)||null);
};

dhtmlXCombo.prototype.setOptionIndex = function(value, index) { // added in 4.1
	
	if (isNaN(index) || index < 0) return;
	
	var p = this.getOption(value);
	if (p == null) return;
	
	if (index == p.index) return;
	
	var t = this.list.childNodes[p.index];
	t.parentNode.removeChild(t);
	
	if (this.list.childNodes[index] != null) {
		this.list.insertBefore(t, this.list.childNodes[index]);
	} else {
		this.list.appendChild(t);
	}
	t = null;
	
};

dhtmlXCombo.prototype.getOptionsCount = function() { // added in 4.1
	return this.list.childNodes.length;
};

// multicolumn feature
dhtmlXCombo.prototype._mcMakeTemplate = function(cols) {
	
	var h = "";
	var t = "";
	
	this.conf.col_w = 0;
	
	for (var q=0; q<cols.length; q++) {
		
		var w = Number(parseInt(cols[q].width)||50);
		var css = (cols[q].css||"");
		var cssIE = (q == 0 && window.dhx4.isIE6 == true ? "_first":"");
		
		t += "<div class='dhxcombo_cell"+cssIE+" "+css+"' style='width:"+w+"px;'><div class='dhxcombo_cell_text'>"+(cols[q].option||"&nbsp;")+"</div></div>";
		h += "<div class='dhxcombo_hdrcell"+cssIE+" "+css+"' style='width:"+w+"px;'><div class='dhxcombo_hdrcell_text'>"+(cols[q].header||"&nbsp;")+"</div></div>";
		//
		this.conf.col_w += w+1;
	}
	
	var w = 500;
	var k = document.createElement("DIV");
	k.style.position = "absolute";
	k.style.top = "10px";
	k.style.left = -w*2+"px";
	k.style.width = w+"px";
	k.style.height = "50px";
	k.style.overflowY = "scroll";
	k.innerHTML = "<div>&nbsp;</div>";
	document.body.appendChild(k);
	
	this.conf.col_w += w-k.firstChild.offsetWidth+10;
	
	k.parentNode.removeChild(k);
	k = null;
	
	this.conf.template.option = t;
	this._mcAttachHeader(h);
	
	this.list.className += " dhxcombolist_multicolumn";
};

dhtmlXCombo.prototype._mcAttachHeader = function(text) {
	
	if (this.hdr == null) {
		
		this.hdr = document.createElement("DIV");
		this.hdr.className = "dhxcombolist_"+this.conf.skin+" dhxcombolist_hdr";
		this.hdr.style.display = "none";
		
		this.list.parentNode.insertBefore(this.hdr, this.list);
		
		if (typeof(window.addEventListener) == "function") {
			this.hdr.addEventListener("mousedown", this._doOnListMouseDown, false);
		} else {
			this.hdr.attachEvent("onmousedown", this._doOnListMouseDown);
		}
		
		// remove top-image from input
		if (this.conf.opts_type == "checkbox" && this.conf.combo_image == true) {
			this.conf.combo_image = false;
			if (this.base.lastChild.className.match(/dhxcombo_top_image/) != null) this.base.removeChild(this.base.lastChild);
			this._adjustBase();
		}
	}
	
	this.hdr.innerHTML = "<div class='dhxcombo_hdrtext'>"+text+"</div>";
	
};

dhtmlXCombo.prototype._mcDetachHeader = function() {
	
	if (this.hdr != null) {
		
		if (typeof(window.addEventListener) == "function") {
			this.hdr.removeEventListener("mousedown", this._doOnListMouseDown, false);
		} else {
			this.hdr.detachEvent("onmousedown", this._doOnListMouseDown);
		}
		
		this.hdr.parentNode.removeChild(this.hdr);
		this.hdr = null;
	}
	
	this.conf.col_w = null;
	this.conf.item_h = null;
	
};


/****************************************************************************************************************************************************************************************************************/

/* options */
dhtmlXCombo.prototype.modes = {}; // option types

dhtmlXCombo.prototype.doWithItem = function(index, method, param1, param2) { // wrapper to perform opts operations from combo
	
	// get option inner id
	var id = (index >= 0 && index < this.list.childNodes.length ? this.list.childNodes[index]._optId : null);
	if (id == null) return null; // opt no found
	if (typeof(this.t[id].obj[method]) != "function") return null; // function not found
	
	// generate params
	var params = [this.t[id].item];
	for (var q=2; q<arguments.length; q++) params.push(arguments[q]);
	
	// call method
	return this.t[id].obj[method].apply(this.t[id].obj, params);
	
};

function dhtmlXComboExtend(to, from) {
	for (var a in dhtmlXCombo.prototype.modes[from]) {
		if (typeof(dhtmlXCombo.prototype.modes[to][a]) == "undefined") {
			dhtmlXCombo.prototype.modes[to][a] = dhtmlXCombo.prototype.modes[from][a];
		}
	};
};
/****************************************************************************************************************************************************************************************************************/

dhtmlXCombo.prototype.modes.option = {
	
	image: false, // top-level image prev-to input
	html: false,
	option_css: "dhxcombo_option_text",
	
	render: function(item, data) {
		
		item._conf = {value: data.value, css: ""};
		
		item.className = "dhxcombo_option";
		item.innerHTML = "<div class='"+this.option_css+"'>&nbsp;</div>";
		
		if (data.css != null) {
			item.lastChild.style.cssText = data.css;
			item._conf.css = data.css;
		}
		
		this.setText(item, data.text);
		
		return this;
	},
	
	destruct: function(item) {
		item._conf = null;
	},
	
	update: function(item, data) {
		item._conf.value = data.value;
		item._conf.css = data.css;
		item.lastChild.style.cssText = data.css;
		this.setText(item, data.text);
	},
	
	setText: function(item, text, skip) {
		item._conf.text = text;
		var t = (typeof(text) == "object" ? window.dhx4.template(item._tpl.option, this.replaceHtml(item._conf.text, skip), true) : window.dhx4.trim(this.replaceHtml(item._conf.text, skip)||""));
		item.lastChild.innerHTML = (t.length==0?"&nbsp;":t);
	},
	
	getText: function(item, asStringInput, asStringOption) {
		if (window.dhx4.s2b(asStringInput) && typeof(item._conf.text) == "object") return window.dhx4.template(item._tpl.input, item._conf.text, true);
		if (window.dhx4.s2b(asStringOption) && typeof(item._conf.text) == "object") return window.dhx4.template(item._tpl.option, item._conf.text, true);
		return item._conf.text;
	},
	
	getValue: function(item) {
		return item._conf.value;
	},
	
	getCss: function(item) {
		return item._conf.css;
	},
	
	setSelected: function(item, state) {
		item.className = "dhxcombo_option"+(state?" dhxcombo_option_selected":"");
	},
	
	isSelected: function(item) {
		return String(item.className).indexOf("dhxcombo_option_selected") >= 0;
	},
	
	getExtraData: function(item) {
		// optional function,
		// adds extra data to option object returned by getOption()
		return {type: "option"};
	},
	
	replaceHtml: function(text, skip) {
		if (this.html == true) return text;
		if (typeof(skip) == "undefined" || skip == null) skip = {};
		if (typeof(text) == "object") {
			var t = {};
			for (var a in text) {
				t[a] = (skip[a]==true?text[a]:this.replaceHtml(text[a]));
			}
		} else {
			var t = (text||"").replace(/[\<\>\&\s]/g, function(t){
				switch (t) {
					case "<": return "&lt;";
					case ">": return "&gt;";
					case "&": return "&amp;";
					case " ": return "&nbsp;";
				}
				return t;
			});
		}
		return t;
	}
	
};

/****************************************************************************************************************************************************************************************************************/

dhtmlXCombo.prototype.modes.checkbox = {
	
	image: true, // disable in code if multicolumn
	html: false,
	image_css: "dhxcombo_checkbox dhxcombo_chbx_#state#",
	option_css: "dhxcombo_option_text dhxcombo_option_text_chbx",
	
	render: function(item, data) {
		
		if (this.image_css_regexp == null) this.image_css_regexp = new RegExp(this.image_css.replace("#state#","\\d*"));
		
		item._conf = {value: data.value, css: "", checked: window.dhx4.s2b(data.checked)};
		
		item.className = "dhxcombo_option";
		
		var skip = {}; // skip html replace
		
		if (data.multicol == true) {
			data.text.checkbox = "<div class='"+String(this.image_css).replace("#state#",(item._conf.checked?"1":"0"))+"'></div>&nbsp;";
			skip.checkbox = true;
			item.innerHTML = "<div class='"+dhtmlXCombo.prototype.modes.option.option_css+"'></div>";
		} else {
			item.innerHTML = "<div class='"+String(this.image_css).replace("#state#",(item._conf.checked?"1":"0"))+"'></div>"+
					"<div class='"+this.option_css+"'>&nbsp;</div>";
		}
		
		if (data.css != null) {
			item.lastChild.style.cssText += data.css;
			item._conf.css = data.css;
		}
		
		this.setText(item, data.text, skip);
		
		return this;
	},
	
	setChecked: function(item, state) {
		item._conf.checked = window.dhx4.s2b(state);
		var css = String(this.image_css).replace("#state#",(item._conf.checked?"1":"0"));
		this._changeChbxCss(item.childNodes, css);
	},
	
	_changeChbxCss: function(nodes, css) {
		for (var q=0; q<nodes.length; q++) {
			if (nodes[q].tagName != null && nodes[q].className != null && nodes[q].className.match(this.image_css_regexp) != null) {
				nodes[q].className = css;
			} else if (nodes[q].childNodes.length > 0) {
				this._changeChbxCss(nodes[q].childNodes, css);
			}
		}
	},
	
	isChecked: function(item) {
		return (item._conf.checked==true);
	},
	
	getExtraData: function(item) {
		return {type: "checkbox", checked: item._conf.checked};
	},
	
	optionClick: function(item, ev, combo) {
		// called when option clicked, return true allows selection+confirm, return false - not
		var r = true;
		var t = (ev.target||ev.srcElement);
		while (r == true && t != null && t != item && t.className != null) {
			if (t.className.match(this.image_css_regexp) != null) {
				var args = [item._conf.value, !item._conf.checked];
				if (combo.callEvent("onBeforeCheck", args) === true) {
					this.setChecked(item, !this.isChecked(item));
					combo.callEvent("onCheck", args);
				};
				r = false;
				args = null;
			} else {
				t = t.parentNode;
			}
		}
		t = combo = item = null;
		return r;
	},
	
	getTopImage: function(item, enabled) {
		// returns html for top image
		// if item not specified - default image
		// enabled specify if combo enabled
		return "";
	},
	
	topImageClick: function(item, combo) {
		// called when user clicked on top-image,
		// return true/false to allow defailt action (open/close list) ot not
		// for checkbox - perform default action
		return true;
	}
	
};

dhtmlXComboExtend("checkbox", "option");

dhtmlXCombo.prototype.setChecked = function(index, mode) {
	this.doWithItem(index, "setChecked", mode);
};

dhtmlXCombo.prototype.getChecked = function(index) {
	// return checked values
	var t = [];
	for (var q=0; q<this.list.childNodes.length; q++) {
		if (this.isChecked(q)) t.push(this._getOptionProp(this.list.childNodes[q]._optId, "value", ""));
	}
	return t;
};

dhtmlXCombo.prototype.isChecked = function(index) {
	return this.doWithItem(index, "isChecked");
};

/****************************************************************************************************************************************************************************************************************/

dhtmlXCombo.prototype.modes.image = {
	
	image: true,
	html: false,
	image_css: "dhxcombo_image",
	option_css: "dhxcombo_option_text dhxcombo_option_text_image",
	
	render: function(item, data) {
		
		item._conf = {value: data.value, css: ""};
		
		item.className = "dhxcombo_option";
		item.innerHTML = "<div class='"+this.image_css+"'></div>"+
				"<div class='"+this.option_css+"'>&nbsp;</div>";
		
		if (data.css != null) {
			item.lastChild.style.cssText += data.css;
			item._conf.css = data.css;
		}
		
		this.setText(item, data.text);
		this.setImage(item, data.img, data.img_dis, data.img_path, data.img_def, data.img_def_dis);
		
		return this;
	},
	
	update: function(item, data) {
		item._conf.value = data.value;
		item._conf.css = data.css;
		item.lastChild.style.cssText = data.css;
		this.setText(item, data.text);
		this.setImage(item, data.img, data.img_dis, data.img_path, data.img_def, data.img_def_dis);
	},
	
	setImage: function(item, img, img_dis, path, def, def_dis) {
		
		// image
		if (img != null && img.length > 0) {
			img = path+img;
		} else if (def != null && def.length > 0) {
			img = path+def;
		} else {
			img = null;
		}
		
		// image
		if (img_dis != null && img_dis.length > 0) {
			img_dis = path+img_dis;
		} else if (def_dis != null && def_dis.length > 0) {
			img_dis = path+def_dis;
		} else if (def_dis == true) {
			img_dis = img;
		} else {
			img_dis = null;
		}
		
		item._conf.img = img;
		item._conf.img_dis = img_dis;
		
		item.firstChild.style.backgroundImage = (img!=null?"url("+img+")":"none");
	},
	
	getExtraData: function(item) {
		return {type: "image"};
	},
	
	getTopImage: function(item, enabled) {
		// returns html for top image
		// if item not specified - default image
		var a = (enabled?"img":"img_dis");
		if (item != null && item._conf[a] != null) return "<div class='"+this.image_css+"' style='background-image:url("+item._conf[a]+");'></div>";
		return "";
	}
	
};

dhtmlXComboExtend("image", "option");

dhtmlXCombo.prototype.setDefaultImage = function(img, imgDis) {
	// sets default image
	// set imgDis to tru to use the same image as for enabled combo, default
	if (img != null) this.conf.img_def = img;
	if (imgDis != null) this.conf.img_def_dis = imgDis;
};
dhtmlXCombo.prototype.setImagePath = function(path) {
	this.conf.img_path = path;
};

;
///<jscompress sourcefile="dhtmlxwindows.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXWindows(params) {
	
	// console.log("context menu for top icon?");
	// console.log("resize with attached iframe - cover or cross events?");
	// console.log("resize allow while progress is on?");
	// console.log("deny resize for maxed window, but allow for partially maxed");
	// console.log("add cancelBubble for mousedown/click for modal cover?");
	
	var that = this;
	
	var conf = {};
	if (typeof(params) != "undefined") {
		for (var a in params) conf[a] = params[a];
	}
	params = null;
	
	this.conf = {
		skin: window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxwins")||"material",
		// viewport conf
		vp_pos_ofs: 20, // windows-veieport overlay (left, right, bottom) and 0 for top
		vp_custom: false,
		vp_of_auto: (conf.vp_overflow=="auto"), // overflow for body from layout init
		vp_of_id: window.dhx4.newId(),
		// window dinmension offset
		ofs_w: null,
		ofs_h: null,
		// button down/up state
		button_last: null,
		// hdr dblclick
		dblclick_tm: 300,
		dblclick_last: null,
		dblclick_id: null,
		dblclick_mode: "minmax", // "park", function(){}, "function_name"
		dblclick_active: false,
		dblclick_ev: (window.dhx4.isIE6||window.dhx4.isIE7||window.dhx4.isIE8),
		// fr cover render
		fr_cover: (navigator.userAgent.indexOf("MSIE 6.0")>=0) // iframe+select issue, ie6 only
	};
	
	var transData = window.dhx4.transDetect();
	this.conf.tr = {
		prop: transData.transProp, // false if not available
		ev: transData.transEv,
		height_open: "height 0.2s cubic-bezier(0.25,0.1,0.25,1)", // cell open/close by click
		height_close: "height 0.18s cubic-bezier(0.25,0.1,0.25,1)", // cell open/close by click
		op_open: "opacity 0.16s ease-in", // cell_cont on open
		op_close: "opacity 0.2s ease-out", // cell_cont on close
		op_v_open: "1", // opacity for opened cell
		op_v_close: "0.4" // opacity for closed cell
	};
	
	if (!conf.viewport) {
		this.attachViewportTo(document.body);
	} else {
		if (conf.viewport.object != null) {
			this.attachViewportTo(conf.viewport.object);
		} else if (conf.viewport.left != null && conf.viewport.top != null && conf.viewport.width != null && conf.viewport.height != null) {
			this.setViewport(conf.viewport.left, conf.viewport.top, conf.viewport.width, conf.viewport.height, conf.viewport.parent);
		} else {
			this.attachViewportTo(document.body);
		}
	}
	
	this.w = {};
	
	this.createWindow = function(id, x, y, width, height) {
		
		var r = {};
		if (arguments.length == 1 && typeof(id) == "object") {
			r = id;
		} else {
			r.id = id;
			r.left = x;
			r.top = y;
			r.width = width;
			r.height = height;
			if (typeof(r.id) == "undefined" || r.id == null) r.id = window.dhx4.newId();
			while (this.w[r.id] != null) r.id = window.dhx4.newId();
		}
		
		if (r.left == null) r.left = 0;
		if (r.top == null) r.top = 0;
		
		r.move = (r.move != null && window.dhx4.s2b(r.move) == false ? false : (r.deny_move != null && window.dhx4.s2b(r.deny_move) == true ? false : true));
		r.park = (r.park != null && window.dhx4.s2b(r.park) == false ? false : (r.deny_park != null && window.dhx4.s2b(r.deny_park) == true ? false : true));
		r.resize = (r.resize != null && window.dhx4.s2b(r.resize) == false ? false : (r.deny_resize != null && window.dhx4.s2b(r.deny_resize) == true ? false : true));
		r.keep_in_viewport = (r.keep_in_viewport != null && window.dhx4.s2b(r.keep_in_viewport));
		r.modal = (r.modal != null && window.dhx4.s2b(r.modal));
		r.center = (r.center != null && window.dhx4.s2b(r.center));
		r.text = (r.text != null ? r.text:(r.caption!=null?r.caption:"dhtmlxWindow"));
		r.header = (!(r.header != null && window.dhx4.s2b(r.header) == false));
		
		var t = document.createElement("DIV");
		t.className = "dhxwin_active";
		this.vp.appendChild(t);
		
		t._isWindow = true;
		t._idd = r.id;
		
		var h = document.createElement("DIV");
		h.className = "dhxwin_hdr";
		h.style.zIndex = 0;
		h.innerHTML = "<div class='dhxwin_icon'></div>"+
				"<div class='dhxwin_text'><div class='dhxwin_text_inside'>"+r.text+"</div></div>"+
				"<div class='dhxwin_btns'></div>";
		t.appendChild(h);
		
		h.onselectstart = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
		
		h.oncontextmenu = function(e) {
			e = e||event;
			e.cancelBubble = true;
			return false;
		}
		
		h._isWinHdr = true;
		h.firstChild._isWinIcon = true;
		
		var k = document.createElement("DIV");
		k.className = "dhxwin_brd";
		t.appendChild(k);
		
		var fr_cover = document.createElement("DIV");
		fr_cover.className = "dhxwin_fr_cover";
		fr_cover.innerHTML = "<iframe class='dhxwin_fr_cover_inner' frameborder='0' border='0'></iframe><div class='dhxwin_fr_cover_inner'></div>";
		t.appendChild(fr_cover);
		
		this.w[r.id] = {
			win: t,
			hdr: h,
			brd: k,
			fr_cover: fr_cover,
			b: {},
			conf: {
				z_id: window.dhx4.newId(),
				actv: false,
				modal: false,
				maxed: false,
				parked: false,
				sticked: false,
				visible: true,
				header: true,
				text: r.text,
				keep_in_vp: r.keep_in_viewport,
				allow_move: r.move,
				allow_park: r.park,
				allow_resize: r.resize,
				max_w: null,
				max_h: null,
				min_w: 80,
				min_h: 80
			}
		};
		
		// buttons, id=>visible
		var btns = {
			help: {title: "Help", visible: false},
			stick: {title: "Stick", visible: false},
			park: {title: "Park", visible: true},
			minmax: {title: "Min/Max", visible: true},
			close: {title: "Close", visible: true}
		};
		for (var a in btns) {
			var b = new dhtmlXWindowsButton(this, r.id, a, btns[a].title, false);
			if (btns[a].visible == false) b.hide();
			h.lastChild.appendChild(b.button);
			this.w[r.id].b[a] = b;
			b = null;
		}
		this._winAdjustTitle(r.id);
		
		this.w[r.id].win.style.zIndex = window.dhx4.zim.reserve(this.w[r.id].conf.z_id);
		
		var cell = new dhtmlXWindowsCell(r.id, this);
		this.w[r.id].win.insertBefore(cell.cell, fr_cover);
		this.w[r.id].cell = cell;
		
		if (typeof(window.addEventListener) == "function") {
			this.w[r.id].win.addEventListener("mousedown", this._winOnMouseDown, false);
			this.w[r.id].win.addEventListener("mouseup", this._winOnMouseDown, false);
			if (this.conf.dblclick_ev) this.w[r.id].win.addEventListener("dblclick", this._winOnMouseDown, false);
			// touch
			if (this.conf.dnd_enabled == true && window.dhx4.dnd.evs.start != null) {
				this.w[r.id].win.addEventListener(window.dhx4.dnd.evs.start, this._winOnMouseDown, false);
				if (window.dhx4.dnd.p_en != true) {
					this.w[r.id].win.addEventListener(window.dhx4.dnd.evs.start, this._winOnMouseDown, false);
					this.w[r.id].win.addEventListener(window.dhx4.dnd.evs.end, this._winOnMouseDown, false);
				}
			}
		} else {
			this.w[r.id].win.attachEvent("onmousedown", this._winOnMouseDown);
			this.w[r.id].win.attachEvent("onmouseup", this._winOnMouseDown);
			if (this.conf.dblclick_ev) this.w[r.id].win.attachEvent("ondblclick", this._winOnMouseDown);
		}
		
		// fr for IE6
		this._winInitFRM(r.id);
		
		this._winSetPosition(r.id, r.left, r.top);
		this._winSetSize(r.id, r.width, r.height);
		this._winMakeActive(r.id);
		
		if (r.center == true) this.w[r.id].cell.center();
		if (r.modal == true) this.w[r.id].cell.setModal(true);
		if (r.header == false) this.w[r.id].cell.hideHeader();
		
		f = t = h = k = fr_cover = cell = null;
		
		return this.w[r.id].cell;
	}
	
	this._winOnMouseDown = function(e) {
		
		e = e||event;
		
		var t = e.target||e.srcElement;
		var data = {press_type: e.type};
		
		if (e.type == "MSPointerDown" || e.type == "pointerdown") {
			return;
		} else if (that.conf.ev_skip == true) {
			that.conf.ev_skip = false;
			t = null;
			return;
		}
		
		
		while (t != null && t._isWindow != true) {
			if (typeof(t.className) != "undefined" && data.mode == null) {
				if (typeof(t._buttonName) != "undefined") {
					data.mode = "button";
					data.button_name = t._buttonName;
				} else if (t._isWinHdr == true) {
					data.mode = "hdr";
				} else if (t._isWinIcon == true) {
					data.mode = "icon";
				}
			}
			t = t.parentNode;
		}
		if (data.mode == null) data.mode = "win";
		
		data.id = (t != null && t._isWindow == true ? t._idd:null);
		
		t = null;
		
		if (data.id != null && that.w[data.id] != null) that.callEvent("_winMouseDown",[e,data]); // window can be attached to anther window and unexisting ID can be here
	}
	
	this._winOnParkTrans = function(e) {
		if (e.stopPropagation) e.stopPropagation();
		var w = that.w[this._idd];
		if (e.propertyName == "opacity") {
			that._winCellClearOpacity(this._idd);
		}
		if (e.propertyName == "height" && w.conf.tr_mode == "park") {
			if (w.conf.tr_mode == "park") {
				w.win.style[that.conf.tr.prop] = "";
				if (!w.conf.parked) {
					that._winAdjustCell(this._idd);
					that._callMainEvent("onParkDown", this._idd);
					if (w.conf.keep_in_vp) that._winAdjustPosition(this._idd, w.conf.x, w.conf.y);
				} else {
					w.hdr.style.zIndex = 3;
					that._callMainEvent("onParkUp", this._idd);
				}
			}
			
		}
		w = null;
	}
	
	this.unload = function() {
		
		this.conf.unloading = true;
		
		// dnd
		if (this._dndInitModule) this._dndUnloadModule();
		
		// windows
		for (var a in this.w) this._winClose(a);
		this.w = null;
		
		// context menu
		if (this.cm != null && typeof(this._unloadContextMenu) == "function") this._unloadContextMenu();
		
		// events
		window.dhx4._eventable(this, "clear");
		
		// viewport
		this.attachViewportTo(null);
		
		// conf
		for (var a in this.conf) {
			this.conf[a] = null;
			delete this.conf[a];
		}
		
		for (var a in this) this[a] = null;
		
		that = a = null;
		
	}
	
	window.dhx4._eventable(this);
	
	this.attachEvent("_winMouseDown", this._winMouseDownHandler);
	
	if (this._dndInitModule) this._dndInitModule();
	
	if (conf.wins != null) {
		for (var q=0; q<conf.wins.length; q++) {
			var r = conf.wins[q];
			this.createWindow(r);
		}
	}
	conf = null;
	
	
	return this;
};

// common
dhtmlXWindows.prototype.forEachWindow = function(func) {
	for (var a in this.w) {
		func.apply(window, [this.w[a].cell]);
	}
};
dhtmlXWindows.prototype.window = function(id) {
	if (this.w[id] != null) return this.w[id].cell;
	return null;
};
dhtmlXWindows.prototype.isWindow = function(id) {
	return (this.w[id] != null);
};
dhtmlXWindows.prototype.findByText = function(text) {
	var p = [];
	for (var a in this.w) {
		if ((this.w[a].cell.getText()).indexOf(String(text)) >= 0) p.push(this.w[a]);
	}
	return p;
};
dhtmlXWindows.prototype.setSkin = function(skin) {
	if (skin == this.conf.skin) return;
	if (this.vp != null) {
		this.vp.className = String(this.vp.className).replace("dhxwins_vp_"+this.conf.skin," dhxwins_vp_"+skin);
	}
	for (var a in this.w) {
		this.w[a].cell._resetSizeState();
		this._winAdjustCell(a);
		this._winAdjustTitle(a);
	}
	this.conf.skin = skin;
};


// z-index
dhtmlXWindows.prototype.getBottommostWindow = function() {
	return this._getTopBottomWin(false);
};
dhtmlXWindows.prototype.getTopmostWindow = function() {
	return this._getTopBottomWin(true);
};
dhtmlXWindows.prototype._getTopBottomWin = function(mode) {
	var data = null;
	for (var a in this.w) {
		if (this.w[a].conf.visible) {
			var k = false;
			if (data != null) {
				k = data.z > this.w[a].win.style.zIndex;
				if (mode) k = !k;
			}
			if (data == null || k) data = {win: this.w[a].cell, z: this.w[a].win.style.zIndex};
		}
	}
	return (data?data.win:null);
};
dhtmlXWindows.prototype._winMakeActive = function(id, force) {
	
	// if id is null activate last z-index window
	
	if (id != null && force !== true && this.w[id].conf.actv == true) return;
	
	var all = [];
	
	var inList = {};
	
	for (var q=0; q<this._zOrder.length; q++) {
		
		var propName = this._zOrder[q].name;
		var propValue = this._zOrder[q].value;
		
		var st = [];
		
		// windows matched to prop but not with specified id
		for (var a in this.w) {
			var w = this.w[a];
			if (inList[a] == null && w.conf[propName] === propValue && w.conf.visible == true) {
				if (id != a) {
					window.dhx4.zim.clear(w.conf.z_id);
					st.push([a, Number(w.win.style.zIndex)]);
					inList[a] = true;
				}
			}
			w = null;
		}
		st.sort(function(a,b){
			return (a[1]<b[1]?1:-1);
		});
		
		// check windows which is specified to be active
		if (id != null && this.w[id].conf[propName] === propValue && inList[id] == null) {
			// clear zim
			window.dhx4.zim.clear(this.w[id].conf.z_id);
			var k = [[id, Number(this.w[id].win.style.zIndex)]];
			st = k.concat(st);
			inList[id] = true;
		}
		
		all = all.concat(st);
	}
	
	// change windows' z-index
	for (var q=all.length-1; q>=0; q--) {
		
		var a = all[q][0];
		var w = this.w[a];
		
		w.win.style.zIndex = window.dhx4.zim.reserve(w.conf.z_id);
		
		// adjust modal cover z-index
		if (w.conf.modal && this.mcover != null) {
			for (var b in this.mcover) this.mcover[b].style.zIndex = w.win.style.zIndex;
		}
		
		// ajust fr_cover if any
		this._winAdjustFRMZIndex(a);
		
		// if id not specified, make last z-index active, can be triggered from _winHide
		if (id == null && q == 0) id = a;
		
		w.conf.actv = (id==a);
		w.win.className = (w.conf.actv?"dhxwin_active":"dhxwin_inactive");
		
		w = null;
	}
	
	if (id != null && this.conf.last_active != id) this._callMainEvent("onFocus", id);
	
	this.conf.last_active = id;
	
};

// z-index order, from top to bottom,
// first modal, then sticked if any, then regular
dhtmlXWindows.prototype._zOrder = [
	{name: "modal",   value: true},
	{name: "sticked", value: true},
	{name: "sticked", value: false}
];

// viewports
dhtmlXWindows.prototype._vpPull = {};
dhtmlXWindows.prototype._vpOf = {};

dhtmlXWindows.prototype._vpPullAdd = function() {
	if (this.vp == null) return;
	var id = null;
	for (var a in this._vpPull) {
		if (this._vpPull[a].vp == this.vp) {
			this._vpPull[a].count++;
			id = a;
		}
	}
	if (id == null) {
		this._vpPull[window.dhx4.newId()] = {vp: this.vp, count: 1};
	}
	if (this.vp == document.body && this.conf.vp_of_auto == true) {
		// if window inited on behalf on layout, clear overflow from body to enable scroll)
		this._vpOfInit();
	}
	this._vpOfUpd();
};

dhtmlXWindows.prototype._vpPullRemove = function() {
	if (this.vp == null) return 0;
	var count = 0;
	for (var a in this._vpPull) {
		if (this._vpPull[a].vp == this.vp) {
			count = --this._vpPull[a].count;
			if (count == 0) {
				this._vpPull[a].vp = null;
				this._vpPull[a].count = null;
				delete this._vpPull[a];
			}
		}
	}
	this._vpOfClear();
	return count;
};

dhtmlXWindows.prototype._vpOfInit = function() {
	this._vpOf[this.conf.vp_of_id] = true;
};
dhtmlXWindows.prototype._vpOfClear = function() {
	this._vpOf[this.conf.vp_of_id] = false;
	delete this._vpOf[this.conf.vp_of_id];
	this._vpOfUpd();
};

dhtmlXWindows.prototype._vpOfUpd = function() {
	var auto = false;
	for (var a in this._vpOf) auto = auto||this._vpOf[a];
	if (auto == true) {
		if (document.body.className.match(/dhxwins_vp_auto/) == null) {
			document.body.className += " dhxwins_vp_auto";
		}
	} else {
		if (document.body.className.match(/dhxwins_vp_auto/) != null) {
			document.body.className = String(document.body.className).replace(/\s{0,}dhxwins_vp_auto/gi, "");
		}
	}
};

dhtmlXWindows.prototype.attachViewportTo = function(id) {
	
	// old one
	var vpCount = this._vpPullRemove();
	
	if (this.conf.vp_custom) {
		while (this.vp.childNodes.length > 0) this.vp.removeChild(this.vp.lastChild);
		this.vp.parentNode.removeChild(this.vp);
		this.vp = null;
	} else if (this.vp != null && vpCount == 0) {
		this.vp.className = String(this.vp.className).replace(new RegExp("\\s{1,}dhxwins_vp_"+this.conf.skin),""); // no more window instances attached to same object, clear css
	}
	
	// new if set
	if (id == null) {
		
		this.vp = null; // clear link
		
	} else {
		
		this.vp = (typeof(id)=="string"?document.getElementById(id):id);
		var skin = "dhxwins_vp_"+this.conf.skin;
		if (this.vp.className.indexOf(skin) < 0) this.vp.className += " "+skin;
		id = null;
		
		// windows
		for (var a in this.w) this.vp.appendChild(this.w[a].win);
		
		this.conf.vp_custom = false;
		
	}
	
	if (this.vp == document.body) {
		document.body.style.position = "static"; // abs-left/top broken for relative/absolute
	}
	
	this._vpPullAdd();
	
};

dhtmlXWindows.prototype.setViewport = function(x, y, width, height, parentObj) {
	
	var t = document.createElement("DIV");
	
	t.style.position = "absolute";
	t.style.left = x+"px";
	t.style.top = y+"px";
	t.style.width = width+"px";
	t.style.height = height+"px";
	
	if (typeof(parentObj) == "undefined" || parentObj == null) {
		parentObj = document.body;
	} else if (typeof(parentObj) == "string") {
		parentObj = document.getElementById(parentObj);
	}
	parentObj.appendChild(t);
	
	this.attachViewportTo(t);
	this.conf.vp_custom = true;
	
	parentObj = t = null;
	
};

// position
dhtmlXWindows.prototype._winSetPosition = function(id, x, y) {
	
	var w = this.w[id];
	
	if (w.conf.maxed) {
		// probably window have max_w/max_h set and dragable
		// adjust saved w/h
		w.conf.lastMX += (x-w.conf.x);
		w.conf.lastMY += (y-w.conf.y);
	}
	
	w.conf.x = x;
	w.conf.y = y;
	
	w.win.style.left = w.conf.x+"px";
	w.win.style.top = w.conf.y+"px";
	
	this._winAdjustFRMPosition(id);
	
	w = null;
};
dhtmlXWindows.prototype._winAdjustPosition = function(id, x, y) { // check if window out of viewport
	
	var w = this.w[id];
	
	// if called from cell's adjustPosition, just make sure window position is okey
	if (typeof(x) == "undefined") x = w.conf.x;
	if (typeof(y) == "undefined") y = w.conf.y;
	
	var minX = (w.conf.keep_in_vp?0:-w.conf.w+this.conf.vp_pos_ofs);
	var maxX = (w.conf.keep_in_vp?this.vp.clientWidth-w.conf.w:this.vp.clientWidth-this.conf.vp_pos_ofs);
	
	if (x < minX) {
		x = minX;
	} else if (x > maxX) {
		x = maxX;
	}
	
	var maxY = (w.conf.keep_in_vp?this.vp.clientHeight-w.conf.h:this.vp.clientHeight-this.conf.vp_pos_ofs);
	
	if (y < 0) {
		y = 0;
	} else if (y > maxY) {
		y = maxY;
	}
	
	if (x != w.conf.x || y != w.conf.y) {
		this._winSetPosition(id, x, y);
	}
	
	w = null;
};

// dimension
dhtmlXWindows.prototype._winSetSize = function(id, width, height, skipAdjust, fixPos) {
	
	var w = this.w[id];
	
	var w2 = (width != null ? width : w.conf.w);
	var h2 = (height != null ? height : w.conf.h);
	
	if (this.conf.ofs_w == null) {
		w.win.style.width = w2+"px";
		w.win.style.height = h2+"px";
		this.conf.ofs_w = w.win.offsetWidth-w2;
		this.conf.ofs_h = w.win.offsetHeight-h2;
	}
	
	if (w.conf.min_w != null && w2 < w.conf.min_w) w2 = w.conf.min_w;
	if (w.conf.max_w != null && w2 > w.conf.max_w) w2 = w.conf.max_w;
	
	if (!w.conf.parked && w.conf.min_h != null && h2 < w.conf.min_h) h2 = w.conf.min_h;
	if (w.conf.max_h != null && h2 > w.conf.max_h) h2 = w.conf.max_h;
	
	if (w.conf.keep_in_vp) {
		if (w2 > this.vp.clientWidth) w2 = this.vp.clientWidth;
		if (h2 > this.vp.clientHeight) h2 = this.vp.clientHeight;
	}
	
	w.win.style.width = w2-this.conf.ofs_w+"px";
	w.win.style.height = h2-this.conf.ofs_h+"px";
	
	w.conf.w = w2;
	w.conf.h = h2;
	
	this._winAdjustFRMSize(id);
	
	if (fixPos) this._winAdjustPosition(id, w.conf.x, w.conf.y);
	
	// adjust content
	if (!w.conf.parked && skipAdjust != true) this._winAdjustCell(id);
	
	w = null;
};

// minmax
dhtmlXWindows.prototype._winMinmax = function(id, mode) {
		
	if (typeof(mode) != "undefined" && this.w[id].conf.maxed == mode) return; // already requested state
	if (this.w[id].conf.allow_resize == false) return;
	
	var w = this.w[id];
	
	if (w.conf.parked) this._winPark(id, false);
	
	if (w.conf.maxed) {
		
		this._winSetSize(id, w.conf.lastMW, w.conf.lastMH);
		this._winAdjustPosition(id, w.conf.lastMX, w.conf.lastMY);
		w.conf.maxed = false;
		
	} else {
		
		var x = 0;
		var y = 0;
		
		// adjust position, if any max w/h values - do not allow win to be moved outside vp
		if (w.conf.max_w != null) x = w.conf.x + Math.round(w.conf.w-w.conf.max_w)/2;
		if (w.conf.max_h != null) y = Math.max(w.conf.y + Math.round(w.conf.h-w.conf.max_h)/2, 0);
		
		// save old coords and dim
		w.conf.lastMX = w.conf.x;
		w.conf.lastMY = w.conf.y;
		w.conf.lastMW = w.conf.w;
		w.conf.lastMH = w.conf.h;
		
		this._winSetSize(id, this.vp.clientWidth, this.vp.clientHeight);
		this._winAdjustPosition(id, x, y);
		
		
		w.conf.maxed = true;
		
	}
	
	w.b.minmax.setCss(w.conf.maxed?"minmaxed":"minmax");
	
	if (w.conf.maxed) {
		this._callMainEvent("onMaximize", id);
	} else {
		this._callMainEvent("onMinimize", id);
	}
	this._callMainEvent("onResizeFinish", id);	
	w = null;
};

// show/hide
dhtmlXWindows.prototype._winShow = function(id, makeActive) {
	
	if (this.w[id].conf.visible == true) return;
	
	this.w[id].win.style.display = "";
	this.w[id].conf.visible = true;
	
	// makeActive set to true or only this window is visible
	if (makeActive == true || this.conf.last_active == null) this._winMakeActive(id, true);
	
	this._callMainEvent("onShow", id);
};
dhtmlXWindows.prototype._winHide = function(id, actvId) {
	
	if (this.w[id].conf.visible == false) return;
	
	this.w[id].win.style.display = "none";
	this.w[id].conf.visible = false;
	
	if (this.w[id].conf.actv) {
		this.w[id].conf.actv = false;
		this.w[id].win.className = "dhxwin_inactive";
		this._winMakeActive(null, true);
	}
	
	this._callMainEvent("onHide", id);
};

// park
dhtmlXWindows.prototype._winPark = function(id, ef) {
		
	if (this.w[id].conf.allow_park == false) return;
	if (this.w[id].conf.header == false) return;
	
	var w = this.w[id];
	
	if (ef == true && this.conf.tr.prop !== false) {
		w.win.style[this.conf.tr.prop] = this.conf.tr[w.conf.parked?"height_open":"height_close"];
		if (!w.conf.tr_ev) {
			w.win.addEventListener(this.conf.tr.ev, this._winOnParkTrans, false);
			w.conf.tr_ev = true;
		}
	}
	
	if (w.conf.parked) {
		// restore
		w.hdr.className = String(w.hdr.className).replace(/\s{1,}dhxwin_hdr_parked/gi,"");
		w.hdr.style.zIndex = 0;
		w.conf.parked = false;
		w.conf.tr_mode = "park";
		this._winCellSetOpacity(id, "open", ef);
		this._winSetSize(id, w.conf.w, w.conf.lastPH, (ef==true && this.conf.tr.prop!==false)); // adjust cont if trans not available
		if (!(ef == true && this.conf.tr.prop !== false)) {
			this._callMainEvent("onParkDown", id);
			if (w.conf.keep_in_vp) this._winAdjustPosition(id, w.conf.x, w.conf.y);
		}
		// IE8 bottom-border fix
		if (window.dhx4.isIE8 == true && this.conf.tr.prop == false && w.cell.cell.className.match(/dhxwin_parked/) != null) {
			w.cell.cell.className = w.cell.cell.className.replace(/\s{0,}dhxwin_parked/gi,"");
		}
	} else {
		// park
		w.conf.lastPH = w.conf.h;
		w.hdr.className += " dhxwin_hdr_parked";
		if (ef == false || this.conf.tr.prop == false) w.hdr.style.zIndex = 3; // no-trans
		w.conf.parked = true;
		w.conf.tr_mode = "park";
		this._winCellSetOpacity(id, "close", ef);
		this._winSetSize(id, w.conf.w, w.hdr.offsetHeight+this.conf.ofs_h, (ef==true && this.conf.tr.prop!==false)); // adjust cont if trans not available
		if (!(ef == true && this.conf.tr.prop !== false)) this._callMainEvent("onParkUp", id);
		// IE8 bottom-border fix
		if (window.dhx4.isIE8 == true && this.conf.tr.prop == false && w.cell.cell.className.match(/dhxwin_parked/) == null) {
			w.cell.cell.className += " dhxwin_parked";
		}
	}
	
	w = null;
	
};
dhtmlXWindows.prototype._winCellSetOpacity = function(id, op, ef, mode) {
	var cell = this.w[id].cell;
	for (var a in cell.conf.idx) {
		if ({pr1:true,pr2:true}[a] != true) { // skip progress
			if (ef == true && this.conf.tr.prop != false) cell.cell.childNodes[cell.conf.idx[a]].style[this.conf.tr.prop] = this.conf.tr["op_"+op];
			cell.cell.childNodes[cell.conf.idx[a]].style.opacity = this.conf.tr["op_v_"+op];
		}
	}
	cell = null;
};
dhtmlXWindows.prototype._winCellClearOpacity = function(id) {
	var cell = this.w[id].cell;
	for (var a in cell.conf.idx) {
		if ({pr1:true,pr2:true}[a] != true) { // skip progress
			if (this.conf.tr.prop != false) cell.cell.childNodes[cell.conf.idx[a]].style[this.conf.tr.prop] = "";
		}
	}
	cell = null;
};

// stick
dhtmlXWindows.prototype._winStick = function(id, mode) {
	
	if (typeof(mode) != "undefined" && this.w[id].conf.sticked == mode) return; // already requested state
	
	this.w[id].conf.sticked = !this.w[id].conf.sticked;
	this.w[id].b.stick.setCss(this.w[id].conf.sticked?"sticked":"stick");
	
	this._winMakeActive(this.conf.last_active, true);
	if (this.w[id].conf.sticked) {
		this._callMainEvent("onStick", id);
	} else {
		this._callMainEvent("onUnStick", id);
	}
};

// close
dhtmlXWindows.prototype._winClose = function(id) {
	
	if (this._callMainEvent("onClose", id) !== true && this.conf.unloading != true) return;
	var w = this.w[id];
	
	if (w.conf.fs_mode) w.cell.setToFullScreen(false);
	if (w.conf.modal) this._winSetModal(id, false);
	
	// z-index clear
	window.dhx4.zim.clear(w.conf.z_id);
	
	// context menu
	if (this.cm != null && this.cm.icon[id] != null) {
		this._detachContextMenu("icon", id, null);
	}
	
	// header click/dblclick events
	if (typeof(window.addEventListener) == "function") {
		w.win.removeEventListener("mousedown", this._winOnMouseDown, false);
		w.win.removeEventListener("mouseup", this._winOnMouseDown, false);
		if (this.conf.dblclick_ev) w.win.removeEventListener("dblclick", this._winOnMouseDown, false);
		// touch
		if (this.conf.dnd_enabled == true && window.dhx4.dnd.evs.start != null) {
			w.win.removeEventListener(window.dhx4.dnd.evs.start, this._winOnMouseDown, false)
			if (window.dhx4.dnd.p_en != true) {
				w.win.removeEventListener(window.dhx4.dnd.evs.start, this._winOnMouseDown, false);
				w.win.removeEventListener(window.dhx4.dnd.evs.end, this._winOnMouseDown, false);
			}
		}
	} else {
		w.win.detachEvent("onmousedown", this._winOnMouseDown);
		w.win.detachEvent("onmouseup", this._winOnMouseDown);
		if (this.conf.dblclick_ev) w.win.attachEvent("ondblclick", this._winOnMouseDown);
	}
	
	// buttons
	for (var a in w.b) this._winRemoveButton(id, a, true);
	w.b = null;
	
	// cell
	w.cell._unload();
	w.cell = null;
	
	// border
	w.brd.parentNode.removeChild(w.brd);
	w.brd = null;
	
	// covers
	if (w.fr_cover != null) {
		w.fr_cover.parentNode.removeChild(w.fr_cover);
		w.fr_cover = null;
	}
	if (w.fr_m_cover != null) {
		w.fr_m_cover.parentNode.removeChild(w.fr_m_cover);
		w.fr_m_cover = null;
	}
	
	// hdr
	w.hdr._isWinHdr = true;
	w.hdr.firstChild._isWinIcon = true;
	w.hdr.onselectstart = null;
	w.hdr.parentNode.removeChild(w.hdr);
	w.hdr = null;
	
	// conf
	for (var a in w.conf) {
		w.conf[a] = null;
		delete w.conf[a];
	}
	w.conf = null;
	
	// win
	w.win._idd = null;
	w.win._isWindow = null;
	w.win.parentNode.removeChild(w.win);
	w.win = null;
	
	w = null;
	this.w[id] = null;
	delete this.w[id];
	
	// activate topmost window
	if (!this.conf.unloading) this._winMakeActive(null, true);
	
};

// modal
dhtmlXWindows.prototype._winSetModal = function(id, modal, removeCover) {
	
	if (this.w[id].conf.modal == modal) return; // already have specified modal state
	
	if (typeof(removeCover) == "undefined") removeCover = true;
	
	var w = this.w[id];
	
	if (modal == true && w.conf.modal == false) {
		
		// remove modality from prev window
		if (this.conf.last_modal != null) {
			this._winSetModal(this.conf.last_modal, false, false);
		}
		
		if (this.mcover == null) {
			
			// create a new one
			var d = document.createElement("DIV");
			d.className = "dhxwins_mcover";
			this.vp.insertBefore(d, w.fr_m_cover||w.win);
			this.mcover = {d:d};
			
			if (this.conf.fr_cover) {
				this.mcover.f = document.createElement("IFRAME");
				this.mcover.f.className = "dhxwins_mcover";
				this.mcover.f.border = 0;
				this.mcover.f.frameBorder = 0;
				this.vp.insertBefore(this.mcover.f,d);
			}
			
			d = null;
			
		} else if (this.mcover.d.nextSibling != (w.fr_m_cover||w.win)) {
			// move cover to place it before modal window
			this.vp.insertBefore(this.mcover.d, w.fr_m_cover||w.win);
			if (this.mcover.f != null) this.vp.insertBefore(this.mcover.f, this.mcover.d);
		}
		
		w.conf.modal = true;
		this.conf.last_modal = id;
		
		this._winMakeActive(id, true);
		
	} else if (modal == false && w.conf.modal == true) {
		
		// remove modality, clear cover
		
		w.conf.modal = false;
		this.conf.last_modal = null;
		
		if (removeCover && this.mcover != null) {
			for (var a in this.mcover) {
				
				this.vp.removeChild(this.mcover[a]);
				this.mcover[a] = null;
			}
			this.mcover = null;
		}
		
	}
	
	w = null;
};

// misc
dhtmlXWindows.prototype._winMouseDownHandler = function(e, data) {
	
	var t = e.target||e.srcElement;
	
	if (e.button >= 2) return;
	
	if (data.mode == "button") {
		if (data.press_type == "mousedown") {
			this.conf.button_last = data.button_name;
		} else if ((data.press_type == "mouseup" && data.button_name == this.conf.button_last) || data.press_type == "MSPointerDown" || data.press_type == "pointerdown") {
			this.conf.button_last = null;
			if (this._winButtonClick(data.id, data.button_name, e) !== true) return;
		}
	}
	//var inEdge = (data.press_type == "pointerdown" && window.dhx4.dnd._mTouch(e) == true);
	if ((data.press_type == "pointerdown" || data.press_type == "mousedown" || data.press_type == "dblclick") && data.mode == "hdr") {
		
		// dblclick
		this.conf.dblclick_active = false;
		if (this.conf.dblclick_ev == true) {
			// IE6, IE7, IE8 native dblclick event
			if (data.press_type == "dblclick") this.conf.dblclick_active = true;
		} else {
			
			if (this.conf.dblclick_last == null) {
				this.conf.dblclick_last = new Date().getTime();
				this.dblclick_id = data.id;
			} else {
				var t = new Date().getTime();
				if (this.conf.dblclick_last + this.conf.dblclick_tm > t && this.dblclick_id == data.id) {
					this.conf.dblclick_active = true;
					this.conf.dblclick_last = null;
					this.dblclick_id = null;
				} else {
					this.conf.dblclick_last = t;
					this.dblclick_id = data.id;
				}
			}
		}
		if (this.conf.dblclick_active) {
			this._winDoHeaderDblClick(data.id);
			return;
		}
	}
	
	// for all modes
	if (data.press_type == "mousedown" || (data.press_type == window.dhx4.dnd.evs.start)) {
		this._winMakeActive(data.id);
	}
	if (data.press_type == "touchend") {
		// if (e.preventDefault) e.preventDefault();
	}
	
};

dhtmlXWindows.prototype._winDoHeaderDblClick = function(id) {
	if (this.conf.dblclick_mode == "minmax") {
		this._winMinmax(id);
		return;
	}
	if (this.conf.dblclick_mode == "park") {
		this._winPark(id, true);
		return;
	}
	// use action if any
	if (typeof(this.conf.dblclick_mode) == "function") {
		this.conf.dblclick_mode.apply(window, [id]);
		return;
	}
	if (typeof(window[this.conf.dblclick_mode]) == "function") {
		window[this.conf.dblclick_mode].apply(window, [id]);
		return;
	}
};
dhtmlXWindows.prototype._winAdjustCell = function(id) {
	
	var w = this.w[id];
	
	if (this.conf.skin == "material") {
		var x = 0;
		var y = (w.conf.header?w.hdr.offsetHeight:1);
		var width = w.win.clientWidth;
		var height = w.win.clientHeight-y;
	} else {
		var x = 1;
		var y = (w.conf.header?w.hdr.offsetHeight:1);
		var width = w.win.clientWidth-2;
		var height = w.win.clientHeight-y-1;
	}
	
	w.brd.style.left = x+"px";
	w.brd.style.top = y+"px";
	if (w.conf.brd == null) {
		w.brd.style.width = width+"px";
		w.brd.style.height = height+"px";
		w.conf.brd = {
			w: width-w.brd.offsetWidth,
			h: height-w.brd.offsetHeight
		};
	}
	w.brd.style.width = width+w.conf.brd.w+"px";
	w.brd.style.height = height+w.conf.brd.h+"px";
	
	var p = 5; // cell_cont position
	if (this.conf.skin == "material") p = 1;
	
	var x2 = 1+p;
	var y2 = (w.conf.header?y:y+p);
	var w2 = w.brd.clientWidth;
	var h2 = w.brd.clientHeight;
	
	w.cell._setSize(x2, y2, w2, h2);
	
	w.fr_cover.style.left = x2+"px";
	w.fr_cover.style.top = y2+"px";
	w.fr_cover.style.width = w2+"px";
	w.fr_cover.style.height = h2+"px";
	
	w = null;
};
dhtmlXWindows.prototype._winAdjustTitle = function(id) {
	var icon = this.w[id].hdr.childNodes[0];
	var text = this.w[id].hdr.childNodes[1];
	var btns = this.w[id].hdr.childNodes[2];
	var x = (this.conf.skin=="material"?7:0);
	text.style.paddingLeft = icon.offsetWidth+12+x+"px";
	text.style.paddingRight = btns.offsetWidth+10+x+"px";
	text = btns = icon = null;
};
dhtmlXWindows.prototype._callMainEvent = function(name, id) {
	var w = this.w[id];
	if (w.cell.checkEvent(name)) {
		var r = w.cell._callMainEvent(name, [w.cell]);
	} else {
		var r = this.callEvent(name, [w.cell]);
	}
	w = null;
	return r;
};

// fr_m_cover
dhtmlXWindows.prototype._winInitFRM = function(id) {
	if (this.conf.fr_cover != true) return;
	var w = this.w[id];
	var f = document.createElement("IFRAME");
	f.className = "dhxwin_main_fr_cover";
	f.border = 0;
	f.frameBorder = 0;
	f.style.zIndex = w.win.style.zIndex;
	w.win.parentNode.insertBefore(f, w.win);
	w.fr_m_cover = f;
	f = null;
};
dhtmlXWindows.prototype._winAdjustFRMSize = function(id) {
	var w = this.w[id];
	if (w.fr_m_cover != null) {
		w.fr_m_cover.style.width = w.conf.w+"px";
		w.fr_m_cover.style.height = w.conf.h+"px";
	}
	w = null;
};
dhtmlXWindows.prototype._winAdjustFRMPosition = function(id) {
	var w = this.w[id];
	if (w.fr_m_cover != null) {
		w.fr_m_cover.style.left = w.win.style.left;
		w.fr_m_cover.style.top = w.win.style.top;
	}
	w = null;
};
dhtmlXWindows.prototype._winAdjustFRMZIndex = function(id) {
	var w = this.w[id];
	if (w.fr_m_cover != null) {
		w.fr_m_cover.style.zIndex = w.win.style.zIndex;
	}
	w = null;
};


function dhtmlXWindowsCell(id, wins) {
	
	dhtmlXCellObject.apply(this, [id, "_wins"]);
	
	this.wins = wins;
	
	this.cell._winId = id;
	this.conf.skin = this.wins.conf.skin;
	
	this.attachEvent("_onCellUnload", function(){
		
		if (this._unloadResize) {
			this._unloadResize();
		}
		
		window.dhx4._eventable(this.cell, "clear");
		
		this.cell._winId = null;
		this.wins = null;
		
		this.setText = null;
		this.getText = null;
		this.allowMove = null;
		this.denyMove = null;
		this.isMovable = null;
		this.allowResize = null;
		this.denyResize = null;
		this.isResizable = null;
		this.maximize = null;
		this.minimize = null;
		this.isMaximized = null;
		this.setPosition = null;
		this.getPosition = null;
		this.adjustPosition = null;
		this.park = null;
		this.isParked = null;
		this.allowPark = null;
		this.denyPark = null;
		this.isParkable = null;
		this.show = null;
		this.hide = null;
		this.isHidden = null;
		this.stick = null;
		this.unstick = null;
		this.isSticked = null;
		this.setDimension = null;
		this.getDimension = null;
		this.setMinDimension = null;
		this.getMinDimension = null;
		this.setMaxDimension = null;
		this.getMaxDimension = null;
		this.keepInViewport = null;
		this.center = null;
		this.centerOnScreen = null;
		this.bringToTop = null;
		this.bringToBottom = null;
		this.isOnTop = null;
		this.isOnBottom = null;
		this.showHeader = null;
		this.hideHeader = null;
		this.setModal = null;
		this.isModal = null;
		this.close = null;
		
		this._adjustByCont = null;
		
		this.button = null;
		this.addUserButton = null;
		this.removeUserButton = null;
		
		that = null;
	});
	
	this.attachEvent("_onContentLoaded", function() {
		this.wins._callMainEvent("onContentLoaded", this._idd);
	});
	this.attachEvent("_onContentMouseDown", function(id,e) {
		this.wins.callEvent("_winMouseDown",[e,{id:id,mode:"win"}]);
	});
	
	this._callMainEvent = function(name, args) {
		return this.callEvent(name, args);
	}
	
	// open/close, check trans-effects
	
	this.conf.tr = {};
	for (var a in this.wins.conf.tr) this.conf.tr[a] = this.wins.conf.tr[a];
	
	if (this.conf.tr.prop != false) {
		/* 
		this.attachEvent("_onIdxUpdated", function(){
			// if cell hidden - update opacity for menu/toolbar/status which attached to parked window
			if (this.wins.w[this._idd].conf.parked) {
				for (var a in this.conf.idx) {
					if ({hdr:true,pr1:true,pr2:true}[a] != true) { // skip hdr and progress
						this.wins._winCellSetOpacity(this._idd, "close", false);
					}
				}
			}
		});
		*/
	}
	
	
	if (this._initResize) this._initResize();
	
	// personal window events,
	// dhxWins.window(id).attachEvent()
	window.dhx4._eventable(this.cell);
	
	// adjustParentSize (for form)
	var that = this;
	this.cell.attachEvent("_setCellSize", function(w, h){
		var w0 = that.wins.w[this._winId].conf.w-that.conf.size.w;
		var h0 = that.wins.w[this._winId].conf.h-that.conf.size.h;
		that.setDimension(w+w0, h+h0);
	});
	
	return this;
	
};

dhtmlXWindowsCell.prototype = new dhtmlXCellObject();

// text
dhtmlXWindowsCell.prototype.setText = function(text) {
	this.wins.w[this._idd].conf.text = text;
	this.wins.w[this._idd].hdr.childNodes[1].firstChild.innerHTML = text;
};
dhtmlXWindowsCell.prototype.getText = function() {
	return this.wins.w[this._idd].conf.text;
};

// move/dnd
dhtmlXWindowsCell.prototype.allowMove = function() {
	this.wins.w[this._idd].conf.allow_move = true;
};
dhtmlXWindowsCell.prototype.denyMove = function() {
	this.wins.w[this._idd].conf.allow_move = false;
};
dhtmlXWindowsCell.prototype.isMovable = function() {
	return (this.wins.w[this._idd].conf.allow_move == true);
};

// resize
dhtmlXWindowsCell.prototype.allowResize = function() {
	this.wins.w[this._idd].conf.allow_resize = true;
	this.wins.w[this._idd].b.minmax.enable();
};
dhtmlXWindowsCell.prototype.denyResize = function() {
	this.wins.w[this._idd].conf.allow_resize = false;
	this.wins.w[this._idd].b.minmax.disable();
};
dhtmlXWindowsCell.prototype.isResizable = function() {
	return (this.wins.w[this._idd].conf.allow_resize == true);
};

// min/max
dhtmlXWindowsCell.prototype.maximize = function() {
	this.wins._winMinmax(this._idd, true);
};
dhtmlXWindowsCell.prototype.minimize = function() {
	this.wins._winMinmax(this._idd, false);
};
dhtmlXWindowsCell.prototype.isMaximized = function() {
	return (this.wins.w[this._idd].conf.maxed == true);
};

// position
dhtmlXWindowsCell.prototype.setPosition = function(x, y) {
	this.wins._winSetPosition(this._idd, x, y);
};
dhtmlXWindowsCell.prototype.getPosition = function() {
	var w = this.wins.w[this._idd];
	var p = [w.conf.x,w.conf.y];
	w = null;
	return p;
};
dhtmlXWindowsCell.prototype.adjustPosition = function() {
	this.wins._winAdjustPosition(this._idd);
};

// parking
dhtmlXWindowsCell.prototype.park = function() {
	this.wins._winPark(this._idd, true); // with effect
};
dhtmlXWindowsCell.prototype.isParked = function() {
	return (this.wins.w[this._idd].conf.parked == true);
};
dhtmlXWindowsCell.prototype.allowPark = function() {
	this.wins.w[this._idd].conf.allow_park = true;
	this.wins.w[this._idd].b.park.enable();
};
dhtmlXWindowsCell.prototype.denyPark = function() {
	this.wins.w[this._idd].conf.allow_park = false;
	this.wins.w[this._idd].b.park.disable();
};
dhtmlXWindowsCell.prototype.isParkable = function() {
	return (this.wins.w[this._idd].conf.allow_park == true);
};

// show/hide
dhtmlXWindowsCell.prototype.show = function(makeActive) {
	this.wins._winShow(this._idd, window.dhx4.s2b(makeActive));
};
dhtmlXWindowsCell.prototype.hide = function() {
	this.wins._winHide(this._idd);
};
dhtmlXWindowsCell.prototype.isHidden = function() {
	return (this.wins.w[this._idd].conf.visible != true);
};

// sticking
dhtmlXWindowsCell.prototype.stick = function() {
	this.wins._winStick(this._idd, true);
};
dhtmlXWindowsCell.prototype.unstick = function() {
	this.wins._winStick(this._idd, false);
};
dhtmlXWindowsCell.prototype.isSticked = function() {
	return (this.wins.w[this._idd].conf.sticked == true);
};

// dimension
dhtmlXWindowsCell.prototype.setDimension = function(width, height) {
	var w = this.wins.w[this._idd];
	if (w.conf.parked) this.wins._winPark(this._idd, false);
	if (w.conf.maxed) {
		if (width != null) w.conf.lastMW = width;
		if (height != null) w.conf.lastMH = height;
		this.wins._winMinmax(this._idd);
	} else {
		this.wins._winSetSize(this._idd, width, height, false, true);
	}
	w = null;
};
dhtmlXWindowsCell.prototype.getDimension = function() {
	var w = this.wins.w[this._idd];
	var d = [w.conf.w, w.conf.h];
	w = null;
	return d;
};
dhtmlXWindowsCell.prototype.setMinDimension = function(width, height) {
	var w = this.wins.w[this._idd];
	w.conf.min_w = width;
	w.conf.min_h = height;
	// parked and maxed will ajusted in _winSetSize
	this.wins._winSetSize(this._idd, w.conf.w, w.conf.h);
	w = null;
};
dhtmlXWindowsCell.prototype.getMinDimension = function() {
	var w = this.wins.w[this._idd];
	var d = [w.conf.min_w, w.conf.min_h];
	w = null;
	return d;
};
dhtmlXWindowsCell.prototype.setMaxDimension = function(width, height) {
	var w = this.wins.w[this._idd];
	w.conf.max_w = width;
	w.conf.max_h = height;
	// parked and maxed will ajusted in _winSetSize
	this.wins._winSetSize(this._idd, w.conf.w, w.conf.h);
	w = null;
};
dhtmlXWindowsCell.prototype.getMaxDimension = function() {
	var w = this.wins.w[this._idd];
	var d = [w.conf.max_w, w.conf.max_h];
	w = null;
	return d;
};

// viewport
dhtmlXWindowsCell.prototype.keepInViewport = function(mode) {
	this.wins.w[this._idd].conf.keep_in_vp = window.dhx4.s2b(mode);
};
dhtmlXWindowsCell.prototype.center = function() {
	
	var vp = this.wins.vp;
	var w = this.wins.w[this._idd];
	
	var x = Math.round((vp.clientWidth-w.conf.w)/2);
	var y = Math.round((vp.clientHeight-w.conf.h)/2);
	
	this.wins._winSetPosition(this._idd, x, y);
	vp = w = null;
};
dhtmlXWindowsCell.prototype.centerOnScreen = function() {
	
	var w = this.wins.w[this._idd];
	var dim = window.dhx4.screenDim();
	
	// viewport correction
	var vx = window.dhx4.absLeft(this.wins.vp);
	var vy = window.dhx4.absTop(this.wins.vp);
	var k = this.wins.vp.parentNode;
	while (k != null) {
		if (k.scrollLeft) vx = vx-k.scrollLeft;
		if (k.scrollTop) vy = vy-k.scrollTop;
		k = k.parentNode;
	}
	
	var x = Math.round((dim.right-dim.left-w.conf.w)/2);
	var y = Math.round((dim.bottom-dim.top-w.conf.h)/2);
	
	this.wins._winAdjustPosition(this._idd, x-vx, y-vy);
	d = w = null;
	
};

// z-index
dhtmlXWindowsCell.prototype.bringToTop = function() {
	this.wins._winMakeActive(this._idd, true);
};
dhtmlXWindowsCell.prototype.bringToBottom = function() {
	var actv = (this.wins.w[this._idd].conf.actv?null:this.wins.conf.last_active);
	window.dhx4.zim.clear(this.wins.w[this._idd].conf.z_id);
	this.wins.w[this._idd].win.style.zIndex = 0;
	this.wins._winMakeActive(actv, true);
};
dhtmlXWindowsCell.prototype.isOnTop = function() {
	return (this.wins.w[this._idd].conf.actv == true);
};
dhtmlXWindowsCell.prototype.isOnBottom = function() {
	var data = {id: null, z:+Infinity};
	for (var a in this.wins.w) {
		if (this.wins.w[a].conf.visible && this.wins.w[a].win.style.zIndex < data.z) {
			data.id = a;
			data.z = this.wins.w[a].win.style.zIndex;
		}
	}
	return (data.id==this._idd);
};

// header
dhtmlXWindowsCell.prototype.showHeader = function() {
	var w = this.wins.w[this._idd];
	if (w.conf.header == false) {
		w.hdr.className = String(w.hdr.className).replace(/\s{0,}dhxwin_hdr_hidden/gi,"");
		w.brd.className = String(w.brd.className).replace(/\s{0,}dhxwin_hdr_hidden/gi,"");
		this.conf.cells_cont = null; // reset saved borders
		w.conf.brd = null; // reset brd
		w.conf.header = true;
		this.wins._winAdjustCell(this._idd);
	}
	w = null;
};
dhtmlXWindowsCell.prototype.hideHeader = function() {
	var w = this.wins.w[this._idd];
	if (w.conf.header == true) {
		if (w.conf.parked) this.wins._winPark(this._idd, false);
		w.hdr.className += " dhxwin_hdr_hidden";
		w.brd.className += " dhxwin_hdr_hidden";
		this.conf.cells_cont = null; // reset saved borders
		w.conf.brd = null; // reset brd
		w.conf.header = false;
		this.wins._winAdjustCell(this._idd);
	}
	w = null;
};

// modality
dhtmlXWindowsCell.prototype.setModal = function(modal) {
	this.wins._winSetModal(this._idd, window.dhx4.s2b(modal));
};
dhtmlXWindowsCell.prototype.isModal = function() {
	return (this.wins.w[this._idd].conf.modal==true);
};

// adjust cell to content
dhtmlXWindowsCell.prototype._adjustByCont = function(w, h) {
	w += this.wins.w[this._idd].conf.w-this.conf.size.w;
	h += this.wins.w[this._idd].conf.h-this.conf.size.h;
	this.wins._winSetSize(this._idd, w, h);
};

// closing
dhtmlXWindowsCell.prototype.close = function() {
	this.wins._winClose(this._idd);
};

// icon
dhtmlXWindowsCell.prototype.setIconCss = function(css) {
	this.wins.w[this._idd].hdr.firstChild.className = "dhxwin_icon "+css;
	this.wins._winAdjustTitle(this._idd);
};

// fullscreen mode
dhtmlXWindowsCell.prototype.setToFullScreen = function(mode) {
	
	mode = window.dhx4.s2b(mode);
	
	var w = this.wins.w[this._idd];
	
	if (w.conf.fs_mode == mode) {
		w = null;
		return;
	}
	
	if (this.wins.fsn == null) {
		this.wins.fsn = document.createElement("DIV");
		this.wins.fsn.className = this.wins.vp.className+" dhxwins_vp_fs";
		document.body.appendChild(this.wins.fsn);
	}
	
	if (mode) {
		this.wins.fsn.appendChild(w.win);
		this.maximize();
		this.hideHeader();
	} else {
		this.wins.vp.appendChild(w.win);
		this.minimize();
		this.showHeader();
		
		if (this.wins.fsn.childNodes.length == 0) {
			this.wins.fsn.parentNode.removeChild(this.wins.fsn);
			this.wins.fsn = null;
		}
	}
	
	w.conf.fs_mode = mode;
	w = null;
	
};

// buttons

dhtmlXWindowsCell.prototype.button = function(id) {
	if (id == "minmax1" || id == "minmax2") { // deprecated
		// console.warn("windows: minmax1/minmax2 buttons are deprecated, from 4.0 there is single button minmax");
		id = "minmax";
	}
	return this.wins.w[this._idd].b[id];
};

dhtmlXWindowsCell.prototype.addUserButton = function(id, pos, title) {
	var b = new dhtmlXWindowsButton(this.wins, this._idd, id, title, true);
	var n = null;
	var h = this.wins.w[this._idd].hdr.lastChild;
	if (isNaN(pos)) pos = 0; else if (pos < 0) pos = 0;
	if (h.childNodes[pos] != null) n = h.childNodes[pos];
	if (n != null) h.insertBefore(b.button, n); else h.appendChild(b.button);
	this.wins.w[this._idd].b[id] = b;
	b = n = h = null;
	this.wins._winAdjustTitle(this._idd);
};

dhtmlXWindowsCell.prototype.removeUserButton = function(id) {
	if (this.wins.w[this._idd].b[id] == null || this.wins.w[this._idd].b[id].conf.custom != true) return;
	this.wins._winRemoveButton(this._idd, id);
};


window.dhtmlXWindowsButton = function(wins, winId, name, title, custom) {
	
	this.conf = {
		wins: wins,
		winId: winId,
		name: name,
		enabled: true,
		visible: true,
		custom:  true
	};
	
	this.button = document.createElement("DIV");
	this.button._buttonName = name;
	this.button.title = title;
	
	this.enable = function() {
		this.conf.enabled = true;
		this.setCss(this.conf.css);
	}
	this.disable = function() {
		this.conf.enabled = false;
		this.setCss(this.conf.css);
	}
	this.isEnabled = function() {
		return (this.conf.enabled==true);
	}
	//
	this.show = function() {
		this.button.style.display = "";
		this.conf.visible = true;
		this.conf.wins._winAdjustTitle(this.conf.winId);
	}
	this.hide = function() {
		this.button.style.display = "none";
		this.conf.visible = false;
		this.conf.wins._winAdjustTitle(this.conf.winId);
	}
	this.isHidden = function() {
		return (this.conf.visible==false);
	}
	//
	this.setCss = function(css) {
		this.conf.css = css;
		var dis = (this.conf.enabled?"":"_dis");
		this.button.className = "dhxwin_button"+dis+" dhxwin_button_"+this.conf.css+dis;
	}
	
	this._doOnClick = function(ev) {
		return this.callEvent("onClick", [this.conf.wins.w[this.conf.winId].cell, this]);
	}
	
	this.unload = function(winClosing) {
		//
		dhx4._eventable(this, "clear");
		this.button._buttonName = null;
		this.button.parentNode.removeChild(this.button);
		
		// context context menu if any
		if (this.conf.wins.cm != null && this.conf.wins.cm.button[this.conf.winId] != null && this.conf.wins.cm.button[this.conf.winId][this.conf.name] != null) {
			this.conf.wins._detachContextMenu("button", this.conf.winId, this.conf.name);
		}
		
		this.button = null;
		this.enable = null;
		this.disable = null;
		this.isEnabled = null;
		this.show = null;
		this.hide = null;
		this.isHidden = null;
		this.setCss = null;
		this.unload = null;
		//
		if (winClosing != true) this.conf.wins._winAdjustTitle(this.conf.winId);
		//
		this.conf.wins = null;
		this.conf.winId = null;
		this.conf = null;
		
	}
	
	this.setCss(name);
	dhx4._eventable(this);
	
	return this;
};

dhtmlXWindows.prototype._winButtonClick = function(id, button, ev) {
	
	if (!this.w[id].b[button].isEnabled()) return true;
	
	if (this.w[id].b[button]._doOnClick() !== true) return;
	
	if (button == "help") {
		this._callMainEvent("onHelp", id);
	}
	
	if (button == "park") {
		this._winPark(id, true);
	}
	
	if (button == "minmax") {
		this._winMinmax(id);
	}
	
	if (button == "stick") {
		this._winStick(id);
		return false;
	}

	if (button == "close") {
		this._winClose(id);
		return false;
	}
	return true; // allow default action
};

dhtmlXWindows.prototype._winRemoveButton = function(wId, bId, winClosing) {
	this.w[wId].b[bId].unload(winClosing);
	this.w[wId].b[bId] = null;
	delete this.w[wId].b[bId];
};


;
///<jscompress sourcefile="dhtmlxtoolbar.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXToolbarObject(base, skin) {
	
	var main_self = this;
	
	this.conf = {
		skin: (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxtoolbar")||"material"),
		align: "left",
		align_autostart: "left",
		icons_path: "",
		icons_css: false,
		iconSize: 18,
		sel_ofs_x: 0,
		sel_ofs_y: 0,
		xml_autoload: null,
		items_autoload: null,
		cssShadow: (dhx4.isIE6||dhx4.isIE7||dhx4.isIE8?"":" dhx_toolbar_shadow") // for material
	}
	
	if (typeof(base) == "object" && base != null && typeof(base.tagName) == "undefined") {
		// object-api init
		if (base.icons_path != null || base.icon_path != null) this.conf.icons_path = (base.icons_path||base.icon_path);
		if (base.icons_size != null) this.conf.icons_size_autoload = base.icons_size;
		if (base.iconset != null) this.conf.icons_css = (base.iconset == "awesome");
		if (base.json != null) this.conf.json_autoload = base.json;
		if (base.xml != null) this.conf.xml_autoload = base.xml;
		if (base.onload != null) this.conf.onload_autoload = base.onload;
		if (base.onclick != null || base.onClick != null) this.conf.auto_onclick = (base.onclick|| base.onClick);
		if (base.items != null) this.conf.items_autoload = base.items;
		if (base.skin != null) this.conf.skin = base.skin;
		if (base.align != null) this.conf.align_autostart = base.align;
		base = base.parent;
	}
	
	this.cont = (typeof(base)!="object")?document.getElementById(base):base;
	while (this.cont.childNodes.length > 0) this.cont.removeChild(this.cont.childNodes[0]);
	
	base = null;
	
	this.cont.dir = "ltr";
	
	this.base = document.createElement("DIV");
	this.base.className = "dhxtoolbar_float_left";
	this.cont.appendChild(this.base);
	
	this.cont.ontouchstart = function(e){
		e = e||event;
		if ((String(e.target.tagName||"").toLowerCase()=="input")) return true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	
	this.setSkin(this.conf.skin);
	
	this.objPull = {};
	this.anyUsed = null;
	
	/* random prefix */
	this._genStr = function(w) {
		var s = "dhxId_";
		var z = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		for (var q=0; q<w; q++) s += z.charAt(Math.round(Math.random() * (z.length-1)));
		return s;
	}
	this.rootTypes = new Array("button", "buttonSelect", "buttonTwoState", "separator", "label", "slider", "text", "buttonInput");
	this.idPrefix = this._genStr(12);
	//
	
	window.dhx4._enableDataLoading(this, "_initObj", "_xmlToJson", "toolbar", {struct:true});
	window.dhx4._eventable(this);
	//
	// return obj if exists by tagname
	this._getObj = function(obj, tag) {
		var targ = null;
		for (var q=0; q<obj.childNodes.length; q++) {
			if (obj.childNodes[q].tagName != null) {
				if (String(obj.childNodes[q].tagName).toLowerCase() == String(tag).toLowerCase()) targ = obj.childNodes[q];
			}
		}
		return targ;
	}
	// create and return image object
	this._addImgObj = function(obj) {
		var imgObj = document.createElement(this.conf.icons_css==true?"I":"IMG");
		if (obj.childNodes.length > 0) obj.insertBefore(imgObj, obj.childNodes[0]); else obj.appendChild(imgObj);
		return imgObj;
	}
	// set/clear item image/imagedis
	this._setItemImage = function(item, url, dis) {
		if (dis == true) item.imgEn = url; else item.imgDis = url;
		if ((!item.state && dis == true) || (item.state && dis == false)) return;
		if (this.conf.icons_css == true) {
			var imgObj = this._getObj(item.obj, "i");
			if (imgObj == null) imgObj = this._addImgObj(item.obj);
			imgObj.className = this.conf.icons_path+url;
		} else {
			var imgObj = this._getObj(item.obj, "img");
			if (imgObj == null) imgObj = this._addImgObj(item.obj);
			imgObj.src = this.conf.icons_path+url;
		}
	}
	this._clearItemImage = function(item, dis) {
		if (dis == true) item.imgEn = ""; else item.imgDis = "";
		if ((!item.state && dis == true) || (item.state && dis == false)) return;
		var imgObj = this._getObj(item.obj, (this.conf.icons_css?"i":"img"));
		if (imgObj != null) imgObj.parentNode.removeChild(imgObj);
	}
	// set/get item text
	this._setItemText = function(item, text) {
		var txtObj = this._getObj(item.obj, "div");
		if (text == null || text.length == 0) {
			if (txtObj != null) txtObj.parentNode.removeChild(txtObj);
			return;
		}
		if (txtObj == null) {
			txtObj = document.createElement("DIV");
			txtObj.className = "dhxtoolbar_text";
			item.obj.appendChild(txtObj);
		}
		txtObj.innerHTML = text;
	}
	this._getItemText = function(item) {
		var txtObj = this._getObj(item.obj, "div");
		if (txtObj != null) return txtObj.innerHTML;
		return "";
	}
	
	// enable/disable btn
	this._enableItem = function(item) {
		if (item.state) return;
		item.state = true;
		if (this.objPull[item.id]["type"] == "buttonTwoState" && this.objPull[item.id]["obj"]["pressed"] == true) {
			item.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_pres";
			item.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_over";
		} else {
			item.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
			item.obj.renderAs = item.obj.className; 
		}
		if (item.arw) item.arw.className = String(item.obj.className).replace("btn","arw");
		var imgObj = this._getObj(item.obj, (this.conf.icons_css?"i":"img"));
		if (item.imgEn != "") {
			if (imgObj == null) imgObj = this._addImgObj(item.obj);
			imgObj[this.conf.icons_css?"className":"src"] = this.conf.icons_path+item.imgEn;
		} else {
			if (imgObj != null) imgObj.parentNode.removeChild(imgObj);
		}
	}
	this._disableItem = function(item) {
		if (!item.state) return;
		item.state = false;
		item.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.objPull[item.id]["type"]=="buttonTwoState"&&item.obj.pressed?"pres_":"")+"dis";
		item.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_def";
		if (item.arw) item.arw.className = String(item.obj.className).replace("btn","arw");
		var imgObj = this._getObj(item.obj, (this.conf.icons_css?"i":"img"));
		if (item.imgDis != "") {
			if (imgObj == null) imgObj = this._addImgObj(item.obj);
			imgObj[this.conf.icons_css?"className":"src"] = this.conf.icons_path+item.imgDis;
		} else {
			if (imgObj != null) imgObj.parentNode.removeChild(imgObj);
		}
		// if (this.objPull[item.id]["type"] == "buttonTwoState") this.objPull[item.id]["obj"]["pressed"] = false;
		// hide opened polygon if any
		if (item.polygon != null) {
			if (item.polygon.style.display != "none") {
				window.dhx4.zim.clear(item.polygon._idd);
				item.polygon.style.display = "none";
				if (item.polygon._ie6cover) item.polygon._ie6cover.style.display = "none";
				// fix border
				if (this.conf.skin == "dhx_terrace") this._improveTerraceButtonSelect(item.id, true);
				// event
				this.callEvent("onButtonSelectHide", [item.obj.idd]);
			}
		}
		this.anyUsed = null;
	}
	
	this.clearAll = function() {
		for (var a in this.objPull) this._removeItem(String(a).replace(this.idPrefix,""));
	}
	
	
	//
	this._doOnClick = function(e) {
		if (main_self && main_self.forEachItem) {
			main_self.forEachItem(function(itemId){
				if (main_self.objPull[main_self.idPrefix+itemId].type == "buttonSelect") {
					// hide any opened buttonSelect's polygons, clear selection if any
					var item = main_self.objPull[main_self.idPrefix+itemId];
					if (item.arw._skip === true) {
						item.arw._skip = false;
					} else if (item.polygon.style.display != "none") {
						item.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_def";
						item.obj.className = item.obj.renderAs;
						item.arw.className = String(item.obj.renderAs).replace("btn","arw");
						main_self.anyUsed = null;
						main_self.conf.touch_id = null;
						window.dhx4.zim.clear(item.polygon._idd);
						item.polygon.style.display = "none";
						if (item.polygon._ie6cover) item.polygon._ie6cover.style.display = "none";
						// fix border
						if (main_self.conf.skin == "dhx_terrace") main_self._improveTerraceButtonSelect(item.id, true);
						// event
						main_self.callEvent("onButtonSelectHide", [item.obj.idd]);
					}
				}
			});
		}
	}
	
	if (typeof(window.addEventListener) != "undefined") {
		window.addEventListener("mousedown", this._doOnClick, false);
		window.addEventListener("touchstart", this._doOnClick, false);
	} else {
		document.body.attachEvent("onmousedown", this._doOnClick);
	}
	
	if (this.conf.icons_size_autoload != null) {
		this.setIconSize(this.conf.icons_size_autoload);
		this.conf.icons_size_autoload = null;
	}
	
	if (this.conf.items_autoload != null) {
		this.loadStruct(this.conf.items_autoload, this.conf.onload_autoload);
		this.conf.items_autoload = null;
	} else if (this.conf.json_autoload != null) {
		this.loadStruct(this.conf.json_autoload, this.conf.onload_autoload);
		this.conf.json_autoload = null;
	} else if (this.conf.xml_autoload != null) {
		this.loadStruct(this.conf.xml_autoload, this.conf.onload_autoload);
		this.conf.xml_autoload = null;
	}
	
	if (this.conf.align_autostart != this.conf.align) {
		this.setAlign(this.conf.align_autostart);
		this.conf.align_autostart = null;
	}
	
	if (typeof(this.conf.auto_onclick) == "function") {
		this.attachEvent("onClick", this.conf.auto_onclick);
	} else if (typeof(this.conf.auto_onclick) == "string" && typeof(window[this.conf.auto_onclick]) == "function") {
		this.attachEvent("onClick", window[this.conf.auto_onclick]);
	}
	
	//
	return this;
}
dhtmlXToolbarObject.prototype.addSpacer = function(nextToId) {
	var nti = this.idPrefix+nextToId;
	if (this._spacer != null) {
		// spacer already at specified position
		if (this._spacer.idd == nextToId) return;
		// if current spacer contain nextToId item
		// move all items from first to nextToId to this.base
		if (this._spacer == this.objPull[nti].obj.parentNode) {
			var doMove = true;
			while (doMove) {
				var idd = this._spacer.childNodes[0].idd;
				this.base.appendChild(this._spacer.childNodes[0]);
				if (idd == nextToId || this._spacer.childNodes.length == 0) {
					if (this.objPull[nti].arw != null) this.base.appendChild(this.objPull[nti].arw);
					doMove = false;
				}
			}
			this._spacer.idd = nextToId;
			this._fixSpacer();
			return;
		}
		// if this.base contain nextToId item, move (insertBefore[0])
		if (this.base == this.objPull[nti].obj.parentNode) {
			var doMove = true;
			var chArw = (this.objPull[nti].arw!=null);
			while (doMove) {
				var q = this.base.childNodes.length-1;
				if (chArw == true) if (this.base.childNodes[q] == this.objPull[nti].arw) doMove = false;
				if (this.base.childNodes[q].idd == nextToId) doMove = false;
				if (doMove) { if (this._spacer.childNodes.length > 0) this._spacer.insertBefore(this.base.childNodes[q], this._spacer.childNodes[0]); else this._spacer.appendChild(this.base.childNodes[q]); }
			}
			this._spacer.idd = nextToId;
			this._fixSpacer();
			return;
		}
		
	} else {
		var np = null;
		for (var q=0; q<this.base.childNodes.length; q++) {
			if (this.base.childNodes[q] == this.objPull[this.idPrefix+nextToId].obj) {
				np = q;
				if (this.objPull[this.idPrefix+nextToId].arw != null) np = q+1;
			}
		}
		if (np != null) {
			this._spacer = document.createElement("DIV");
			this._spacer.className = (this.conf.align=="right"?" dhxtoolbar_float_left":" dhxtoolbar_float_right");
			this._spacer.dir = "ltr";
			this._spacer.idd = nextToId;
			while (this.base.childNodes.length > np+1) this._spacer.appendChild(this.base.childNodes[np+1]);
			this.cont.appendChild(this._spacer);
			this._fixSpacer();
		}
	}
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
}
dhtmlXToolbarObject.prototype.removeSpacer = function() {
	if (!this._spacer) return;
	while (this._spacer.childNodes.length > 0) this.base.appendChild(this._spacer.childNodes[0]);
	this._spacer.parentNode.removeChild(this._spacer);
	this._spacer = null;
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
}
dhtmlXToolbarObject.prototype._fixSpacer = function() {
	// IE icons mixing fix
	if (typeof(window.addEventListener) == "undefined" && this._spacer != null) {
		this._spacer.style.borderLeft = "1px solid #a4bed4";
		var k = this._spacer;
		window.setTimeout(function(){k.style.borderLeft="0px solid #a4bed4";k=null;},1);
	}
}

dhtmlXToolbarObject.prototype.getType = function(itemId) {
	var parentId = this.getParentId(itemId);
	if (parentId != null) {
		var typeExt = null;
		var itemData = this.objPull[this.idPrefix+parentId]._listOptions[itemId];
		if (itemData != null) if (itemData.sep != null) typeExt = "buttonSelectSeparator"; else typeExt = "buttonSelectButton";
		return typeExt;
	} else {
		if (this.objPull[this.idPrefix+itemId] == null) return null;
		return this.objPull[this.idPrefix+itemId]["type"];
	}
}

dhtmlXToolbarObject.prototype.getTypeExt = function(itemId) {
	var type = this.getType(itemId);
	if (type == "buttonSelectButton" || type == "buttonSelectSeparator") {
		if (type == "buttonSelectButton") type = "button"; else type = "separator";
		return type;
	}
	return null;
}
dhtmlXToolbarObject.prototype.inArray = function(array, value) {
	for (var q=0; q<array.length; q++) { if (array[q]==value) return true; }
	return false;
}
dhtmlXToolbarObject.prototype.getParentId = function(listId) {
	var parentId = null;
	for (var a in this.objPull) if (this.objPull[a]._listOptions) for (var b in this.objPull[a]._listOptions) if (b == listId) parentId = String(a).replace(this.idPrefix,"");
	return parentId;
}
/* adding items */
dhtmlXToolbarObject.prototype._addItem = function(itemData, pos) {
	if (typeof(itemData.text) == "string") {
		itemData.text = window.dhx4.trim(itemData.text);
		if (itemData.text.length == 0) itemData.text = null;
	}
	this._addItemToStorage(itemData, pos);
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
}

dhtmlXToolbarObject.prototype.addButton = function(id, pos, text, imgEnabled, imgDisabled) {
	this._addItem({id:id, type:"button", text:text, img:imgEnabled, imgdis:imgDisabled}, pos);
}

dhtmlXToolbarObject.prototype.addText = function(id, pos, text) {
	this._addItem({id:id,type:"text",text:text}, pos);
}

dhtmlXToolbarObject.prototype.addButtonSelect = function(id, pos, text, opts, imgEnabled, imgDisabled, renderSelect, openAll, maxOpen, mode) { 
	var options = [];
	for (var q=0; q<opts.length; q++) {
		var u = {};
		if (opts[q] instanceof Array) {
			u.id = opts[q][0];
			u.type = (opts[q][1]=="obj"?"button":"separator");
			u.text = (opts[q][2]||null);
			u.img = (opts[q][3]||null);
		} else if (opts[q] instanceof Object && opts[q] != null && typeof(opts[q].id) != "undefined" && typeof(opts[q].type) != "undefined") {
			u.id = opts[q].id;
			u.type = (opts[q].type=="obj"?"button":"separator");
			u.text = opts[q].text;
			u.img = opts[q].img;
		}
		options.push(u);
	}
	this._addItem({id:id, type:"buttonSelect", text:text, img:imgEnabled, imgdis:imgDisabled, renderSelect:renderSelect, openAll:openAll, options:options, maxOpen:maxOpen, mode:mode}, pos);
}

dhtmlXToolbarObject.prototype.addButtonTwoState = function(id, pos, text, imgEnabled, imgDisabled) {
	this._addItem({id:id, type:"buttonTwoState", img:imgEnabled, imgdis:imgDisabled, text:text}, pos);
}

dhtmlXToolbarObject.prototype.addSeparator = function(id, pos) {
	this._addItem({id:id,type:"separator"}, pos);
}

dhtmlXToolbarObject.prototype.addSlider = function(id, pos, len, valueMin, valueMax, valueNow, textMin, textMax, tip) {
	this._addItem({id:id, type:"slider", length:len, valueMin:valueMin, valueMax:valueMax, valueNow:valueNow, textMin:textMin, textMax:textMax, toolTip:tip}, pos);
}

dhtmlXToolbarObject.prototype.addInput = function(id, pos, value, width) {
	this._addItem({id:id,type:"buttonInput",value:value,width:width}, pos);
}

dhtmlXToolbarObject.prototype.forEachItem = function(handler) {
	for (var a in this.objPull) {
		if (this.inArray(this.rootTypes, this.objPull[a]["type"])) {
			handler(this.objPull[a]["id"].replace(this.idPrefix,""));
		}
	}
};
(function(){
	var list="isVisible,enableItem,disableItem,isEnabled,setItemText,getItemText,setItemToolTip,getItemToolTip,getInput,setItemImage,setItemImageDis,clearItemImage,clearItemImageDis,setItemState,getItemState,setItemToolTipTemplate,getItemToolTipTemplate,setValue,getValue,setMinValue,getMinValue,setMaxValue,getMaxValue,setWidth,getWidth,setMaxOpen".split(",")
	var ret=[false,"","",false,"","","","","","","","","",false,"","","",null,"",[null,null],"",[null,null],"",null]
	var functor=function(name,res){
		return function(itemId,a,b){
			itemId = this.idPrefix+itemId;
			if (this.objPull[itemId][name] != null) return this.objPull[itemId][name].call(this.objPull[itemId],a,b); else return res;
		};
	}
	for (var i=0; i<list.length; i++){
		var name=list[i];
		var res=ret[i];
		dhtmlXToolbarObject.prototype[name] = functor(name,res);
	}
})();

dhtmlXToolbarObject.prototype.showItem = function(itemId) {
	itemId = this.idPrefix+itemId;
	if (this.objPull[itemId] != null && this.objPull[itemId].showItem != null) {
		this.objPull[itemId].showItem();
		if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
	}
}

dhtmlXToolbarObject.prototype.hideItem = function(itemId) {
	itemId = this.idPrefix+itemId;
	if (this.objPull[itemId] != null && this.objPull[itemId].hideItem != null) {
		this.objPull[itemId].hideItem();
		if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
	}
}
dhtmlXToolbarObject.prototype.getPosition = function(itemId) {
	return this._getPosition(itemId);
}
dhtmlXToolbarObject.prototype._getPosition = function(id, getRealPosition) {
	
	if (this.objPull[this.idPrefix+id] == null) return null;
	
	var pos = null;
	var w = 0;
	for (var q=0; q<this.base.childNodes.length; q++) {
		if (this.base.childNodes[q].idd != null) {
			if (this.base.childNodes[q].idd == id) pos = w;
			w++;
		}
	}
	if (!pos && this._spacer != null) {
		for (var q=0; q<this._spacer.childNodes.length; q++) {
			if (this._spacer.childNodes[q].idd != null) {
				if (this._spacer.childNodes[q].idd == id) pos = w;
				w++;
			}
		}
	}
	return pos;
}

dhtmlXToolbarObject.prototype.setPosition = function(itemId, pos) {
	this._setPosition(itemId, pos);
}

dhtmlXToolbarObject.prototype._setPosition = function(id, pos) {
	
	if (this.objPull[this.idPrefix+id] == null) return;
	
	var spacerId = null;
	if (this._spacer) {
		spacerId = this._spacer.idd;
		this.removeSpacer();
	}
	
	if (isNaN(pos)) pos = this.base.childNodes.length;
	if (pos < 0) pos = 0;
	
	var item = this.objPull[this.idPrefix+id];
	this.base.removeChild(item.obj);
	if (item.arw) this.base.removeChild(item.arw);
	
	var newPos = this._getIdByPosition(pos, true);
	
	if (newPos[0] == null) {
		this.base.appendChild(item.obj);
		if (item.arw) this.base.appendChild(item.arw);
	} else {
		this.base.insertBefore(item.obj, this.base.childNodes[newPos[1]]);
		if (item.arw) this.base.insertBefore(item.arw, this.base.childNodes[newPos[1]+1]);
	}
	if (spacerId != null) this.addSpacer(spacerId);
	
}
dhtmlXToolbarObject.prototype._getIdByPosition = function(pos, retRealPos) {
	
	var id = null;
	var w = 0;
	var realPos = 0;
	for (var q=0; q<this.base.childNodes.length; q++) {
		if (this.base.childNodes[q]["idd"] != null && id == null) {
			if ((w++) == pos) id = this.base.childNodes[q]["idd"];
		}
		if (id == null) realPos++;
	}
	realPos = (id==null?null:realPos);
	return (retRealPos==true?new Array(id, realPos):id);
}

dhtmlXToolbarObject.prototype.removeItem = function(itemId) {
	this._removeItem(itemId);
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
};

dhtmlXToolbarObject.prototype._removeItem = function(itemId) {
	
	var t = this.getType(itemId);
	
	itemId = this.idPrefix+itemId;
	var p = this.objPull[itemId];
	
	
	if ({button:1, buttonTwoState:1}[t] == 1) {
		
		if (window.dhx4.isIE) p.obj.onselectstart = null;
		this._evs.clear.apply(p, [p.obj.evs, p.obj]);
		
		for (var a in p.obj) if (typeof(p.obj[a]) == "function") p.obj[a] = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		for (var a in p) p[a] = null;
		
	}
	
	if (t == "buttonSelect") {
		
		for (var a in p._listOptions) this.removeListOption(itemId, a);
		p._listOptions = null;
		
		if (p.polygon._ie6cover) {
			document.body.removeChild(p.polygon._ie6cover);
			p.polygon._ie6cover = null;
		}
		
		p.p_tbl.removeChild(p.p_tbody);
		p.polygon.removeChild(p.p_tbl);
		p.polygon.onselectstart = null;
		document.body.removeChild(p.polygon);
		
		if (window.dhx4.isIE) {
			p.obj.onselectstart = null;
			p.arw.onselectstart = null;
		}
		this._evs.clear.apply(p, [p.obj.evs, p.obj]);
		this._evs.clear.apply(p, [p.arw.evs, p.arw]);
		
		for (var a in p.obj) if (typeof(p.obj[a]) == "function") p.obj[a] = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		for (var a in p.arw) if (typeof(p.arw[a]) == "function") p.arw[a] = null;
		p.arw.parentNode.removeChild(p.arw);
		p.arw = null;
		
		for (var a in p) p[a] = null;
		
		
	}
	
	if (t == "buttonInput") {
		
		p.obj.childNodes[0].onkeydown = null;
		p.obj.removeChild(p.obj.childNodes[0]);
		
		p.obj.w = null;
		p.obj.idd = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		p.id = null;
		p.type = null;
		
		p.enableItem = null;
		p.disableItem = null;
		p.isEnabled = null;
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		p.setItemToolTip = null;
		p.getItemToolTip = null;
		p.setWidth = null;
		p.getWidth = null;
		p.setValue = null;
		p.getValue = null;
		p.setItemText = null;
		p.getItemText = null;
		
	}
	
	if (t == "slider") {
		
		if (window.dhx4.isIPad) {
			document.removeEventListener("touchmove", pen._doOnMouseMoveStart, false);
			document.removeEventListener("touchend", pen._doOnMouseMoveEnd, false);
		} else {
			if (typeof(window.addEventListener) == "function") {
				window.removeEventListener("mousemove", p.pen._doOnMouseMoveStart, false);
				window.removeEventListener("mouseup", p.pen._doOnMouseMoveEnd, false);
			} else {
				document.body.detachEvent("onmousemove", p.pen._doOnMouseMoveStart);
				document.body.detachEvent("onmouseup", p.pen._doOnMouseMoveEnd);
			}
		}
		
		p.pen.allowMove = null;
		p.pen.initXY = null;
		p.pen.maxX = null;
		p.pen.minX = null;
		p.pen.nowX = null;
		p.pen.newNowX = null;
		p.pen.valueMax = null;
		p.pen.valueMin = null;
		p.pen.valueNow = null;
		
		p.pen._definePos = null;
		p.pen._detectLimits = null;
		p.pen._doOnMouseMoveStart = null;
		p.pen._doOnMouseMoveEnd = null;
		p.pen.onmousedown = null;
		
		p.obj.removeChild(p.pen);
		p.pen = null;
		
		p.label.tip = null;
		document.body.removeChild(p.label);
		p.label = null;
		
		p.obj.onselectstart = null;
		p.obj.idd = null;
		while (p.obj.childNodes.length > 0) p.obj.removeChild(p.obj.childNodes[0]);
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		p.id = null;
		p.type = null;
		p.state = null;
		
		p.enableItem = null;
		p.disableItem = null;
		p.isEnabled = null;
		p.setItemToolTipTemplate = null;
		p.getItemToolTipTemplate = null;
		p.setMaxValue = null;
		p.setMinValue = null;
		p.getMaxValue = null;
		p.getMinValue = null;
		p.setValue = null;
		p.getValue = null;
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		
	}
	
	if (t == "separator") {
		
		p.obj.onselectstart = null;
		p.obj.idd = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		p.id = null;
		p.type = null;
		
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		
	}
	
	if (t == "text") {
		
		p.obj.onselectstart = null;
		p.obj.idd = null;
		p.obj.parentNode.removeChild(p.obj);
		p.obj = null;
		
		p.id = null;
		p.type = null;
		
		p.showItem = null;
		p.hideItem = null;
		p.isVisible = null;
		p.setWidth = null;
		p.setItemText = null;
		p.getItemText = null;
		
	}
	
	t = null;
	p = null;
	this.objPull[itemId] = null;
	delete this.objPull[itemId];
	
	
};
//#tool_list:06062008{
(function(){
	var list="addListOption,removeListOption,showListOption,hideListOption,isListOptionVisible,enableListOption,disableListOption,isListOptionEnabled,setListOptionPosition,getListOptionPosition,setListOptionText,getListOptionText,setListOptionToolTip,getListOptionToolTip,setListOptionImage,getListOptionImage,clearListOptionImage,forEachListOption,getAllListOptions,setListOptionSelected,getListOptionSelected".split(",")
	var functor = function(name){
				return function(parentId,a,b,c,d,e){
				parentId = this.idPrefix+parentId;
				if (this.objPull[parentId] == null) return;
				if (this.objPull[parentId]["type"] != "buttonSelect") return;
				return this.objPull[parentId][name].call(this.objPull[parentId],a,b,c,d,e);
			}
		}
	for (var i=0; i<list.length; i++){
		var name=list[i];
		dhtmlXToolbarObject.prototype[name]=functor(name)
	}
})();

dhtmlXToolbarObject.prototype._rtlParseBtn = function(t1, t2) {
	return t1+t2;
}
/*****************************************************************************************************************************************************************
	object: separator
*****************************************************************************************************************************************************************/
dhtmlXToolbarObject.prototype._separatorObject = function(that, id, data) {
	//
	this.id = that.idPrefix+id;
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_sep";
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	this.obj.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	
	this.obj.ontouchstart = function(e){
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	
	//
	// add object
	that.base.appendChild(this.obj);
	
	// functions
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	//
	return this;
}
/*****************************************************************************************************************************************************************
	object: text
*****************************************************************************************************************************************************************/
dhtmlXToolbarObject.prototype._textObject = function(that, id, data) {
	this.id = that.idPrefix+id;
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_text";
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	this.obj.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	
	this.obj.ontouchstart = function(e){
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	
	//
	this.obj.innerHTML = (data.text||"");
	//
	that.base.appendChild(this.obj);
	//
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setItemText = function(text) {
		this.obj.innerHTML = text;
	}
	this.getItemText = function() {
		return this.obj.innerHTML;
	}
	this.setWidth = function(width) {
		this.obj.style.width = width+"px";
	}
	this.setItemToolTip = function(t) {
		this.obj.title = t;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	//
	return this;
}
/*****************************************************************************************************************************************************************
	object: button
******************************************************************************************************************************************************************/
dhtmlXToolbarObject.prototype._buttonObject = function(that, id, data) {
	
	this.id = that.idPrefix+id;
	this.state = (data.enabled!=null?false:true);
	this.imgEn = (data.img||"");
	this.imgDis = (data.imgdis||"");
	this.img = (this.state?(this.imgEn!=""?this.imgEn:""):(this.imgDis!=""?this.imgDis:""));
	
	//
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.state?"def":"dis");
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.allowClick = false;
	this.obj.extAction = (data.action||null);
	this.obj.renderAs = this.obj.className;
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	this.obj.pressed = false;
	//
	var img = (that.conf.icons_css?"<i class='"+that.conf.icons_path+this.img+"'></i>":"<img src='"+that.conf.icons_path+this.img+"'>");
	this.obj.innerHTML = that._rtlParseBtn((this.img!=""?img:""), (data.text!=null?"<div class='dhxtoolbar_text'>"+data.text+"</div>":""));
	
	// add object
	that.base.appendChild(this.obj);
	
	if (window.dhx4.isIE) {
		this.obj.onselectstart = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
	}
	
	var t = this;
	this._doOnMouseOver = function(e) {
		e = e||event;
		if (t.state == false || t.obj.pressed == true || t.obj.over == true) return;
		if (t.obj.className.match(/dhxtoolbar_btn_over/gi) == null) t.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_over";
		t.obj.over = true;
	}
	
	this._doOnMouseOut = function(e) {
		e = e||event;
		if (t.state == false) return;
		if (t.obj.className.match(/dhxtoolbar_btn_over/gi) != null) t.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
		t.obj.over = t.obj.pressed = false;
	}
	
	this._doOnMouseDown = function(e) {
		e = e||event;
		if (e.type == "touchstart") {
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			if (that.conf.touch_id != null && that.conf.touch_id != t.id) return; // multiple touches?
			that.conf.touch_id = t.id;
		}
		if (t.state == false) return;
		if (t.obj.className.match(/dhxtoolbar_btn_pres/gi) == null) t.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_pres";
		t.obj.pressed = true;
	}
	
	this._doOnMouseUp = function(e) {
		e = e||event;
		if (e.type == "touchend") {
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			if (that.conf.touch_id == t.id) that.conf.touch_id = null;
		}
		if (t.state == false || t.obj.pressed == false) return;
		if (t.obj.className.match(/dhxtoolbar_btn_pres/gi) != null) t.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(t.obj.over?"over":"def");
		t.obj.pressed = false;
		if (t.obj.extAction){window.setTimeout(function(){try{if(t&&t.obj)window[t.obj.extAction](t.id);}catch(e){}},1);}
		that.callEvent("onClick", [t.obj.idd.replace(that.idPrefix,"")]);
	}
	
	// add mouse events
	this.obj.evs = {
		mouseover: "_doOnMouseOver",
		mouseout: "_doOnMouseOut",
		mousedown: "_doOnMouseDown",
		mouseup: "_doOnMouseUp",
		touchstart: "_doOnMouseDown",
		touchend: "_doOnMouseUp"
	};
	
	that._evs.add.apply(this, [this.obj.evs, this.obj]);
	
	// functions
	this.enableItem = function() {
		that._enableItem(this);
	}
	this.disableItem = function() {
		that._disableItem(this);
	}
	this.isEnabled = function() {
		return this.state;
	}
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setItemText = function(text) {
		that._setItemText(this, text);
	}
	this.getItemText = function() {
		return that._getItemText(this);
	}
	this.setItemImage = function(url) {
		that._setItemImage(this, url, true);
	}
	this.clearItemImage = function() {
		that._clearItemImage(this, true);
	}
	this.setItemImageDis = function(url) {
		that._setItemImage(this, url, false);
	}
	this.clearItemImageDis = function() {
		that._clearItemImage(this, false);
	}
	this.setItemToolTip = function(tip) {
		this.obj.title = tip;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	return this;
}

/******************************************************************************************************************************************************************
	object: buttonSelect
*******************************************************************************************************************************************************************/
dhtmlXToolbarObject.prototype._buttonSelectObject = function(that, id, data) {
	this.id = that.idPrefix+id;
	this.state = (data.enabled!=null?(data.enabled=="true"?true:false):true);
	this.imgEn = (data.img||"");
	this.imgDis = (data.imgdis||"");
	this.img = (this.state?(this.imgEn!=""?this.imgEn:""):(this.imgDis!=""?this.imgDis:""));
	
	this.mode = (data.mode||"button"); // button, select
	if (this.mode == "select") {
		this.openAll = true;
		this.renderSelect = false;
		if (!data.text||data.text.length==0) data.text = "&nbsp;"
	} else {
		this.openAll = (window.dhx4.s2b(data.openAll)==true);
		this.renderSelect = (data.renderSelect == null ? true : window.dhx4.s2b(data.renderSelect));
	}
	this.maxOpen = (!isNaN(data.maxOpen?data.maxOpen:"")?data.maxOpen:null);
	
	this._maxOpenTest = function() {
		if (!isNaN(this.maxOpen)) {
			if (!that._sbw) {
				var t = document.createElement("DIV");
				t.className = "dhxtoolbar_maxopen_test";
				document.body.appendChild(t);
				var k = document.createElement("DIV");
				k.className = "dhxtoolbar_maxopen_test2";
				t.appendChild(k);
				that._sbw = t.offsetWidth-k.offsetWidth;
				t.removeChild(k);
				k = null;
				document.body.removeChild(t);
				t = null;
			}
		}
	}
	this._maxOpenTest();
	
	//
	this.obj = document.createElement("DIV");
	this.obj.allowClick = false;
	this.obj.extAction = (data.action||null);
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.state?"def":"dis");
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.renderAs = this.obj.className;
	this.obj.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	this.obj.pressed = false;
	
	this.callEvent = false;
	
	
	var img = (that.conf.icons_css?"<i class='"+that.conf.icons_path+this.img+"'></i>":"<img src='"+that.conf.icons_path+this.img+"'>");
	this.obj.innerHTML = that._rtlParseBtn((this.img!=""?img:""),(data.text!=null?"<div class='dhxtoolbar_text'>"+data.text+"</div>":""));
	
	// add object
	that.base.appendChild(this.obj);
	
	this.arw = document.createElement("DIV");
	this.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_"+(this.state?"def":"dis");
	this.arw.style.display = this.obj.style.display;
	this.arw.innerHTML = "<div class='arwimg'>&nbsp;</div>";
	
	this.arw.title = this.obj.title;
	this.arw.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	that.base.appendChild(this.arw);
	
	var self = this;
	
	if (window.dhx4.isIE) {
		this.arw.onselectstart = this.obj.onselectstart = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
	}
	
	this._doOnMouseOver = function(e) {
		e = e||event;
		if (self.state == false || self.obj.over == true || that.anyUsed == self.obj.idd) return;
		if (self.obj.className.match(/dhxtoolbar_btn_over/gi) == null) {
			self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_over";
			self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_over";
		}
		self.obj.over = true;
	}
	
	this._doOnMouseOut = function(e) {
		e = e||event;
		if (self.state == false || that.anyUsed == self.obj.idd || that.anyUsed == self.obj.idd) return;
		if (self.obj.className.match(/dhxtoolbar_btn_over/gi) != null) {
			self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
			self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_def";
		}
		self.obj.over = self.obj.pressed = false;
	}
	
	this._doOnMouseDown = function(e) {
		e = e||event;
		if (e.type == "touchstart") {
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			if (that.conf.touch_id != null && that.conf.touch_id != self.id) return; // multiple touches?
			that.conf.touch_id = self.id;
		}
		if (self.state == false) return;
		
		if (that.anyUsed == self.obj.idd) {
			// hide polygon
			if (self.obj.over == true) {
				self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_over";
				self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_over";
			} else {
				self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
				self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_def";
			}
			self._hidePoly(true);
			that.anyUsed = null;
		} else {
			// show polygon
			var node = (e.target||e.srcElement);
			if (self.openAll == true || node == self.arw || node.parentNode == self.arw) {
				if (e.type == "touchstart") self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_over";
				self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_pres";
				self.arw._skip = true;
				self._showPoly(true);
				that.anyUsed = self.obj.idd;
			} else {
				if (self.obj.className.match(/dhxtoolbar_btn_pres/gi) == null) {
					self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_pres";
					self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_pres";
				}
				self.obj.pressed = true;
			}
		}
	}
	
	this._doOnMouseUp = function(e) {
		e = e||event;
		if (e.type == "touchend") {
			if (self.polygon.style.display == "") return;
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			if (that.conf.touch_id == self.id) that.conf.touch_id = null;
		}
		if (self.state == false || self.obj.pressed == false) return;
		if (self.obj.className.match(/dhxtoolbar_btn_pres/gi) != null) {
			self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(self.obj.over?"over":"def");
			self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_"+(self.obj.over?"over":"def");
		}
		// event
		if (this.extAction) {var k = this;window.setTimeout(function(){try{window[k.extAction](id);}catch(e){};k=null;},1);}
		that.callEvent("onClick", [self.obj.idd.replace(that.idPrefix,"")]);
	}
	
	// add mouse events
	this.arw.evs = {
		mouseover: "_doOnMouseOver",
		mouseout: "_doOnMouseOut",
		mousedown: "_doOnMouseDown",
		touchstart: "_doOnMouseDown"
	};
	that._evs.add.apply(this, [this.arw.evs, this.arw]);
	
	this.obj.evs = {
		mouseover: "_doOnMouseOver",
		mouseout: "_doOnMouseOut",
		mousedown: "_doOnMouseDown",
		mouseup: "_doOnMouseUp",
		touchstart: "_doOnMouseDown",
		touchend: "_doOnMouseUp"
	};
	that._evs.add.apply(this, [this.obj.evs, this.obj]);
	
	this._showPoly = function(callEvent) {
		// hide other if already opened
		if (that.anyUsed != null) {
			if (that.objPull[that.idPrefix+that.anyUsed].type == "buttonSelect") {
				var item = that.objPull[that.idPrefix+that.anyUsed];
				if (item.polygon.style.display != "none") {
					item.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
					item.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_def";
					item.obj.over = false;
					window.dhx4.zim.clear(item.polygon._idd);
					item.polygon.style.display = "none";
					if (item.polygon._ie6cover) item.polygon._ie6cover.style.display = "none";
					// fix border
					if (that.conf.skin == "dhx_terrace") that._improveTerraceButtonSelect(item.id, true);
					// event
					that.callEvent("onButtonSelectHide", [item.obj.idd]);
				}
			}
		}
		// show
		this.polygon.style.top = "0px";
		this.polygon.style.visibility = "hidden";
		this.polygon.style.zIndex = window.dhx4.zim.reserve(this.polygon._idd);
		this.polygon.style.display = "";
		// fix border
		if (that.conf.skin == "dhx_terrace") that._improveTerraceButtonSelect(this.id, false);
		// check maxOpen
		this._fixMaxOpenHeight(this.maxOpen||null);
		// detect overlay by Y axis
		that._autoDetectVisibleArea();
		// calculate top position
		var newTop = window.dhx4.absTop(this.obj)+this.obj.offsetHeight+that.conf.sel_ofs_y;
		var newH = this.polygon.offsetHeight;
		if (newTop + newH > that.tY2) {
			// if maxOpen mode enabled, check if at bottom at least one item can be shown
			// and show it, if no space - show on top. in maxOpen mode not enabled, show at top
			var k0 = (this.maxOpen!=null?Math.floor((that.tY2-newTop)/22):0); // k0 = count of items that can be visible
			if (k0 >= 1) {
				this._fixMaxOpenHeight(k0);
			} else {
				newTop = window.dhx4.absTop(this.obj)-newH-that.conf.sel_ofs_y;
				if (newTop < 0) newTop = 0;
			}
		}
		this.polygon.style.top = newTop+"px";
		// calculate left position
		if (that.rtl) {
			this.polygon.style.left = window.dhx4.absLeft(this.obj)+this.obj.offsetWidth-this.polygon.offsetWidth+that.conf.sel_ofs_x+"px";
		} else {
			var x1 = document.body.scrollLeft;
			var x2 = x1+(window.innerWidth||document.body.clientWidth);
			var newLeft = window.dhx4.absLeft(this.obj)+that.conf.sel_ofs_x;
			if (newLeft+this.polygon.offsetWidth > x2) newLeft = window.dhx4.absLeft(this.arw)+this.arw.offsetWidth-this.polygon.offsetWidth;
			this.polygon.style.left = Math.max(newLeft,5)+"px";
		}
		this.polygon.style.visibility = "visible";
		// show IE6 cover if needed
		if (this.polygon._ie6cover) {
			this.polygon._ie6cover.style.left = this.polygon.style.left;
			this.polygon._ie6cover.style.top = this.polygon.style.top;
			this.polygon._ie6cover.style.width = this.polygon.offsetWidth+"px";
			this.polygon._ie6cover.style.height = this.polygon.offsetHeight+"px";
			this.polygon._ie6cover.style.display = "";
		}
		// event, added in 4.5
		if (callEvent) that.callEvent("onButtonSelectShow", [this.obj.idd]);
	}
	
	this._hidePoly = function(callEvent) {
		window.dhx4.zim.clear(this.polygon._idd);
		this.polygon.style.display = "none";
		if (this.polygon._ie6cover) this.polygon._ie6cover.style.display = "none";
		// fix border
		if (that.conf.skin == "dhx_terrace") that._improveTerraceButtonSelect(this.id, true);
		if (callEvent) that.callEvent("onButtonSelectHide", [this.obj.idd]); // event, added in 4.5
		// reset touch event if any
		that.conf.touch_id = null;
	}
	
	this.obj.iddPrefix = that.idPrefix;
	this._listOptions = {};
	
	this._fixMaxOpenHeight = function(maxOpen) {
		var h = "auto";
		var h0 = false;
		if (maxOpen !== null) {
			var t = 0;
			for (var a in this._listOptions) t++;
			if (t > maxOpen) {
				this._ph = 22*maxOpen;
				h = this._ph+"px";
			} else {
				h0 = true;
			}
		}
		this.polygon.style.width = "auto";
		this.polygon.style.height = "auto";
		if (!h0 && self.maxOpen != null) {
			this.polygon.style.width = this.p_tbl.offsetWidth+that._sbw+"px";
			this.polygon.style.height = h;
		}
	}
	
	// inner objects: separator
	this._separatorButtonSelectObject = function(id, data, pos) {
		
		this.obj = {};
		this.obj.tr = document.createElement("TR");
		this.obj.tr.className = "tr_sep";
		this.obj.tr.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		this.obj.td = document.createElement("TD");
		this.obj.td.colSpan = "2";
		this.obj.td.className = "td_btn_sep";
		this.obj.td.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		
		if (isNaN(pos)) pos = self.p_tbody.childNodes.length+1; else if (pos < 1) pos = 1;
		if (pos > self.p_tbody.childNodes.length) self.p_tbody.appendChild(this.obj.tr); else self.p_tbody.insertBefore(this.obj.tr, self.p_tbody.childNodes[pos-1]);
		
		this.obj.tr.appendChild(this.obj.td);
		
		this.obj.sep = document.createElement("DIV");
		this.obj.sep.className = "btn_sep";
		this.obj.sep.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		this.obj.td.appendChild(this.obj.sep);
		
		self._listOptions[id] = this.obj;
		return this;
	}
	// inner objects: button
	this._buttonButtonSelectObject = function(id, data, pos) {
		
		var en = true;
		if (typeof(data.enabled) != "undefined") {
			en = window.dhx4.s2b(data.enabled);
		} else if (typeof(data.disabled) != "undefined") {
			en = window.dhx4.s2b(data.disabled);
		}
		
		this.obj = {};
		this.obj.tr = document.createElement("TR");
		this.obj.tr.en = en;
		this.obj.tr.extAction = (data.action||null);
		this.obj.tr._selected = (data.selected!=null);
		this.obj.tr.className = "tr_btn"+(this.obj.tr.en?(this.obj.tr._selected&&self.renderSelect?" tr_btn_selected":""):" tr_btn_disabled");
		this.obj.tr.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		this.obj.tr.idd = String(id);
		
		if (isNaN(pos)) pos = self.p_tbody.childNodes.length+1; else if (pos < 1) pos = 1;
		if (pos > self.p_tbody.childNodes.length) self.p_tbody.appendChild(this.obj.tr); else self.p_tbody.insertBefore(this.obj.tr, self.p_tbody.childNodes[pos-1]);
		
		this.obj.td_a = document.createElement("TD");
		this.obj.td_a.className = "td_btn_img";
		this.obj.td_a.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		this.obj.td_b = document.createElement("TD");
		this.obj.td_b.className = "td_btn_txt";
		this.obj.td_b.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		
		if (that.rtl) {
			this.obj.tr.appendChild(this.obj.td_b);
			this.obj.tr.appendChild(this.obj.td_a);
		} else {
			this.obj.tr.appendChild(this.obj.td_a);
			this.obj.tr.appendChild(this.obj.td_b);
		}
		
		// image
		if (data.img != null) {
			if (that.conf.icons_css == true) {
				this.obj.td_a.innerHTML = "<i class='"+that.conf.icons_path+data.img+"'></i>";
			} else {
				this.obj.td_a.innerHTML = "<img class='btn_sel_img' src='"+that.conf.icons_path+data.img+"' border='0'>";
			}
			this.obj.tr._img = data.img;
		} else {
			this.obj.td_a.innerHTML = "&nbsp;";
		}
		
		// text
		var itemText = (data.text!=null?data.text:(data.itemText||""));
		this.obj.td_b.innerHTML = "<div class='btn_sel_text'>"+itemText+"</div>";
		
		this.obj.tr.onmouseover = function(e) {
			e = e||event;
			if (e.type.match(/touch/) != null) return;
			if (!this.en || (this._selected && self.renderSelect)) return;
			this.className = "tr_btn tr_btn_over";
		}
		
		this.obj.tr.onmouseout = function(e) {
			e = e||event;
			if (e.type.match(/touch/) != null) return;
			if (!this.en) return;
			if (this._selected && self.renderSelect) {
				if (String(this.className).search("tr_btn_selected") == -1) this.className = "tr_btn tr_btn_selected";
			} else {
				this.className = "tr_btn";
			}
		}
		
		this.obj.tr.ontouchstart = this.obj.tr.onmousedown = function(e) {
			e = e||event;
			if (this._etype == null) this._etype = e.type;
		}
		this.obj.tr.onclick = function(e) {
			
			e = e||event;
			e.cancelBubble = true;
			if (!this.en) return;
			
			self.setListOptionSelected(this.idd.replace(that.idPrefix,""));
			
			self.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
			self.arw.className = "dhx_toolbar_arw dhxtoolbar_btn_def";
			self.obj.over = false;
			
			if (this._etype != null && this._etype.match(/touch/) == null) {
				window.dhx4.zim.clear(self.polygon._idd);
				self.polygon.style.display = "none";
				if (self.polygon._ie6cover) self.polygon._ie6cover.style.display = "none";
			} else {
				var p = self.polygon;
				window.setTimeout(function(){
					window.dhx4.zim.clear(p._idd);
					p.style.display = "none";
					p = null;
				}, 500);
			}
			this._etype = null;
			
			// fix border
			if (that.conf.skin == "dhx_terrace") that._improveTerraceButtonSelect(self.id, true);
			that.anyUsed = null;
			that.conf.touch_id = null;
			// event
			that.callEvent("onButtonSelectHide", [self.obj.idd]);
			// event
			var id = this.idd.replace(that.idPrefix,"");
			if (this.extAction) try {window[this.extAction](id);} catch(e){};
			that.callEvent("onClick", [id]);
		}		
		self._listOptions[id] = this.obj;
		
		return this;
		
	}
	
	// add polygon
	this.polygon = document.createElement("DIV");
	this.polygon.dir = "ltr";
	this.polygon.style.display = "none";
	this.polygon.className = "dhx_toolbar_poly_"+that.conf.skin+" dhxtoolbar_icons_"+that.conf.iconSize+that.conf.cssShadow;
	this.polygon.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	this.polygon.onmousedown = function(e) { e = e||event; e.cancelBubble = true; }
	this.polygon.style.overflowY = "auto";
	this.polygon._idd = window.dhx4.newId();
	
	this.polygon.ontouchstart = function(e){
		e = e||event;
		e.cancelBubble = true;
	}
	this.polygon.ontouchend = function(e){
		e = e||event;
		e.cancelBubble = true;
	}
	
	this.p_tbl = document.createElement("TABLE");
	this.p_tbl.className = "buttons_cont";
	this.p_tbl.cellSpacing = "0";
	this.p_tbl.cellPadding = "0";
	this.p_tbl.border = "0";
	this.polygon.appendChild(this.p_tbl);
	
	this.p_tbody = document.createElement("TBODY");
	this.p_tbl.appendChild(this.p_tbody);
	
	//
	if (data.options != null) {
		for (var q=0; q<data.options.length; q++) {
			var t = "_"+(data.options[q].type||"")+"ButtonSelectObject";
			if (data.options[q].id == null) data.options[q].id = that._genStr(24);
			if (typeof(this[t]) == "function") new this[t](data.options[q].id, data.options[q]);
		}
	}
	
	document.body.appendChild(this.polygon);
	
	// add poly ie6cover
	if (window.dhx4.isIE6) {
		this.polygon._ie6cover = document.createElement("IFRAME");
		this.polygon._ie6cover.frameBorder = 0;
		this.polygon._ie6cover.style.position = "absolute";
		this.polygon._ie6cover.style.border = "none";
		this.polygon._ie6cover.style.backgroundColor = "#000000";
		this.polygon._ie6cover.style.filter = "alpha(opacity=100)";
		this.polygon._ie6cover.style.display = "none";
		this.polygon._ie6cover.setAttribute("src","javascript:false;");
		document.body.appendChild(this.polygon._ie6cover);
	}
	
	// functions
	// new engine
	this.setWidth = function(width) {
		this.obj.style.width = width-this.arw.offsetWidth+"px";
		this.polygon.style.width = this.obj.offsetWidth+this.arw.offsetWidth-2+"px";
		this.p_tbl.style.width = this.polygon.style.width;
	}
	this.enableItem = function() {
		that._enableItem(this);
	}
	this.disableItem = function() {
		that._disableItem(this);
	}
	this.isEnabled = function() {
		return this.state;
	}
	this.showItem = function() {
		this.obj.style.display = "";
		this.arw.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
		this.arw.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setItemText = function(text) {
		that._setItemText(this, text);
	}
	this.getItemText = function() {
		return that._getItemText(this);
	}
	this.setItemImage = function(url) {
		that._setItemImage(this, url, true);
	}
	this.clearItemImage = function() {
		that._clearItemImage(this, true);
	}
	this.setItemImageDis = function(url) {
		that._setItemImage(this, url, false);
	}
	this.clearItemImageDis = function() {
		that._clearItemImage(this, false);
	}
	this.setItemToolTip = function(tip) {
		this.obj.title = tip;
		this.arw.title = tip;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	/* list option functions */
	// new engine
	this.addListOption = function(id, pos, type, text, img) {
		if (!(type == "button" || type == "separator")) return;
		var dataItem = {id:id,type:type,text:text,img:img};
		new this["_"+type+"ButtonSelectObject"](id, dataItem, pos);
	}
	// new engine
	this.removeListOption = function(id) {
		if (!this._isListButton(id, true)) return;
		var item = this._listOptions[id];
		if (item.td_a != null && item.td_b != null) {
			// button
			item.td_a.onselectstart = null;
			item.td_b.onselectstart = null;
			while (item.td_a.childNodes.length > 0) item.td_a.removeChild(item.td_a.childNodes[0]);
			while (item.td_b.childNodes.length > 0) item.td_b.removeChild(item.td_b.childNodes[0]);
			item.tr.onselectstart = null;
			item.tr.onmouseover = null;
			item.tr.onmouseout = null;
			item.tr.onclick = null;
			item.tr.ontouchstart = null;
			item.tr.onmousedown = null;
			while (item.tr.childNodes.length > 0) item.tr.removeChild(item.tr.childNodes[0]);
			item.tr.parentNode.removeChild(item.tr);
			item.td_a = null;
			item.td_b = null;
			item.tr = null;
		} else {
			// separator
			item.sep.onselectstart = null;
			item.td.onselectstart = null;
			item.tr.onselectstart = null;
			while (item.td.childNodes.length > 0) item.td.removeChild(item.td.childNodes[0]);
			while (item.tr.childNodes.length > 0) item.tr.removeChild(item.tr.childNodes[0]);
			item.tr.parentNode.removeChild(item.tr);
			item.sep = null;
			item.td = null;
			item.tr = null;
		}
		item = null;
		this._listOptions[id] = null;
		try { delete this._listOptions[id]; } catch(e) {}
	}
	// new engine
	this.showListOption = function(id) {
		if (!this._isListButton(id, true)) return;
		this._listOptions[id].tr.style.display = "";
	}
	// new engine
	this.hideListOption = function(id) {
		if (!this._isListButton(id, true)) return;
		this._listOptions[id].tr.style.display = "none";
	}
	// new engine
	this.isListOptionVisible = function(id) {
		if (!this._isListButton(id, true)) return;
		return (this._listOptions[id].tr.style.display != "none");
	}
	// new engine
	this.enableListOption = function(id) {
		if (!this._isListButton(id)) return;
		this._listOptions[id].tr.en = true;
		this._listOptions[id].tr.className = "tr_btn"+(this._listOptions[id].tr._selected&&that.renderSelect?" tr_btn_selected":"");
	}
	// new engine
	this.disableListOption = function(id) {
		if (!this._isListButton(id)) return;
		this._listOptions[id].tr.en = false;
		this._listOptions[id].tr.className = "tr_btn tr_btn_disabled";
	}
	// new engine
	this.isListOptionEnabled = function(id) {
		if (!this._isListButton(id)) return;
		return this._listOptions[id].tr.en;
	}
	// new engine
	this.setListOptionPosition = function(id, pos) {
		if (!this._listOptions[id] || this.getListOptionPosition(id) == pos || isNaN(pos)) return;
		if (pos < 1) pos = 1;
		var tr = this._listOptions[id].tr;
		this.p_tbody.removeChild(tr);
		if (pos > this.p_tbody.childNodes.length) this.p_tbody.appendChild(tr); else this.p_tbody.insertBefore(tr, this.p_tbody.childNodes[pos-1]);
		tr = null;
	}
	// new engine
	this.getListOptionPosition = function(id) {
		var pos = -1;
		if (!this._listOptions[id]) return pos;
		for (var q=0; q<this.p_tbody.childNodes.length; q++) if (this.p_tbody.childNodes[q] == this._listOptions[id].tr) pos=q+1;
		return pos;
	}
	// new engine
	this.setListOptionImage = function(id, img) {
		if (!this._isListButton(id)) return;
		var td = this._listOptions[id].tr.childNodes[(that.rtl?1:0)];
		td.innerHTML = (that.conf.icons_css?"<i class='"+that.conf.icons_path+img+"'></i>":"<img src='"+that.conf.icons_path+img+"' class='btn_sel_img'>");
		td = null;
	}
	// new engine
	this.getListOptionImage = function(id) {
		if (!this._isListButton(id)) return;
		var td = this._listOptions[id].tr.childNodes[(that.rtl?1:0)];
		var src = null;
		if (td.childNodes.length > 0) src = td.childNodes[0][(that.conf.icons_css?"className":"src")];
		td = null;
		return src;
	}
	// new engine
	this.clearListOptionImage = function(id) {
		if (!this._isListButton(id)) return;
		var td = this._listOptions[id].tr.childNodes[(that.rtl?1:0)];
		while (td.childNodes.length > 0) td.removeChild(td.childNodes[0]);
		td.innerHTML = "&nbsp;";
		td = null;
	}
	// new engine
	this.setListOptionText = function(id, text) {
		if (!this._isListButton(id)) return;
		this._listOptions[id].tr.childNodes[(that.rtl?0:1)].childNodes[0].innerHTML = text;
	}
	// new engine
	this.getListOptionText = function(id) {
		if (!this._isListButton(id)) return;
		return this._listOptions[id].tr.childNodes[(that.rtl?0:1)].childNodes[0].innerHTML;
	}
	// new engine
	this.setListOptionToolTip = function(id, tip) {
		if (!this._isListButton(id)) return;
		this._listOptions[id].tr.title = tip;
	}
	// new engine
	this.getListOptionToolTip = function(id) {
		if (!this._isListButton(id)) return;
		return this._listOptions[id].tr.title;
	}
	// works
	this.forEachListOption = function(handler) {
		for (var a in this._listOptions) handler(a);
	}
	// works, return array with ids
	this.getAllListOptions = function() {
		var listData = new Array();
		for (var a in this._listOptions) listData[listData.length] = a;
		return listData;
	}
	// new engine
	this.setListOptionSelected = function(id) {
		for (var a in this._listOptions) {
			var item = this._listOptions[a];
			if (item.td_a != null && item.td_b != null && item.tr.en) {
				if (a == id) {
					item.tr._selected = true;
					item.tr.className = "tr_btn"+(this.renderSelect?" tr_btn_selected":"");
					//
					if (this.mode == "select") {
						if (item.tr._img) this.setItemImage(item.tr._img); else this.clearItemImage();
						this.setItemText(this.getListOptionText(id));
					}
				} else {
					item.tr._selected = false;
					item.tr.className = "tr_btn";
				}
			}
			item = null;
		}
	}
	// new engine
	this.getListOptionSelected = function() {
		var id = null;
		for (var a in this._listOptions) if (this._listOptions[a].tr._selected == true) id = a;
		return id;
	}
	// inner, return tru if list option is button and is exists
	this._isListButton = function(id, allowSeparator) {
		if (this._listOptions[id] == null) return false;
		if (!allowSeparator && this._listOptions[id].tr.className == "tr_sep") return false;
		return true;
	}
	
	this.setMaxOpen = function(r) {
		this._ph = null;
		if (typeof(r) == "number") {
			this.maxOpen = r;
			this._maxOpenTest();
			return;
		}
		this.maxOpen = null;
	}
	
	if (data.width) this.setWidth(data.width);
	
	if (this.mode == "select" && typeof(data.selected) != "undefined") this.setListOptionSelected(data.selected);
	
	//
	return this;
}

/*****************************************************************************************************************************************************************
	object: buttonInput
***************************************************************************************************************************************************************** */
dhtmlXToolbarObject.prototype._buttonInputObject = function(that, id, data) {
	//
	this.id = that.idPrefix+id;
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.idd = String(id);
	this.obj.w = (data.width!=null?data.width:100);
	this.obj.title = (data.title!=null?data.title:"");
	//
	this.obj.innerHTML = "<input class='dhxtoolbar_input' type='text' style='width:"+this.obj.w+"px;'"+(data.value!=null?" value='"+data.value+"'":"")+">";
	
	var th = that;
	var self = this;
	this.obj.childNodes[0].onkeydown = function(e) {
		e = e||event;
		if (e.keyCode == 13) { th.callEvent("onEnter", [self.obj.idd, this.value]); }
	}
	// add
	that.base.appendChild(this.obj);
	//
	this.enableItem = function() {
		this.obj.childNodes[0].disabled = false;
	}
	this.disableItem = function() {
		this.obj.childNodes[0].disabled = true;
	}
	this.isEnabled = function() {
		return (!this.obj.childNodes[0].disabled);
	}
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display != "none");
	}
	this.setValue = function(value) {
		this.obj.childNodes[0].value = value;
	}
	this.getValue = function() {
		return this.obj.childNodes[0].value;
	}
	this.setWidth = function(width) {
		this.obj.w = width;
		this.obj.childNodes[0].style.width = this.obj.w+"px";
	}
	this.getWidth = function() {
		return this.obj.w;
	}
	this.setItemToolTip = function(tip) {
		this.obj.title = tip;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	this.getInput = function() {
		return this.obj.firstChild;
	}
	
	if (typeof(data.enabled) != "undefined" && window.dhx4.s2b(data.enabled) == false) {
		this.disableItem();
	}
	
	//
	return this;
}

/*****************************************************************************************************************************************************************
	object: buttonTwoState
***************************************************************************************************************************************************************** */
dhtmlXToolbarObject.prototype._buttonTwoStateObject = function(that, id, data) {
	this.id = that.idPrefix+id;
	this.state = (data.enabled!=null?false:true);
	this.imgEn = (data.img!=null?data.img:"");
	this.imgDis = (data.imgdis!=null?data.imgdis:"");
	this.img = (this.state?(this.imgEn!=""?this.imgEn:""):(this.imgDis!=""?this.imgDis:""));
	//
	this.obj = document.createElement("DIV");
	this.obj.pressed = (data.selected!=null);
	this.obj.extAction = (data.action||null);
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.obj.pressed?"pres"+(this.state?"":"_dis"):(this.state?"def":"dis"));
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.renderAs = this.obj.className;
	this.obj.idd = String(id);
	this.obj.title = (data.title||"");
	if (this.obj.pressed) { this.obj.renderAs = "dhx_toolbar_btn dhxtoolbar_btn_over"; }
	
	var img = (that.conf.icons_css?"<i class='"+that.conf.icons_path+this.img+"'></i>":"<img src='"+that.conf.icons_path+this.img+"'>");
	this.obj.innerHTML = that._rtlParseBtn((this.img!=""?img:""),(data.text!=null?"<div class='dhxtoolbar_text'>"+data.text+"</div>":""));
	
	// add object
	that.base.appendChild(this.obj);
	
	if (window.dhx4.isIE) {
		this.obj.onselectstart = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
	}
	
	var t = this;
	this._doOnMouseOver = function(e) {
		e = e||event;
		if (t.state == false || t.obj.over == true) return;
		if (t.obj.pressed != true && t.obj.className.match(/dhxtoolbar_btn_over/gi) == null) t.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_over";
		t.obj.over = true;
	}
	
	this._doOnMouseOut = function(e) {
		e = e||event;
		if (t.state == false) return;
		if (t.obj.pressed != true && t.obj.className.match(/dhxtoolbar_btn_over/gi) != null) t.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
		t.obj.over = false;
	}
	
	this._doOnMouseDown = function(e) {
		e = e||event;
		if (e.type == "touchstart") {
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			if (that.conf.touch_id != null && that.conf.touch_id != t.id) return; // multiple touches?
			that.conf.touch_id = t.id;
		}
		if (t.state == false) return;
		if (that.callEvent("onBeforeStateChange", [t.obj.idd.replace(that.idPrefix, ""), t.obj.pressed]) !== true) return;
		t.obj.pressed = !t.obj.pressed;
		t.obj.className = "dhx_toolbar_btn " + (t.obj.pressed == true ? "dhxtoolbar_btn_pres" : (t.obj.over == true? "dhxtoolbar_btn_over" : "dhxtoolbar_btn_def"));
		//
		var id = t.obj.idd.replace(that.idPrefix, "");
		if (t.obj.extAction) try {window[t.obj.extAction](idd, t.obj.pressed);} catch(e){};
		that.callEvent("onStateChange", [id, t.obj.pressed]);
	}
	this._doOnMouseUp = function(e) {
		e = e||event;
		if (e.type == "touchend") {
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			if (that.conf.touch_id == t.id) that.conf.touch_id = null;
		}
	}
	
	
	// mouse events
	this.obj.evs = {
		mouseover: "_doOnMouseOver",
		mouseout: "_doOnMouseOut",
		mousedown: "_doOnMouseDown",
		touchstart: "_doOnMouseDown",
		touchend: "_doOnMouseUp"
	};
	
	that._evs.add.apply(this, [this.obj.evs, this.obj]);
	
	// functions
	this.setItemState = function(state, callEvent) {
		if (this.obj.pressed != state) {
			if (state == true) {
				this.obj.pressed = true;
				this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_pres"+(this.state?"":"_dis");
			} else {
				this.obj.pressed = false;
				this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.state?"def":"dis");
			}
			if (callEvent == true) {
				var id = this.obj.idd.replace(that.idPrefix, "");
				if (this.obj.extAction) try {window[this.obj.extAction](id, this.obj.pressed);} catch(e){};
				that.callEvent("onStateChange", [id, this.obj.pressed]);
			}
		}
	}
	this.getItemState = function() {
		return this.obj.pressed;
	}
	this.enableItem = function() {
		that._enableItem(this);
	}
	this.disableItem = function() {
		that._disableItem(this);
	}
	this.isEnabled = function() {
		return this.state;
	}
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setItemText = function(text) {
		that._setItemText(this, text);
	}
	this.getItemText = function() {
		return that._getItemText(this);
	}
	this.setItemImage = function(url) {
		that._setItemImage(this, url, true);
	}
	this.clearItemImage = function() {
		that._clearItemImage(this, true);
	}
	this.setItemImageDis = function(url) {
		that._setItemImage(this, url, false);
	}
	this.clearItemImageDis = function() {
		that._clearItemImage(this, false);
	}
	this.setItemToolTip = function(tip) {
		this.obj.title = tip;
	}
	this.getItemToolTip = function() {
		return this.obj.title;
	}
	//
	return this;
}

/*****************************************************************************************************************************************************************
	object: slider
***************************************************************************************************************************************************************** */
dhtmlXToolbarObject.prototype._sliderObject = function(that, id, data) {
	this.id = that.idPrefix+id;
	this.state = (data.enabled!=null?(data.enabled=="true"?true:false):true);
	this.obj = document.createElement("DIV");
	this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_"+(this.state?"def":"dis");
	this.obj.style.display = (data.hidden!=null?"none":"");
	this.obj.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	this.obj.idd = String(id);
	this.obj.len = (data.length!=null?Number(data.length):50);
	//
	this.obj.innerHTML = "<div class='dhxtoolbar_text'>"+(data.textMin||"")+"</div>"+
				"<div class='dhxtoolbar_sl_bg_l'></div>"+
				"<div class='dhxtoolbar_sl_bg_m' style='width:"+this.obj.len+"px;'></div>"+
				"<div class='dhxtoolbar_sl_bg_r'></div>"+
				"<div class='dhxtoolbar_text'>"+(data.textMax||"")+"</div>";
	// add object
	that.base.appendChild(this.obj);
	var self = this;
	
	this.pen = document.createElement("DIV");
	this.pen.className = "dhxtoolbar_sl_pen";
	this.obj.appendChild(this.pen);
	var pen = this.pen;
	
	this.label = document.createElement("DIV");
	this.label.dir = "ltr";
	this.label.className = "dhx_toolbar_slider_label_"+that.conf.skin+(that.rtl?"_rtl":"");
	this.label.style.display = "none";
	this.label.tip = (data.toolTip||"%v");
	this.label._zi = window.dhx4.newId();
	document.body.appendChild(this.label);
	var label = this.label;
	
	// mix-max value
	this.pen.valueMin = (data.valueMin!=null?Number(data.valueMin):0);
	this.pen.valueMax = (data.valueMax!=null?Number(data.valueMax):100);
	if (this.pen.valueMin > this.pen.valueMax) this.pen.valueMin = this.pen.valueMax;
	
	// init value
	this.pen.valueNow = (data.valueNow!=null?Number(data.valueNow):this.pen.valueMax);
	if (this.pen.valueNow > this.pen.valueMax) this.pen.valueNow = this.pen.valueMax;
	if (this.pen.valueNow < this.pen.valueMin) this.pen.valueNow = this.pen.valueMin;
	
	// min/max x coordinate
	this.pen._detectLimits = function() {
		this.minX = self.obj.childNodes[1].offsetLeft+2;
		this.maxX = self.obj.childNodes[3].offsetLeft-this.offsetWidth+1;
	}
	this.pen._detectLimits();
	
	// position
	this.pen._definePos = function() {
		this.nowX = Math.round((this.valueNow-this.valueMin)*(this.maxX-this.minX)/(this.valueMax-this.valueMin)+this.minX);
		this.style.left = this.nowX+"px";
		this.newNowX = this.nowX;
	}
	this.pen._definePos();

	this.pen.initXY = 0;
	this.pen.allowMove = false;
	this.pen[window.dhx4.isIPad?"ontouchstart":"onmousedown"] = function(e) {
		if (self.state == false) return;
		e = e||event;
		this.initXY = (window.dhx4.isIPad?e.touches[0].clientX:e.clientX); //e.clientX;
		this.newValueNow = this.valueNow;
		this.allowMove = true;
		this.className = "dhxtoolbar_sl_pen dhxtoolbar_over";
		if (label.tip != "") {
			label.style.visibility = "hidden";
			label.style.display = "";
			label.innerHTML = label.tip.replace("%v", this.valueNow);
			label.style.left = Math.round(window.dhx4.absLeft(this)+this.offsetWidth/2-label.offsetWidth/2)+"px";
			label.style.top = window.dhx4.absTop(this)-label.offsetHeight-3+"px";
			label.style.visibility = "";
			label.style.zIndex = window.dhx4.zim.reserve(label._zi);
		}
	}
	
	this.pen._doOnMouseMoveStart = function(e) {
		// optimized for destructor
		e=e||event;
		if (!pen.allowMove) return;
		var ecx = (window.dhx4.isIPad?e.touches[0].clientX:e.clientX);
		var ofst = ecx - pen.initXY;
		
		// mouse goes out to left/right from pen
		if (ecx < window.dhx4.absLeft(pen)+Math.round(pen.offsetWidth/2) && pen.nowX == pen.minX) return;
		if (ecx > window.dhx4.absLeft(pen)+Math.round(pen.offsetWidth/2) && pen.nowX == pen.maxX) return;
		
		pen.newNowX = pen.nowX + ofst;
		
		if (pen.newNowX < pen.minX) pen.newNowX = pen.minX;
		if (pen.newNowX > pen.maxX) pen.newNowX = pen.maxX;
		pen.nowX = pen.newNowX;
		pen.style.left = pen.nowX+"px";
		pen.initXY = ecx;
		pen.newValueNow = Math.round((pen.valueMax-pen.valueMin)*(pen.newNowX-pen.minX)/(pen.maxX-pen.minX)+pen.valueMin);
		if (label.tip != "") {
			label.innerHTML = label.tip.replace(/%v/gi, pen.newValueNow);
			label.style.left = Math.round(window.dhx4.absLeft(pen)+pen.offsetWidth/2-label.offsetWidth/2)+"px";
			label.style.top = window.dhx4.absTop(pen)-label.offsetHeight-3+"px";
		}
		e.cancelBubble = true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	}
	this.pen._doOnMouseMoveEnd = function() {
		if (!pen.allowMove) return;
		pen.className = "dhxtoolbar_sl_pen";
		pen.allowMove = false;
		pen.nowX = pen.newNowX;
		pen.valueNow = pen.newValueNow;
		if (label.tip != "") {
			label.style.display = "none";
			window.dhx4.zim.clear(label._zi);
		}
		that.callEvent("onValueChange", [self.obj.idd.replace(that.idPrefix, ""), pen.valueNow]);
	}
	
	if (window.dhx4.isIPad) {
		document.addEventListener("touchmove", pen._doOnMouseMoveStart, false);
		document.addEventListener("touchend", pen._doOnMouseMoveEnd, false);
	} else {
		if (typeof(window.addEventListener) != "undefined") {
			window.addEventListener("mousemove", pen._doOnMouseMoveStart, false);
			window.addEventListener("mouseup", pen._doOnMouseMoveEnd, false);
		} else {
			document.body.attachEvent("onmousemove", pen._doOnMouseMoveStart);
			document.body.attachEvent("onmouseup", pen._doOnMouseMoveEnd);
		}
	}
	// functions
	this.enableItem = function() {
		if (this.state) return;
		this.state = true;
		this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_def";
	}
	this.disableItem = function() {
		if (!this.state) return;
		this.state = false;
		this.obj.className = "dhx_toolbar_btn dhxtoolbar_btn_dis";
	}
	this.isEnabled = function() {
		return this.state;
	}
	this.showItem = function() {
		this.obj.style.display = "";
	}
	this.hideItem = function() {
		this.obj.style.display = "none";
	}
	this.isVisible = function() {
		return (this.obj.style.display == "");
	}
	this.setValue = function(value, callEvent) {
		value = Number(value);
		if (value < this.pen.valueMin) value = this.pen.valueMin;
		if (value > this.pen.valueMax) value = this.pen.valueMax;
		this.pen.valueNow = value;
		this.pen._definePos();
		if (callEvent == true) that.callEvent("onValueChange", [this.obj.idd.replace(that.idPrefix, ""), this.pen.valueNow]);
	}
	this.getValue = function() {
		return this.pen.valueNow;
	}
	this.setMinValue = function(value, label) {
		value = Number(value);
		if (value > this.pen.valueMax) return;
		this.obj.childNodes[0].innerHTML = label;
		this.obj.childNodes[0].style.display = (label.length>0?"":"none");
		this.pen.valueMin = value;
		if (this.pen.valueNow < this.pen.valueMin) this.pen.valueNow = this.pen.valueMin;
		this.pen._detectLimits();
		this.pen._definePos();
	}
	this.setMaxValue = function(value, label) {
		value = Number(value);
		if (value < this.pen.valueMin) return;
		this.obj.childNodes[4].innerHTML = label;
		this.obj.childNodes[4].style.display = (label.length>0?"":"none");
		this.pen.valueMax = value;
		if (this.pen.valueNow > this.pen.valueMax) this.pen.valueNow = this.pen.valueMax;
		this.pen._detectLimits();
		this.pen._definePos();
	}
	this.getMinValue = function() {
		var label = this.obj.childNodes[0].innerHTML;
		var value = this.pen.valueMin;
		return new Array(value, label);
	}
	this.getMaxValue = function() {
		var label = this.obj.childNodes[4].innerHTML;
		var value = this.pen.valueMax;
		return new Array(value, label);
	}
	this.setItemToolTipTemplate = function(template) {
		this.label.tip = template;
	}
	this.getItemToolTipTemplate = function() {
		return this.label.tip;
	}
	//
	return this;
}

dhtmlXToolbarObject.prototype.unload = function() {
	
	if (typeof(window.addEventListener) == "function") {
		window.removeEventListener("mousedown", this._doOnClick, false);
		window.removeEventListener("touchstart", this._doOnClick, false);
	} else {
		document.body.detachEvent("onmousedown", this._doOnClick);
	}
	
	this._doOnClick = null;
	
	this.clearAll();
	this.objPull = null;
	
	if (this._xmlLoader) {
		this._xmlLoader.destructor();
		this._xmlLoader = null;
	}
	
	while (this.base.childNodes.length > 0) this.base.removeChild(this.base.childNodes[0]);
	this.cont.removeChild(this.base);
	this.base = null;
	
	while (this.cont.childNodes.length > 0) this.cont.removeChild(this.cont.childNodes[0]);
	this.cont.className = "";
	this.cont = null;
	
	window.dhx4._enableDataLoading(this, null, null, null, "clear");
	window.dhx4._eventable(this, "clear");
	
	this.tX1 = null;
	this.tX2 = null;
	this.tY1 = null;
	this.tY2 = null;
	
	this.anyUsed = null;
	this.idPrefix = null;
	this.rootTypes = null;
	
	this._rtl = null;
	this._rtlParseBtn = null;
	this.setRTL = null;
	
	this._sbw = null;
	this._getObj = null;
	this._addImgObj = null;
	this._setItemImage = null;
	this._clearItemImage = null;
	this._setItemText = null;
	this._getItemText = null;
	this._enableItem = null;
	this._disableItem = null;
	this._xmlParser = null;
	
	this._addItemToStorage = null;
	this._genStr = null;
	this._addItem = null;
	this._getPosition = null;
	this._setPosition = null;
	this._getIdByPosition = null;
	this._separatorObject = null;
	this._textObject = null;
	this._buttonObject = null;
	this._buttonSelectObject = null;
	this._buttonInputObject = null;
	this._buttonTwoStateObject = null;
	this._sliderObject = null;
	this._autoDetectVisibleArea = null;
	this._removeItem = null;
	this.setAlign = null;
	this.setSkin = null;
	this.setIconsPath = null;
	this.setIconPath = null;
	this.loadXML = null;
	this.loadXMLString = null;
	this.clearAll = null;
	this.addSpacer = null;
	this.removeSpacer = null;
	this.getType = null;
	this.getTypeExt = null;
	this.inArray = null;
	this.getParentId = null;
	this.addButton = null;
	this.addText = null;
	this.addButtonSelect = null;
	this.addButtonTwoState = null;
	this.addSeparator = null;
	this.addSlider = null;
	this.addInput = null;
	this.forEachItem = null;
	this.showItem = null;
	this.hideItem = null;
	this.isVisible = null;
	this.enableItem = null;
	this.disableItem = null;
	this.isEnabled = null;
	this.setItemText = null;
	this.getItemText = null;
	this.setItemToolTip = null;
	this.getItemToolTip = null;
	this.setItemImage = null;
	this.setItemImageDis = null;
	this.clearItemImage = null;
	this.clearItemImageDis = null;
	this.setItemState = null;
	this.getItemState = null;
	this.setItemToolTipTemplate = null;
	this.getItemToolTipTemplate = null;
	this.setValue = null;
	this.getValue = null;
	this.setMinValue = null;
	this.getMinValue = null;
	this.setMaxValue = null;
	this.getMaxValue = null;
	this.setWidth = null;
	this.getWidth = null;
	this.getPosition = null;
	this.setPosition = null;
	this.removeItem = null;
	this.addListOption = null;
	this.removeListOption = null;
	this.showListOption = null;
	this.hideListOption = null;
	this.isListOptionVisible = null;
	this.enableListOption = null;
	this.disableListOption = null;
	this.isListOptionEnabled = null;
	this.setListOptionPosition = null;
	this.getListOptionPosition = null;
	this.setListOptionText = null;
	this.getListOptionText = null;
	this.setListOptionToolTip = null;
	this.getListOptionToolTip = null;
	this.setListOptionImage = null;
	this.getListOptionImage = null;
	this.clearListOptionImage = null;
	this.forEachListOption = null;
	this.getAllListOptions = null;
	this.setListOptionSelected = null;
	this.getListOptionSelected = null;
	this.unload = null;
	this.setUserData = null;
	this.getUserData = null;
	this.setMaxOpen = null;
	this.items = null;
	this.conf = null;
};

dhtmlXToolbarObject.prototype._autoDetectVisibleArea = function() {
	var d = window.dhx4.screenDim();
	this.tX1 = d.left;
	this.tX2 = d.right;
	this.tY1 = d.top;
	this.tY2 = d.bottom;
};

dhtmlXToolbarObject.prototype.setIconset = function(name) {
	this.conf.icons_css = (name=="awesome");
};
dhtmlXToolbarObject.prototype._evs = {
	add: function(evs, obj) { // this->calle
		for (var a in evs) {
			if (typeof(window.addEventListener) == "function") {
				obj.addEventListener(a, this[evs[a]], false);
			} else if (a.match(/^touch/) == null) {
				obj.attachEvent("on"+a, this[evs[a]]);
			}
		}
		obj = evs = null;
	},
	clear: function(evs, obj) {
		for (var a in evs) {
			if (typeof(window.addEventListener) == "function") {
				obj.removeEventListener(a, this[evs[a]], false);
			} else if (a.match(/^touch/) == null) {
				obj.detachEvent("on"+a, this[evs[a]]);
			}
		}
		obj = evs = null;
	}
};
dhtmlXToolbarObject.prototype._initObj = function(data) {
	for (var q=0; q<data.length; q++) this._addItemToStorage(data[q]);
	if (this.conf.skin == "dhx_terrace") this._improveTerraceSkin();
};

dhtmlXToolbarObject.prototype._xmlToJson = function(xml) {
	
	var data = [];
	var root = xml.getElementsByTagName("toolbar");
	
	if (root != null && root[0] != null) {
		
		root = root[0];
		
		var getExtText = function(node) {
			var t = null;
			for (var q=0; q<node.childNodes.length; q++) {
				if (t == null && node.childNodes[q].tagName == "itemText") {
					t = window.dhx4._xmlNodeValue(node.childNodes[q]);
					break;
				}
			}
			return t;
		}
		
		var t = ["id", "type", "hidden", "title", "text", "enabled", "img", "imgdis", "action", "openAll", "renderSelect", "mode", "maxOpen", "width", "value", "selected", "length", "textMin", "textMax", "toolTip", "valueMin", "valueMax", "valueNow"];
		var p = ["id", "type", "enabled", "disabled", "action", "selected", "img", "text"];
		//
		for (var q=0; q<root.childNodes.length; q++) {
			if (root.childNodes[q].tagName == "item") {
				
				var itemData = {};
				for (var w=0; w<t.length; w++) {
					var val = root.childNodes[q].getAttribute(t[w]);
					if (val != null) itemData[t[w]] = val;
				}
				
				for (var e=0; e<root.childNodes[q].childNodes.length; e++) {
					if (root.childNodes[q].childNodes[e].tagName == "item" && itemData.type == "buttonSelect") {
						var u = {};
						for (var w=0; w<p.length; w++) {
							var val = root.childNodes[q].childNodes[e].getAttribute(p[w]);
							if (val != null) u[p[w]] = val;
						}
						// listed options userdata
						var h = root.childNodes[q].childNodes[e].getElementsByTagName("userdata");
						for (var w=0; w<h.length; w++) {
							if (!u.userdata) u.userdata = {};
							var r = {};
							try { r.name = h[w].getAttribute("name"); } catch(k) { r.name = null; }
							try { r.value = h[w].firstChild.nodeValue; } catch(k) { r.value = ""; }
							if (r.name != null) u.userdata[r.name] = r.value;
						}
						// get extended <itemText>
						u.text = getExtText(root.childNodes[q].childNodes[e])||u.text;
						//
						if (itemData.options == null) itemData.options = [];
						itemData.options.push(u);
					}
					
					// items userdata
					if (root.childNodes[q].childNodes[e].tagName == "userdata") {
						if (itemData.userdata == null) itemData.userdata = {};
						var u = {};
						try { u.name = root.childNodes[q].childNodes[e].getAttribute("name"); } catch(k) { u.name = null; }
						try { u.value = root.childNodes[q].childNodes[e].firstChild.nodeValue; } catch(k) { u.value = ""; }
						if (u.name != null) itemData.userdata[u.name] = u.value;
					}
				}
				
				// get extended <itemText>
				itemData.text = getExtText(root.childNodes[q])||itemData.text;
				
				data.push(itemData);
			}
		}
		
		getExtText = null;
	}
	
	return data;
};

dhtmlXToolbarObject.prototype._addItemToStorage = function(data, pos) {
	
	var id = (data.id||this._genStr(24));
	var type = (data.type||"");
	
	if (type == "spacer") {
		this.addSpacer(this._lastId);
	} else {
		this._lastId = id;
	}
	
	if (type != "" && this["_"+type+"Object"] != null) {
		
		if (type == "buttonSelect") {
			if (data.options != null) {
				for (var q=0; q<data.options.length; q++) { // js-array button select init used obj/sep
					if (data.options[q].type == "obj") data.options[q].type = "button";
					if (data.options[q].type == "sep") data.options[q].type = "separator";
				}
			}
		}
		
		if (type == "slider") {
			var k = {
				tip_template: "toolTip",
				value_min: "valueMin",
				value_max: "valueMax",
				value_now: "valueNow",
				text_min: "textMin",
				text_max: "textMax"
			};
			for (var a in k) {
				if (data[k[a]] == null && data[a] != null) data[k[a]] = data[a];
			}
		}
		
		if (type == "buttonInput") {
			if (data.value == null && data.text != null) data.value = data.text;
		}
		
		if (type == "buttonTwoState") {
			if (typeof(data.selected) == "undefined" && typeof(data.pressed) != "undefined" && window.dhx4.s2b(data.pressed)) {
				data.selected = true;
			}
		}
		
		// common
		if (typeof(data.enabled) == "undefined" && typeof(data.disabled) != "undefined" && window.dhx4.s2b(data.disabled)) {
			data.enabled = false;
		}
		if (data.imgDis == null && data.img_disabled != null) {
			data.imgdis = data.img_disabled;
		}
		
		if ((typeof(data.openAll) == "undefined" || data.openAll == null) && this.conf.skin == "dhx_terrace") data.openAll = true;
		this.objPull[this.idPrefix+id] = new this["_"+type+"Object"](this, id, data);
		this.objPull[this.idPrefix+id]["type"] = type;
		this.setPosition(id, pos);
	}
	
	// userdata
	if (data.userdata != null) {
		for (var a in data.userdata) this.setUserData(id, a, data.userdata[a]);
	}
	// userdata for options
	if (data.options != null) {
		for (var q=0; q<data.options.length; q++) {
			if (data.options[q].userdata != null) {
				for (var a in data.options[q].userdata) {
					this.setListOptionUserData(data.id, data.options[q].id, a, data.options[q].userdata[a]);
				}
			}
		}
	}

};

// skin
dhtmlXToolbarObject.prototype.setSkin = function(skin, onlyIcons) {
	if (onlyIcons === true) {
		// prevent of removing skin postfixes when attached to layout/acc/etc
		this.cont.className = this.cont.className.replace(/dhxtoolbar_icons_\d{1,}/,"dhxtoolbar_icons_"+this.conf.iconSize);
	} else {
		this.conf.skin = skin;
		if (this.conf.skin == "dhx_skyblue") {
			this.conf.sel_ofs_y = 1;
		}
		if (this.conf.skin == "dhx_web") {
			this.conf.sel_ofs_y = 1;
			this.conf.sel_ofs_x = 1;
		}
		if (this.conf.skin == "dhx_terrace") {
			this.conf.sel_ofs_y = -1;
			this.conf.sel_ofs_x = 0;
		}
		if (this.conf.skin == "material") {
			this.conf.sel_ofs_y = -1;
			this.conf.sel_ofs_x = 0;
		}
		this.cont.className = "dhx_toolbar_"+this.conf.skin+" dhxtoolbar_icons_"+this.conf.iconSize+this.conf.cssShadow;
	}
	
	for (var a in this.objPull) {
		var item = this.objPull[a];
		if (item["type"] == "slider") {
			item.pen._detectLimits();
			item.pen._definePos();
			item.label.className = "dhx_toolbar_slider_label_"+this.conf.skin;
		}
		if (item["type"] == "buttonSelect") {
			item.polygon.className = "dhx_toolbar_poly_"+this.conf.skin+" dhxtoolbar_icons_"+this.conf.iconSize+this.conf.cssShadow;
		}
	}
	if (skin == "dhx_terrace") this._improveTerraceSkin();
};

dhtmlXToolbarObject.prototype.setAlign = function(align) {
	this.conf.align = (align=="right"?"right":"left");
	this.base.className = (align=="right"?"dhxtoolbar_float_right":"dhxtoolbar_float_left");
	if (this._spacer) this._spacer.className = (align=="right"?" dhxtoolbar_float_left":" dhxtoolbar_float_right")
};

dhtmlXToolbarObject.prototype.setIconSize = function(size) {
	this.conf.iconSize = ({18:true,24:true,32:true,48:true}[size]?size:18);
	this.setSkin(this.conf.skin, true);
	this.callEvent("_onIconSizeChange",[this.conf.iconSize]);
};

dhtmlXToolbarObject.prototype.setIconsPath = function(path) {
	this.conf.icons_path = path;
};


// user data
dhtmlXToolbarObject.prototype.setUserData = function(id, name, value) {
	id = this.idPrefix+id;
	if (this.objPull[id] != null) {
		if (this.objPull[id].userData == null) this.objPull[id].userData = {};
		this.objPull[id].userData[name] = value;
	}
};
dhtmlXToolbarObject.prototype.getUserData = function(id, name) {
	id = this.idPrefix+id;
	if (this.objPull[id] != null && this.objPull[id].userData != null) return this.objPull[id].userData[name]||null;
	return null;
};
// userdata for listed options
dhtmlXToolbarObject.prototype._isListOptionExists = function(listId, optionId) {
	if (this.objPull[this.idPrefix+listId] == null) return false;
	var item = this.objPull[this.idPrefix+listId];
	if (item.type != "buttonSelect") return false;
	if (item._listOptions[optionId] == null) return false;
	return true;
};
dhtmlXToolbarObject.prototype.setListOptionUserData = function(listId, optionId, name, value) {
	// is exists?
	if (!this._isListOptionExists(listId, optionId)) return;
	// set userdata
	var opt = this.objPull[this.idPrefix+listId]._listOptions[optionId];
	if (opt.userData == null) opt.userData = {};
	opt.userData[name] = value;
};
dhtmlXToolbarObject.prototype.getListOptionUserData = function(listId, optionId, name) {
	// is exists?
	if (!this._isListOptionExists(listId, optionId)) return null;
	// get userdata
	var opt = this.objPull[this.idPrefix+listId]._listOptions[optionId];
	if (!opt.userData) return null;
	return (opt.userData[name]?opt.userData[name]:null);
};


// terrace skin fixes
dhtmlXToolbarObject.prototype._improveTerraceSkin = function() {
	
	if (this.conf.terrace_radius == null) this.conf.terrace_radius = "3px";
	
	var p = [];
	var bn = {separator: true, text: true}; // border-less items
	
	var e = [this.base];
	if (this._spacer != null) e.push(this._spacer);
	for (var w=0; w<e.length; w++) {
		p[w] = [];
		for (var q=0; q<e[w].childNodes.length; q++) {
			if (e[w].childNodes[q].idd != null && e[w].childNodes[q].style.display != "none") {
				var a = this.idPrefix+e[w].childNodes[q].idd;
				if (this.objPull[a] != null && this.objPull[a].obj == e[w].childNodes[q]) {
					p[w].push({a:a,type:this.objPull[a].type,node:this.objPull[a][this.objPull[a].type=="buttonSelect"?"arw":"obj"]});
				}
			}
		}
		e[w] = null;
	}
	
	for (var w=0; w<p.length; w++) {
		for (var q=0; q<p[w].length; q++) {
			
			var t = p[w][q];
			
			// check if border-right/border-left needed
			var br = false;
			var bl = false;
			
			if (!bn[t.type]) {
				
				// right side - check if item last-child or next-sibling is borderless item
				if (q == p[w].length-1 || (p[w][q+1] != null && bn[p[w][q+1].type])) br = true;
				
				// left side, check if item first-child or prev-sibling is borderless item
				if (q == 0 || (q-1 >= 0 && p[w][q-1] != null && bn[p[w][q-1].type])) bl = true;
				
			}
			
			t.node.style.borderRightWidth = (br?"1px":"0px");
			t.node.style.borderTopRightRadius = t.node.style.borderBottomRightRadius = (br?this.conf.terrace_radius:"0px");
			
			if (t.type == "buttonSelect") {
				t.node.previousSibling.style.borderTopLeftRadius = t.node.previousSibling.style.borderBottomLeftRadius = (bl?this.conf.terrace_radius:"0px");
				t.node.previousSibling._br = br;
				t.node.previousSibling._bl = bl;
			} else {
				t.node.style.borderTopLeftRadius = t.node.style.borderBottomLeftRadius = (bl?this.conf.terrace_radius:"0px");
			}
			
			t.node._br = br;
			t.node._bl = bl;
			
		}
	}
	
	for (var w=0; w<p.length; w++) {
		for (var q=0; q<p[w].length; q++) {
			for (var a in p[w][q]) p[w][q][a] = null;
			p[w][q] = null;
		}
		p[w] = null;
	}
	
	p = e = null;
};

// enable/disable riunded corners when sublist opened
dhtmlXToolbarObject.prototype._improveTerraceButtonSelect = function(id, state) {
	var item = this.objPull[id];
	if (state == true) {
		item.obj.style.borderBottomLeftRadius = (item.obj._bl?this.conf.terrace_radius:"0px");
		item.arw.style.borderBottomRightRadius = (item.obj._br?this.conf.terrace_radius:"0px");
	} else {
		item.obj.style.borderBottomLeftRadius = "0px";
		item.arw.style.borderBottomRightRadius = "0px";
	}
	item = null;
};

if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype._createNode_toolbar = function(obj, type, htmlString, append, node) {
		
		if (typeof(node) != "undefined") {
			obj = node;
		} else {
			obj = document.createElement("DIV");
			obj.className = "dhx_cell_toolbar_"+(this.conf.borders?"def":"no_borders");
			obj.appendChild(document.createElement("DIV"));
			obj.firstChild.className = "dhx_toolbar_base_18_dhx_skyblue";
		}
		
		this.cell.insertBefore(obj, this.cell.childNodes[this.conf.idx.cont]); // before cont only
		
		this.conf.ofs_nodes.t.toolbar = true;
		this._updateIdx();
		// adjust cont will performed after toolbar init
		
		return obj;
		
	}
	
	dhtmlXCellObject.prototype.attachToolbar = function(conf) {
		
		if (!(this.dataNodes.ribbon == null && this.dataNodes.toolbar == null)) return;
		
		this.callEvent("_onBeforeContentAttach", ["toolbar"]);
		
		if (typeof(conf) == "undefined") {
			conf = {};
		} else if (typeof(conf) == "string") {
			conf = {skin:conf};
		}
		if (typeof(conf.skin) == "undefined") conf.skin = this.conf.skin;
		conf.parent = this._attachObject("toolbar").firstChild;
		
		this.dataNodes.toolbar = new dhtmlXToolbarObject(conf);
		this._adjustCont(this._idd);
		
		this.dataNodes.toolbar._masterCell = this;
		this.dataNodes.toolbar.attachEvent("_onIconSizeChange", function(){
			this._masterCell._adjustCont();
		});
		
		conf.parent = null;
		conf = null;
		
		this.callEvent("_onContentAttach", []);
		
		return this.dataNodes.toolbar;
		
	};
	
	dhtmlXCellObject.prototype.detachToolbar = function() {
		
		if (this.dataNodes.toolbar == null) return;
		
		this.dataNodes.toolbar._masterCell = null; // link to this
		if (typeof(this.dataNodes.toolbar.unload) == "function") this.dataNodes.toolbar.unload();
		this.dataNodes.toolbar = null;
		delete this.dataNodes.toolbar;
		
		this._detachObject("toolbar");
		
	};
	
	dhtmlXCellObject.prototype.showToolbar = function() {
		this._mtbShowHide("toolbar", "");
	};
	
	dhtmlXCellObject.prototype.hideToolbar = function() {
		this._mtbShowHide("toolbar", "none");
	};
	

	
	dhtmlXCellObject.prototype.getAttachedToolbar = function() {
		return this.dataNodes.toolbar;
	};
	
}

;
///<jscompress sourcefile="dhtmlxwindows_dnd.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXWindows.prototype._dndInitModule = function() {
	
	var that = this;
	
	this.conf.dnd_enabled = true;
	this.conf.dnd_tm = null;
	this.conf.dnd_time = 0; // 400 or 0
	
	this._dndOnMouseDown = function(e, id) {
		
		if (that.conf.dblclick_active) return;
		
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		
		if (that._callMainEvent("onBeforeMoveStart", id) !== true) return;
		
		
		that.conf.dnd = {
			id: id,
			x: that._dndPos(e,"X"),
			y: that._dndPos(e,"Y"),
			ready: true,
			css: false,
			css_touch: false,
			css_vp: false,
			tr: null,
			mode: "def", //"def" - move win, "tr" - for translate, "rect" - move rectange
			moved: false,
			prevent: false
		};
		
		if (that.w[id].conf.keep_in_vp) {
			that.conf.dnd.minX = 0;
			that.conf.dnd.maxX = that.vp.clientWidth-that.w[id].conf.w;
			that.conf.dnd.minY = 0;
			that.conf.dnd.maxY = that.vp.clientHeight-that.w[id].conf.h;
		} else {
			that.conf.dnd.minX = -that.w[id].conf.w+that.conf.vp_pos_ofs;
			that.conf.dnd.maxX = that.vp.clientWidth-that.conf.vp_pos_ofs;
			that.conf.dnd.minY = 0;
			that.conf.dnd.maxY = that.vp.clientHeight-that.conf.vp_pos_ofs;
		}
		
		var k = [
			"MozTransform",
			"WebkitTransform",
			"OTransform",
			"msTransform",
			"transform"
		];
		
		for (var q=0; q<k.length; q++) {
			if (document.documentElement.style[k[q]] != null && that.conf.dnd.tr == null) {
				that.conf.dnd.tr = k[q];
				that.conf.dnd.mode = "tr";
			}
		}
		
		// that.conf.dnd.mode = "def";
		// console.log("dnd ready, mode: "+that.conf.dnd.mode);
		
		if (that.conf.dnd.mode == "tr") {
			that.w[id].win.style[that.conf.dnd.tr] = "translate(0px,0px)";
			if (that.w[id].fr_m_cover != null) that.w[id].fr_m_cover.style[that.conf.dnd.tr] = that.w[id].win.style[that.conf.dnd.tr];
		}
		
		// touch indicator
		if (window.dhx4.dnd._mTouch(e) == false && e.type == window.dhx4.dnd.evs.start) {
			if (that.conf.dnd.css_touch == false) {
				that.w[id].win.className += " dhxwin_dnd_touch";
				that.conf.dnd.css_touch = true;
			}
			if (that.conf.dnd.css_vp == false) {
				that.vp.className += " dhxwins_vp_dnd";
				that.conf.dnd.css_vp = true;
			}
		} else {
			// init events
			that._dndInitEvents();
		}
	}
	
	this._dndOnMouseMove = function(e) {
		
		// dhtmlx.message({text: "a", expire: 100});
		e = e||event;
		
		var dnd = that.conf.dnd;
		
		var x = that._dndPos(e,"X")-dnd.x;
		var y = that._dndPos(e,"Y")-dnd.y;
		
		// check if user will move body while timer is active, allow 10px interval from touch point
		if (e.type == window.dhx4.dnd.evs.move) {
			
			if (dnd.moved != true && (Math.abs(x) > 20 || Math.abs(y) > 20)) {
				
				if (that.conf.dnd_tm != null) {
					window.clearTimeout(that.conf.dnd_tm);
					that.conf.dnd_tm = null;
				}
				window.removeEventListener(window.dhx4.dnd.evs.start, that._dndOnMouseMove, false);
				
				return;
			}
		}
		
		
		if (dnd.ready != true) return;
		
		var w = that.w[dnd.id];
		
		// dhtmlx.message({text:x+","+y,expire:100});
		
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		
		
		if (dnd.css != true) {
			if (dnd.css_touch == false) w.win.className += " dhxwin_dnd";
			w.fr_cover.className += " dhxwin_fr_cover_dnd";
			dnd.css = true;
		}
		if (dnd.css_vp != true) {
			that.vp.className += " dhxwins_vp_dnd";
			dnd.css_vp = true;
		}
		
		dnd.newX = w.conf.x+x;
		dnd.newY = w.conf.y+y;
		
		if (dnd.mode == "tr") {
			
			dnd.newX = Math.min(Math.max(dnd.newX, dnd.minX), dnd.maxX);
			x = dnd.newX-w.conf.x;
			
			dnd.newY = Math.min(Math.max(dnd.newY, dnd.minY), dnd.maxY);
			y = dnd.newY-w.conf.y;
			
			w.win.style[dnd.tr] = "translate("+x+"px,"+y+"px)";
			if (w.fr_m_cover != null) w.fr_m_cover.style[dnd.tr] = w.win.style[dnd.tr];
				
		} else {
			
			if (dnd.newX < dnd.minX || dnd.newX > dnd.maxX) {
				dnd.newX = Math.min(Math.max(dnd.newX, dnd.minX), dnd.maxX);
			} else {
				dnd.x = that._dndPos(e,"X");
			}
			
			if (dnd.newY < dnd.minY || dnd.newY > dnd.maxY) {
				dnd.newY = Math.min(Math.max(dnd.newY, dnd.minY), dnd.maxY);
			} else {
				dnd.y = that._dndPos(e,"Y");
			}
			
			that._winSetPosition(dnd.id, dnd.newX, dnd.newY);
			
		}
		
		dnd.moved = true;
		
		w = dnd = null;
	}
	
	this._dndOnMouseUp = function(e) {
		
		e = e||event;
		that._dndUnloadEvents();
		
		if (that.conf.dnd != null && that.conf.dnd.id != null) {
			
			var dnd = that.conf.dnd;
			var w = that.w[dnd.id];
			
			if (dnd.newX != null) {
				if (dnd.mode == "tr") {
					that._winSetPosition(dnd.id, dnd.newX, dnd.newY);
					w.win.style[dnd.tr] = "translate(0px,0px)";
					if (w.fr_m_cover != null) w.fr_m_cover.style[dnd.tr] = w.win.style[dnd.tr];
				}
			}
			if (dnd.css == true) {
				if (dnd.css_touch == false) w.win.className = String(w.win.className).replace(/\s{0,}dhxwin_dnd/gi,"");
				w.fr_cover.className = String(w.fr_cover.className).replace(/\s{0,}dhxwin_fr_cover_dnd/gi,"");
			}
			if (dnd.css_touch == true) {
				w.win.className = String(w.win.className).replace(/\s{0,}dhxwin_dnd_touch/gi,"");
			}
			if (dnd.css_vp == true) {
				that.vp.className = String(that.vp.className).replace(/\s{0,}dhxwins_vp_dnd/gi,"");
			}
			
			if (dnd.moved == true) {
				that._callMainEvent("onMoveFinish", dnd.id);
			} else {
				that._callMainEvent("onMoveCancel", dnd.id);
			}
			
			w = dnd = that.conf.dnd = null;
			
		}
		
		if (window.dhx4.dnd.p_en == true && e.type == window.dhx4.dnd.evs.end) {
			window.dhx4.dnd._touchOn();
			window.removeEventListener(window.dhx4.dnd.evs.end, that._dndOnMouseUp, false);
			window.removeEventListener(window.dhx4.dnd.evs.move, that._dndOnMouseMove, false);
			if (that.conf.dnd_tm != null) window.clearTimeout(that.conf.dnd_tm);
			that.conf.dnd_tm = null;
		}
	}
	
	this._dndOnSelectStart = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	}
	
	this._dndInitEvents = function() {
		if (typeof(window.addEventListener) == "function") {
			window.addEventListener("mousemove", this._dndOnMouseMove, false);
			window.addEventListener("mouseup", this._dndOnMouseUp, false);
			window.addEventListener("selectstart", this._dndOnSelectStart, false);
		} else {
			document.body.attachEvent("onmousemove", this._dndOnMouseMove);
			document.body.attachEvent("onmouseup", this._dndOnMouseUp);
			document.body.attachEvent("onselectstart", this._dndOnSelectStart);
		}
	}
	
	this._dndUnloadEvents = function() {
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("mousemove", this._dndOnMouseMove, false);
			window.removeEventListener("mouseup", this._dndOnMouseUp, false);
			window.removeEventListener("selectstart", this._dndOnSelectStart, false);
		} else {
			document.body.detachEvent("onmousemove", this._dndOnMouseMove);
			document.body.detachEvent("onmouseup", this._dndOnMouseUp);
			document.body.detachEvent("onselectstart", this._dndOnSelectStart);
		}
	}
	
	this._dndUnloadModule = function() {
		
		this.detachEvent(this.conf.dnd_evid);
		this.conf.dnd_evid = null;
		
		this._dndOnMouseDown = null;
		this._dndOnMouseMove = null;
		this._dndOnMouseUp = null;
		this._dndOnSelectStart = null;
		this._dndInitEvents = null;
		this._dndUnloadEvents = null;
		this._dndInitModule = null;
		this._dndUnloadModule = null;
		
		that = null;
	}
	
	this._dndPos = function(ev, type) {
		var pos = ev[this.conf.dnd_ev_prefix+type];
		if ((pos == null || pos == 0) && ev.touches != null) pos = ev.touches[0][this.conf.dnd_ev_prefix+type];
		return pos;
	}
	
	this.conf.dnd_evid = this.attachEvent("_winMouseDown", function(e, data){
		
		if (this.w[data.id] == null || this.w[data.id].conf.allow_move != true) return;
		
		if (typeof(e.button) != "undefined" && e.button >= 2) return;
		
		if (e.type == window.dhx4.dnd.evs.start) {
			
			if (data.mode == "hdr") {
				
				if (this.w[data.id].conf.maxed && this.w[data.id].conf.max_w == null && this.w[data.id].conf.max_h == null) return;
				
				this.conf.dnd_ev_prefix = "page";
				this.conf.dnd = {
					x: this._dndPos(e,"X"),
					y: this._dndPos(e,"Y")
				};
				
				if (this.conf.dnd_time < 1) {
					this._dndOnMouseDown(e, data.id);
				} else {
					if (this.conf.dnd_tm != null) window.clearTimeout(this.conf.dnd_tm);
					this.conf.dnd_tm = window.setTimeout(function(){that._dndOnMouseDown(e,data.id);}, this.conf.dnd_time);
				}
				
				if (window.dhx4.dnd.p_en == true) {
					window.dhx4.dnd._touchOff();
					window.addEventListener(window.dhx4.dnd.evs.end, this._dndOnMouseUp, false);
				}
				
				window.addEventListener(window.dhx4.dnd.evs.move, this._dndOnMouseMove, false);
				
			}
			
			return false;
		}
		
		if (e.type == window.dhx4.dnd.evs.end) {
			
			if (this.conf.dnd_tm != null) {
				window.clearTimeout(this.conf.dnd_tm);
				this.conf.dnd_tm = null;
			}
			
			this._dndOnMouseUp(e);
			window.removeEventListener(window.dhx4.dnd.evs.move, this._dndOnMouseMove, false);
			
			return false;
		}
		
		this.conf.dnd_ev_prefix = "client";
		if (!(data.mode == "hdr" && e.type == "mousedown")) return;
		if (this.w[data.id].conf.maxed && this.w[data.id].conf.max_w == null && this.w[data.id].conf.max_h == null) return;
		
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		this._dndOnMouseDown(e, data.id);
		return false;
		
	});
	
};

;
///<jscompress sourcefile="dhtmlxwindows_resize.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXWindowsCell.prototype._initResize = function() {
	
	var that = this;
	var n = navigator.userAgent;
	
	this.conf.resize = {
		b_width: 6,
		c_type: (n.indexOf("MSIE 10.0")>0||n.indexOf("MSIE 9.0")>0||n.indexOf("MSIE 8.0")>0||n.indexOf("MSIE 7.0")>0||n.indexOf("MSIE 6.0")>0),
		btn_left: ((window.dhx4.isIE6||window.dhx4.isIE7||window.dhx4.isIE8) && typeof(window.addEventListener) == "undefined" ? 1:0)
	};
	
	this._rOnCellMouseMove = function(e) {
		
		if (that.wins.conf.resize_actv == true || that.wins.w[that._idd].conf.allow_resize == false || that.conf.progress == true || that.wins.w[that._idd].conf.maxed == true || that.wins.w[that._idd].conf.fs_mode == true) {
			var k = that.wins.w[that._idd].brd;
			if (k.style.cursor != "default") k.style.cursor = "default";
			k = null;
			return;
		}
		
		
		e = e||event;
		
		var cont = that.wins.w[that._idd].brd;
		var r = that.conf.resize;
		
		var no_header = (that.wins.w[that._idd].conf.header==false);
		
		var x = e.clientX;
		var y = e.clientY;
		
		// body/html scrolls
		x += (document.documentElement.scrollLeft||document.body.scrollLeft||0);
		y += (document.documentElement.scrollTop||document.body.scrollTop||0);
		
		var x0 = window.dhx4.absLeft(cont);
		var y0 = window.dhx4.absTop(cont);
		
		var mode = "";
		if (x <= x0+r.b_width) { // left
			mode = "w";
		} else if (x >= x0+cont.offsetWidth-r.b_width) { // right
			mode = "e";
		}
		if (y >= y0+cont.offsetHeight-r.b_width) { // bottom
			mode = "s"+mode;
		} else if (no_header && y <= y0+r.b_width) { // top (only for no_header mode)
			mode = "n"+mode;
		}
		
		if (mode == "") mode = false;
		if (r.mode != mode) {
			r.mode = mode;
			if (mode == false) {
				cont.style.cursor = "default";
			} else {
				cont.style.cursor = mode+"-resize";
			}
		}
		
		cont = r = null;
	};
	
	this._rOnCellMouseDown = function(e) {
		
		e = e||event;
		if (typeof(e.button) != "undefined" && e.button != that.conf.resize.btn_left) return;
		
		if (that.conf.resize.mode == false) return;
		if (that.conf.progress == true) return; // if progress is on - deny
		if (that.wins.w[that._idd].conf.allow_resize == false) return;
		if (that.wins.w[that._idd].conf.fs_mode == true) return; // fullscreened window
		
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		
		if (that.wins._callMainEvent("onBeforeResizeStart", that._idd) !== true) return;
		
		var w = that.wins.w[that._idd];
		var r = that.conf.resize;
		
		that.wins.conf.resize_actv = true;
		
		r.min_w = w.conf.min_w;
		r.min_h = w.conf.min_h;
		r.max_w = w.conf.max_w||+Infinity;
		r.max_h = w.conf.max_h||+Infinity;
		
		// if layout attached - check custom min w/h
		if (w.cell.dataType == "layout" && w.cell.dataObj != null && typeof(w.cell.dataObj._getWindowMinDimension) == "function") {
			var t = w.cell.dataObj._getWindowMinDimension(w.cell);
			r.min_w = Math.max(t.w, r.min_w);
			r.min_h = Math.max(t.h, r.min_h);
		}
		
		r.vp_l = that.wins.conf.vp_pos_ofs;
		r.vp_r = that.wins.vp.clientWidth-that.wins.conf.vp_pos_ofs;
		r.vp_b = that.wins.vp.clientHeight-that.wins.conf.vp_pos_ofs;
		
		r.x = e.clientX;
		r.y = e.clientY;
		
		// start resize
		if (typeof(window.addEventListener) == "function") {
			window.addEventListener("mousemove", that._rOnWinMouseMove, false);
			window.addEventListener("mouseup", that._rOnWinMouseUp, false);
			window.addEventListener("selectstart", that._rOnSelectStart, false);
		} else {
			document.body.attachEvent("onmousemove", that._rOnWinMouseMove);
			document.body.attachEvent("onmouseup", that._rOnWinMouseUp);
			document.body.attachEvent("onselectstart", that._rOnSelectStart);
		}
		
		r.resized = false;
		
		r.vp_cursor = that.wins.vp.style.cursor;
		that.wins.vp.style.cursor = r.mode+"-resize";
		
		w = r = null;
	};
	
	this._rOnCellContextMenu = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	};
	
	this._rOnWinMouseMove = function(e) {
		
		// resize in progress
		e = e||event;
		
		var w = that.wins.w[that._idd];
		var r = that.conf.resize;
		
		if (!r.resized) {
			w.fr_cover.className += " dhxwin_fr_cover_resize";
			r.resized = true;
		}
		
		var x = e.clientX-r.x;
		var y = e.clientY-r.y;
		
		if (r.mode.indexOf("e") >= 0) { // right win side dragged
			
			r.rw = Math.min(Math.max(w.conf.w+x, r.min_w), r.max_w);
			r.rx = null;
			
			if (w.conf.x+r.rw < r.vp_l) { // check overflow to left
				r.rw = r.vp_l-w.conf.x;
			} else if (w.conf.x+r.rw > that.wins.vp.clientWidth) { // and right
				r.rw = that.wins.vp.clientWidth-w.conf.x;
			}
			
		} else if (r.mode.indexOf("w") >= 0) { // left win side dragged
			
			r.rw = Math.min(Math.max(w.conf.w-x,r.min_w),r.max_w);
			r.rx = w.conf.x+w.conf.w-r.rw;
			
			if (r.rx < 0) { // check overflow to left
				r.rw = r.rw+r.rx;
				r.rx = 0;
			} else if (r.rx > r.vp_r) { // and right
				r.rw = r.rw-r.vp_r;
				r.rx = r.vp_r;
			}
			
		}
		
		if (r.mode.indexOf("s") >= 0) { // bottom win side (can be together with left or right)
			
			r.rh = Math.min(Math.max(w.conf.h+y, r.min_h),r.max_h);
			r.ry = null;
			
			if (w.conf.y+r.rh > that.wins.vp.clientHeight) { // bottom overflow
				r.rh = that.wins.vp.clientHeight-w.conf.y;
			}
			
		} else if (r.mode.indexOf("n") >= 0) { // top win side (can be together with left or right) (only for no_header mode)
			
			r.rh = Math.min(Math.max(w.conf.h-y, r.min_h),r.max_h);
			r.ry = w.conf.y+w.conf.h-r.rh;
			
			if (r.ry < 0) { // top overflow
				r.rh = r.rh+r.ry;
				r.ry = 0;
			} else if (r.ry > r.vp_b) { // and bottom
				r.rh = r.rh-r.vp_b;
				r.ry = r.vp_b;
			}
		}
		
		that._rAdjustSizer();
		
		w = r = null;
	}
	this._rOnWinMouseUp = function() {
		
		// stop resize
		
		var r = that.conf.resize;
		var w = that.wins.w[that._idd];
		
		that.wins.conf.resize_actv = false;
		that.wins.vp.style.cursor = r.vp_cursor;
		
		w.fr_cover.className = String(w.fr_cover.className).replace(/\s{0,}dhxwin_fr_cover_resize/gi,"");
		
		if (r.resized) {
			that.wins._winSetSize(that._idd, r.rw, r.rh);
			if (r.rx == null) r.rx = w.conf.x;
			if (r.ry == null) r.ry = w.conf.y;
			if (r.rx != w.conf.x || r.ry != w.conf.y) that.wins._winSetPosition(that._idd, r.rx, r.ry);
		}
		
		if (r.obj != null) {
			r.obj.parentNode.removeChild(r.obj);
			r.obj = null;
		}
		if (r.objFR != null) {
			r.objFR.parentNode.removeChild(r.objFR);
			r.objFR = null;
		}
		
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("mousemove", that._rOnWinMouseMove, false);
			window.removeEventListener("mouseup", that._rOnWinMouseUp, false);
			window.removeEventListener("selectstart", that._rOnSelectStart, false);
		} else {
			document.body.detachEvent("onmousemove", that._rOnWinMouseMove);
			document.body.detachEvent("onmouseup", that._rOnWinMouseUp);
			document.body.detachEvent("onselectstart", that._rOnSelectStart);
		}
		
		if (r.resized == true) {
			if (that.dataType == "layout" && that.dataObj != null) that.dataObj.callEvent("onResize",[]); // deprecated, 3.6 compat
			that.wins._callMainEvent("onResizeFinish", that._idd);
		} else {
			that.wins._callMainEvent("onResizeCancel", that._idd);
		}
		
		r.mode = "";
		
		w = r = null;
	}
	
	this._rOnSelectStart = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	}
	
	this._rInitSizer = function() {
		
		var r = that.conf.resize;
		var w = that.wins.w[that._idd];
		
		r.obj = document.createElement("DIV");
		r.obj.className = "dhxwin_resize";
		r.obj.style.zIndex = w.win.style.zIndex;
		r.obj.style.cursor = r.mode+"-resize";
		that.wins.vp.appendChild(r.obj);
		
		if (that.wins.conf.fr_cover == true) {
			r.objFR = document.createElement("IFRAME");
			r.objFR.className = "dhxwin_resize_fr_cover";
			r.objFR.style.zIndex = r.obj.style.zIndex;
			that.wins.vp.insertBefore(r.objFR, r.obj);
		}
		
		r.rx = w.conf.x;
		r.ry = w.conf.y;
		r.rw = w.conf.w;
		r.rh = w.conf.h;
		r = null;
	}
	
	this._rAdjustSizer = function() {
		var r = that.conf.resize;
		if (!r.obj) this._rInitSizer();
		// dim
		r.obj.style.width = r.rw+"px";
		r.obj.style.height = r.rh+"px";
		
		// pos, optional
		if (r.rx != null) r.obj.style.left = r.rx+"px";
		if (r.ry != null) r.obj.style.top = r.ry+"px";
		
		if (r.objFR != null) {
			r.objFR.style.width = r.obj.style.width;
			r.objFR.style.height = r.obj.style.height;
			if (r.rx != null) r.objFR.style.left = r.obj.style.left;
			if (r.ry != null) r.objFR.style.top = r.obj.style.top;
		}
		
		r = null;
	}
	
	if (typeof(window.addEventListener) == "function") {
		this.wins.w[this._idd].brd.addEventListener("mousemove", this._rOnCellMouseMove, false);
		this.wins.w[this._idd].brd.addEventListener("mousedown", this._rOnCellMouseDown, false);
		this.wins.w[this._idd].brd.addEventListener("contextmenu", this._rOnCellContextMenu, false);
	} else {
		this.wins.w[this._idd].brd.attachEvent("onmousemove", this._rOnCellMouseMove);
		this.wins.w[this._idd].brd.attachEvent("onmousedown", this._rOnCellMouseDown);
		this.wins.w[this._idd].brd.attachEvent("oncontextmenu", this._rOnCellContextMenu);
	}
	
	this._unloadResize = function() {
		
		if (typeof(window.addEventListener) == "function") {
			this.wins.w[this._idd].brd.removeEventListener("mousemove", this._rOnCellMouseMove, false);
			this.wins.w[this._idd].brd.removeEventListener("mousedown", this._rOnCellMouseDown, false);
			this.wins.w[this._idd].brd.removeEventListener("contextmenu", this._rOnCellContextMenu, false);
		} else {
			this.wins.w[this._idd].brd.detachEvent("onmousemove", this._rOnCellMouseMove);
			this.wins.w[this._idd].brd.detachEvent("onmousedown", this._rOnCellMouseDown);
			this.wins.w[this._idd].brd.detachEvent("oncontextmenu", this._rOnCellContextMenu);
		}
		
		this._initResize = null;
		this._rOnCellMouseMove = null;
		this._rOnCellMouseDown = null;
		this._rOnWinMouseMove = null;
		this._rOnWinMouseUp = null;
		this._rOnSelectStart = null;
		this._rInitSizer = null;
		this._rAdjustSizer = null;
		this._unloadResize = null;
		
		this.conf.resize = null;
		that = null;
	};

};

;
///<jscompress sourcefile="dhtmlxwindows_menu.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

// global context menu
dhtmlXWindows.prototype.attachContextMenu = function(conf) {
	return this._renderContextMenu("icon", null, null, conf);
};
dhtmlXWindows.prototype.getContextMenu = function() {
	if (this.cm != null && this.cm.global != null) return this.cm.global;
	return null;
};
dhtmlXWindows.prototype.detachContextMenu = function() {
	this._detachContextMenu("icon", null, null);
};

// custom menu
dhtmlXWindowsCell.prototype.attachContextMenu = function(conf) {
	return this.wins._renderContextMenu("icon", this._idd, null, conf);
};
dhtmlXWindowsCell.prototype.getContextMenu = function() {
	if (this.wins.cm != null && this.wins.cm.icon[this._idd] != null) return this.wins.cm.icon[this._idd];
	return null;
};
dhtmlXWindowsCell.prototype.detachContextMenu = function() {
	this.wins._detachContextMenu("icon", this._idd, null);
};

// menu for button
dhtmlXWindowsButton.prototype.attachContextMenu = function(conf) {
	return this.conf.wins._renderContextMenu("button", this.conf.winId, this.conf.name, conf);
};
dhtmlXWindowsButton.prototype.getContextMenu = function() {
	if (this.conf.wins.cm == null || this.conf.wins.cm.button[this.conf.winId] == null) return null;
	if (this.conf.wins.cm.button[this.conf.winId][this.conf.name] != null) return this.conf.wins.cm.button[this.conf.winId][this.conf.name];
	return null;
};
dhtmlXWindowsButton.prototype.detachContextMenu = function() {
	this.conf.wins._detachContextMenu("button", this.conf.winId, this.conf.name);
};

dhtmlXWindows.prototype._renderContextMenu = function(mode, wId, bId, conf) {
	
	var that = this;
	var firstInit = false;
	
	if (this.cm == null) {
		this.cm = {
			global:	null,	// global context menu for icon
			icon:	{},	// custom for icon, {winId:menuInst, winId2:menuInst2}
			button: {}	// custom foc button, {winId:{buttonId:menuInst, buttonId2:menuInst2}, winId2:{..}}
		};
		firstInit = true;
	}
	
	// check if already attached
	if (wId == null) {
		if (this.cm.global != null) return;
	} else if (mode == "icon") {
		if (this.cm.icon[wId] != null) return;
	} else if (mode == "button") {
		if (this.cm.button[wId] != null && this.cm.button[wId][bId] != null) return;
	}
	
	
	// init
	if (conf == null) conf = {};
	conf.parent = null;
	conf.context = true;
	
	var menu = new dhtmlXMenuObject(conf);
	menu.setAutoHideMode(false);
	
	menu.attachEvent("onShow", function() {
		this.conf.wins_menu_open = true;
	});
	
	menu.attachEvent("onHide", function() {
		this.conf.wins_menu_open = false;
		that.conf.opened_menu = null;
	});
	
	if (wId == null) {
		this.cm.global = menu;
	} else if (mode == "icon") {
		this.cm.icon[wId] = menu;
	} else if (mode == "button") {
		if (this.cm.button[wId] == null) this.cm.button[wId] = {};
		this.cm.button[wId][bId] = menu;
	}
	
	if (firstInit) {
		
		this._showContextMenu = function(e, data) {
			
			if (e.button >= 2) return;
			
			if (data.mode == "icon" && data.id != null && data.press_type == "mousedown") {
				
				var menu = this.cm.icon[data.id]||this.cm.global;
				if (menu == null) return;
				
				e.cancelBubble = true;
				
				var icon = this.w[data.id].hdr.firstChild;
				
				if (menu.conf.wins_menu_open && this.conf.opened_menu == data.id) {
					menu.hideContextMenu();
				} else {
					this._hideContextMenu();
					menu.showContextMenu(window.dhx4.absLeft(icon), window.dhx4.absTop(icon)+icon.offsetHeight);
					this.conf.opened_menu = data.id;
				}
				menu = icon = null;
				
			}
			
			if (data.mode == "button" && data.id != null && data.press_type == "mousedown") {
				
				if (this.cm.button[data.id] == null || this.cm.button[data.id][data.button_name] == null) return;
				
				e.cancelBubble = true;
				
				this.conf.button_last = null; // cancel button click
				
				var menu = this.cm.button[data.id][data.button_name];
				var button = this.w[data.id].b[data.button_name].button;
				
				if (menu.conf.wins_menu_open && this.conf.opened_menu == data.id) {
					menu.hideContextMenu();
				} else {
					this._hideContextMenu();
					menu.showContextMenu(window.dhx4.absLeft(button), window.dhx4.absTop(button)+button.offsetHeight);
					this.conf.opened_menu = data.id;
				}
				menu = button = null;
				
			}
			
		}
		
		this._hideContextMenu = function(e) {
			
			if (e != null) {
				e = e||event;
				if (e.type == "keydown" && e.keyCode != 27) return;
				
				var t = e.target||e.srcElement;
				var m = true;
				while (t != null && m == true) {
					if (t.className != null && t.className.search(/SubLevelArea_Polygon/) >= 0) {
						m = false;
					} else {
						t = t.parentNode;
					}
				}
			}
			
			if (m || e == null) {
				if (that.cm.global != null) that.cm.global.hideContextMenu();
				for (var a in that.cm.icon) {
					if (that.cm.icon[a] != null) that.cm.icon[a].hideContextMenu();
				}
				for (var a in that.cm.button) {
					for (var b in that.cm.button[a]) {
						if (that.cm.button[a][b] != null) that.cm.button[a][b].hideContextMenu();
					}
				}
			}
			
		}
		
		this._detachContextMenu = function(mode, wId, bId) {
			if (this.cm == null) return;
			if (wId == null) {
				if (this.cm.global != null) {
					this.cm.global.unload();
					this.cm.global = null;
				}
			} else if (mode == "icon") {
				if (this.cm.icon[wId] != null) {
					this.cm.icon[wId].unload();
					this.cm.icon[wId] = null;
				}
			} else if (mode == "button") {
				if (this.cm.button[wId] != null && this.cm.button[wId][bId] != null) {
					this.cm.button[wId][bId].unload();
					this.cm.button[wId][bId] = null;
				}
			}
			
		}
		
		this.attachEvent("_winMouseDown", this._showContextMenu);
		
		if (typeof(window.addEventListener) == "function") {
			window.addEventListener("mousedown", this._hideContextMenu, false);
			window.addEventListener("keydown", this._hideContextMenu, false);
		} else {
			document.body.attachEvent("onmousedown", this._hideContextMenu);
			document.body.attachEvent("onkeydown", this._hideContextMenu);
		}
		
		this._unloadContextMenu = function() {
			
			// remove only global menu if any, other will removed from win/button unload
			this._detachContextMenu("icon", null, null);
			this.cm = null;
			
			if (typeof(window.addEventListener) == "function") {
				window.removeEventListener("mousedown", this._hideContextMenu, false);
				window.removeEventListener("keydown", this._hideContextMenu, false);
			} else {
				document.body.detachEvent("onmousedown", this._hideContextMenu);
				document.body.detachEvent("onkeydown", this._hideContextMenu);
			}
			
			that = null;
		}
		
	}
	
	return menu;
};

;
///<jscompress sourcefile="dhtmlxcheckbox.js" />
/*
filename：dhtmlxcheckbox.js
creater：温龙香
date created：2016-01-12
description：单选、复选按钮组
date modified：2017.12.26
modifier：刘志伟
version：2.2.15.1129
others：
copyright：Copyright @1999-2016, hwkj, All Rights Reserved
*/

function dhtmlXCheckBox(parentId, options) {
    var skin = null;
    this.cont = (typeof (parentId) == "string" ? document.getElementById(parentId) : parentId);

    this.options = {
        skin: (options.skin || window.dhx4.skin || (typeof (dhtmlx) != "undefined" ? dhtmlx.skin : null) || window.dhx4.skinDetect("dhtmlxcheckbox") || "material"),
        enabled: true,
        enableAll:false,
        text: "text",
        value:"value",
        checked:"checked",
        data: [],
        mode:"checkbox"
    };
    this.t = {};
    this.lastValue = "";
    window.dhx4._eventable(this);
    dhtmlXCheckBox.extend(this.options, options);
    var that = this;
    this.checked = [];
    this.base = document.createElement("DIV");
    this.base.className = "dhtmlxcheckbox_" + this.options.skin;

    this.base.innerHTML = "";

    // data loading
    this._init = function (data) {
        that.addOption(data);
        that.cont.appendChild(this.base);
    }
    /* add / remove options */
    this.addOption = function (value, options) {
        
        //继承属性
        if (options) {
            dhtmlXCheckBox.extend(that.options, options,true);
        }
        that.clearAll();
        if (value && value.length > 0 && that.isChkAngEnbleAll()) {
            var isAllChecked = 1;
            for (var i = 0; i < value.length; i++) {
                if (!value[i].checked) {
                    isAllChecked = 0;
                    break;
                }
            }
            that._renderOption({ id: "_dhtmlx_all", value: "allall", text: unescape("%u5168%u9009"), checked: isAllChecked }, true);
        }
        //如果不是数组
        if (!(value instanceof Array)) {
            var id = that._renderOption({ value: value, text: text });
        } else {
            for (var q = 0; q < value.length; q++) {
                var data = {
                    text: value[q]['text'],
                    value: value[q]['value'],
                    checked: window.dhx4.s2b(value[q]['checked']) ? 1 : 0,
                    id: value[q]["id"]
                };
                that._renderOption(data);
            }
        }
        //有其他项时
        if (that.options.qita == "1") {
            that._renderOther({ id: "_dhtmlx_qita", value: "qita", text: unescape("%u5176%u4ED6"), inputText: "" }, true);
        }       
        
        //单选如果没有选中项选中第一项如果选中多项，排除其他项
        if (that.options.mode == "radio" && value && value.length > 0) {
            var checkNum = 0;
            var firstValue = "";

            var firstCheckedValue = undefined;
            that._forEachOption2(function (item, index) {
                if (index == 0) firstValue = item._value;
                if (item._checked) {
                    checkNum++;
                    if (firstCheckedValue == undefined) firstCheckedValue = item._value;

                    that.datastore._cursor = item._optId;
                }

            });
            if (checkNum == 0) {
                that.setValue(firstValue);
                that.datastore._cursor = value[0].id;
            } else if (checkNum > 1) {
                that.setValue(firstCheckedValue);
            }
        }
        that.lastValue = that.getValue();
        window.setTimeout(function(){
        	 that.callEvent("onLoaded", [that.getValue()]);
        },20)       
    }
    this._renderOption = function (data, mode) {
        /*
            <div class="dhtmlxcheckbox_dhx_skyblue_opt" onclick="changeState(that)" state="false">
                <div class="dhtmlxcheckbox_dhx_skyblue_chk0"></div>
                <span >选项一</span>
            </div>
        */
        var item = document.createElement("DIV");
        item._checked = data["checked"];
        item._optId = data.id;
        item._value = data.value;
        item._text = data.text;


        item.className = "dhtmlxcheckbox_" + that.options.skin + "_opt";
        var itemChk = document.createElement("DIV");
        if (that.options.mode == "radio") {
            itemChk.className = "dhtmlxcheckbox_" + that.options.skin + "_" + (that.options.style == undefined ? "rad" : that.options.style) + item._checked;
        } else {
            itemChk.className = "dhtmlxcheckbox_" + that.options.skin + "_" + (that.options.style == undefined ? "chk" : that.options.style) + item._checked;
        }
        if (!that.options.enabled) {
            itemChk.className = itemChk.className + "_dis";
        }
        var itemTxt = document.createElement("span");
        itemTxt.className = "dhtmlxcheckbox_" + that.options.skin + "_txt";
        itemTxt.innerHTML = item._text;
        item.appendChild(itemChk);
        item.appendChild(itemTxt);
        that.base.appendChild(item);
        item.onclick=function (e) {
            
            if (!that.options.enabled) return;
            var item = e.target || window.event.srcElement;
            if (!item._optId) {
                item = item.parentNode;
            }
            //如果开启全选按钮且全选选中
            if (mode && item._value == "allall" && item._checked) {
                that._forEachOption2(function (item) {
                    item.children[0].className = item.children[0].className.replace(/1/, "0");
                    item._checked = 0;
                });
            } else if (mode && item._value == "allall" && !item._checked) {
                that._forEachOption2(function (item) {
                    item.children[0].className = item.children[0].className.replace(/0/, "1");
                    item._checked = 1;
                });
            }
            else {
                if (that.options.mode == "checkbox") {
                    if (item._checked) {
                        item.children[0].className = item.children[0].className.replace(/1/, "0");
                        item._checked = 0;
                    } else {
                        item.children[0].className = item.children[0].className.replace(/0/, "1");
                        item._checked = 1;
                    }
                    if (that.options.enableAll) {
                        if (!that.isCheckedAll()) {
                            that.t['_dhtmlx_all'].children[0].className = item.children[0].className.replace(/1/, "0");
                            that.t['_dhtmlx_all']._checked = 0;
                        }
                        else {
                            that.t['_dhtmlx_all'].children[0].className = item.children[0].className.replace(/0/, "1");
                            that.t['_dhtmlx_all']._checked = 1;
                        }
                    }
                } else if (that.options.mode == "radio") {
                    if (!item._checked) {
                        that._forEachOption2(function (item) {
                            item.children[0].className = item.children[0].className.replace(/1/, "0");
                            item._checked = 0;
                        });
                        item.children[0].className = item.children[0].className.replace(/0/, "1");
                        item._checked = 1;
                    }
                }
            }
            
            //event:value changed
            if (that.lastValue != that.getValue()) {
                that.callEvent("onCheckChanged", [that.getValue(), that.lastValue]);
                that.lastValue = that.getValue();
            }
            that.callEvent("onClick", [that.getValue()]);
        }
        
        that.t[item._optId] = item;
        
        return item._optId;
    };

    this._renderOther = function (data) {

        var item = document.createElement("DIV");
        item._checked = 0;
        item._optId = data.id;
        item._value = data.value;
        item._text = data.text;

        item.className = "dhtmlxcheckbox_" + that.options.skin + "_opt_qita";

        var itemTxt = document.createElement("span");
        itemTxt.className = "dhtmlxcheckbox_" + that.options.skin + "_txt";
        itemTxt.innerHTML = item._text;
        item.appendChild(itemTxt);

        var itemInput = document.createElement("input");
        itemInput.className = "dhtmlxcheckbox_" + that.options.skin + "_input";
        item.appendChild(itemInput);

        that.base.appendChild(item);

        that.t[item._optId] = item;
        return item._optId;
    }

    that._init(that.options.data);
    return this;

};
/* visibility */
dhtmlXCheckBox.prototype.show = function (mode) {
    if (typeof (mode) == "undefined") mode = true; else mode = window.dhx4.s2b(mode);
    this.base.style.display = (mode == true ? "" : "none");
};
dhtmlXCheckBox.prototype.hide = function (mode) {
    if (typeof (mode) == "undefined") mode = true;
    this.show(!mode);
};

dhtmlXCheckBox.prototype.isVisible = function () {
    return (this.base.style.display == "");
};
/* enable checkbox */
dhtmlXCheckBox.prototype.enable = function (mode) {
    if (mode == undefined) mode = true;
    this.options.enabled = mode;
    var that = this;
    this._forEachOption2(function (item) {
        that._enableOption(item._optId, mode);
    });
};
/* enable checkbox */
dhtmlXCheckBox.prototype.disable = function () {
    this.enable(false);

};
/* enable option */
dhtmlXCheckBox.prototype._enableOption = function (id, state) {
    if (state) {
        this.t[id].children[0].className = this.t[id].children[0].className.replace(/_dis/, "");
    } else {
        if (!/_dis/.test(this.t[id].children[0].className)) {
            //disabled其他项
            if (id == "_dhtmlx_qita") {
                this.t[id].children[1].disabled = "disabled";
            }
            else {
                this.t[id].children[0].className = this.t[id].children[0].className + "_dis";
            }
        }
    }
};

//20170111 刘志伟 添加复选框组排列方式
dhtmlXCheckBox.prototype.setAlign = function (arrange, align) {
    var that = this;
    
    if (arrange == "0") { //纵向排列
        if (align == 'center') {
            this._forEachOption2(function (item) {
                that.t[item._optId].style.marginLeft = (that.base.clientWidth - that.t[item._optId].clientWidth) / 2 + 'px';
            });
        }
        else {
            this._forEachOption2(function (item) {
                that.t[item._optId].style.float = "none";
            });
        }

    } else {
        if (align == 'center') {
            var rows = [];
            var rowIndex = 0;
            var tmpRowWidth = [];
            this._forEachOption2(function (item) {
                if (((tmpRowWidth[rowIndex] || 0) + that.t[item._optId].clientWidth) < that.base.clientWidth) {
                    rows[rowIndex] = rows[rowIndex] || [];
                    rows[rowIndex].push(that.t[item._optId]);
                    tmpRowWidth[rowIndex] = (tmpRowWidth[rowIndex] || 0) + that.t[item._optId].clientWidth;
                }
                else if (!rows[rowIndex] || rows[rowIndex].length == 0) {
                    rows[rowIndex] = rows[rowIndex] || [];
                    rows[rowIndex].push(that.t[item._optId]);
                    tmpRowWidth[rowIndex] = (tmpRowWidth[rowIndex] || 0) + that.t[item._optId].clientWidth;
                    rowIndex++;
                }
                else {
                    rowIndex++;
                    rows[rowIndex] = rows[rowIndex] || [];
                    rows[rowIndex].push(that.t[item._optId]);
                    tmpRowWidth[rowIndex] = (tmpRowWidth[rowIndex] || 0) + that.t[item._optId].clientWidth;
                }
            });
            for (var i = 0; i < rows.length; i++){
                for (var j = 0; j < rows[i].length; j++){
                    rows[i][j].style.float = "left";
                }
                rows[i][0].style.marginLeft = (that.base.clientWidth - tmpRowWidth[i]) / 2 + 'px';
            }
        }
        else if (align == 'right') {
            this._forEachOption2(function (item) {
                that.t[item._optId].style.float = "right";
            });
        }
        else {
            this._forEachOption2(function (item) {
                that.t[item._optId].style.float = "left";
            });
        }
    }
};

//20171125 刘志伟 设置显示列数
dhtmlXCheckBox.prototype.setColAlign = function (cols) {
    var that = this;
    cols = parseInt(cols);
    var maxColWidth = [];
    var itemIndex = 0;
    this._forEachOption2(function (item) {
        var colw = maxColWidth[itemIndex % cols];
        maxColWidth[itemIndex % cols] = colw ? Math.max(colw, that.t[item._optId].clientWidth) : that.t[item._optId].clientWidth;
        itemIndex++;
    });
    //调整最大列宽
    var totalW = eval(maxColWidth.join("+")) || 0;
    if (that.base.clientWidth < totalW) {
        var itemWidth = Math.floor(that.base.clientWidth / cols);
        for (var i = 0; i < maxColWidth.length; i++) {
            maxColWidth[i] = itemWidth;
        }
    }
    else {
        var remainWidth = that.base.clientWidth - totalW - cols;
        if (remainWidth > 0) {
            for (var i = 0; i < maxColWidth.length; i++) {
                maxColWidth[i] += remainWidth / cols;
            }
        }
    }

    itemIndex = 0;
    this._forEachOption2(function (item) {
        that.t[item._optId].style.width = maxColWidth[itemIndex % cols] + "px";
        that.t[item._optId].style.float = "left";
        itemIndex++;
    });
};

/* enable option */
dhtmlXCheckBox.prototype.setRowMargin = function (margin) {
    var that = this;
    this._forEachOption2(function (item) {
        var marginTop = Math.round(item.clientHeight * (parseInt(margin) / 100)) / 2;
        that.t[item._optId].style.marginTop = marginTop + "px";
        that.t[item._optId].style.marginBottom = marginTop + "px";
    });
};

//清除单选按钮选中状态
dhtmlXCheckBox.prototype.clearSelectStatus = function () {
    var that = this;
    for (var id in that.t) {
        that.t[id].childNodes[0].style.border = "0px solid #FFFFFF";
    }
}

/* enable option */
dhtmlXCheckBox.prototype.moveToNext = function () {
    var that = this;
    that.clearSelectStatus();
    var currentSelectId = that.currentSelectId;
    if (!currentSelectId) {
        for (var id in that.t) {
            currentSelectId = that.currentSelectId = id;
            break;
        }
    }
    else {
        var isJumpOut = false;
        for (var id in that.t) {
            if (isJumpOut) {
                currentSelectId = that.currentSelectId = id;
                break;
            }
            if (currentSelectId == id) {
                currentSelectId = that.currentSelectId = null;
                isJumpOut = true;
            }
        }
    }
    if (that.t[currentSelectId]) {
        that.t[currentSelectId].childNodes[0].style.border = "0px dotted #A0A0A0";
    }
    return currentSelectId;
};

/* enable option */
dhtmlXCheckBox.prototype.moveToPre = function () {
    var that = this;
    that.clearSelectStatus();
    var currentSelectId = that.currentSelectId;
    if (!currentSelectId) {
        for (var id in that.t) {
            currentSelectId = that.currentSelectId = id;
        }
    }
    else {
        var index = 0;
        var preSelectId;
        for (var id in that.t) {
            if (currentSelectId == id && index == 0) { //第一个
                currentSelectId = that.currentSelectId = null;
                break;
            }
            if (currentSelectId == id) {
                currentSelectId = that.currentSelectId = preSelectId;
                break;
            }
            preSelectId = id;
            index++;
        }
    }
    if (that.t[currentSelectId]) {
        that.t[currentSelectId].childNodes[0].style.border = "0px dotted #A0A0A0";
    }
    return currentSelectId;
};

/* setValue */
dhtmlXCheckBox.prototype.setValue = function (value) {
    if (value) {
        value += "";
        var that = this;
        var values = value.split(",").map(function (v) { return dhx4.trim(v) });
        this.checkAll(false);
        
        if (this.options.mode == "radio") {
            this._forEachOption2(function (item, index) {
                if (item._value == values[0]) {
                    that._check(item._optId, true);
                }
            });
        } else if (this.options.mode == "checkbox") {
            this._forEachOption2(function (item, index) {
                if (values.indexOf(item._value) != -1) {
                    that._check(item._optId, true);
                    //value = value.replace(values[i], "");
                }
            });
        }

        //如果存在其他项，则给其他项赋值
        if (that.t["_dhtmlx_qita"]) {
            function getWidth(str) {
                var span = document.getElementById("__getwidth");
                if (span == null) {
                    span = document.createElement("span");
                    span.id = "__getwidth";
                    document.body.appendChild(span);
                    span.style.visibility = "hidden";
                    span.style.whiteSpace = "nowrap";
                }
                span.innerText = str;
                span.style.fontSize = 13.5 + "px";

                return span.offsetWidth;
            }

            var qitaInputElement = that.t["_dhtmlx_qita"].children[1];

            if (qitaInputElement) {
                //替换掉复选框的值后会留下多余的逗号，先将逗号清除然后在把其他项的值中的逗号替换回来
                value = value.replace(/,/g, "").replace(/\*=\*/g, ",");
                qitaInputElement.value = value;

                qitaInputElement.style.width = (getWidth(value) > 100 ? getWidth(value) : 100) + "px";
            }
        }

        //if (this.lastValue != this.getValue()) {
        //    this.lastValue = this.getValue();
        //    this.callEvent("onCheckChanged", [this.getValue()]);
        //}
    }
	//刘志伟 20170812 修复填报列表中如果第一条记录的复选框选中时，后面的记录即使查询值为空默认选中的问题
    else if (this.options.mode != "radio") {
        this.checkAll(false);
    }
};
/* check option */
dhtmlXCheckBox.prototype._check = function (id, value) {
    if (!value) return;
    this.t[id].children[0].className = this.t[id].children[0].className.replace(/0/, "1");
    this.t[id]._checked = 1;
};
/* check all */
dhtmlXCheckBox.prototype.checkAll = function (bool) {
    if (this.options.mode == "radio") return;
    var that = this;
    if (bool) {
        this._forEachOption(function (item) {
            item.children[0].className = item.children[0].className.replace(/0/, "1");
            item._checked = 1;
        });
    }
    else {
        this._forEachOption(function (item) {
            item.children[0].className = item.children[0].className.replace(/1/, "0");
            item._checked = 0;
        });
    }
};

/* remove all options */
dhtmlXCheckBox.prototype.clearAll = function () {
    var that = this;
    this._forEachOption2(function (item) {
        that._removeOption(item._optId);
    });
};
/* remove all options */
dhtmlXCheckBox.prototype._removeOption = function (id) {
    this.base.removeChild(this.t[id]);
    delete this.t[id];
};
/* get option id */
dhtmlXCheckBox.prototype._getIndexById = function (_id) {
    this._forEachOption(function (id, index) {
        if (id == _id) return index;
    });
};
/* get checked value */
dhtmlXCheckBox.prototype.getValue = function () {
    var values = [];
    var hasItems = false;
    var qitaText = "";
    this._forEachOption2(function (item) {
        hasItems = true;
        if (item._optId == "_dhtmlx_all") {
            return;
        }
        else if (item._optId == "_dhtmlx_qita") {
            qitaText = item.childNodes[1].value;
            //qitaText = qitaText.replace(",", "*=*");
        }
        else if (item._checked) {
            values.push(item._value);
        }
    });
    if (qitaText) {
        values.push(qitaText);
    }
    return hasItems ? values.join(this.options.seperator) : null;
}
/* get checked text */
dhtmlXCheckBox.prototype.getText = function () {
    var texts = [];
    this._forEachOption2(function (item) {
        if (item._optId == "_dhtmlx_all") {
            return;
        }
        else if (item._optId == "_dhtmlx_qita") {
            qitaText = item.childNodes[1].value;
            //qitaText = qitaText.replace(",", "*=*");
        }
        else if (item._checked) {
            texts.push(item._text);
        }
    });
    if (qitaText) {
        texts.push(qitaText);
    }

    return texts.join(this.options.seperator);
}
/* iterator option */
dhtmlXCheckBox.prototype._forEachOption = function (handler) {
    var i = 0;
    for (id in this.t) {
        if (this.options.mode == "checkbox" && this.options.enableAll ) {
			if(id!='_dhtmlx_all')
				handler.apply(window, [this.t[id], i - 1]);
        }
        i++;
    }
};
dhtmlXCheckBox.prototype._forEachOption2 = function (handler) {
    var i = 0;
    for (id in this.t) {
        handler.apply(window, [this.t[id], i]);
        i++;
    }
};

/* whether checkbox & enableAll  */
dhtmlXCheckBox.prototype.isChkAngEnbleAll = function () {
    return this.options.enableAll && this.options.mode == "checkbox";
};

/* whether all option is checked */
dhtmlXCheckBox.prototype.isCheckedAll = function () {
    if (this.options.mode == "radio") return false;

    for (id in this.t) {
        if (id == '_dhtmlx_all') {
            continue;
        }
        if (!this.t[id]._checked) {
            return false;
        }
    }
    return true;
};

/* extend */
dhtmlXCheckBox.extend = function (destination, source) {
    for (var property in source) {
        destination[property] = source[property];
    }
    return destination;
}
;
///<jscompress sourcefile="dhtmlxfileupload.js" />
/*
filename：dhtmlXFileUpload.js
creater：刘志伟
date created：2017.6.20
description：上传组件
date modified：2018.08.03
modifier：刘志伟
version：2.3.12.0626
others：
copyright：Copyright @1999-2016, hwkj, All Rights Reserved
*/

/* uploader */
function dhtmlXFileUpload(p, options) {
    var that = this;
    window.dhx4._eventable(this);
    if (typeof (options.mode) == "string" && typeof (this[options.mode]) == "function") {
        this.engine = options.mode;
    } else {
        this.engine = "html4";

        var k = null;
        if (typeof (window.FormData) != "undefined" && typeof (window.XMLHttpRequest) != "undefined") {
            k = new XMLHttpRequest();
            if (typeof (k.upload) == "undefined") k = null;
        }

        if (k != null) {
            // IE10, IE11, FF, Chrome, Opera
            this.engine = "html5";
            this.engine = "html5";
        }
        else if (typeof (window.swfobject) != "undefined" || k === false) {
            var k = swfobject.getFlashPlayerVersion();
            if (k.major >= 32) this.engine = "flash";
            else {
                Ext.Msg.confirm("提示!", "当前flash版本低，是否立即下载修复?", function (btn) {
                    if (btn == "yes") {
                        window.open(options.flashPath);
                    }
                });
            }
            //mafei 20150901 
            //this.engine = "html4";
        } else {
            // check if silverlight installed
            this._sl_v = this.getSLVersion();
            if (this._sl_v) this.engine = "sl";
        }
        k = null;
    }

    if (typeof (p) == "string") p = document.getElementById(p);
    this.base = p;

    this._upload_mp = (typeof (options.multiple) != "undefined" ? options.multiple == true : true); // multiple file select
    this._upload_dnd = true;


    // swf-file path
    this._swf_file_url = options.swfPath || "";
    this._swf_upolad_url = options.swfUrl || "";
    this._swf_logs = options.swfLogs;

    // sl-data
    this._sl_xap = options.slXap || "";
    this._sl_upload_url = options.slUrl || "";
    this._sl_logs = options.slLogs || "";

    // main cont
    this.p = document.createElement("DIV");
    this.p.className += " dhx_file_uploader";
    //this.p.style.position = 'relative';
    p.appendChild(this.p);

    // files
    this.p_files = document.createElement("DIV");
    this.p_files.className = "dhx_upload_files";
    //this.p_files.style.position = 'absolute';
    this.p.appendChild(this.p_files);

    // buttons
    this.p_controls = document.createElement("DIV");
    this.p_controls.className = "dhx_upload_controls";
    this.p.appendChild(this.p_controls);

    // init engine

    /* upload */

    this._files = {};
    this._items = {};
    this._oldFiles={};

    this._data = {}; // uploaded files

    this._autoStart = false;
    this._autoRemove = false;
    this._titleScreen = true;

    this._enabled = true;

    this._uploaded_count = 0;
    this._fileType = options.fileType;
    this._showmode = options.showmode;

    this._numPerPage = options.numPerPage;
    this._cols = options.cols;

    this._isShowAll = options.isShowAll;
    this._dataHost = options.dataHost;
    this._wdkHost = options.wdkHost;

    this._initToolbar = function () {

        // add
        this.b_opts = {
            info: { onclick: null },
            browse: { onclick: null, tooltip: "Browse" },
            upload: {
                onclick: function () {
                    if (!that._enabled) return; if (!that._uploading) { that._uploadStart(); }
                }, tooltip: "Upload"
            },
            cancel: { onclick: function () { if (!that._enabled) return; that._uploadStop(); that._switchButton(false); }, tooltip: "Stop" },
            clear: { onclick: function () { if (!that._enabled) return; that.clear(); }, tooltip: "Clear list" }
        };

        this.buttons = {};

        for (var a in this.b_opts) {
            var k = document.createElement("DIV");
            k.innerHTML = "&nbsp;";
            k.className = "dhx_file_uploader_button button_" + a;
            k.onclick = this.b_opts[a].onclick;
            if (this.b_opts[a].tooltip) k.title = this.b_opts[a].tooltip;

            this.p_controls.appendChild(k);
            this.buttons[a] = k;

            k = null;
        }
    }

    this._readableSize = function (t) {
        var i = false;
        var b = ["b", "Kb", "Mb", "Gb", "Tb", "Pb", "Eb"];
        for (var q = 0; q < b.length; q++) if (t > 1024) t = t / 1024; else if (i === false) i = q;
        if (i === false) i = b.length - 1;
        return Math.round(t * 100) / 100 + " " + b[i];
    }

    this._beforeAddFileToList = function (name, size) {
        return (this.callEvent("onBeforeFileAdd", [name, size]) === true);
    }

    this.setDatas = function (datas) {
        this.datas = datas;
    }

    this.addItems = function () {
        if (!this.datas || this.datas.length == 0) {
            return;
        }
        var that = this;

        //清空数据
        this.p_files.innerHTML = "";
        this._files = {};
        this._items = {};
        this._oldFiles = {};

        // 文档库模式
        if (this.isWdk) {
            var hwFao = new HwFao(this._dataHost, "wdk");//地址:端口和存储标识(服务管理员分配)
            var docIds = this.datas.map(function (v) { return v.docid });
            hwFao.getWdkBrowseUrl(this._wdkHost, "vmdcode", docIds.join(","), function (res) {
                if (res.isSucceed && res.data) {
                    for (var i = 0; i < res.data.length; i++) {
                        that.addItem(res.data[i]);
                    }
                    that.doLayout();
                } else {
                    Ext.Msg.show({
                        title: "提示",
                        msg: "查询文件信息失败！文件id：" + docIds.join(","),
                        buttons: Ext.Msg.OK,
                        icon: Ext.Msg.ERROR
                    });
                }
            }, function (res) {
                Ext.Msg.alert("错误信息", res,
                    function () { })
            });
        }
        // 常规模式
        else {
            for (var i = 0; i < this.datas.length; i++){
                this.addItem(this.datas[i]);
            }
        }
        this.doLayout();
    }

    this.addItem = function (data) {
        if (!data) {
            return;
        }
        var filePath = data.url || data.path || "";
        var relativePath = data.url || "";
        var fileName = data.name || (filePath.substr(filePath.lastIndexOf('/') + 1));
        var fileType = (data.extend || (filePath.substr(filePath.lastIndexOf('.') + 1)) || "").replace(".", "");
        var fileSize = data.size || "";
        var fileDocId = data.docid || "";

        var vals = (this.val && this.val.split(",")) || [];
        var isShow = this._isShowAll ? true : (this.isWdk ? (fileDocId && vals.indexOf(fileDocId) != -1) : (filePath && vals.indexOf(filePath) != -1));
        if (isShow) {
            this._addServerFileToList(data.docid || data.id, fileName, filePath, relativePath, fileSize, fileType, fileDocId, "uploaded", "nochange");
        }
    }

    this._addServerFileToList = function (id, name, path,relativePath, size, ext, docId, state, storageState) {
        this._checkTitleScreen();

        var t = document.createElement("DIV");
        t._idd = id;
        t._server = true;
        t.className = "dhx_file dhx_file_" + state;
        //t.style.position = 'absolute';
        t.innerHTML = "<div class='dhx_file_param dhx_file_name'>" + name + "</div>" +
				"<div class='dhx_file_param dhx_file_progress'>" + "" + "%</div>" +
				"<div class='dhx_file_param dhx_file_delete' title='Remove from list'>&nbsp;</div>";

        this.p_files.appendChild(t);

        // filename area width
        //t.childNodes[0].style.width = t.offsetWidth - 127 + "px";

        this._items[id] = t;

        this.timestamp = this.timestamp || (new Date()).valueOf();
        this._files[id] = { server: true, file: null, name: name, size: size, state: state, path: path,relativePath:relativePath, ext: ext, id: docId,timestamp: this.timestamp++, storageState: storageState };
        this._oldFiles[id] =   this._files[id];
            t.childNodes[2].onclick = function () {
            if (!that._enabled) return;
            var id = this.parentNode._idd;
            that._removeFileFromQueue(id);
        }

        this.callEvent("onFileAdd", [this.id, name, id]);
    }

    this._addFileToList = function (id, name, size, state, progress) {

        this._checkTitleScreen();

        var t = document.createElement("DIV");
        t._idd = id;
        t.className = "dhx_file dhx_file_" + state;
        //t.style.position = 'absolute';
        t.innerHTML = "<div class='dhx_file_param dhx_file_name'>&nbsp;</div>" +
				"<div class='dhx_file_param dhx_file_progress'>" + progress + "%</div>" +
				"<div class='dhx_file_param dhx_file_delete' title='Remove from list'>&nbsp;</div>";
        
        this.p_files.appendChild(t);

        // filename area width
        //t.childNodes[0].style.width = t.offsetWidth - 127 + "px";

        this._items[id] = t;

        this._updateFileNameSize(id);
        //刘志伟20161008
        //添加鼠标指向时的提示功能
        this._items[id].childNodes[0].onmouseover = function (e) {
            e = e || window.event;
            e.cancelBubble = true;

            //var c = that.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
            //c._attrs['title'] = " ";
            var pageX = e.pageX;
            var pageY = e.pageY;
            if (pageX == undefined) {
                pageX = e.clientX + document.body.scrollLeft || document.documentElement.scrollLeft;
            }
            if (pageY == undefined) {
                pageY = e.clientY + document.body.scrollTop || document.documentElement.scrollTop;
            }
            var divTip = document.createElement("div");
            divTip.id = "upload_tip_" + this.id; //根据元素id生成提示信息DIV的id
            divTip.style.position = "absolute"; //采取绝对定位方式
            divTip.style.top = pageY + 10 + "px";         //定位提示信息显示位置在当前元素附近
            divTip.style.left = pageX + "px";
            divTip.style.border = "1px solid #666";
            divTip.style.background = "#FFFFFF";
            divTip.style.textIndent = 0;
            divTip.style.display = "";  //允许显示，为none则为不显示，但仍然在内存中
            divTip.innerHTML = this.innerText;//添加提示信息内容
            document.getElementsByTagName("body")[0].appendChild(divTip);   //添加到body作为网页内容的一部分，不添加则不会显示
            return false;
        }

        this._items[id].childNodes[0].onmouseout = function () {
            var divTip = document.getElementById("upload_tip_" + this.id);
            if (divTip) {     // 判断id是否存在，防止出现出错信息
                divTip.parentNode.removeChild(divTip);  // 实质是关闭，Remove掉，以免造成内存泄露
                // this.style.display = 'none'; 或者 divTip.style.display = 'none' 只是隐藏提示信息，仍占用内存空间，
                // 反复多次使用则会因为内存空间未释放而造成内存泄露问题

            }
        }

        t.childNodes[2].onclick = function () {
            if (!that._enabled) return;
            var id = this.parentNode._idd;
            that._removeFileFromQueue(id);
        }

        this.callEvent("onFileAdd", [this.id, name, id]);
    }

    this._removeFileFromList = function (id) {

        if (!this._items[id]) return;

        this._items[id].childNodes[2].onclick = null;
        this._items[id].parentNode.removeChild(this._items[id]);
        this._items[id] = null;
        delete this._items[id];

        if (this._data[id]) {
            this._data[id] = null;
            delete this._data[id];
        }

        this._checkTitleScreen();
    }

    this._getAddFileCount = function () {
        var count = 0;
        for(var fileID in this._files){
            if (this._files.hasOwnProperty(fileID) && this._files[fileID].storageState != "delete") {
                count++;
            }
        }
        return count;
    },

    this._displayFileToArea = function (fileID, top, left, width, height) {
        var that = this;
        var item = this._items[fileID];
        var file = this._files[fileID];
        var nameNode = item.childNodes[0];
        var uploadPercentNode = item.childNodes[1];
        var delNode = item.childNodes[2];

        item.style.top = top + "px";
        item.style.left = left + "px";
        item.style.width = width + "px";
        item.style.height = height + "px";
        item.style.position = "absolute";

        nameNode.style.top = (height - nameNode.clientHeight) / 2 + "px";
        uploadPercentNode.style.top = (height - uploadPercentNode.clientHeight) / 2 + "px";
        delNode.style.top = (height - delNode.clientHeight) / 2 + "px";

        var path = file.path.indexOf("http://") == -1 ? ("http://" + this._dataHost.replace("http://", "") + "/wdk/" + file.path) : file.path;

        nameNode.innerHTML = "<a target='_blank' style='text-align:left' href='" + path + "'>" + nameNode.innerHTML + "</a>";
        uploadPercentNode.style.visibility = "hidden";
        if (!this._deletable) {
            delNode.style.visibility = "hidden";
        }
    },

    this._displayImageToArea = function (fileID, top, left, width, height, displayMode, callback) {
        var that = this;
        var item = this._items[fileID];
        var file = this._files[fileID];

        if (item.childNodes.length == 0) {
            item.innerHTML = "<div class='dhx_file_param dhx_file_name'>" + name + "</div>" +
				"<div class='dhx_file_param dhx_file_progress'>" + "" + "%</div>" +
				"<div class='dhx_file_param dhx_file_delete' title='Remove from list'>&nbsp;</div>";
        }
        var nameNode = item.childNodes[0];
        var uploadPercentNode = item.childNodes[1];
        var delNode = item.childNodes[2];

        delNode.onclick = function () {
            if (!that._enabled) return;
            var id = this.parentNode._idd;
            dhtmlXFileUpload.prototype.html5.prototype._removeFileFromQueue.call(that, [id]);
        }

        item.style.top = top + "px";
        item.style.left = left + "px";
        item.style.width = width + "px";
        item.style.height = height + "px";
        item.style.position = "absolute";

        var timer;
        var imgOnload = function (imgs, that) {
            var cRadio = width / height;
            var imgRadio = imgs.width / imgs.height;

            if (displayMode == "ActualSize") {// 图片实际大小
                if (imgs.height < height) {
                    imgs.style.top = (height - imgs.height) / 2 + "px";
                }
            }
            else if (displayMode == "Extend") {// 伸展，拉伸
                imgs.width = width;
                imgs.height = height;
            }
            else if (displayMode == "Hextend") {// 横向拉伸
                var h = imgs.height;
                imgs.width = width;
                if (h < height) {
                    imgs.height = h;
                }
                imgs.style.top = (height - imgs.height) / 2 + "px";
            }
            else if (displayMode == "Vextens") {//纵向拉伸
                var w = imgs.width;
                imgs.height = height;
                if (w < imgs.width) {
                    imgs.width = w;
                }
            }
            else if (displayMode == "Fill") {//填充

            }
            else if (displayMode == "EqualScaling") {//等比例缩放
                //如果显示区域的宽高比大于图片的宽高比，则图片的高度等于显示区域高度，宽度按比例缩放
                if (cRadio > imgRadio) {
                    imgs.height = height - 2;
                    imgs.width = height * imgRadio;
                    imgs.style.left = (width - imgs.width) / 2 + "px";
                    imgs.style.top = 1 + "px";
                }
                else {
                    imgs.width = width - 2;
                    imgs.height = width / imgRadio;
                    imgs.style.left = 1 + "px";
                    imgs.style.top = (height - imgs.height) / 2 + "px";
                }
            }
            else if (displayMode == "Adapt") {//适应

            }
            else if (displayMode == "Tile") {//平铺

            }
            else {
               
            }
            if (callback) {
                callback.apply(that, []);
            }
        }

        var imgs = new Image();
        //imgs._width = this._items[fileID].clientWidth;
        this._items[fileID].removeChild(nameNode);
        imgs.onload = function () {
            if (imgs.complete && imgs.height && imgs.width) {
                imgOnload(this, that);
            }
            else {
                timer = setInterval(function () {
                    if (imgs.complete && imgs.height && imgs.width) {
                        imgOnload(imgs, that);
                        if (timer) {
                            clearInterval(timer);
                        }
                    }
                    else {
                        imgs.src = file.path.indexOf("http://") == -1 ? ("http://" + this._dataHost.replace("http://", "") + "/wdk/" + file.path) : file.path;
                    }
                }, 40);
            }
        };
        imgs.src = file.path.indexOf("http://") == -1 ? ("http://" + this._dataHost.replace("http://", "") + "/wdk/" + file.path) : file.path;

        imgs.ondragstart = function () { return false };
        imgs.onclick = function () {
            that.callEvent("onImgClick", [file]);
        }
        imgs.style.cursor = "pointer";
        imgs.style.position = "relative";
        //that._items[fileID].style.height = "100%";
        item.insertBefore(imgs, uploadPercentNode);
        delNode.style.top = (height - 12) / 2 + "px";
        delNode.style.right = "5px";
        uploadPercentNode.style.visibility = "hidden";

        if (!this._deletable) {
            delNode.style.visibility = "hidden";
        }
    },

    this.doLayout = function () {
        var that = this;
        var fileCount = this._getAddFileCount();

        var numPerPage = this._numPerPage || fileCount || 1;
        var cols = Math.min(numPerPage, this._cols);
        var displayMode = this._showmode; //ActualSize Extend Hextend Vextens Fill EqualScaling

        var pageNums = Math.ceil(fileCount / numPerPage);
        var perPageHeight = this.base.parentNode.clientHeight;

        var rows = Math.ceil(fileCount / cols);
        var areaLeft = 0;
        var areaTop = 0;
        var areaWidth = this.base.parentNode.clientWidth;
        var areaHeight = this.base.parentNode.clientHeight / rows;

        if (fileCount >= cols) {
            areaWidth = this.base.parentNode.clientWidth / cols;
        }
        else {
            areaWidth = this.base.parentNode.clientWidth / fileCount;
        }

        //排序
        var orderFiles = [];
        for (fileID in this._files) {
            if (this._files[fileID].storageState != "delete") {
                this._files[fileID].fileID = fileID;
                orderFiles.push(this._files[fileID]);
                this._items[fileID].style.pageBreakAfter = '';
            }
        }
        for (var i = 0; i < orderFiles.length; i++) {
            for (var j = 0; j < orderFiles.length; j++) {
                if (orderFiles[i].timestamp < orderFiles[j].timestamp) {
                    var temp = orderFiles[j];
                    orderFiles[j] = orderFiles[i];
                    orderFiles[i] = temp;
                }
            }
        }

        if (this._fileType == "image") {
            //根据页数对图片进行分组
            var pageImages = [];
            for (var i = 0; i < pageNums; i++) {
                pageImages[i] = [];
            }
            var pageIndex = 0;
            for (var i = 0; i < orderFiles.length; i++) {
                if (pageImages[pageIndex].length == numPerPage) {
                    pageIndex++;
                }
                pageImages[pageIndex].push(orderFiles[i]);
            }

            this.p_files.innerHTML = "";
            var rowsInpage = Math.ceil(numPerPage / cols);
            if (rowsInpage > 0) {
                areaHeight = perPageHeight / rowsInpage;
            }
            for (var i = 0; i < pageNums; i++) {
                var files = pageImages[i];

                var table = document.createElement('table');
                table.style.borderSpacing = "0px";
                table.style.borderCollapse = "collapse";
                table.style.textAlign = "left";
                if (i != pageNums - 1) {
                    table.style.pageBreakAfter = 'always';
                }

                this.p_files.appendChild(table);
                var ajustCompleteNum = 0;
                for (var j = 0; j < rowsInpage; j++) {
                    var tr = document.createElement('tr');
                    tr.style.height = areaHeight + 'px';
                    table.appendChild(tr);
                    var tdNums = Math.min(cols, orderFiles.length);
                    for (var k = 0; k < tdNums; k++) {
                        var td = document.createElement('td');
                        td.style.borderWidth = '0px';
                        td.style.height = areaHeight + 'px';
                        td.style.width = areaWidth + 'px';
                        td.style.position = "relative";
                        td.style.padding = "0px";
                        tr.appendChild(td);
                        var file = files[j * cols + k];
                        if (file) {
                            var item = this._items[file.fileID];
                            if (item) {
                                td.appendChild(item);
                                this._displayImageToArea(file.fileID, 0, 0, areaWidth, areaHeight, displayMode, function () {
                                    //ajustCompleteNum++;
                                    //if (ajustCompleteNum == fileCount) {
                                    //    that.grid.callEvent("ajustImageSuccess", []);
                                    //}
                                });
                            }
                        }
                    }
                }
            }
        }
        else {
            for (var fileIndex = 0; fileIndex < orderFiles.length; fileIndex++) {
                areaLeft = areaWidth * (fileIndex % cols);
                areaTop = parseInt(fileIndex / cols) * areaHeight;
                this._displayFileToArea(orderFiles[fileIndex].fileID, areaTop, areaLeft, areaWidth, areaHeight);
            }
        }
    },

    this._updateFileNameSize = function (id) {
        this._items[id].childNodes[0].innerHTML = this._files[id].name + (!isNaN(this._files[id].size) ? " (" + this._readableSize(this._files[id].size) + ")" : "&nbsp;");
        this._items[id].childNodes[0].title = this._files[id].name + (!isNaN(this._files[id].size) ? " (" + this._readableSize(this._files[id].size) + ")" : "");
        this._items[id].childNodes[0].id = id;
    }

    this._updateFileInList = function (id, state, progress) {
        if (!this._items[id]) return;
        this._items[id].className = "dhx_file dhx_file_" + state;
        //this._items[id].style.position = 'absolute';
        // progress
        this._updateProgress(id, state, progress);
        this._updateFileNameSize(id);
    }

    this.showProgress = function () {
        if (!this.p_progress) {
            this.p_progress = document.createElement("DIV");
            this.p_progress.className = "dhx_upload_progress";
            this.p.appendChild(this.p_progress);
        }
    },

    this.hideProgress = function () {
        if (this.p_progress) {
            this.p_progress.parentNode.removeChild(this.p_progress);
            this.p_progress = null;
        }
    }

    this._updateProgress = function (id, state, progress) {
        if (state == "uploading" && progress < 100 && this._progress_type == "loader") {
            this._items[id].childNodes[1].className = "dhx_file_param dhx_file_uploading";
            this._items[id].childNodes[1].innerHTML = "&nbsp;";
        } else {
            this._items[id].childNodes[1].className = "dhx_file_param dhx_file_progress";
            this._items[id].childNodes[1].innerHTML = progress + "%";
        }
        this._updateFileNameSize(id);
    }

    this._removeFilesByState = function (state) {
        for (var a in this._files) {
            if (state === true || this._files[a].state == state) {
                //this._removeFileFromQueue(a);
                dhtmlXFileUpload.prototype.html5.prototype._removeFileFromQueue.call(this, [a]);
            }
        }
    }

    this._removeFilesDoms = function (state) {
        if (!state) {
            return;
        }
        for (var a in this._files) {
            this._files[a].server = false;
            this._removeFileFromQueue(a, false);
        }
    }

    this._switchButton = function (state) {
        if (state == true) {
            this.buttons["upload"].style.display = "none";
            this.buttons["cancel"].style.display = "";
        } else {
            var t = this._uploaded_count;
            this.buttons["upload"].style.display = "";
            this.buttons["cancel"].style.display = "none";
            this._uploaded_count = 0;
            if (t > 0) this.callEvent("onUploadComplete", [t]);
        }
    }
    
    this._uploadStart = function () {

        this._switchButton(true);

        // change status for prev fail auploads if any
        if (!this._uploading) {
            for (var a in this._files) {
                if (this._files[a].state == "fail") {
                    this._files[a].state = "added";
                    this._updateFileInList(a, "added", 0);
                }
            }
        }

        this._uploading = true;

        var t = false;

        for (var a in this._files) {
            if (!t && [this._files[a].state] == "added") {
                t = true;
                this._files[a].state = "uploading";
                this._updateFileInList(a, "uploading", 0);
                this._doUploadFile(a);
            }
        }
        if (!t) {
            this._uploading = false;
            this._switchButton(false);
        }
    }

    this._onUploadSuccess = function (id, serverName, r, extra) {

        var response = "";
        // flash mode
        if (typeof (r) != "undefined" && this.engine == "flash") {
            dhx4.temp = null;
            try { eval("dhx4.temp=" + r.data); } catch (e) { dhx4.temp = null; };
            var t = dhx4.temp;
            response = r.data;
            dhx4.temp = null;
            if (t == null || !t.isSucceed) {
                this._onUploadFail(id, (t != null && t.extra != null ? t.extra : null));
                return;
            }
        }
        else {
            response = this._loader && this._loader.responseText;
        }

        //
        this._uploaded_count++;
        this._data[id] = { realName: this._files[id].name, serverName: serverName };
        this._files[id].state = "uploaded";
        this.timestamp = this.timestamp || (new Date()).valueOf();
        this._files[id].timestamp = this.timestamp++;
        this._files[id].storageState = "save";
        this._updateFileInList(id, "uploaded", 100);
        //this.callEvent("onUploadFile", [this._files[id].name, serverName, extra]);
        //wenlongxiang 20141222 Add argument t  
        this.callEvent("onUploadFile", [this._files[id].name, serverName, extra, t, response, this.id, id]);
        if (this._autoRemove) this._removeFileFromQueue(id);
        if (this._uploading) this._uploadStart();

    }

    this._onUploadFail = function (id, extra) {
        this._files[id].state = "fail";
        this._updateFileInList(id, "fail", 0);
        this.callEvent("onUploadFail", [this._files[id].name, extra]);
        if (this._uploading) this._uploadStart();
    }

    this._onUploadAbort = function (id) {
        this._uploading = false;
        this._files[id].state = "added";
        this._updateFileInList(id, "added", 0);
        this.callEvent("onUploadCancel", [this._files[id].name]);
    }

    this._checkTitleScreen = function () {
        var k = 0;
        for (var a in this._files) k++;

        if (k == 0 && this.p.className.search("dhx_file_uploader_title") < 0 && this._titleScreen) {
            // show title screen
            this.p.className += " dhx_file_uploader_title";
            this.buttons["info"].innerHTML = this._titleText;
            this.buttons["info"].style.width = Math.max(this.p_controls.offsetWidth - 134, 0) + "px";
        }
        if ((k > 0 || !this._titleScreen) && this.p.className.search("dhx_file_uploader_title") >= 0) {
            // hide title screen
            this.p.className = this.p.className.replace(/dhx_file_uploader_title/g, "");
            this.buttons["info"].innerHTML = "";
        }
    }

    // events
    //this.callEvent = function () { }
    this.checkAllUpload = function () {
        for (var a in this._files) {
            if (this._files[a].state != "uploaded") {
                return false;
            }
        }
        return true;
    }

    // public
    this.upload = function () {
        if (!this._uploading) this._uploadStart();
    }

    this.setIsWdk = function (isWdk) {
        this.isWdk = isWdk;
    }

    this.setUploadPath = function (uploadPath) {
        this.uploadPath = uploadPath;
    }

    this.setDeletable = function (deletable) {
        this._deletable = deletable;
        if (!deletable) {
            this.buttons["browse"].style.right = "40px";
        }
        this.buttons["clear"].style.display = deletable ? "block" : "none";
    }

    this.setAddable = function (addable) {
        this._addable = addable;
        if (!addable) {
            this.buttons["clear"].style.right = "40px";
        }
        this.buttons["browse"].style.display = addable ? "block" : "none";
    }

    this.setUploadable = function (uploadable) {
        this._uploadable = uploadable;
        this.buttons["upload"].style.display = uploadable ? "block" : "none";
    }
    
    this.setCancelable = function (cancelable) {
        this._cancelable = cancelable;
        this.buttons["cancel"].style.display = cancelable ? "block" : "none";
    }

    this.setInfoable = function (infoable) {
        this._infoable = infoable;
        this.buttons["info"].style.display = infoable ? "block" : "none";
    }
    
    this.setAutoStart = function (state) {
        this._autoStart = (state == true);
    }

    this.setAutoRemove = function (state) {
        this._autoRemove = (state == true);
    }

    this.enableTitleScreen = function (state) {
        this._titleScreen = (state == true);
        this._checkTitleScreen();
    }

    this.setTitleText = function (text) {
        this._titleText = text;
        if (this.p.className.search("dhx_file_uploader_title") >= 0) this.buttons["info"].innerHTML = this._titleText;
    }

    this.setURL = function (url) {
        this._url = url;
    }

    this.setSWFURL = function (url) {
        this._swf_upolad_url = url;
    }

    this.enable = function () {
        this._enabled = true;
        this.p_files.className = "dhx_upload_files";
        this.p_controls.className = "dhx_upload_controls";
    }

    this.disable = function () {
        this._enabled = false;
        this.p_files.className = "dhx_upload_files dhx_uploader_dis";
        this.p_controls.className = "dhx_upload_controls dhx_uploader_dis";
    }

    this.getStatus = function () {
        // 0 - filelist is empty
        // 1 - all files in filelist uploaded
        //-1 - not all files uploaded
        var t = 0;
        for (var a in this._files) {
            if (this._files[a].state != "uploaded") return -1;
            t = 1;
        }
        return t;
    }

    this.getData = function () {
        // return struct of uploaded files
        return this._data;
    }

    this.clear = function () {
        if (this.callEvent("onBeforeClear", []) !== true) return;
        if (this._uploading) that._uploadStop();
        that._switchButton(false);
        that._removeFilesByState(true);
        this.callEvent("onClear", []);
    }

    this.unload = function () {

        // remove all files from queue/list
        this._removeFilesByState(true);
        this._data = null;
        this._files = null;
        this._items = null;

        // custom engine stuff
        this._unloadEngine();

        // buttons
        for (var a in this.buttons) {
            this.buttons[a].onclick = null;
            this.buttons[a].parentNode.removeChild(this.buttons[a]);
            this.buttons[a] = null;
            delete this.buttons[a];
        }
        this.buttons = null;

        // buttons settings
        for (var a in this.b_opts) {
            this.b_opts[a].onclick = null;
            this.b_opts[a] = null;
            delete this.b_opts[a];
        }
        this.b_opts = null;

        this.p_controls.parentNode.removeChild(this.p_controls);
        this.p_files.parentNode.removeChild(this.p_files);

        // main container
        this.p.className = this.p.className.replace(/dhx_file_uploader_title/gi, "").replace(/dhx_file_uploader/gi, "");

        for (var a in this) this[a] = null;

        that = a = null;

    }

    // init engine-relative funcs
    var e = new this[this.engine]();
    for (var a in e) { this[a] = e[a]; e[a] = null; }
    a = e = p = null;

    // init app
    this._initToolbar();
    this._initEngine();
    this._checkTitleScreen();

    return this;

}

// html5 engine

dhtmlXFileUpload.prototype.html5 = function () { };

dhtmlXFileUpload.prototype.html5.prototype = {

    _initEngine: function () {

        var that = this;
        this.buttons["browse"].onclick = function () {
            if (that._enabled) that.f.click();
        }

        this._progress_type = "percentage";

        // Safari on Windows sometimes have problem with multiple file selections
        // file length set to zero, do not allow multiple file selecting
        // d-n-d seems works fine

        var k = window.navigator.userAgent;
        if (k.match(/Windows/gi) != null && k.match(/AppleWebKit/gi) != null && k.match(/Safari/gi) != null) {
            if (k.match(/Version\/5\.1\.5/gi)) this._upload_mp = false;
            if (k.match(/Version\/5\.1[^\.\d{1,}]/gi)) this._upload_dnd = false;
            if (k.match(/Version\/5\.1\.1/gi)) {
                this._upload_mp = false;
                this._upload_dnd = false;
            }
            if (k.match(/Version\/5\.1\.2/gi)) this._upload_dnd = false;
            if (k.match(/Version\/5\.1\.7/gi)) this._upload_mp = false;
        }

        // "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-EN) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.1 Safari/533.17.8"	// ok, no dnd
        // "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-EN) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.2 Safari/533.18.5"	// ok, no dnd
        // "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-EN) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.3 Safari/533.19.4"	// ok, no dnd
        // "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-EN) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.4 Safari/533.20.27"	// ok, no dnd
        // "Mozilla/5.0 (Windows; U; Windows NT 6.1; en-EN) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.5 Safari/533.21.1"	// ok, no dnd
        // "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50"				// ok, dnd partialy fail, disabled
        // "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.52.7 (KHTML, like Gecko) Version/5.1.1 Safari/534.51.22"			// multiple files add - fail, dnd partialy fail, disabled
        // "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.52.7 (KHTML, like Gecko) Version/5.1.2 Safari/534.52.7"			// ok, dnd partialy fail, disabled
        // "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.54.16 (KHTML, like Gecko) Version/5.1.4 Safari/534.54.16"			// ok
        // "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.55.3 (KHTML, like Gecko) Version/5.1.5 Safari/534.55.3"			// multiple files add - fail
        // "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2"			// dnd - ok, multiselect - fail (Windows 8)

        // input
        this._addFileInput();

        // dnd
        if (this._upload_dnd) {

            this.p.ondragenter = function (e) {
                if (!e.dataTransfer) return;
                e.stopPropagation();
                e.preventDefault();
            }
            this.p.ondragover = function (e) {
                if (!e.dataTransfer) return;
                e.stopPropagation();
                e.preventDefault();
            }
            this.p.ondrop = function (e) {
                if (!e.dataTransfer) return;
                e.stopPropagation();
                e.preventDefault();
                if (that._enabled) that._parseFilesInInput(e.dataTransfer.files);
            }

            this._titleText = "Drag-n-Drop files here or<br>click to select files for upload.";

        } else {
            this._titleText = "Click to select files for upload.";
        }
    },

    _addFileInput: function () {

        // complete input reload, opera needs
        if (this.f != null) {
            this.f.onchange = null;
            this.f.parentNode.removeChild(this.f);
            this.f = null;
        }

        var that = this;

        this.f = document.createElement("INPUT");
        this.f.type = "file";

        if (this._fileType == "image") {
            this.f.accept = "image/gif,image/jpeg,image/jpg,image/png";
        }

        if (this._upload_mp) this.f.multiple = "1";
        this.f.className = "dhx_uploader_input";
        this.p_controls.appendChild(this.f);

        this.f.onchange = function () {
            that._parseFilesInInput(this.files);
            //if (window.dhx4.isOpera) that._addFileInput(); else this.value = "";
            //mafei 20160115 修复同个文件上传一次后不能再次上传的问题
            that._addFileInput();
        }
    },

    _doUploadFile: function (id) {

        var that = this;

        if (!this._loader) {
            this._loader = new XMLHttpRequest();
            this._loader.upload.onprogress = function (e) {
                if (that._files[this._idd].state == "uploading") that._updateFileInList(this._idd, "uploading", Math.round(e.loaded * 100 / e.total));
            }
            this._loader.onload = function (e) {
                dhx4.temp = null;
                try { eval("dhx4.temp=" + this.responseText); } catch (e) { };
                var r = dhx4.temp;
                dhx4.temp = null;
                if (typeof (r) == "object" && r != null && typeof (r.isSucceed) != "undefined" && r.isSucceed == true) {
                    that._onUploadSuccess(this.upload._idd, r.data[0].name, null);
                    r = null;
                } else {
                    that._onUploadFail(this.upload._idd, (r != null && r.extra != null ? r.extra : null));
                }

            }
            this._loader.onerror = function (e) {
                that._onUploadFail(this.upload._idd);
            }
            this._loader.onabort = function (e) {
                that._onUploadAbort(this.upload._idd);
            }
        }

        this._loader.upload._idd = id;

        var form = new FormData();
        form.append("file", this._files[id].file);
        if (this.ruleJson && this.fldtJson) {
            form.append(this.ruleJson["key"], this.ruleJson["value"]);
            form.append(this.fldtJson["key"], this.fldtJson["value"]);
        }
        //this._loader.open("POST", this._url+(String(this._url).indexOf("?")<0?"?":"&")+"mode=html5&dhxr"+new Date().getTime(), true);
        this._loader.open("POST", this._url + (String(this._url).indexOf("?") < 0 ? "?" : "&") + "mode=html5&isWdk=" + this.isWdk + (this.uploadPath ? ("&uploadPath=" + escape(this.uploadPath)) : "") + "&dhxr" + new Date().getTime(), true);
        this._loader.setRequestHeader("X-Requested-With", "XMLHttpRequest");
        //this._loader.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
        this._loader.send(form);
        //mafei 20160115为了修复上传一次后不能再次上传的问题暂时去掉
        // if (this.ruleJson) this.ruleJson = null;
    },

    _uploadStop: function () {
        if (!this._uploading || !this._loader) return;
        this._loader.abort();
    },

    _parseFilesInInput: function (f) {
        for (var q = 0; q < f.length; q++) this._addFileToQueue(f[q]);
    },

    _addFileToQueue: function (f) {
        if (!this._beforeAddFileToList(f.name, f.size)) return;
        var id = (f._idd || window.dhx4.newId());
        this._files[id] = { file: f, name: f.name, size: f.size, state: "added" };
        this._addFileToList(id, f.name, f.size, "added", 0);
        if (this._autoStart && !this._uploading) this._uploadStart(true);
    },

    _removeFileFromQueue: function (id, callBeforeFileRemove) {

        if (!this._files[id] || this._files[id].storageState=="delete") return;

        var name = this._files[id].name;
        var serverName = (this._data != null && this._data[id] != null ? this._data[id].serverName : null);

        if (callBeforeFileRemove !== false) {
            if (this.callEvent("onBeforeFileRemove", [name, serverName]) !== true) return;
        }
        
        var k = false;
        if (this._uploading && id == this._loader.upload._idd && this._files[id].state == "uploading") {
            this._uploadStop();
            k = true;
        }
        var timeStamp = this._files[id].timestamp;

        if (this._files[id].server) {
            this._delFiles = this._delFiles || {};
            this._delFiles[id] = {
                id: this._files[id].id,
                name: this._files[id].name,
                path: this._files[id].path,
                size: this._files[id].size,
                storageState: "delete"
            }
        }
        this._files[id].file = null;
        this._files[id].name = null;
        this._files[id].size = null;
        this._files[id].state = null;
        this._files[id] = null;
        delete this._files[id];

        var dataID = this._items[id].dataID;
        this._removeFileFromList(id);

        this.callEvent("onFileRemove", [name, serverName, this.id, dataID, timeStamp]);

        if (k) this._uploadStart();

    },

    _unloadEngine: function () {

        this.buttons["browse"].onclick = null;

        this.f.onchange = null;
        this.f.parentNode.removeChild(this.f);
        this.f = null;

        this.p.ondragenter = null;
        this.p.ondragover = null;
        this.p.ondrop = null;

        if (this._loader) {
            this._loader.upload.onprogress = null;
            this._loader.onload = null;
            this._loader.onerror = null;
            this._loader.onabort = null;
            this._loader.upload._idd = null;
            this._loader = null;
        }

        this._initEngine = null;
        this._doUploadFile = null;
        this._uploadStop = null;
        this._parseFilesInInput = null;
        this._addFileToQueue = null;
        this._removeFileFromQueue = null;
        this._unloadEngine = null;

    }

};

// html4 engine

dhtmlXFileUpload.prototype.html4 = function () { };

dhtmlXFileUpload.prototype.html4.prototype = {

    _initEngine: function () {

        this._addForm();
        this._progress_type = "loader";

        this._titleText = "Click button<br>to select files for upload.";
    },

    _addForm: function () {

        var that = this;
        var id = window.dhx4.newId();

        if (!this.k) {

            this.k = document.createElement("DIV");
            this.k.className = "dhx_file_form_cont";
            this.buttons["browse"].appendChild(this.k);

            this.fr_name = "dhx_file_" + window.dhx4.newId();
            this.k.innerHTML = '<iframe name="' + this.fr_name + '" style="height:0px;width:0px;" frameBorder="0"></iframe>';

            this.fr = this.k.firstChild;

            if (window.navigator.userAgent.indexOf("MSIE") >= 0) {
                this.fr.onreadystatechange = function () {
                    if (this.readyState == "complete") that._onLoad();
                }
            } else {
                this.fr.onload = function () {
                    that._onLoad();
                }
            }

        }

        var f = document.createElement("DIV");
        /*f.innerHTML = "<form method='POST' enctype='multipart/form-data' target='"+this.fr_name+"' class='dhx_file_form' name='dhx_file_form_"+window.dhx4.newId()+"'>"+
				"<input type='hidden' name='mode' value='html4'>"+
				"<input type='hidden' name='uid' value='"+id+"'>"+
				"<input type='file' name='file' class='dhx_file_input'>"+
				"</form>";
                */
        //mafei 20150901 add rulejson and fldtjson field
        if (!this.ruleJson) {
            this.ruleJson = {};
            this.ruleJson["value"] = "{}";
        }
        if (!this.fldtJson) {
            this.fldtJson = {};
            this.fldtJson["value"] = "{}";
        }
        f.innerHTML = "<form method='POST' enctype='multipart/form-data' target='" + this.fr_name + "' class='dhx_file_form' name='dhx_file_form_" + window.dhx4.newId() + "'>" +
				"<input type='hidden' name='mode' value='html4'>" +
				"<input type='hidden' name='uid' value='" + id + "'>" +
                "<input type='hidden' name='rulejson' value='" + this.ruleJson["value"] + "'>" +
                "<input type='hidden' name='fldtjson' value='" + this.fldtJson["value"] + "'>" +
                "<input type='file' name='file' class='dhx_file_input'>" +
				"</form>";

        this.k.appendChild(f);

        f.firstChild.lastChild._idd = id;

        f.firstChild.lastChild.onchange = function () {
            if (!that._beforeAddFileToList(this.value, null)) return;
            that._addFileToQueue(this);
            this.onchange = null;
            this.parentNode.parentNode.style.display = "none";
            that._addForm();
        }

        f = null;
    },

    _onLoad: function () {
        if (this._uploading) {
            dhx4.temp = null;
            try { eval("dhx4.temp=" + this.fr.contentWindow.document.body.innerHTML); } catch (e) { };
            var r = dhx4.temp;
            dhx4.temp = null;
            //this.fr.contentWindow.document.body.innerHTML = "";
            if (typeof (r) == "object" && r != null) {
                if (typeof (r.state) != "undefined") {
                    if (r.state == "cancelled") {
                        this._onUploadAbort(this.fr._idd);
                        r = null;
                        return;
                    } else if (r.state == true) {
                        if (typeof (r.size) != "undefined" && !isNaN(r.size)) this._files[this.fr._idd].size = r.size;

                        //this._onUploadSuccess(this.fr._idd, r.name, null, r.extra);
                        //mafei 20150901
                        this._onUploadSuccess(this.fr._idd, r.name, null, r);
                        r = null;
                        return;
                    }
                }
            }
            this._onUploadFail(this.fr._idd, (r != null && r.extra != null ? r.extra : null));
        }

    },

    _addFileToQueue: function (t) {
        var v = t.value.match(/[^\\\/]*$/g);
        if (v[0] != null) v = v[0]; else v = t.value;
        //
        this._files[t._idd] = { name: v, form: t.parentNode, node: t.parentNode.parentNode, input: t, state: "added" };
        this._addFileToList(t._idd, t.value, false, "added", 0);
        if (this._autoStart && !this._uploading) this._uploadStart(true);
    },

    _removeFileFromQueue: function (id, callBeforeFileRemove) {

        var name = this._files[id].name;
        var serverName = (this._data != null && this._data[id] != null ? this._data[id].serverName : null);

        if (callBeforeFileRemove !== false) {
            if (this.callEvent("onBeforeFileRemove", [name, serverName]) !== true) return;
        }
        var timeStamp = this._files[id].timestamp;

        if (this._files[id].server) {
            this._delFiles = this._delFiles || {};
            this._delFiles[id] = {
                id: this._files[id].id,
                name: this._files[id].name,
                path: this._files[id].path,
                size: this._files[id].size,
                storageState: "delete"
            }
        }
        this._files[id].input.onchange = null;
        this._files[id].form.removeChild(this._files[id].input);
        this._files[id].node.removeChild(this._files[id].form);
        this._files[id].node.parentNode.removeChild(this._files[id].node);
        this._files[id].input = null;
        this._files[id].name = null;
        this._files[id].form = null;
        this._files[id].node = null;
        this._files[id].size = null;
        this._files[id].state = null;
        this._files[id] = null;
        delete this._files[id];

        var dataID = this._items[id].dataID;
        this._removeFileFromList(id);

        this.callEvent("onFileRemove", [name, serverName, this.id, dataID, timeStamp]);
    },

    _doUploadFile: function (id) {

        this.fr._idd = id;
        this._files[id].form.action = this._url;
        //mafei 20150901 add rulejson and fldtjson field
        if (this.ruleJson) {
            if (this._files[id].form[2].name == "rulejson")
                this._files[id].form[2].value = this.ruleJson["value"];
        }
        if (this.fldtJson) {
            if (this._files[id].form[3].name == "fldtjson")
                this._files[id].form[3].value = this.fldtJson["value"];
        }
        this._files[id].form.submit();
    },

    _uploadStop: function () {
        if (!this._uploading) return;
        this.fr.contentWindow.location.href = (this._url) + (this._url.indexOf("?") < 0 ? "?" : "&") + "mode=html4&isWdk=" + this.isWdk + (this.uploadPath ? ("&uploadPath=" + escape(this.uploadPath)) : "") + "&action=cancel&dhxr" + new Date().getTime();
    },

    _unloadEngine: function () {

        if (this.k) {

            this.fr_name = null;
            this.fr.onreadystatechange = null;
            this.fr.onload = null;
            this.fr.parentNode.removeChild(this.fr);
            this.fr = null;

            // remove empty form
            this.k.firstChild.firstChild.lastChild.onchange = null;

            this.k.parentNode.removeChild(this.k);
            this.k = null;

        }

        this._initEngine = null;
        this._addForm = null;
        this._onLoad = null;
        this._addFileToQueue = null;
        this._removeFileFromQueue = null;
        this._doUploadFile = null;
        this._uploadStop = null;
        this._unloadEngine = null;

    }

};


dhtmlXFileUpload.prototype.flash = function () { };

dhtmlXFileUpload.prototype.flash.prototype = {

    _initEngine: function () {

        if (!window.dhtmlXFileUploaderSWFObjects) {
            window.dhtmlXFileUploaderSWFObjects = {
                items: {},
                callEvent: function (id, name, params) {
                    //console.log(arguments)

                    return window.dhtmlXFileUploaderSWFObjects.items[id].uploader[name].apply(window.dhtmlXFileUploaderSWFObjects.items[id].uploader, params);
                }
            };
        }

        var that = this;

        this._swf_obj_id = "dhtmlXFileUploaderSWFObject_" + window.dhx4.newId();
        this._swf_file_url = this._swf_file_url + (this._swf_file_url.indexOf("?") >= 0 ? "&" : "?") + "dhxr" + new Date().getTime();
        this.buttons["browse"].innerHTML = "<div id='" + this._swf_obj_id + "' style='width:100%;height:100%;'></div>";

        swfobject.embedSWF(this._swf_file_url, this._swf_obj_id, "100%", "100%", "9", null, { ID: this._swf_obj_id, enableLogs: this._swf_logs }, { wmode: "transparent" });

        var v = swfobject.getFlashPlayerVersion();
        this._titleText = "Engine successfuly inited<br>Flash Player: " + v.major + "." + v.minor + "." + v.release;

        this._progress_type = "percentage";

        window.dhtmlXFileUploaderSWFObjects.items[this._swf_obj_id] = { id: this._swf_obj_id, uploader: this };
    },

    _beforeAddFileToQueue: function (name, size) {
        return (this.callEvent("onBeforeFileAdd", [name, size]) === true);
    },

    _addFileToQueue: function (id, name, size) {
        if (window.dhx4.isIE) {
            // focus+hide fix for IE
            var k = document.createElement("INPUT");
            k.type = "TEXT";
            k.style.position = "absolute";
            k.style.left = "0px";
            k.style.top = window.dhx4.absTop(this.buttons["browse"]) + "px";
            k.style.width = "10px";
            document.body.appendChild(k);
            k.focus();
            document.body.removeChild(k);
            k = null;
        }
        this._files[id] = { name: name, size: size, state: "added" };
        this._addFileToList(id, name, size, "added", 0);
        if (this._autoStart && !this._uploading) this._uploadStart(true);
    },

    _removeFileFromQueue: function (id, callBeforeFileRemove) {

        if (!this._files[id]) return;

        var name = this._files[id].name;
        var serverName = (this._data != null && this._data[id] != null ? this._data[id].serverName : null);

        if (callBeforeFileRemove !== false) {
            if (this.callEvent("onBeforeFileRemove", [name, serverName]) !== true) return;
        }

        var k = false;
        if (this._uploading && this._files[id].state == "uploading") {
            this._uploadStop();
            k = true;
        }

        swfobject.getObjectById(this._swf_obj_id).removeFileById(id);

        var timeStamp = this._files[id].timestamp;
        if (this._files[id].server) {
            this._files[id].storageState = "delete";
        }
        else {
            this._files[id].name = null;
            this._files[id].size = null;
            this._files[id].state = null;
            this._files[id] = null;
            delete this._files[id];
        }

        var dataID = this._items[id].dataID;
        this._removeFileFromList(id);

        this.callEvent("onFileRemove", [name, serverName, this.id, dataID, timeStamp]);

        if (k) this._uploadStart();

    },

    _doUploadFile: function (id) {

        swfobject.getObjectById(this._swf_obj_id).upload(id, this._swf_upolad_url);

    },

    _uploadStop: function (id) {
        for (var a in this._files) if (this._files[a].state == "uploading") swfobject.getObjectById(this._swf_obj_id).uploadStop(a);
    },

    _unloadEngine: function () {

        // remove instance from global storage

        if (window.dhtmlXFileUploaderSWFObjects.items[this._swf_obj_id]) {
            window.dhtmlXFileUploaderSWFObjects.items[this._swf_obj_id].id = null;
            window.dhtmlXFileUploaderSWFObjects.items[this._swf_obj_id].uploader = null;
            window.dhtmlXFileUploaderSWFObjects.items[this._swf_obj_id] = null
            delete window.dhtmlXFileUploaderSWFObjects.items[this._swf_obj_id];
        }

        this._swf_obj_id = null;

        this._initEngine = null;
        this._addFileToQueue = null;
        this._removeFileFromQueue = null;
        this._doUploadFile = null;
        this._uploadStop = null;
        this._unloadEngine = null;
    }

};

dhtmlXFileUpload.prototype.sl = function () { };

dhtmlXFileUpload.prototype.sl.prototype = {

    _initEngine: function () {

        if (typeof (this._sl_v) == "undefined") this._sl_v = this.getSLVersion();

        if (!window.dhtmlXFileUploaderSLObjects) {
            window.dhtmlXFileUploaderSLObjects = {
                items: {},
                callEvent: function (id, name, params) {
                    //console.log(arguments)
                    window.dhtmlXFileUploaderSLObjects.items[id].uploader[name].apply(window.dhtmlXFileUploaderSLObjects.items[id].uploader, params);
                }
            };
        }

        //var that = this;

        this._sl_obj_id = "dhtmlXFileUploaderSLObject_" + window.dhx4.newId();

        if (this._sl_v != false) {
            this._titleText = "Engine successfuly inited<br>Silverlight version: " + this._sl_v[0] + "." + this._sl_v[1];
            this.buttons["browse"].innerHTML = '<div style="width:100%;height:100%;">' +
									'<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" width="100%" height="100%" id="' + this._sl_obj_id + '">' +
										'<param name="source" value="' + this._sl_xap + '"/>' +
										'<param name="background" value="Transparent"/>' +
										'<param name="windowless" value="true"/>' +
										'<param name="initParams" value="SLID=' + this._sl_obj_id + ',LOGS=' + this._sl_logs + '"/>' +
										'<param name="minRuntimeVersion" value="5.0"/>' +
									'</object>' +
								'</div>';
        } else {
            this._titleText = "Silverlight plugin not found<br>or version less than 4.0";
            this.buttons["browse"].style.cursor = "wait";
            this.buttons["browse"].title = "";
        }

        this._progress_type = "percentage";

        window.dhtmlXFileUploaderSLObjects.items[this._sl_obj_id] = { id: this._sl_obj_id, uploader: this };
    },

    _addFileToQueue: function (id, name, size) {
        this._files[id] = { name: name, size: size, state: "added" };
        this._addFileToList(id, name, size, "added", 0);
        if (this._autoStart && !this._uploading) this._uploadStart(true);
    },

    _removeFileFromQueue: function (id) {
        if (!this._files[id]) return;

        var k = false;
        if (this._uploading && this._files[id].state == "uploading") {
            this._uploadStop();
            k = true;
        }

        document.getElementById([this._sl_obj_id]).Content.a.removeFileById(id);

        if (this._files[id].server) {
            this._delFiles = this._delFiles || {};
            this._delFiles[id] = {
                id: this._files[id].id,
                name: this._files[id].name,
                path: this._files[id].path,
                size: this._files[id].size,
                storageState: "delete"
            }
        }

        this._files[id].name = null;
        this._files[id].size = null;
        this._files[id].state = null;
        this._files[id] = null;
        delete this._files[id];

        this._removeFileFromList(id);

        if (k) this._uploadStart();

    },

    _doUploadFile: function (id) {
        document.getElementById(this._sl_obj_id).Content.a.upload(id, this._sl_upload_url, "&mode=sl&isWdk=" + this.isWdk + (this.uploadPath ? ("&uploadPath=" + escape(this.uploadPath)) : "") + "&dhxr" + new Date().getTime()); // leading "&" required!
    },

    _uploadStop: function (id) {
        this._uploading = false;
        for (var a in this._files) if (this._files[a].state == "uploading") document.getElementById(this._sl_obj_id).Content.a.uploadStop(a);
    },

    _unloadEngine: function () {

        // remove instance from global storage

        if (window.dhtmlXFileUploaderSLObjects.items[this._sl_obj_id]) {
            window.dhtmlXFileUploaderSLObjects.items[this._sl_obj_id].id = null;
            window.dhtmlXFileUploaderSLObjects.items[this._sl_obj_id].uploader = null;
            window.dhtmlXFileUploaderSLObjects.items[this._sl_obj_id] = null
            delete window.dhtmlXFileUploaderSLObjects.items[this._sl_obj_id];
        }

        this._sl_obj_id = null;

        this._initEngine = null;
        this._addFileToQueue = null;
        this._removeFileFromQueue = null;
        this._doUploadFile = null;
        this._uploadStop = null;
        this._unloadEngine = null;
    }

};

dhtmlXFileUpload.prototype.setValue = function (val) {
    this.val = val;
    this.addItems();
};

dhtmlXFileUpload.prototype.setSLURL = function (url) {
    this._sl_upload_url = url;
};

dhtmlXFileUpload.prototype.getSLVersion = function () {
    var v = false;
    if (window.dhx4.isIE) {
        try {
            var t = new ActiveXObject('AgControl.AgControl');
            if (t != null) {
                // loop through [4-x, 0-9] until supported
                var k1 = 4, k2 = 0;
                while (t.isVersionSupported([k1, k2].join("."))) {
                    v = [k1, k2];
                    if (++k2 > 9) { k1++; k2 = 0; }
                }
            }
            t = null;
        } catch (e) { };
    } else {
        if (navigator.plugins["Silverlight Plug-In"] != null) {
            v = navigator.plugins["Silverlight Plug-In"].description.split(".");
        }
    }
    return v;
};;
///<jscompress sourcefile="dhtmlxmessage.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

if(!window.dhtmlx)
	window.dhtmlx = {};

(function(){
	var _dhx_msg_cfg = null;
	function callback(config, result){
			var usercall = config.callback;
			modality(false);
			config.box.parentNode.removeChild(config.box);
			_dhx_msg_cfg = config.box = null;
			if (usercall)
				usercall(result);
	}
	function modal_key(e){
		if (_dhx_msg_cfg){
			e = e||event;
			var code = e.which||event.keyCode;
			if (dhtmlx.message.keyboard){
				if (code == 13 || code == 32)
					callback(_dhx_msg_cfg, true);
				if (code == 27)
					callback(_dhx_msg_cfg, false);
			}
			if (e.preventDefault)
				e.preventDefault();
			return !(e.cancelBubble = true);
		}
	}
	if (document.attachEvent)
		document.attachEvent("onkeydown", modal_key);
	else
		document.addEventListener("keydown", modal_key, true);
		
	function modality(mode){
		if(!modality.cover){
			modality.cover = document.createElement("DIV");
			//necessary for IE only
			modality.cover.onkeydown = modal_key;
			modality.cover.className = "dhx_modal_cover";
			document.body.appendChild(modality.cover);
		}
		var height =  document.body.scrollHeight;
		modality.cover.style.display = mode?"inline-block":"none";
	}

	function button(text, result){
		return "<div class='dhtmlx_popup_button' result='"+result+"' ><div>"+text+"</div></div>";
	}

	function info(text){
		if (!t.area){
			t.area = document.createElement("DIV");
			t.area.className = "dhtmlx_message_area";
			t.area.style[t.position]="15px";
			document.body.appendChild(t.area);
		}

		t.hide(text.id);
		var message = document.createElement("DIV");
		message.innerHTML = "<div>"+text.text+"</div>";
		message.className = "dhtmlx-info dhtmlx-" + text.type;
		message.onclick = function(){
			if (text) t.hide(text.id);
			text = null;
		};

		if (t.position == "bottom" && t.area.firstChild)
			t.area.insertBefore(message,t.area.firstChild);
		else
			t.area.appendChild(message);
		
		if (text.expire > 0)
			t.timers[text.id]=window.setTimeout(function(){
				t.hide(text.id);
			}, text.expire);

		t.pull[text.id] = message;
		message = null;

		return text.id;
	}
	function _boxStructure(config, ok, cancel){
		var box = document.createElement("DIV");
		box.className = " dhtmlx_modal_box dhtmlx-"+config.type;
		box.setAttribute("dhxbox", 1);
			
		var inner = '';

		if (config.width)
			box.style.width = config.width;
		if (config.height)
			box.style.height = config.height;
		if (config.title)
			inner+='<div class="dhtmlx_popup_title">'+config.title+'</div>';
		inner+='<div class="dhtmlx_popup_text"><span>'+(config.content?'':config.text)+'</span></div><div  class="dhtmlx_popup_controls">';
		if (ok)
			inner += button(config.ok || "OK", true);
		if (cancel)
			inner += button(config.cancel || "Cancel", false);
		if (config.buttons){
			for (var i=0; i<config.buttons.length; i++)
				inner += button(config.buttons[i],i);
		}
		inner += '</div>';
		box.innerHTML = inner;

		if (config.content){
			var node = config.content;
			if (typeof node == "string") 
				node = document.getElementById(node);
			if (node.style.display == 'none')
				node.style.display = "";
			box.childNodes[config.title?1:0].appendChild(node);
		}

		box.onclick = function(e){
			e = e ||event;
			var source = e.target || e.srcElement;
			if (!source.className) source = source.parentNode;
			if (source.className == "dhtmlx_popup_button"){
				var result = source.getAttribute("result");
				result = (result == "true")||(result == "false"?false:result);
				callback(config, result);
			}
		};
		config.box = box;
		if (ok||cancel)
			_dhx_msg_cfg = config;

		return box;
	}
	function _createBox(config, ok, cancel){
		var box = config.tagName ? config : _boxStructure(config, ok, cancel);
		
		if (!config.hidden)
			modality(true);
		document.body.appendChild(box);
		var x = config.left||Math.abs(Math.floor(((window.innerWidth||document.documentElement.offsetWidth) - box.offsetWidth)/2));
		var y = config.top||Math.abs(Math.floor(((window.innerHeight||document.documentElement.offsetHeight) - box.offsetHeight)/2));
		if (config.position == "top")
			box.style.top = "-3px";
		else
			box.style.top = y+'px';
		box.style.left = x+'px';
		//necessary for IE only
		box.onkeydown = modal_key;

		box.focus();
		if (config.hidden)
			dhtmlx.modalbox.hide(box);

		return box;
	}

	function alertPopup(config){
		return _createBox(config, true, false);
	}
	function confirmPopup(config){
		return _createBox(config, true, true);
	}
	function boxPopup(config){
		return _createBox(config);
	}
	function box_params(text, type, callback){
		if (typeof text != "object"){
			if (typeof type == "function"){
				callback = type;
				type = "";
			}
			text = {text:text, type:type, callback:callback };
		}
		return text;
	}
	function params(text, type, expire, id){
		if (typeof text != "object" || !text)
			text = {text:text, type:type, expire:expire, id:id};
		text.id = text.id||t.uid();
		text.expire = text.expire||t.expire;
		return text;
	}
	dhtmlx.alert = function(){
		var text = box_params.apply(this, arguments);
		text.type = text.type || "confirm";
		return alertPopup(text);
	};
	dhtmlx.confirm = function(){
		var text = box_params.apply(this, arguments);
		text.type = text.type || "alert";
		return confirmPopup(text);
	};
	dhtmlx.modalbox = function(){
		var text = box_params.apply(this, arguments);
		text.type = text.type || "alert";
		return boxPopup(text);
	};
	dhtmlx.modalbox.hide = function(node){
		while (node && node.getAttribute && !node.getAttribute("dhxbox"))
			node = node.parentNode;
		if (node){
			node.parentNode.removeChild(node);
			modality(false);
			_dhx_msg_cfg = null;
		}
	};
	var t = dhtmlx.message = function(text, type, expire, id){
		text = params.apply(this, arguments);
		text.type = text.type||"info";

		var subtype = text.type.split("-")[0];
		switch (subtype){
			case "alert":
				return alertPopup(text);
			case "confirm":
				return confirmPopup(text);
			case "modalbox":
				return boxPopup(text);
			default:
				return info(text);
			break;
		}
	};

	t.seed = (new Date()).valueOf();
	t.uid = function(){return t.seed++;};
	t.expire = 4000;
	t.keyboard = true;
	t.position = "top";
	t.pull = {};
	t.timers = {};

	t.hideAll = function(){
		for (var key in t.pull)
			t.hide(key);
	};
	t.hide = function(id){
		var obj = t.pull[id];
		if (obj && obj.parentNode){
			window.setTimeout(function(){
				obj.parentNode.removeChild(obj);
				obj = null;
			},2000);
			obj.className+=" hidden";
			
			if(t.timers[id])
				window.clearTimeout(t.timers[id]);
			delete t.pull[id];
		}
	};
})();
;
///<jscompress sourcefile="dhtmlxcolorpicker.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXColorPicker(base) {
	
	if (!(this instanceof window.dhtmlXColorPicker)) {
		return new dhtmlXColorPicker(base);
	}
	
	dhx4._eventable(this);
	
	var that = this, base_type = undefined,
	temp_node = null, i,l, temp_conf;
	
	this._nodes = [];
	
	this.activeNode = null;
	this._inputListenerId = null;
	this.base = null;
	this._globalNode = null;
	this.memory = null;
	this.skin = null;
	
	this.conf = {
		cp_id: dhx4.newId(),
		x: 0,
		y: 0,
		c: 0,
		indent: 2,
		position: "right", // right or bottom
		customColors: false,
		selectedColor: null,
		hide: false,
		hideOnSelect: false,
		lang: "en",
		closeable: true // autohide when button cancel clicked, can be used for custom-parent init
	};
	
	this.value = {
		red: -1,
		blue: -1,
		green: -1,
		hue: -1,
		sat: -1,
		lum: -1
	};
	
	this._initMoveSelection = function(e) {
		e = e || event;
		if (typeof(window.addEventListener) == "function") {
			that._controllerNodes.colorArea.addEventListener("mousemove", that._setMoveSelection, false);
			document.body.addEventListener("mouseup", that._cleanMoveSelection, false);
		} else {
			that._controllerNodes.colorArea.attachEvent("onmousemove", that._setMoveSelection);
			document.body.attachEvent("onmouseup", that._cleanMoveSelection);
		}
		
		that._setMoveSelection(e,that._controllerNodes.colorArea);
		return false;
	};
	
	this._cleanMoveSelection = function() {
		if (typeof(window.removeEventListener) == "function") {
			that._controllerNodes.colorArea.removeEventListener("mousemove", that._setMoveSelection, false);
			document.body.removeEventListener("mouseup", that._cleanMoveSelection, false);
		} else {
			that._controllerNodes.colorArea.detachEvent("onmousemove", that._setMoveSelection);
			document.body.detachEvent("onmouseup", that._cleanMoveSelection);
		}
		
		return false;
	};
	
	this._setMoveSelection = function(e) {
		e = e || event;
		var coord = that._getOffsetPosition(e, that._controllerNodes.colorArea);
		if (that._controllerNodes.fr_cover) {
			setTimeout(function() {
					that._setColorAreaXY(coord.x, coord.y);
					that._setColorByXYC();
			},0);
		} else {
			that._setColorAreaXY(coord.x, coord.y);
			that._setColorByXYC();
		}
		return false;
	};
	
	this._initMoveContrast = function(e) {
		e = e || event;
		if (typeof(window.addEventListener) == "function") {
			document.body.addEventListener("mousemove", that._setMoveContrast, false);
			document.body.addEventListener("mouseup", that._cleanMoveContrast, false);
		} else {
			document.body.attachEvent("onmousemove", that._setMoveContrast);
			document.body.attachEvent("onmouseup", that._cleanMoveContrast);
		}
		
		that._setMoveContrast(e,that._controllerNodes.contrastArea);
	};
	
	this._cleanMoveContrast = function() {
		if (typeof(window.removeEventListener) == "function") {
			document.body.removeEventListener("mousemove", that._setMoveContrast, false);
			document.body.removeEventListener("mouseup", that._cleanMoveContrast, false);
		} else {
			document.body.detachEvent("onmousemove", that._setMoveContrast);
			document.body.detachEvent("onmouseup", that._cleanMoveContrast);
		}
	};
	
	this._setMoveContrast = function(e) {
		e = e || event;
		
		var coord = that._getOffsetPosition(e, that._controllerNodes.contrastArea);
		that._setContrastY(coord.y);
		that._setColorByXYC(true);
	};
	
	this._doOnSelectColor = function() {
		var hex = that.colorAIP.rgb2hex({
				r: that.value.red,
				g: that.value.green,
				b: that.value.blue
		});
		
		if (that.activeNode != null) {
			if (that.activeNode.valueCont) {
				that.activeNode.valueCont.value = hex;
			}
			if (that.activeNode.valueColor) {
				that.activeNode.valueColor.style.backgroundColor = hex;
			}
		}
		
		if (that.base._dhx_remove || that.conf.hideOnSelect) {
			that.hide();
		}
		
		that.callEvent("onSelect",[hex,((that.activeNode)? that.activeNode.node: null)]);
	};
	
	this._doOnCancel = function() {
		// if cp isn't closeable - allow event to be fired anyway
		if (that.callEvent("onCancel",[((that.activeNode)? that.activeNode.node: null)]) == true && that.conf.closeable == true) {
			that.hide();
		}
	};
	
	this._doOnFocusByInput = function() {
		var target = (this != window)? this : event.srcElement;
		var object = (that.activeNode && that.activeNode.valueCont && that.activeNode.valueCont == target) ? that.activeNode : that._getNodeByValueCont(target);
		
		that.activeNode = object;
		if (object && object == that.activeNode) {
			that._initListenerInput();
		}
	};
	
	this._doOnBlurByInput = function() {
		var target = (this != window)? this : event.srcElement;
		var object = (that.activeNode && that.activeNode.valueCont && that.activeNode.valueCont == target) ? that.activeNode : that._getNodeByValueCont(target);
		if (object && object == that.activeNode) {
			that._removeListenerInput();
		}
	};
	
	this._doOnClickByNode = function(e) {
		e = e || event;
		var target = (this != window)? this : event.srcElement;
		that.activeNode = (that.activeNode.node != target)
		? that._getNodeByElement(target)
		: that.activeNode;
		if (!that.isVisible()) {
			that.show();
		}
	};
	
	this.saveColor = function() {
		that.memory.setValue(that.value);
	};
	
	this._onSelectMemoryEl = function(contr) {
		var key;
		that._refreshCoordinatesByHSL(contr.value.hue, contr.value.sat, contr.value.lum);
		
		for (key in contr.value) {
			that.value[key] = contr.value[key];
		}
		
		that._refreshContrast();
		that._refreshInputValues();
		that._refreshColorValue();
	};
	
	this._doOnClickByBody = function(e) {
		e = e || event;
		var is_close = true, target =e.target || e.srcElement;
		
		if (that._isBaseNode(target)) {
			is_close = false;
		}
		
		if (is_close && that.activeNode && (that.activeNode.node == target || that.activeNode.valueCont == target)) {
			is_close = false;
		}
		
		if (is_close) {
			that.hide();
		}
	};
	
	this._doOnChangeHSL = function() {
		var hue = parseInt(that._controllerNodes.hue.value),
		sat = parseInt(that._controllerNodes.sat.value),
		lum = parseInt(that._controllerNodes.lum.value),
		rgb;
		
		if (isNaN(hue) || hue > 359 || hue < 0) {
			that._controllerNodes.hue.value = that.value.hue;
		} else {
			that.value.hue = hue;
		}
		
		if (isNaN(sat) || sat > 100 || sat < 0) {
			that._controllerNodes.sat.value = that.value.sat;
		} else {
			that.value.sat = sat;
		}
		
		
		if (isNaN(lum) || lum > 100 || lum < 0) {
			that._controllerNodes.lum.value = that.value.lum;
		} else {
			that.value.lum = lum;
		}
		
		rgb = that.colorAIP.hsl2rgb(that.value.hue, that.value.sat/100, that.value.lum/100);
		that.value.red = Math.round(255*rgb.r);
		that.value.green = Math.round(255*rgb.g);
		that.value.blue = Math.round(255*rgb.b);
		
		that._refreshCoordinatesByHSL(that.value.hue,that.value.sat,that.value.lum);
		that._refreshContrast();
		that._refreshInputValues();
		that._refreshColorValue();
	};
	
	this._doOnChangeRGB = function() {
		var red = parseInt(that._controllerNodes.red.value),
		green = parseInt(that._controllerNodes.green.value),
		blue = parseInt(that._controllerNodes.blue.value),
		hsl;
		
		if (isNaN(red) || red > 255 || red < 0) {
			that._controllerNodes.red.value = that.value.red;
		} else {
			that.value.red = red;
		}
		
		if (isNaN(green) || green > 255 || green < 0) {
			that._controllerNodes.green.value = that.value.green;
		} else {
			that.value.green = green;
		}
		
		if (isNaN(blue) || blue > 255 || blue < 0) {
			that._controllerNodes.blue.value = that.value.blue;
		} else {
			that.value.blue = blue;
		}
		
		hsl = that.colorAIP.rgb2hsl(that.value.red/255, that.value.green/255, that.value.blue/255);
		that.value.hue = Math.round(hsl.h);
		that.value.sat = Math.round(hsl.s*100);
		that.value.lum = Math.round(hsl.l*100);
		
		that._refreshCoordinatesByHSL(that.value.hue,that.value.sat,that.value.lum);
		that._refreshContrast();
		that._refreshInputValues();
		that._refreshColorValue();
	};
	
	this._doOnChangeHSV = function() {
		that._controllerNodes.hsv.value = that.setColor(that._controllerNodes.hsv.value);
	};
	
	this._checkType = function (base) {
		var tempType;
		if (base instanceof Array) {
			tempType = that._checkType(base[0]);
			switch (tempType) {
			case "string":
				return "array_string";
				break;
			case "input":
			case "textarea":
				return "array_input";
				break;
			case "object":
				return "array_object";
				break;
				default:
				return undefined;
			}
			
		} else if (base == undefined) {
			return null;
			
		} else if (typeof(base) == "string") {
			return "string";
			
		} else if (base.tagName && base.tagName.toLowerCase() == "input") {
			return "input";
			
		} else if (base.tagName && base.tagName.toLowerCase() == "textarea") {
			return "textarea";
			
		} else if (base.tagName) {
			return "container";
			
		} else if (typeof(base) == "object") {
			return "object";
			
		} else return undefined;
	};
	
	this._initByObject = function (conf) {
		if (conf.parent && conf.parent.tagName) {
			that.base = conf.parent;
		} else if (typeof(conf.parent) == "string") {
			that.base = document.getElementById(conf.parent);
		} else {
			that.base = document.createElement("div");
			that.base._dhx_remove = true;
		}
		
		if (conf.color) {
			that.conf.selectedColor = conf.color;
		}
		if (typeof(conf.closeable) != "undefined") {
			this.conf.closeable = dhx4.s2b(conf.closeable);
		}
		if (conf.custom_colors) {
			this._tempInitCC = function() {
				var i, l;
				this.initMemoryColors();
				this.conf.customColors = true;
				
				if (conf.custom_colors instanceof Array) {
					l = conf.custom_colors.length;
					for (i=0; i<l; i++) {
						this.setCustomColors(conf.custom_colors[i]);
					}
				}
				
				if (this.base.parentNode) {
					this.showMemory();
				}
				delete this._tempInitCC;
			};
		}
		
		if (conf.hide) {
			that.conf.hide = true;
		}
		
		if (conf.input) {
			that._addNode(conf.input, conf.target_color, conf.target_value);
		}
		
		var skin = conf.skin || window.dhx4.skin || (typeof(dhtmlx) != "undefined"? dhtmlx.skin : null) || window.dhx4.skinDetect("dhxcolorpicker") || "material";
		that.setSkin(skin);
		
		// deprecated
		if (conf.colors) {
			that.initMemoryColors();
			that.conf.customColors = true;
		}
		
		if (conf.link) {
			that._addNode(conf.link);
		}
	};
	
	this.unload = function() {
		var i,l,key;
		if (this.isVisible()) {
			this.hide();
		}
		this.destructMemory();
		
		l = this._nodes.length;
		for (i=0; i<l; i++) {
			this._detachEventsFromNode(this._nodes[i]);
			for (key in this._nodes[i]) {
				this._nodes[i][key] = null;
			}
			delete this._nodes[i];
		}
		this._nodes = null;
		
		if (!this.base._dhx_remove) {
			this.base.className = this.base.className.replace(/\s?dhtmlxcp_\S*/, "");
		} else {
			delete this.base._dhx_remove;
		}
		
		if (typeof(window.addEventListener) == "function") {
			this._controllerNodes.colorArea.removeEventListener("mousedown", this._initMoveSelection, false);
			this._controllerNodes.colorArea.removeEventListener("dblclick", this._doOnSelectColor, false);
			this._controllerNodes.contrastArea.removeEventListener("mousedown", this._initMoveContrast, false);
			
			this._controllerNodes.button_save.removeEventListener("click", this._doOnSelectColor, false);
			this._controllerNodes.button_cancel.removeEventListener("click", this._doOnCancel, false);
			
			this._controllerNodes.hue.removeEventListener("change", this._doOnChangeHSL, false);
			this._controllerNodes.sat.removeEventListener("change", this._doOnChangeHSL, false);
			this._controllerNodes.lum.removeEventListener("change", this._doOnChangeHSL, false);
			
			this._controllerNodes.red.removeEventListener("change", this._doOnChangeRGB, false);
			this._controllerNodes.green.removeEventListener("change", this._doOnChangeRGB, false);
			this._controllerNodes.blue.removeEventListener("change", this._doOnChangeRGB, false);
			
			this._controllerNodes.hsv.removeEventListener("change", this._doOnChangeHSV, false);
			
		} else {
			this._controllerNodes.colorArea.detachEvent("onmousedown", this._initMoveSelection);
			this._controllerNodes.colorArea.detachEvent("ondblclick", this._doOnSelectColor);
			this._controllerNodes.contrastArea.detachEvent("onmousedown", this._initMoveContrast);
			
			this._controllerNodes.button_save.detachEvent("onclick", this._doOnSelectColor);
			this._controllerNodes.button_cancel.detachEvent("onclick", this._doOnCancel);
			
			this._controllerNodes.hue.detachEvent("onchange", this._doOnChangeHSL);
			this._controllerNodes.sat.detachEvent("onchange", this._doOnChangeHSL);
			this._controllerNodes.lum.detachEvent("onchange", this._doOnChangeHSL);
			
			this._controllerNodes.red.detachEvent("onchange", this._doOnChangeRGB);
			this._controllerNodes.green.detachEvent("onchange", this._doOnChangeRGB);
			this._controllerNodes.blue.detachEvent("onchange", this._doOnChangeRGB);
			
			this._controllerNodes.hsv.detachEvent("onchange", this._doOnChangeHSV);
		}
		
		if (this._controllerNodes.fr_cover) {
			if (this._controllerNodes.fr_cover.parentNode) {
				this._controllerNodes.fr_cover.parentNode.removeChild(this._controllerNodes.fr_cover);
			}
			delete this._controllerNodes.fr_cover;
		}
		
		dhx4.zim.clear(this.conf.cp_id);
		dhx4._eventable(this, "clear");
		
		for (key in this) {
			this[key] = null;
		}
		
		that = null, temp_node = null, temp_conf = null;
	};
	
	base_type = this._checkType(base);
	switch (base_type) {
		case "object":
			that._initByObject(base);
			break;
			
		case "input":
		case "textarea":
			that._initByObject({});
			this._addNode(base);
			break;
			
		case "string":
			temp_node = document.getElementById(base);
			return new dhtmlXColorPicker(temp_node);
			break;
			
		case "container":
			that._initByObject({
				parent: base
			});
			break;
			
		case null:
			that._initByObject({});
			break;
			
		case "array_string":
		case "array_input":
			that._initByObject({});
			l = base.length;
			for (i=0; i<l; i++) this._addNode(base[i]);
			break;
			
		case "array_object":
			that._initByObject({});
			l = base.length;
			for (i=0; i<l; i++) {
				temp_conf = this._addNode(base[i].input, base[i].target_color, base[i].target_value).conf;
				temp_conf.customColors = (base[i].custom_colors != undefined)? dhx4.s2b(base[i].custom_colors): temp_conf.customColors;
				temp_conf.selectedColor = (base[i].color != undefined)? base[i].color: temp_conf.selectedColor;
			}
			break;
	}
	
	this.base.innerHTML = "<div class='dhxcp_g_area'>"+
					"<div class='dhxcp_sub_area'>"+
						"<div class='dhxcp_g_color_area'>"+
							"<div class='dhxcp_color_selector'>"+
								"<div class='dhxcp_v_line'></div>"+
								"<div class='dhxcp_h_line'></div>"+
							"</div>"+
							"<div class='dhxcp_contrast_area'>"+
								"<div class='dhxcp_h_line'></div>"+
							"</div>"+
						"</div>"+
						//+
						"<div class='dhxcp_g_input_area'>"+
							"<div class='dhxcp_value_cont'>"+
								"<div class='dhxcp_value_color'></div>"+
								"<input type='text' class='dhxcp_value'/>"+
							"</div>"+
							"<table class='dhxcp_inputs_cont' cellpadding='0' cellspacing='0' border='0'>"+
								"<tr>"+
									"<td class='dhxcp_label_hsl'>"+this.i18n[this.conf.lang].labelHue+"</td>"+
									"<td class='dhxcp_input_hsl'><input type='text' class='dhxcp_input_hsl'/></td>"+
									"<td class='dhxcp_label_rgb'>"+this.i18n[this.conf.lang].labelRed+"</td>"+
									"<td class='dhxcp_input_rgb'><input type='text' class='dhxcp_input_rgb'/></td>"+
								"</tr>"+
								"<tr>"+
									"<td class='dhxcp_label_hsl'>"+this.i18n[this.conf.lang].labelSat+"</td>"+
									"<td class='dhxcp_input_hsl'><input type='text' class='dhxcp_input_hsl'/></td>"+
									"<td class='dhxcp_label_rgb'>"+this.i18n[this.conf.lang].labelGreen+"</td>"+
									"<td class='dhxcp_input_rgb'><input type='text' class='dhxcp_input_rgb'/></td>"+
								"</tr>"+
								"<tr>"+
									"<td class='dhxcp_label_hsl'>"+this.i18n[this.conf.lang].labelLum+"</td>"+
									"<td class='dhxcp_input_hsl'><input type='text' class='dhxcp_input_hsl'/></td>"+
									"<td class='dhxcp_label_rgb'>"+this.i18n[this.conf.lang].labelBlue+"</td>"+
									"<td class='dhxcp_input_rgb'><input type='text' class='dhxcp_input_rgb'/></td>"+
								"</tr>"+
							"</table>"+
						"</div>"+
						"<div class='dhxcp_g_memory_area'></div>"+
						"<div class='dhxcp_buttons_area'>"+
							"<button class='dhx_button_save'>"+this.i18n[this.conf.lang].btnSelect+"</button>"+
							"<button class='dhx_button_cancel'>"+this.i18n[this.conf.lang].btnCancel+"</button>"+
						"</div>"+
					"</div>"
				"</div>";
	
	this._globalNode = this.base.firstChild;
	
	this._controllerNodes = {
		colorArea: this._globalNode.firstChild.firstChild.firstChild,
		v_line   : this._globalNode.firstChild.firstChild.firstChild.childNodes[0],
		h_line   : this._globalNode.firstChild.firstChild.firstChild.childNodes[1],
		
		contrastArea : this._globalNode.firstChild.firstChild.childNodes[1],
		contrast_line: this._globalNode.firstChild.firstChild.childNodes[1].firstChild,
		
		color: this._globalNode.firstChild.childNodes[1].childNodes[0].firstChild,
		hsv  : this._globalNode.firstChild.childNodes[1].childNodes[0].childNodes[1],
		
		hue: this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[0].childNodes[1].firstChild,
		sat: this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[1].childNodes[1].firstChild,
		lum: this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[2].childNodes[1].firstChild,
		
		red  : this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[0].childNodes[3].firstChild,
		green: this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[1].childNodes[3].firstChild,
		blue : this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[2].childNodes[3].firstChild,
		
		memory_block: this._globalNode.firstChild.childNodes[2],
		
		button_save  : this._globalNode.firstChild.childNodes[3].firstChild,
		button_cancel: this._globalNode.firstChild.childNodes[3].childNodes[1]
	};
	
	this._labelNodes = {
		labelHue   : this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[0].firstChild,
		labelSat   : this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[1].firstChild,
		labelLum   : this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[2].firstChild,
		labelRed   : this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[0].childNodes[2],
		labelGreen : this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[1].childNodes[2],
		labelBlue  : this._globalNode.firstChild.childNodes[1].childNodes[1].firstChild.childNodes[2].childNodes[2],
		btnAddColor: null,
		btnSelect  : this._globalNode.firstChild.childNodes[3].firstChild,
		btnCancel  : this._globalNode.firstChild.childNodes[3].childNodes[1]
	};
	
	if (typeof(this._tempInitCC) == "function") {
		this._tempInitCC();
	};
	
	if (typeof(window.addEventListener) == "function") {
		this._controllerNodes.colorArea.addEventListener("mousedown", this._initMoveSelection, false);
		this._controllerNodes.colorArea.addEventListener("dblclick", this._doOnSelectColor, false);
		this._controllerNodes.contrastArea.addEventListener("mousedown", this._initMoveContrast, false);
		
		this._controllerNodes.button_save.addEventListener("click", this._doOnSelectColor, false);
		this._controllerNodes.button_cancel.addEventListener("click", this._doOnCancel, false);
		
		this._controllerNodes.hue.addEventListener("change", this._doOnChangeHSL, false);
		this._controllerNodes.sat.addEventListener("change", this._doOnChangeHSL, false);
		this._controllerNodes.lum.addEventListener("change", this._doOnChangeHSL, false);
		
		this._controllerNodes.red.addEventListener("change", this._doOnChangeRGB, false);
		this._controllerNodes.green.addEventListener("change", this._doOnChangeRGB, false);
		this._controllerNodes.blue.addEventListener("change", this._doOnChangeRGB, false);
		
		this._controllerNodes.hsv.addEventListener("change", this._doOnChangeHSV, false);
	} else {
		this._controllerNodes.colorArea.attachEvent("onmousedown", this._initMoveSelection);
		this._controllerNodes.colorArea.attachEvent("ondblclick", this._doOnSelectColor);
		this._controllerNodes.contrastArea.attachEvent("onmousedown", this._initMoveContrast);
		
		this._controllerNodes.button_save.attachEvent("onclick", this._doOnSelectColor);
		this._controllerNodes.button_cancel.attachEvent("onclick", this._doOnCancel);
		
		this._controllerNodes.hue.attachEvent("onchange", this._doOnChangeHSL);
		this._controllerNodes.sat.attachEvent("onchange", this._doOnChangeHSL);
		this._controllerNodes.lum.attachEvent("onchange", this._doOnChangeHSL);
		
		this._controllerNodes.red.attachEvent("onchange", this._doOnChangeRGB);
		this._controllerNodes.green.attachEvent("onchange", this._doOnChangeRGB);
		this._controllerNodes.blue.attachEvent("onchange", this._doOnChangeRGB);
		
		this._controllerNodes.hsv.attachEvent("onchange", this._doOnChangeHSV);
	}
	
	this.setColor(this.conf.selectedColor||"#ffffff");
	
	if (this._nodes.length) {
		for (var i=0; i<this._nodes.length; i++) {
			this._attachEventsToNode(this._nodes[i]);
		}
	}
	
	if (this.conf.hide) {
		this.hide();
	}
	
	if (typeof(this._cpInitFRM) == "function") {
		this._cpInitFRM();
	}
}

dhtmlXColorPicker.prototype.linkTo = function(colorValue, element, value) {
	if (arguments.length == 1) {
		element = value = colorValue;
	}
	
	var object;
	colorValue = colorValue || null;
	value = value || null;
	
	if (typeof(element) == "string") {
		element = document.getElementById(element);
	}
	
	object = this._addNode(element,colorValue,value);
	if (object) {
		this._attachEventsToNode(object);
	}
	
	return object;
};

dhtmlXColorPicker.prototype._isBaseNode = function(node) {
	if (node == this.base) {
		return true;
	}
	
	if (node.parentElement == document.body) {
		return false;
	} else if (!node.parentElement) {
		return false;
	} else {
		return this._isBaseNode(node.parentElement);
	}
};

dhtmlXColorPicker.prototype._hasInput = function(node) {
	var i,l, answer = false;
	l = this._nodes.length;
	for (i=0; i<l; i++) {
		if (this._nodes[i].valueCont == node) {
			answer = true;
			break;
		}
	}
	
	return answer;
};

dhtmlXColorPicker.prototype._findNodesByArray = function(data) {
	var i, l, temp, answer = [];
	l = data.length;
	for (i = 0; i<l; i++) {
		if (typeof(data[i]) == "string") {
			temp = document.getElementById(data[i]);
		} else {
			temp = data[i];
		}
		
		if (temp) {
			this._addNode(temp);
		}
	}
};

dhtmlXColorPicker.prototype._addNode = function(node, valueColor, value) {
	var _node, _newCont, _valueColor, object;
	if (typeof(node) == "string") {
		_node = document.getElementById(node);
	} else {
		_node = node;
	}
	
	if (typeof(valueColor) == "string") {
		valueColor = document.getElementById(valueColor);
	}
	
	if (typeof(value) == "string") {
		value = document.getElementById(value);
	}
	
	if (!_node) return null;
	
	if (dhx4.s2b(_node.getAttribute("colorbox"))) {
		_newCont = document.createElement('div');
		_newCont.style.width=_node.offsetWidth+"px";
		_newCont.style.height=_node.offsetHeight+"px";
		_node.style.width=_node.offsetWidth-(_node.offsetHeight+8)+"px";
		_node.parentNode.insertBefore(_newCont,_node);
		_newCont.style.position="relative";
		_valueColor=document.createElement("div");
		_newCont.appendChild(_node);
		_newCont.appendChild(_valueColor);
		_valueColor.className="dhxcp_colorBox";
		_node.className+=" dhxcp_colorInput";
		_valueColor.style.width=_valueColor.style.height= _node.offsetHeight+"px";
	}
	
	object = {
		node: _node,
		valueColor: (valueColor != undefined)? valueColor : _valueColor || _node,
		valueCont: (value != undefined)? value : _node,
		conf: {
			customColors: (_node.getAttribute("customcolors") != null) ? dhx4.s2b(_node.getAttribute("customcolors")) : null,
			selectedColor: _node.getAttribute("selectedcolor")
		}
	};
	
	this._nodes.push(object);
	
	if (!this.activeNode) {
		this.activeNode = object;
	}
	
	return object;
};

dhtmlXColorPicker.prototype.getNode = function(base) {
	var element = null, node = null;
	
	if (typeof(base) == "string") {
		element = document.getElementById(base);
	} else {
		element = base;
	}
	
	if (element.tagName != undefined) {
		node = this._getNodeByElement(element);
	}
	
	return node;
};

dhtmlXColorPicker.prototype._getNodeByElement = function(element) {
	var answer = null,i,l;
	l = this._nodes.length;
	for (i=0; i<l; i++) {
		if (this._nodes[i].node == element) {
			answer = this._nodes[i];
		}
	}
	
	return answer;
};

dhtmlXColorPicker.prototype._getNodeByValueCont = function(element) {
	var answer = null,i,l;
	l = this._nodes.length;
	for (i=0; i<l; i++) {
		if (this._nodes[i].valueCont &&  this._nodes[i].valueCont == element) {
			answer = this._nodes[i];
		}
	}
	
	return answer;
};

dhtmlXColorPicker.prototype.initMemoryColors = function() {
	
	var that = this;
	
	this._controllerNodes.memory_block.innerHTML = "<div class='dhxcp_memory_button_cont'>"+
								"<button class='dhxcp_save_to_memory'>"+
									"<div class='dhxcp_label_bm'>"+this.i18n[this.conf.lang].btnAddColor+"</div>"+
								"</button>"+
							"</div>"+
							"<div class='dhxcp_memory_els_cont'>"+
								"<a class='dhxcp_memory_el'></a>"+
								"<a class='dhxcp_memory_el'></a>"+
								"<a class='dhxcp_memory_el'></a>"+
								"<a class='dhxcp_memory_el'></a>"+
								"<a class='dhxcp_memory_el'></a>"+
								"<a class='dhxcp_memory_el'></a>"+
								"<a class='dhxcp_memory_el'></a>"+
								"<a class='dhxcp_memory_el'></a>"+
							"</div>";
	
	this.memory = new this.Memory(this._controllerNodes.memory_block.childNodes[1]);
	this.memory.onSelect = this._onSelectMemoryEl;
	this.memory.onSave = function(value) {
		var color = that.colorAIP.rgb2hex({r: value.red, g: value.green, b: value.blue});
		that.callEvent("onSaveColor", [color]);
	};
	
	var button = this._controllerNodes.memory_block.childNodes[0].firstChild;
	this._labelNodes.btnAddColor = this._controllerNodes.memory_block.childNodes[0].firstChild.firstChild;
	if (typeof(window.addEventListener) == "function") {
		button.addEventListener("click", this.saveColor, false);
	} else {
		button.attachEvent("onclick", this.saveColor);
	}
};

dhtmlXColorPicker.prototype._refreshCoordinatesByHSL = function(h,s,l) {
	var x,y1,y2;
	x = Math.round((this.configColorArea.maxX - this.configColorArea.minX)*h/359)+this.configColorArea.minX;
	y1 = Math.round((this.configColorArea.maxY - this.configColorArea.minY)*(100-l)/100) + this.configColorArea.minY;
	y2 = Math.round((this.configColorArea.maxY - this.configColorArea.minY)*(100-s)/100) + this.configColorArea.minY;
	
	this._setColorAreaXY(x,y1);
	this._setContrastY(y2);
};

dhtmlXColorPicker.prototype._parseColor = function(value) {
	if (value instanceof Array) {
		var rgb = {
			r: parseInt(value[0]),
			g: parseInt(value[1]),
			b: parseInt(value[2])
		};
	} else if (typeof(value) == "string") {
		value = value.replace(/\s/g,"");
		if (/^rgb\((\d{1,3})\,(\d{1,3})\,(\d{1,3})\)$/i.test(value)) {
			var temp = value.match(/^rgb\((\d{1,3})\,(\d{1,3})\,(\d{1,3})\)$/i);
			var rgb = {
				r: parseInt(temp[1]),
				g: parseInt(temp[2]),
				b: parseInt(temp[3])
			};
		} else {
			var rgb = this.colorAIP.hex2rgb(value);
		}
	}
	return rgb;
};

dhtmlXColorPicker.prototype.setColor = function(value) {
	
	var old_value = this.colorAIP.rgb2hex({ r:this.value.red, g:this.value.green, b:this.value.blue});
	var rgb = this._parseColor(value);
	
	var is_check = (rgb instanceof Object);
	is_check = is_check && (0 <= rgb.r && rgb.r <= 255);
	is_check = is_check && (0 <= rgb.g && rgb.g <= 255);
	is_check = is_check && (0 <= rgb.b && rgb.b <= 255);
	
	if (!is_check) {
		return old_value;
	}
	
	var new_value = this.colorAIP.rgb2hex({ r:rgb.r, g:rgb.g, b:rgb.b });
	
	if (new_value == old_value) {
		return old_value;
	}
	
	this.value.red = rgb.r;
	this.value.green = rgb.g;
	this.value.blue = rgb.b;
	
	var hsl = this.colorAIP.rgb2hsl(rgb.r/255,rgb.g/255,rgb.b/255);
	this.value.hue = Math.round(hsl.h);
	this.value.sat = Math.round(hsl.s*100);
	this.value.lum = Math.round(hsl.l*100);
	
	this._refreshCoordinatesByHSL(this.value.hue, this.value.sat, this.value.lum);
	this._refreshContrast();
	this._refreshInputValues();
	this._refreshColorValue();
	
	return new_value;
};

dhtmlXColorPicker.prototype.getSelectedColor = function() {
	return [
		this.colorAIP.rgb2hex({ r:this.value.red, g:this.value.green, b:this.value.blue }),
		[this.value.red, this.value.green, this.value.blue],
		[this.value.hue, this.value.sat, this.value.lum]
	];
};

dhtmlXColorPicker.prototype._attachEventsToNode = function(object) {
	if (typeof(window.addEventListener) == "function") {
		object.node.addEventListener("click", this._doOnClickByNode, false);
	} else {
		object.node.attachEvent("onclick", this._doOnClickByNode);
	}
	
	if (object.valueCont && object.valueCont.tagName.toLowerCase() == "input") {
		if (typeof(window.addEventListener) == "function") {
			object.valueCont.addEventListener("focus", this._doOnFocusByInput, false);
			object.valueCont.addEventListener("blur", this._doOnBlurByInput, false);
		} else {
			object.valueCont.attachEvent("onfocus", this._doOnFocusByInput);
			object.valueCont.attachEvent("onblur", this._doOnBlurByInput);
		}
	}
};

dhtmlXColorPicker.prototype._detachEventsFromNode = function(object) {
	if (typeof(window.addEventListener) == "function") {
		object.node.removeEventListener("click", this._doOnClickByNode, false);
	} else {
		object.node.detachEvent("onclick", this._doOnClickByNode);
	}
	
	if (object.valueCont && object.valueCont.tagName.toLowerCase() == "input") {
		if (typeof(window.addEventListener) == "function") {
			object.valueCont.removeEventListener("focus", this._doOnFocusByInput, false);
			object.valueCont.removeEventListener("blur", this._doOnBlurByInput, false);
		} else {
			object.valueCont.detachEvent("onfocus", this._doOnFocusByInput);
			object.valueCont.detachEvent("onblur", this._doOnBlurByInput);
		}
	}
};

dhtmlXColorPicker.prototype.show = function(node) {
	var is_show_memory = false;
	
	if (node != undefined) {
		this.activeNode = this.getNode(node) || this.activeNode;
	}
	
	if (this.activeNode && this.activeNode.valueCont && this.activeNode.valueCont.value) {
		this.setColor(this.activeNode.valueCont.value);
	}
	
	if (this.activeNode) {
		is_show_memory = (this.activeNode.conf.customColors!=null?this.activeNode.conf.customColors:this.conf.customColors);
		this.setColor(this.activeNode.conf.selectedColor);
	} else {
		is_show_memory = this.conf.customColors;
	}
	
	if (is_show_memory) {
		this.showMemory();
	} else {
		this.hideMemory();
	}
	
	if (this.base._dhx_remove) {
		this.base.firstChild.style.zIndex = dhx4.zim.reserve(this.conf.cp_id);
		
		this.base.style.visibility = "hidden";
		if (document.body.firstChild) {
			document.body.insertBefore(this.base, document.body.firstChild);
		} else {
			document.body.appendChild(this.base);
		}
		
		this._refreshPosition();
		this.base.style.visibility = "visible";
		
		if (typeof(window.addEventListener) == "function") {
			document.body.addEventListener("mousedown", this._doOnClickByBody, false);
		} else {
			document.body.attachEvent("onmousedown", this._doOnClickByBody);
		}
		
	} else {
		this.base.appendChild(this._globalNode);
	}
	
	if (this._controllerNodes.fr_cover) {
		this.base.insertBefore(this._controllerNodes.fr_cover, this._globalNode);
	}
	
	this.callEvent("onShow",[((this.activeNode)? this.activeNode.node: null) ]);
};

dhtmlXColorPicker.prototype.setPosition = function(x,y) {
	var pos = null;
	var cx = parseInt(x);
	var cy = parseInt(y);
	if (isNaN(cx)) pos = ({right:"right",bottom:"bottom"}[x.toLowerCase()]?x:null);
	
	if (this.base._dhx_remove) {
		if (pos == null) {
			
		} else {
			this.conf.position = pos;
			this._refreshPosition(pos);
		}
		
	} else {
		if (isNaN(cx) || isNaN(cy)) {
			
		} else {
			this._globalNode.style.left = cx + "px";
			this._globalNode.style.top = cy + "px";
			
			if (this._controllerNodes.fr_cover) {
				this._controllerNodes.fr_cover.style.left = this._globalNode.style.left;
				this._controllerNodes.fr_cover.style.top = this._globalNode.style.top;
			}
		}
	}
};

dhtmlXColorPicker.prototype._initListenerInput = function() {
	var that = this;
	this._inputListenerId = this._inputListenerId || setInterval(function() {
			that._refreshValueByInput();
	},70);
};

dhtmlXColorPicker.prototype._removeListenerInput = function() {
	if (this._inputListenerId) {
		clearInterval(this._inputListenerId);
		this._inputListenerId = null;
	}
};

dhtmlXColorPicker.prototype._refreshValueByInput = function() {
	var value = this.activeNode.valueCont.value,
	oldValue = this.getSelectedColor()[0];
	
	if (this._inputListenerId) {
		if (/^#[\da-f]{6}$/i.test(value) && value != oldValue) {
			this.setColor(value);
			this.callEvent("onSelect",[value, this.activeNode.node]);
		}
	}
};

dhtmlXColorPicker.prototype._refreshPosition = function(position) {
	if (this.activeNode == null) return;
	
	var topInp = dhx4.absTop(this.activeNode.node);
	var leftInp = dhx4.absLeft(this.activeNode.node);
	var sizeWindow = dhx4.screenDim();
	var widthCP = this._globalNode.offsetWidth;
	var heigthCP = this._globalNode.offsetHeight;
	var top = 0;
	
	position = position || this.conf.position;
	
	switch (position) {
		case "bottom":
			var top = topInp+this.activeNode.node.offsetHeight+this.conf.indent;
			var left = leftInp;
			
			// no space on right
			if (left+widthCP > sizeWindow.left+sizeWindow.right) {
				left = leftInp+this.activeNode.node.offsetWidth-widthCP;
			}
			//no space on left
			if (left < sizeWindow.left) {
				left = leftInp;
			}
			
			// no space at bottom
			if (top+heigthCP > sizeWindow.top+sizeWindow.bottom) {
				top = topInp-heigthCP-this.conf.indent;
			}
			
			// on top also no more space (browser's height too small?)
			if (top - sizeWindow.top < 0) {
				top = sizeWindow.top + this.conf.indent;
			}
			
			this._globalNode.style.top = top+"px";
			this._globalNode.style.left = left+"px";
			
			
			break;
		default:
			var left = leftInp+this.activeNode.node.offsetWidth+this.conf.indent;
			top = topInp;
			
			if (position == "right") {
				// no space on right, open to left
				if (left+widthCP > sizeWindow.left+sizeWindow.right) {
					left = leftInp-widthCP-this.conf.indent;
				}
				// no space on left, open to right
				if (left < sizeWindow.left) {
					left = leftInp+this.activeNode.node.offsetWidth+this.conf.indent;
				}
			}
			
			if (sizeWindow.bottom - (top + heigthCP) <= 0) {
				top = topInp+this.activeNode.node.offsetHeight-heigthCP;
			}
			
			if (top - sizeWindow.top < 0) {
				top = sizeWindow.top + this.conf.indent;
			}
			this._globalNode.style.left = left+"px";
			this._globalNode.style.top = top+"px";
	}
	
	if (this._controllerNodes.fr_cover) {
		this._controllerNodes.fr_cover.style.left = this._globalNode.style.left;
		this._controllerNodes.fr_cover.style.top = this._globalNode.style.top;
	}
};

dhtmlXColorPicker.prototype.isVisible = function() {
	var answer = false;
	if (this.base._dhx_remove) {
		answer = this.base.parentNode == document.body;
	} else {
		answer = this._globalNode.parentNode == this.base;
	}
	
	return answer;
};

dhtmlXColorPicker.prototype.hide = function() {
	if (this.base._dhx_remove) {
		if (this.base.parentNode) {
			this.base.parentNode.removeChild(this.base);
			dhx4.zim.clear(this.conf.cp_id);
			if (typeof(window.addEventListener) == "function") {
				document.body.removeEventListener("mousedown", this._doOnClickByBody, false);
			} else {
				document.body.detachEvent("onmousedown", this._doOnClickByBody);
			}
		}
	} else {
		if (this.isVisible() == false) return;
		this.base.removeChild(this._globalNode);
	}
	
	if (this._controllerNodes.fr_cover && this._controllerNodes.fr_cover.parentNode) {
		this._controllerNodes.fr_cover.parentNode.removeChild(this._controllerNodes.fr_cover);
	}
	
	if (this.callEvent != undefined) {
		this.callEvent("onHide",[((this.activeNode)? this.activeNode.node: null) ]);
	}
};

dhtmlXColorPicker.prototype.configColorArea = {
	minX: 1,
	maxX: 209,
	minY: 1,
	maxY: 119
};

dhtmlXColorPicker.prototype._skinCollection = {
	dhx_skyblue: true,
	dhx_web: true,
	dhx_terrace: true,
	material: true
};

dhtmlXColorPicker.prototype.i18n = {
	en: {
		labelHue   : "Hue",
		labelSat   : "Sat",
		labelLum   : "Lum",
		labelRed   : "Red",
		labelGreen : "Green",
		labelBlue  : "Blue",
		btnAddColor: "Save the color",
		btnSelect  : "Select",
		btnCancel  : "Cancel"	},
	ch: { 
		labelHue   : "Hue",
		labelSat   : "Sat",
		labelLum   : "Lum",
		labelRed   : "Red",
		labelGreen : "Green",
		labelBlue  : "Blue",
		btnAddColor: "保存",
		btnSelect  : "选择",
		btnCancel  : "取消"
	}
};

dhtmlXColorPicker.prototype.loadUserLanguage = function(ln) {
	// deprecated
	if (typeof(this._mergeLangModules) == "function") { 
		this._mergeLangModules();
	}
	//
	
	this.conf.lang = ln;
	this._refreshLanguage();
};

dhtmlXColorPicker.prototype._refreshLanguage = function() {
	var key, hash= this.i18n[this.conf.lang];
	for (key in hash) {
		if (this._labelNodes[key]) {
			this._labelNodes[key].innerHTML = hash[key];
		}
	}
};

dhtmlXColorPicker.prototype._setColorAreaXY = function(x,y) {
	var config = this.configColorArea;
	
	x = parseInt(x);
	if (config.minX > x) {
		this.conf.x = config.minX;
	} else if (x > config.maxX) {
		this.conf.x = config.maxX;
	} else if (!isNaN(x)) {
		this.conf.x = x;
	}
	
	y = parseInt(y);
	if (config.minY > y) {
		this.conf.y = config.minY;
	} else if (y > config.maxY) {
		this.conf.y = config.maxY;
	} else if (!isNaN(y)) {
		this.conf.y = y;
	}
	
	this._refreshLines();
};

dhtmlXColorPicker.prototype._setColorByXYC = function(notRefreshC) {
	notRefreshC = notRefreshC || false;
	
	this.value.hue = Math.round((359*(this.conf.x - this.configColorArea.minX)) / (this.configColorArea.maxX - this.configColorArea.minX));
	this.value.lum = Math.round(100 - (100*(this.conf.y - this.configColorArea.minY)) / (this.configColorArea.maxY - this.configColorArea.minY));
	this.value.sat = Math.round(100 - (100*(this.conf.c - this.configColorArea.minY)) / (this.configColorArea.maxY - this.configColorArea.minY));
	
	var rgb = this.colorAIP.hsl2rgb(this.value.hue, this.value.sat/100, this.value.lum/100);
	
	this.value.red = Math.round(255*rgb.r);
	this.value.green = Math.round(255*rgb.g);
	this.value.blue = Math.round(255*rgb.b);
	
	if (!notRefreshC) {
		this._refreshContrast();
	} 
	
	this._refreshInputValues();
	this._refreshColorValue();
};

dhtmlXColorPicker.prototype._setContrastY = function(y) {
	var config = this.configColorArea;
	
	y = parseInt(y);
	if (!isNaN(y)) {
		this.conf.c = Math.min(Math.max(config.minY, y), config.maxY);
	}
	
	this._refreshContrastLine();
};

dhtmlXColorPicker.prototype._refreshInputValues = function() {
	this._controllerNodes.hue.value = this.value.hue;
	this._controllerNodes.sat.value = this.value.sat;
	this._controllerNodes.lum.value = this.value.lum;
	
	this._controllerNodes.red.value = this.value.red;
	this._controllerNodes.green.value = this.value.green;
	this._controllerNodes.blue.value = this.value.blue;
};

dhtmlXColorPicker.prototype._refreshColorValue = function() {
	this._controllerNodes.color.style.backgroundColor = "rgb("+[this.value.red, this.value.green, this.value.blue].join(", ")+")";
	
	var hex = this.colorAIP.rgb2hex({
		r: this.value.red,
		g: this.value.green,
		b: this.value.blue
	});
	
	this._controllerNodes.hsv.value = hex;
	this.callEvent("onChange",[hex]);
};

dhtmlXColorPicker.prototype._refreshContrast = function() {
	var rgb_top = this.colorAIP.hsl2rgb(this.value.hue, 0, this.value.lum/100);
	var rgb_bot = this.colorAIP.hsl2rgb(this.value.hue, 1, this.value.lum/100);
	
	var ieV = this._checkIeVersion();
	if (ieV && ieV<=9) {
		var ie_gradient = this._controllerNodes.contrastArea.firstChild;
		if (ie_gradient == this._controllerNodes.contrast_line) {
			ie_gradient = document.createElement("div");
			ie_gradient.className += "dhxcp_ie_gradient";
			this._controllerNodes.contrastArea.appendChild(ie_gradient);
			this._controllerNodes.contrastArea.appendChild(this._controllerNodes.contrast_line);
		}
		var hex_bot = this.colorAIP.rgb2hex({r: Math.round(255*rgb_top.r) ,g: Math.round(255*rgb_top.g) ,b: Math.round(255*rgb_top.b)});
		var hex_top = this.colorAIP.rgb2hex({r: Math.round(255*rgb_bot.r) ,g: Math.round(255*rgb_bot.g) ,b: Math.round(255*rgb_bot.b)});
		ie_gradient.style.filter = "progid:DXImageTransform.Microsoft.gradient(startColorstr='"+hex_top+"', endColorstr='"+hex_bot+"', GradientType=0)";
	} else {
		rgb_top = [Math.round(255*rgb_top.r), Math.round(255*rgb_top.g), Math.round(255*rgb_top.b)];
		rgb_bot = [Math.round(255*rgb_bot.r), Math.round(255*rgb_bot.g), Math.round(255*rgb_bot.b)];
		var bg_img = "linear-gradient(rgb("+rgb_bot.join(",")+"), rgb("+rgb_top.join(",")+"))";
		if (window.dhx4.isKHTML == true && navigator.userAgent.match(/Windows/gi) != null) bg_img = "-webkit-"+bg_img; // for win/safari 5.1.7
		this._controllerNodes.contrastArea.style.backgroundImage = bg_img;
	}
};

dhtmlXColorPicker.prototype._refreshLines = function() {
	this._controllerNodes.v_line.style.left = this.conf.x+"px";
	this._controllerNodes.h_line.style.top = this.conf.y+"px";
};

dhtmlXColorPicker.prototype._refreshContrastLine = function() {
	this._controllerNodes.contrast_line.style.top = this.conf.c+"px";
};

dhtmlXColorPicker.prototype._getOffsetPosition = function(e, node) {
	var answer = {
		x: NaN,
		y: NaN
	}, target = e.target || e.srcElement;
	if (target == node) {
		answer.x = (e.offsetX != undefined)? e.offsetX: e.layerX;
		answer.y = (e.offsetY != undefined)? e.offsetY: e.layerY;
	} else if (target == this._controllerNodes.v_line) {
		answer.y = (e.offsetY != undefined)? e.offsetY: e.layerY;
	} else {
		answer.x = (e.offsetX != undefined)? e.offsetX: e.layerX;
	}
	
	return answer;
};

dhtmlXColorPicker.prototype.colorAIP = {
	hex2rgb: function(str) {
		var data = str.match(/^(#)([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i);
		if (data != null) {
			return {
				r: parseInt("0x"+data[2]),
				g: parseInt("0x"+data[3]),
				b: parseInt("0x"+data[4])
			};
		} else {
			return null;
		}
	},
	// data {r:.., g:.., b:..}
	rgb2hex: function(data) {
		var r = parseInt(data.r), g = parseInt(data.g), b = parseInt(data.b);
		r = r||0, g = g||0, b = b||0;
		return "#"+((r)? ((r<16)? "0"+r.toString(16):r.toString(16)): "00") +((g)? ((g<16)? "0"+g.toString(16):g.toString(16)): "00") +((b)? ((b<16)? "0"+b.toString(16):b.toString(16)): "00");
	},
	
	// {float} r [0..1], g [0..1], b [0..1], returns {object} hsl
	rgb2hsl: function(r,g,b) {
		var H, S, L;
		var max = Math.max(r,g,b), min = Math.min(r,g,b);
		
		//** L **
		L = 0.5*(max + min);
		
		//** H **
		if (max == min) H = 0;
		else if (max == r) {
			H = 60*(g - b)/(max-min);
			if (g < b) H += 360;
		} else if (max == g) H = 60*(b - r)/(max - min) + 120;
		else H = 60*(r-g)/(max - min) + 240;
		
		//** S **
		if (L == 0 || max == min) S = 0;
		else if (L <= 0.5) S = 0.5*(max - min)/L;
		else S = 0.5*(max - min)/(1 - L);
		
		return {
			h: H,
			s: S,
			l: L
		};
	},
	
	// {int} H [0..359], {float} S [0..1], L [0..1] returns {object} rgb [0..1]
	hsl2rgb: function(H,S,L) {
		var Q,P,_H;
		var T = [], RGB = [];
		
		// ** Q **
		if (L <= 0.5) Q = L*(1+S);
		else Q = L + S - (L*S);
		
		//** P **
		P = 2*L - Q;
		
		//** H ***
		_H = H/360;
		
		T.push(_H + 1/3);
		T.push(_H);
		T.push(_H - 1/3);
		
		for (var i = 0; i<3; i++) {
			if (T[i]<0) T[i] += 1;
			else if (T[i]>1) T[i] -= 1;
			
			if (T[i] < 1/6) RGB.push(P + (Q - P)*6*T[i]);
			else if (T[i] < 0.5) RGB.push(Q);
			else if (T[i] < 2/3) RGB.push(P + (Q - P)*(2/3 - T[i])*6);
			else RGB.push(P);
		}
		
		return {
			r: RGB[0],
			g: RGB[1],
			b: RGB[2]
		};
	}
};

dhtmlXColorPicker.prototype._checkIeVersion = function() {
	var answer;
	var str  = navigator.userAgent.match(/(MSIE)\s(\d\.\d)/i);
	answer = (str && str[2])? parseInt(str[2]): null;
	return answer;
};

dhtmlXColorPicker.prototype.setCustomColors = function() {
	if (this.memory == null) {
		this.initMemoryColors();
		this.conf.customColors = true;
	}
	
	var i, l, value,colors,
	q,w;
	l = arguments.length;
	for (i=0; i<l; i++) {
		if (arguments[i] instanceof Array) {
			value = this._rgb2value(arguments[i][0],arguments[i][1],arguments[i][2]);
			this.memory.setValue(value,null,false);
			continue;
			
		} else if (typeof(arguments[i]) == "string") {
			colors = arguments[i].match(/^rgb\((\d{1,3})\,(\d{1,3})\,(\d{1,3})\)$/i);
			if (colors instanceof Array) {
				value = this._rgb2value(colors[1],colors[2],colors[3]);
				this.memory.setValue(value,null,false);
				continue;
			}
			
			colors = arguments[i].match(/(#[\da-f]{6})/ig);
			if (colors instanceof Array) {
				w = colors.length;
				for (q=0; q<w; q++) {
					value = this._hex2value(colors[q]);
					this.memory.setValue(value,null,false);
				}
			} 
			
		}
	}
};

dhtmlXColorPicker.prototype.getCustomColors = function() {
	var k = [];
	if (this.memory != null && this.conf.customColors == true) {
		for (var q=0; q<this.memory.controllers.length; q++) {
			var v = this.memory.controllers[q].value;
			k.push(this.colorAIP.rgb2hex({r: v.red, g: v.green, b: v.blue}));
		}
	}
	return k;
};

dhtmlXColorPicker.prototype._rgb2value = function(r,g,b) {
	var hsl = this.colorAIP.rgb2hsl(r/255,g/255,b/255);
	
	return {
		red: r,
		green: g,
		blue: b,
		hue: Math.round(hsl.h),
		sat: Math.round(hsl.s*100),
		lum: Math.round(hsl.l*100)
	};
};

dhtmlXColorPicker.prototype._hex2value = function(str) {
	var rgb, hsl;
	rgb = this.colorAIP.hex2rgb(str);
	hsl = this.colorAIP.rgb2hsl(rgb.r/255,rgb.g/255,rgb.b/255);
	
	return {
		red: rgb.r,
		green: rgb.g,
		blue: rgb.b,
		hue: Math.round(hsl.h),
		sat: Math.round(hsl.s*100),
		lum: Math.round(hsl.l*100)
	};
};

dhtmlXColorPicker.prototype.showMemory = function() {
	if (this.memory == null) {
		this.initMemoryColors();
	}
	
	if (!this._globalNode.className.match(/dhxcp_add_memory/)) {
		this._globalNode.className += " dhxcp_add_memory";
	}
	
	this.conf.customColors = true;
};

dhtmlXColorPicker.prototype.hideMemory = function() {
	if (this.memory != null) {
		this._globalNode.className = this._globalNode.className.replace(/\sdhxcp_add_memory/, "");
	}
	
	this.conf.customColors = false;
};

dhtmlXColorPicker.prototype.setSkin = function (skin) {
	
	if (this._skinCollection[skin] != true) return;
	
	var r = "dhtmlxcp_"+(this.skin||"dummy");
	this.base.className = this.base.className.replace(new RegExp(r), "");
	this.base.className += " dhtmlxcp_"+skin;
	this.skin = skin;
	
	if (this.skin == "material") {
		var t = {labelHue: "H", labelSat: "S", labelLum: "L", labelRed: "R", labelGreen: "G", labelBlue: "B"};
		for (var a in t) this.i18n.en[a] = t[a];
	}
	
	if (this.base.className.match(/dhxcp_shadow/) == null && !(dhx4.isIE6 || dhx4.isIE7 || dhx4.isIE8)) {
		this.base.className += " dhxcp_shadow";
	}
};

dhtmlXColorPicker.prototype.hideOnSelect = function(value) {
	value = dhx4.s2b(value);
	this.conf.hideOnSelect = value;
};

dhtmlXColorPicker.prototype._indexOf = function(arr, el) {
	var i,l,answer = -1;
	l = arr.length;
	for (i=l; i>=0; i--) {
		if (arr[i] == el) {
			answer = i;
			break;
		}
	}
	
	return answer;
};

dhtmlXColorPicker.prototype.destructMemory = function() {
	if (this.memory == null) {
		return;
	} 
	this.hideMemory();
	
	var button = this._controllerNodes.memory_block.childNodes[0].firstChild;
	this._labelNodes.btnAddColor =  null;
	if (typeof(window.addEventListener) == "function") {
		button.removeEventListener("click", this.saveColor, false);
	} else {
		button.detachEvent("onclick", this.saveColor);
	}
	
	this.memory.remove();
	
	this._controllerNodes.memory_block.innerHTML = "";
	this.memory = null;
};

dhtmlXColorPicker.prototype.Memory = function(base) {
	var  that = this, selected = null,
	dfValue = {
		red: 255,
		blue: 255,
		green: 255,
		hue: 0,
		sat: 0,
		lum: 100
	};
	
	this.select = function() {
		var target  = (this != window)? this: event.srcElement;
		var contr = contr || target.dhxpc_memory;
		
		if (selected != null) {
			that.unSelect();
		}
		selected = contr;
		contr.domElement.className += " dhxcp_memory_el_select";
		
		if (typeof(that.onSelect) == "function") {
			that.onSelect(contr);
		}
	};
	
	this.onSelect = null;
	this.onSave = null;
	
	this._createMemoryController = function (el) {
		var data = {
			domElement: el,
			value: dhx4._copyObj(dfValue)
		};
		
		el.dhxpc_memory = data;
		
		if (typeof(window.addEventListener) == "function") {
			el.addEventListener("click", that.select, false);
		} else {
			el.attachEvent("onclick", that.select);
		}
		
		return data;
	};
	
	this._findMemoryControllers = function (base) {
		var divs = base.getElementsByTagName("a"),i,l,
		answer = [];
		l = divs.length;
		for (i=0; i<l; i++) {
			answer.push(this._createMemoryController(divs[i]));
		}
		
		return answer;
	};
	
	this.controllers = this._findMemoryControllers(base);
	
	this.unSelect = function() {
		if (selected) selected.domElement.className = selected.domElement.className.replace(/\s.*$/i, "");
		selected = null;
	};
	
	this.setActiveNext = function() {
		var ind = null, l;
		if (selected == null) {
			selected = this.controllers[0];
		} else {
			ind = this.getIndex(selected);
			l = this.controllers.length;
			this.unSelect();
			selected = (ind+1 < l)?  this.controllers[ind+1]:this.controllers[0];
		}
		selected.domElement.className += " dhxcp_memory_el_next";
		return selected;
	};
	
	this.setValue = function(value, contr, callEvent) {
		selected = contr || selected;
		if (selected == null) {
			selected = this.controllers[0];
		}
		
		selected.value.red = value.red;
		selected.value.blue = value.blue;
		selected.value.green = value.green;
		selected.value.hue = value.hue;
		selected.value.sat = value.sat;
		selected.value.lum = value.lum;
		
		selected.domElement.style.backgroundColor = "rgb("+[value.red, value.green, value.blue].join(", ")+")";
		
		this.setActiveNext();
		
		if ((callEvent != false) && (typeof(this.onSave) == "function")) this.onSave(value);
	};
	
	this.clean = function() {
		var l = this.controllers.length,
		item;
		for (var i=0; i<l; i++) {
			item = this.controllers[i];
			item.value = dhx4._copyObj(dfValue);
			item.domElement.style.backgroundColor = "rgb("+[dfValue.red, dfValue.green, dfValue.blue].join(", ")+")";
		}
		this.unSelect();
		selected = this.controllers[0];
	};
	
	this.getIndex = function(selected) {
		var i,l,answer = -1;
		
		l = this.controllers.length;
		for (i=0; i<l; i++) {
			if (this.controllers[i] == selected) {
				answer = i;
				break;
			}
		}
		
		return answer;
	};
	
	this.remove = function() {
		var i,l;
		l = this.controllers.length;
		for (i=0; i<l; i++) {
			if (typeof(window.addEventListener) == "function") {
				this.controllers[i].domElement.removeEventListener("click", this.select, false);
			} else {
				this.controllers[i].domElement.detachEvent("onclick", this.select);
			}
			
			delete this.controllers[i].domElement.dhxpc_memory;
		}
		delete this.onSelect;
		delete this.controllers;
		delete this.onSave;
	};
};

if (window.dhx4.isIE6) {
	dhtmlXColorPicker.prototype._cpInitFRM = function() {
		var f;
		if (!this._controllerNodes.fr_cover) {
			f = document.createElement("IFRAME");
			f.className = "dhxcp_frm";
			f.border = 0;
			f.frameBorder = 0;
			this._controllerNodes.fr_cover = f;
		}
		
		if (!this.base._dhx_remove) {
			this.base.insertBefore(f, this._globalNode);
		}
	};
};
;
///<jscompress sourcefile="dhtmlxcalendar.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXCalendarObject(inps, skin) {
	
	// parse inputs
	this.i = {};
	
	var p = null;
	if (typeof(inps) == "string") {
		var t0 = document.getElementById(inps);
	} else {
		var t0 = inps;
	}
	if (t0 && typeof(t0) == "object" && t0.tagName && String(t0.tagName).toLowerCase() != "input") p = t0;
	t0 = null;
	
	// single param
	if (typeof(inps) != "object" || !inps.length) inps = [inps];
	for (var q=0; q<inps.length; q++) {
		if (typeof(inps[q]) == "string") inps[q] = (document.getElementById(inps[q])||null);
		if (inps[q] != null && inps[q].tagName && String(inps[q].tagName).toLowerCase() == "input") {
			this.i[window.dhx4.newId()] = {input: inps[q]};
		} else {
			if (!(inps[q] instanceof Array) && inps[q] instanceof Object && (inps[q].input != null || inps[q].button != null)) {
				if (inps[q].input != null && typeof(inps[q].input) == "string") inps[q].input = document.getElementById(inps[q].input);
				if (inps[q].button != null && typeof(inps[q].button) == "string") inps[q].button = document.getElementById(inps[q].button);
				this.i[window.dhx4.newId()] = inps[q];
			}
		}
		inps[q] = null;
	}
	
	this.conf = {
		skin: (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhtmlxcalendar")||"material"),
		zi: window.dhx4.newId(),
		touch: !window.dhx4.isIE,
		time: true,
		today: false,
		ws_first: true // false => start year from 52/53 wekk number (if 1st jan belongs to 1st week)
	}
	
	this.setSkin = function(skin, force) {
		if (this.conf.skin == skin && !force) return;
		this.conf.skin = skin;
		this.base.className = "dhtmlxcalendar_"+this.conf.skin;
		this._ifrSize();
	}
	
	// create base
	this.base = document.createElement("DIV");
	this.base.style.display = "none";
	this.base.appendChild(document.createElement("DIV"));
	
	if (p != null) {
		this._hasParent = true;
		p.appendChild(this.base);
		p = null;
	} else { 
		document.body.appendChild(this.base);
	}
	
	this.setParent = function(p) {
		if (this._hasParent) {
			if (typeof(p) == "object") {
				p.appendChild(this.base);
			} else if (typeof(p) == "string") {
				document.getElementById(p).appendChild(this.base);
			}
		}
	}
	
	this.setSkin(this.conf.skin, true);
	
	this.base.onclick = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault();
		e.cancelBubble = true;
	}
	this.base.onmousedown = function() {
		return false;
	}
	
	if (this.conf.touch) {
		this.base.ontouchstart = this.base.onclick;
	}
	
	this.loadUserLanguage = function(lang) {
		if (!this.langData[lang]) return;
		this.lang = lang;
		this.setWeekStartDay(this.langData[this.lang].weekstart);
		this.setDateFormat(this.langData[this.lang].dateformat||"%Y-%m-%d");
		// month selector
		if (this.msCont) {
			var e = 0;
			for (var q=0; q<this.msCont.childNodes.length; q++) {
				for (var w=0; w<this.msCont.childNodes[q].childNodes.length; w++) {
					this.msCont.childNodes[q].childNodes[w].innerHTML = this.langData[this.lang].monthesSNames[e++];
				}
			}
		}
		// today/clear
		this.contTime.childNodes[0].childNodes[0].childNodes[5].innerHTML = this.langData[this.lang].today;
		this.contTime.childNodes[0].childNodes[0].childNodes[4].innerHTML = this.langData[this.lang].clear;
	}
	
	// build month and year header
	this.contMonth = document.createElement("DIV");
	this.contMonth.className = "dhtmlxcalendar_month_cont";
	this.contMonth.onselectstart = function(e){
		e = e||event;
		e.cancelBubble = true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		return false;
	}
	this.base.firstChild.appendChild(this.contMonth);
	
	var ul = document.createElement("UL");
	ul.className = "dhtmlxcalendar_line";
	this.contMonth.appendChild(ul);
	
	var li = document.createElement("LI");
	li.className = "dhtmlxcalendar_cell dhtmlxcalendar_month_hdr";
	li.innerHTML = "<div class='dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_left' onmouseover='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_left_hover\";' onmouseout='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_left\";'></div>"+
			"<span></span>"+ // hdrformat will here
			"<div class='dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_right' onmouseover='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_right_hover\";' onmouseout='this.className=\"dhtmlxcalendar_month_arrow dhtmlxcalendar_month_arrow_right\";'></div>";
	ul.appendChild(li);
	
	var that = this;
	
	li.onclick = function(e) {
		
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		
		var t = (e.target||e.srcElement);
		// change month by clicking left-right arrows
		if (t.className && t.className.indexOf("dhtmlxcalendar_month_arrow") === 0) {
			that._hideSelector();
			var ind = (t.parentNode.firstChild==t?-1:1);
			var k0 = new Date(that._activeMonth);
			that._drawMonth(new Date(that._activeMonth.getFullYear(), that._activeMonth.getMonth()+ind, 1, 0, 0, 0, 0));
			that._evOnArrowClick([k0, new Date(that._activeMonth)]);
			return;
		}
		// show month selector
		if (t.className && t.className == "dhtmlxcalendar_month_label_month") {
			e.cancelBubble = true;
			that._showSelector("month", Math.round(t.offsetLeft+t.offsetWidth/2), t.offsetTop+t.offsetHeight+2, "selector_month", true);
			return;
		}
		// show year selector
		if (t.className && t.className == "dhtmlxcalendar_month_label_year") {
			e.cancelBubble = true;
			that._showSelector("year", Math.round(t.offsetLeft+t.offsetWidth/2), t.offsetTop+t.offsetHeight+2, "selector_year", true);
			return;
		}
		// hide selector if it visible
		that._hideSelector();
	}
	if (this.conf.touch == true) {
		li.ontouchstart = li.onclick;
	}
	
	// build days names
	this.contDays = document.createElement("DIV");
	this.contDays.className = "dhtmlxcalendar_days_cont";
	this.base.firstChild.appendChild(this.contDays);
	
	this.setWeekStartDay = function(ind) {
		// 1..7 = Mo-Su, also 0 = Su
		if (ind == 0) ind = 7;
		this._wStart = Math.min(Math.max((isNaN(ind)?1:ind),1),7);
		this._drawDaysOfWeek();
	}
	
	this._drawDaysOfWeek = function() {
		if (this.contDays.childNodes.length == 0) {
			var ul = document.createElement("UL");
			ul.className = "dhtmlxcalendar_line";
			this.contDays.appendChild(ul);
		} else {
			var ul = this.contDays.firstChild;
		}
		
		var w = this._wStart;
		var k = this.langData[this.lang].daysSNames;
		k.push(String(this.langData[this.lang].daysSNames[0]).valueOf());
		
		for (var q=0; q<8; q++) {
			if (ul.childNodes[q] == null) {
				var li = document.createElement("LI");
				ul.appendChild(li);
			} else {
				var li = ul.childNodes[q];
			}
			if (q == 0) {
				li.className = "dhtmlxcalendar_cell_wn";
				li.innerHTML = "<div class='dhtmlxcalendar_label'>"+(this.langData[this.lang].weekname||"w")+"</div>";
			} else {
				li.className = "dhtmlxcalendar_cell"+(w>=6?" dhtmlxcalendar_day_weekday_cell":"")+(q==1?"_first":"");
				li.innerHTML = k[w];
				if (++w > 7) w = 1;
			}
		}
		if (this._activeMonth != null) this._drawMonth(this._activeMonth);
	}
	
	this._wStart = this.langData[this.lang].weekstart;
	this.setWeekStartDay(this._wStart);
	
	// dates container
	this.contDates = document.createElement("DIV");
	this.contDates.className = "dhtmlxcalendar_dates_cont";
	this.base.firstChild.appendChild(this.contDates);
	
	this.contDates.onclick = function(e){
		
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		
		var t = (e.target||e.srcElement);
		
		if (t.parentNode != null && t.parentNode._date != null) t = t.parentNode;
		if (t._date != null && !t._css_dis) {
			
			var t1 = that._activeDate.getHours();
			var t2 = that._activeDate.getMinutes();
			var d0 = t._date;
			
			// cjeck if allow to modify input
			if (that.checkEvent("onBeforeChange")) {
				if (!that.callEvent("onBeforeChange",[new Date(t._date.getFullYear(),t._date.getMonth(),t._date.getDate(),t1,t2)])) return;
			}
			
			if (that._activeDateCell != null) {
				that._activeDateCell._css_date = false;
				that._updateCellStyle(that._activeDateCell._q, that._activeDateCell._w);
			}
			
			// update month if day from prev/next month clicked
			var refreshView = (that._activeDate.getFullYear()+"_"+that._activeDate.getMonth() != d0.getFullYear()+"_"+d0.getMonth());
			
			that._nullDate = false;
			that._activeDate = new Date(d0.getFullYear(),d0.getMonth(),d0.getDate(),t1,t2);
			
			that._activeDateCell = t;
			that._activeDateCell._css_date = true;
			that._activeDateCell._css_hover = false;
			that._updateCellStyle(that._activeDateCell._q, that._activeDateCell._w);
			
			if (refreshView) that._drawMonth(that._activeDate);
			
			// update date in input if any
			that._updateInp();
			
			// hide
			if (!that._hasParent) {
				if (e.type == "touchstart") {
					window.setTimeout(function(){that._hide();},400);
				} else {
					that._hide();
				}
			}
			//
			that._evOnClick([new Date(that._activeDate.getTime())]);
			
		}
	}
	
	if (this.conf.touch == true) {
		this.contDates.ontouchstart = this.contDates.onclick;
	}
	
	this.contDates.onmouseover = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		if (t.parentNode != null && t.parentNode._date != null) t = t.parentNode;
		if (t._date != null) { // && t != that._activeDateCell) { // skip hover for selected date
			if (that._lastHover == t || t._css_hover) return;
			t._css_hover = true;
			that._updateCellStyle(t._q, t._w);
			that._lastHover = t;
			that._evOnMouseOver([new Date(t._date.getFullYear(),t._date.getMonth(),t._date.getDate(),0,0,0,0),e]);
			t = null;
		}
	}
	this.contDates.onmouseout = function(e) {
		that._clearDayHover(e||event);
	}
	
	this._lastHover = null;
	this._clearDayHover = function(ev) {
		if (!this._lastHover) return;
		this._lastHover._css_hover = false;
		this._updateCellStyle(this._lastHover._q, this._lastHover._w);
		if (ev != null) that._evOnMouseOut([new Date(this._lastHover._date.getFullYear(),this._lastHover._date.getMonth(),this._lastHover._date.getDate(),0,0,0,0),ev]);
		this._lastHover = null;
	}
	
	// build cells
	for (var q=0; q<6; q++) {
		var ul = document.createElement("UL");
		ul.className = "dhtmlxcalendar_line";
		this.contDates.appendChild(ul);
		for (var w=0; w<=7; w++) {
			var li = document.createElement("LI");
			if (w == 0) {
				// week number
				li.className = "dhtmlxcalendar_cell_wn";
			} else {
				li.className = "dhtmlxcalendar_cell";
			}
			ul.appendChild(li);
		}
	}
	
	
	// timepicker
	this.contTime = document.createElement("DIV");
	this.contTime.className = "dhtmlxcalendar_time_cont";
	this.contTime.style.display = "none";
	this.base.firstChild.appendChild(this.contTime);
	
	this.showTime = function() {
		if (this.conf.time != true) {
			this.conf.time = true;
			this._adjustTimeCont();
		}
	}
	
	this.hideTime = function() {
		if (this.conf.time == true) {
			this.conf.time = false;
			this._adjustTimeCont();
		}
	}
	
	this.showToday = function() {
		if (this.conf.today != true) {
			this.conf.today = true;
			this._adjustTimeCont();
		}
	}
	
	this.hideToday = function() {
		if (this.conf.today == true) {
			this.conf.today = false;
			this._adjustTimeCont();
		}
	}
	
	this._adjustTimeCont = function() {
		var css = "";
		if (this.conf.time == true) css += "_time";
		if (this.conf.today == true) css += "_today";
		if (css == "") {
			this.contTime.style.display = "none";
		} else {
			this.contTime.className = "dhtmlxcalendar_time_cont dhtmlxcalendar_mode"+css;
			this.contTime.style.display = "";
		}
		this._ifrSize();
	}
	
	this._adjustTimeCont();
	
	var ul = document.createElement("UL");
	ul.className = "dhtmlxcalendar_line";
	this.contTime.appendChild(ul);
	
	var li = document.createElement("LI");
	li.className = "dhtmlxcalendar_cell dhtmlxcalendar_time_hdr";
	li.innerHTML = "<div class='dhtmlxcalendar_time_img'></div>"+
			"<span class='dhtmlxcalendar_label_hours'></span><span class='dhtmlxcalendar_label_colon'>:</span><span class='dhtmlxcalendar_label_minutes'></span>"+
			"<span class='dhtmlxcalendar_label_clear'>"+this.langData[this.lang].clear+"</span><span class='dhtmlxcalendar_label_today'>"+this.langData[this.lang].today+"</span>"; // added in 4.6
	ul.appendChild(li);
	
	li.onclick = function(e) {
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		
		var t = (e.target||e.srcElement);
		if (t.tagName != null && t.tagName.toLowerCase() == "span" && t._par == true && t.parentNode != null) {
			t = t.parentNode;
		}
		// show hours selector
		if (t.className && t.className == "dhtmlxcalendar_label_hours") {
			e.cancelBubble = true;
			var h = that.contMonth.offsetHeight+that.contDays.offsetHeight+that.contDates.offsetHeight+t.offsetTop;
			that._showSelector("hours", Math.round(t.offsetLeft+t.offsetWidth/2), h-2, "selector_hours", true);
			return;
		}
		// show minutes selector
		if (t.className && t.className == "dhtmlxcalendar_label_minutes") {
			e.cancelBubble = true;
			if (that._minutesInterval == 1) {
				var d = that.getFormatedDate("%i");
				t.innerHTML = "<span class='dhtmlxcalendar_selected_date'>"+d.charAt(0)+"</span>"+d.charAt(1);
				t.firstChild._par = true;
				that._selectorMode = 1; // select hour
			}
			var h = that.contMonth.offsetHeight+that.contDays.offsetHeight+that.contDates.offsetHeight+t.offsetTop;
			that._showSelector("minutes", Math.round(t.offsetLeft+t.offsetWidth/2), h-2, "selector_minutes",true);
			return;
		}
		// hide selector if it visible
		that._hideSelector();
		// today/clear buttons, added in 4.6
		if (t.className && t.className == "dhtmlxcalendar_label_today") {
			var d = new Date();
			d = new Date(d.getFullYear(), d.getMonth(), d.getDate(), that._activeDate.getHours(), that._activeDate.getMinutes(), that._activeDate.getSeconds(), that._activeDate.getMilliseconds());
			that.setDate(d);
			that._updateInp();
			that.callEvent("onButtonClick", [d]);
		}
		if (t.className && t.className == "dhtmlxcalendar_label_clear") {
			that._nullDate = true;
			that._drawMonth(new Date());
			that._updateInp();
			that.callEvent("onButtonClick", [null]);
		}
	}
	if (this.conf.touch == true) {
		li.ontouchstart = li.onclick;
	}
	
	this._activeMonth = null;
	
	this._activeDate = new Date();
	this._activeDateCell = null;
	
	this.setDate = function(d) {
		window.dhx4.temp_calendar = {tz:null};
		this._nullDate = (typeof(d) == "undefined" || d === "" || !d);
		
		if (!(d instanceof Date)) {
			d = this._strToDate(String(d||""));
			if (d == "Invalid Date") d = new Date(); else this.conf.tz = window.dhx4.temp_calendar.tz;
			window.dhx4.temp_calendar = null;
		}
		if (this.conf.tz == null) this.conf.tz = window.dhx4.date2str(d,"%P");
		
		var time = d.getTime();
		
		// out of range
		if (this._isOutOfRange(time)) return;
		
		this._activeDate = new Date(time);
		this._drawMonth(this._nullDate?new Date():this._activeDate);
		this._updateVisibleHours();
		this._updateVisibleMinutes();
	}
	
	this.getDate = function(formated) {
		if (this._nullDate) return null;
		var t = new Date(this._activeDate.getTime());
		if (formated) {
			window.dhx4.temp_calendar = {tz:this.conf.tz};
			var d = this._dateToStr(t);
			window.dhx4.temp_calendar = null;
			return d;
		}
		return t;
	}
	
	this._drawMonth = function(d) {
		
		if (!(d instanceof Date)) return;
		if (isNaN(d.getFullYear())) d = new Date(this._activeMonth.getFullYear(), this._activeMonth.getMonth(), 1, 0, 0, 0, 0);
		
		this._activeMonth = new Date(d.getFullYear(), d.getMonth(), 1, 0, 0, 0, 0);
		
		this._activeDateCell = null;
		
		var first = new Date(this._activeMonth.getTime());
		var d0 = first.getDay();
		
		var e0 = d0-this._wStart;
		if (e0 < 0) e0 = e0+7;
		first.setDate(first.getDate()-e0);
		
		var mx = d.getMonth();
		var dx = new Date(this._activeDate.getFullYear(), this._activeDate.getMonth(), this._activeDate.getDate(), 0, 0, 0, 0).getTime();
		var i = 0;
		for (var q=0; q<6; q++) {
			var ws = this._wStart;
			for (var w=0; w<=7; w++) {
				if (w == 0) {
					var wn = this.getWeekNumber(new Date(first.getFullYear(), first.getMonth(), first.getDate()+i, 0, 0, 0, 0));
					// if active month set to jan and 1st jan belong to 1st week - display 1st week instead of 52/53
					if (wn >= 52 && this.conf.ws_first == true && this._activeMonth.getMonth() == 0) {
						var wn2 = this.getWeekNumber(new Date(first.getFullYear(), first.getMonth(), first.getDate()+i+7, 0, 0, 0, 0));
						if (wn2 < wn && wn2 > 1) wn = 1;
					}
					this.contDates.childNodes[q].childNodes[w].innerHTML = "<div class='dhtmlxcalendar_label'>"+wn+"</div>";
				} else {
					
					var d2 = new Date(first.getFullYear(), first.getMonth(), first.getDate()+i, 0, 0, 0, 0);
					if (d2.getHours() != 0) {
						var h = (d2.getHours()>12 ? 24-d2.getHours() : d2.getHours()); // yesturday/tomorrow while daylight saving
						d2.setTime(d2.getTime() + 60*60*1000*h);
					}
					
					var day = d2.getDay();
					var time = d2.getTime();
					
					var label_css = "dhtmlxcalendar_label";
					if (this._tipData[time] != null) {
						if (this._tipData[time].usePopup && typeof(window.dhtmlXPopup) == "function") {
							this.contDates.childNodes[q].childNodes[w].removeAttribute("title");
							this._initTooltipPopup();
						} else {
							this.contDates.childNodes[q].childNodes[w].setAttribute("title", this._tipData[time].text);
						}
						if (this._tipData[time].showIcon) label_css += " dhtmlxcalendar_label_title";
					} else {
						this.contDates.childNodes[q].childNodes[w].removeAttribute("title");
						
					}
					
					this.contDates.childNodes[q].childNodes[w].innerHTML = "<div class='"+label_css+"'>"+d2.getDate()+"</div>";
					
					this.contDates.childNodes[q].childNodes[w]._date = new Date(time);
					this.contDates.childNodes[q].childNodes[w]._q = q;
					this.contDates.childNodes[q].childNodes[w]._w = w;
					this.contDates.childNodes[q].childNodes[w]._css_month = (d2.getMonth()==mx);
					this.contDates.childNodes[q].childNodes[w]._css_date = (!this._nullDate&&time==dx);
					this.contDates.childNodes[q].childNodes[w]._css_weekend = (ws>=6);
					this.contDates.childNodes[q].childNodes[w]._css_dis = this._isOutOfRange(time);
					this.contDates.childNodes[q].childNodes[w]._css_holiday = (this._holidays[time] == true);
					
					this._updateCellStyle(q, w);
					
					if (time==dx) this._activeDateCell = this.contDates.childNodes[q].childNodes[w];
					
					if (++ws > 7) ws = 1;
					i++;
				}
				
			}
		}
		
		this.contMonth.firstChild.firstChild.childNodes[1].innerHTML = this._buildMonthHdr(d);
		
	}
	
	this._updateCellStyle = function(q, w) {
		
		var r = this.contDates.childNodes[q].childNodes[w];
		
		var s = "dhtmlxcalendar_cell dhtmlxcalendar_cell";
		
		// this/another month
		s += (r._css_month ? "_month" : "");
		
		// selected date
		s += (r._css_date ? "_date" : "");
		
		// is weekend
		s += (r._css_weekend ? "_weekend" : "");
		
		// is holiday
		s += (r._css_holiday ? "_holiday" : "");
		
		// is cell disabled
		s += (r._css_dis ? "_dis" : "");
		
		// is cell hover (only if not disabled)
		s += (r._css_hover && !r._css_dis ? "_hover" : "");
		
		r.className = s;
		r = null;
		
	}
	
	/* global selector obj */
	
	this._minutesInterval = 5; // default
	
	this._initSelector = function(type,css) {
		
		if (!this._selCover) {
			this._selCover = document.createElement("DIV");
			this._selCover.className = "dhtmlxcalendar_selector_cover";
			this.base.firstChild.appendChild(this._selCover);
		}

		if (!this._sel) {
			
			this._sel = document.createElement("DIV");
			this._sel.className = "dhtmlxcalendar_selector_obj";
			this.base.firstChild.appendChild(this._sel);
			
			this._sel.appendChild(document.createElement("TABLE"));
			this._sel.firstChild.className = "dhtmlxcalendar_selector_table";
			this._sel.firstChild.cellSpacing = 0;
			this._sel.firstChild.cellPadding = 0;
			this._sel.firstChild.border = 0;
			this._sel.firstChild.appendChild(document.createElement("TBODY"));
			this._sel.firstChild.firstChild.appendChild(document.createElement("TR"));
			
			this._sel.firstChild.firstChild.firstChild.appendChild(document.createElement("TD"));
			this._sel.firstChild.firstChild.firstChild.appendChild(document.createElement("TD"));
			this._sel.firstChild.firstChild.firstChild.appendChild(document.createElement("TD"));
			
			this._sel.firstChild.firstChild.firstChild.childNodes[0].className = "dhtmlxcalendar_selector_cell_left";
			this._sel.firstChild.firstChild.firstChild.childNodes[1].className = "dhtmlxcalendar_selector_cell_middle";
			this._sel.firstChild.firstChild.firstChild.childNodes[2].className = "dhtmlxcalendar_selector_cell_right";
			this._sel.firstChild.firstChild.firstChild.childNodes[0].innerHTML = "&nbsp;";
			this._sel.firstChild.firstChild.firstChild.childNodes[2].innerHTML = "&nbsp;";
			
			this._sel.firstChild.firstChild.firstChild.childNodes[0].onmouseover = function(){
				this.className = "dhtmlxcalendar_selector_cell_left dhtmlxcalendar_selector_cell_left_hover";
			}
			this._sel.firstChild.firstChild.firstChild.childNodes[0].onmouseout = function(){
				this.className = "dhtmlxcalendar_selector_cell_left";
			}
			
			this._sel.firstChild.firstChild.firstChild.childNodes[2].onmouseover = function(){
				this.className = "dhtmlxcalendar_selector_cell_right dhtmlxcalendar_selector_cell_right_hover";
			}
			this._sel.firstChild.firstChild.firstChild.childNodes[2].onmouseout = function(){
				this.className = "dhtmlxcalendar_selector_cell_right";
			}
			
			this._sel.onmouseover = function(e) {
				e = e||event;
				var t = (e.target||e.srcElement);
				if (t._cell === true) {
					if (that._selHover != t) that._clearSelHover();
					if (String(t.className).match(/^\s{0,}dhtmlxcalendar_selector_cell\s{0,}$/gi) !=null) {
						t.className += " dhtmlxcalendar_selector_cell_hover";
						that._selHover = t;
					}
				}
			}
			
			this._sel.onmouseout = function() {
				that._clearSelHover();
			}
			
			this._sel.firstChild.firstChild.firstChild.childNodes[0].onclick = function(e){
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				that._scrollYears(-1);
			}
			
			this._sel.firstChild.firstChild.firstChild.childNodes[2].onclick = function(e){
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				that._scrollYears(1);
			}
			
			if (this.conf.touch == true) {
				this._sel.firstChild.firstChild.firstChild.childNodes[0].ontouchstart = this._sel.firstChild.firstChild.firstChild.childNodes[0].onclick;
				this._sel.firstChild.firstChild.firstChild.childNodes[2].ontouchstart = this._sel.firstChild.firstChild.firstChild.childNodes[2].onclick;
			}
			
			this._sel._ta = {};
			
			this._selHover = null;
			
			this._sel.appendChild(document.createElement("DIV"));
			this._sel.lastChild.className = "dhtmlxcalendar_selector_obj_arrow";
		}
		
		// check if already inited
		if (this._sel._ta[type] == true) return;
		
		// init month
		if (type == "month") {
			
			this._msCells = {};
			
			this.msCont = document.createElement("DIV");
			this.msCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.msCont);
			
			var i = 0;
			for (var q=0; q<4; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.msCont.appendChild(ul);
				for (var w=0; w<3; w++) {
					var li = document.createElement("LI");
					li.innerHTML = this.langData[this.lang].monthesSNames[i];
					li.className = "dhtmlxcalendar_selector_cell";
					ul.appendChild(li);
					li._month = i;
					li._cell = true;
					this._msCells[i++] = li;
				}
			}
			
			this.msCont.onclick = function(e) {
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._month != null) {
					that._hideSelector();
					that._updateActiveMonth();
					that._drawMonth(new Date(that._activeMonth.getFullYear(), t._month, 1, 0, 0, 0, 0));
					that._doOnSelectorChange();
				}
			}
			if (this.conf.touch == true) {
				this.msCont.ontouchstart = this.msCont.onclick;
			}
		}
		
		// init year
		if (type == "year") {
			
			this._ysCells = {};
			
			this.ysCont = document.createElement("DIV");
			this.ysCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.ysCont);
			
			for (var q=0; q<4; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.ysCont.appendChild(ul);
				for (var w=0; w<3; w++) {
					var li = document.createElement("LI");
					li.className = "dhtmlxcalendar_selector_cell";
					li._cell = true;
					ul.appendChild(li);
				}
			}
			
			this.ysCont.onclick = function(e) {
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._year != null) {
					that._hideSelector();
					that._drawMonth(new Date(t._year, that._activeMonth.getMonth(), 1, 0, 0, 0, 0));
					that._doOnSelectorChange();
				}
			}
			if (this.conf.touch == true) {
				this.ysCont.ontouchstart = this.ysCont.onclick;
			}
			
		}
		
		// init hours
		if (type == "hours") {
			
			this._hsCells = {};
			
			this.hsCont = document.createElement("DIV");
			this.hsCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.hsCont);
			
			var i = 0;
			for (var q=0; q<4; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.hsCont.appendChild(ul);
				for (var w=0; w<6; w++) {
					var li = document.createElement("LI");
					li.innerHTML = this._fixLength(i,2);
					li.className = "dhtmlxcalendar_selector_cell";
					ul.appendChild(li);
					li._hours = i;
					li._cell = true;
					this._hsCells[i++] = li;
				}
			}
			
			this.hsCont.onclick = function(e) {
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._hours != null) {
					that._hideSelector();
					that._activeDate.setHours(t._hours);
					that._updateActiveHours();
					that._updateVisibleHours();
					that._doOnSelectorChange();
					//
					that.callEvent("onTimeChange",[new Date(that._activeDate.getTime())]);
				}
			}
			if (this.conf.touch == true) {
				this.hsCont.ontouchstart = this.hsCont.onclick;
			}
		}
		
		// init minutes
		if (type == "minutes") {
			
			// _minutesInterval = 5, def
			
			var q1 = 4;
			var w1 = 3;
			var len = 2; // leading zero
			
			if (this._minutesInterval == 1) {
				if (this._selectorMode == 1) {
					q1 = 2;
					w1 = 3;
					len = 1;
				} else {
					q1 = 2;
					w1 = 5;
					len = 1;
					css += "5";
				}
			}
			if (this._minutesInterval == 10) q1 = 2;
			if (this._minutesInterval == 15) {
				q1 = 1;
				w1 = 4;
				css += "4";
			}
			
			this._rsCells = {};
			
			this.rsCont = document.createElement("DIV");
			this.rsCont.className = "dhtmlxcalendar_area_"+css;
			this._sel.firstChild.firstChild.firstChild.childNodes[1].appendChild(this.rsCont);
			
			var i = 0;
			for (var q=0; q<q1; q++) {
				var ul = document.createElement("UL");
				ul.className = "dhtmlxcalendar_selector_line";
				this.rsCont.appendChild(ul);
				for (var w=0; w<w1; w++) {
					var li = document.createElement("LI");
					li.innerHTML = (len>1?this._fixLength(i,len):i);
					li.className = "dhtmlxcalendar_selector_cell";
					ul.appendChild(li);
					li._minutes = i;
					li._cell = true;
					this._rsCells[i] = li;
					i += this._minutesInterval;
				}
			}
			
			this.rsCont.onclick = function(e) {
				e = e||event;
				if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
				e.cancelBubble = true;
				var t = (e.target||e.srcElement);
				if (t._minutes != null) {
					if (that._minutesInterval == 1) {
						
						var m = that.getFormatedDate("%i");
						if (that._selectorMode == 1) {
							m = t._minutes.toString()+m.charAt(1);
						} else {
							m = m.charAt(0)+t._minutes.toString();
						}
						that._activeDate.setMinutes(Number(m));
						//
						that.callEvent("onTimeChange",[new Date(that._activeDate.getTime())]);
						
						that._hideSelector(); // will unload
						
						if (that._selectorMode == 1) {
							// show 2nd
							
							that._updateVisibleMinutes(true);
							that._selectorMode = 2;
							that._showSelector("minutes", that._sel._x, that._sel._y, "selector_minutes", true);
							that._updateActiveMinutes();
							return;
						} else {
							that._selectorMode = 1;
						}
					} else {
						that._hideSelector();
						that._activeDate.setMinutes(t._minutes);
						that._updateActiveMinutes();
						//
						that.callEvent("onTimeChange",[new Date(that._activeDate.getTime())]);
					}
					that._updateVisibleMinutes();
					that._doOnSelectorChange();
				}
			}
			if (this.conf.touch == true) {
				this.rsCont.ontouchstart = this.rsCont.onclick;
			}
		}
		
		// mark that selector of current type is inited
		this._sel._ta[type] = true;
	}
	
	this._showSelector = function(type, x, y, css, autoHide) {
		
		if (autoHide === true && this._sel != null && this._isSelectorVisible() && type == this._sel._t) {
			this._hideSelector();
			return;
		}
		
		if (this.conf.skin == "dhx_terrace") {
			x += 12; // ul's margin
		}
		
		if (!this._sel || !this._sel._ta[type]) this._initSelector(type,css);
		
		// minutes was visible, selector jumps to other type, remove red line
		if (type != this._sel._t && this._sel._t == "minutes" && this._minutesInterval == 1) {
			this.contTime.firstChild.firstChild.childNodes[3].innerHTML = this.getFormatedDate("%i");
		}
		
		this._sel._x = x;
		this._sel._y = y;
		
		// show selector cover
		this._sel.style.visibility = "hidden";
		this._sel.style.display = "";
		
		this._selCover.style.width = this.base.offsetWidth-2+"px";
		this._selCover.style.top = this.contMonth.offsetHeight+"px";
		this._selCover.style.height = this.contDates.offsetHeight+this.contDays.offsetHeight-1+"px";
		
		this._selCover.style.display = "";
		
		// show selector
		this._sel._t = type;
		this._sel.className = "dhtmlxcalendar_selector_obj dhtmlxcalendar_"+css+(type=="hours"&&this.conf.today==true?"2":"");
		
		// left/right table arrows
		this._sel.childNodes[0].firstChild.firstChild.childNodes[0].style.display = this._sel.childNodes[0].firstChild.firstChild.childNodes[2].style.display = (type=="year"?"":"none");
		
		// coords
		var x0 = Math.max(0, x-Math.round(this._sel.offsetWidth/2));
		if (x0+this._sel.offsetWidth > this._sel.parentNode.offsetWidth) {
			x0 = this._sel.parentNode.offsetWidth - this._sel.offsetWidth;
		}
		
		this._sel.style.left = x0+"px";
		
		if (type == "hours" || type == "minutes") {
			this._sel.style.top = y-this._sel.offsetHeight+"px";
		} else {
			this._sel.style.top = y+"px";
		}
		
		// arrow width
		this._sel.childNodes[1].style.width = this._sel.childNodes[0].offsetWidth+"px";
		
		// final apply
		this._sel.style.visibility = "visible";
		
		// callbacks
		this._doOnSelectorShow(type);
	}
	
	this._doOnSelectorShow = function(type) {
		if (type == "month") this._updateActiveMonth();
		if (type == "year") this._updateYearsList(this._activeMonth);
		if (type == "hours") this._updateActiveHours();
		if (type == "minutes") this._updateActiveMinutes();
	}
	
	this._hideSelector = function(selMode) {
		if (!this._sel) return;
		this._sel.style.display = "none";
		this._sel.style.visible = "hidden";
		this._selCover.style.display = "none";
		//
		if (this._sel._t == "minutes" && this._minutesInterval == 1) {
			this.contTime.firstChild.firstChild.childNodes[3].innerHTML = this.getFormatedDate("%i");
			this._unloadSelector("minutes");
		}
	}
	
	this._isSelectorVisible = function() {
		if (!this._sel) return false;
		return (this._sel.style.display != "none");
	}
	
	this._doOnSelectorChange = function(state) {
		this.callEvent("onChange",[new Date(this._activeMonth.getFullYear(), this._activeMonth.getMonth(), this._activeDate.getDate(), this._activeDate.getHours(), this._activeDate.getMinutes(), this._activeDate.getSeconds()),state===true]);
	}
	
	this._clearSelHover = function() {
		if (!this._selHover) return;
		this._selHover.className = String(this._selHover.className.replace(/dhtmlxcalendar_selector_cell_hover/gi,""));
		this._selHover = null;
	}
	
	this._unloadSelector = function(type) {
		if (!this._sel) return;
		if (!this._sel._ta[type]) return;
		
		// month selector
		if (type == "month") {
			
			this.msCont.onclick = this.msCont.ontouchstart = null;
			this._msActive = null;
			
			// li
			for (var a in this._msCells) {
				this._msCells[a]._cell = null;
				this._msCells[a]._month = null;
				this._msCells[a].parentNode.removeChild(this._msCells[a]);
				this._msCells[a] = null;
			}
			this._msCells = null;
			
			// ul
			while (this.msCont.childNodes.length > 0) this.msCont.removeChild(this.msCont.lastChild);
			
			// div
			this.msCont.parentNode.removeChild(this.msCont);
			this.msCont = null;
			
		}
		
		// years selector
		if (type == "year") {
			
			this.ysCont.onclick = this.ysCont.ontouchstart = null;
			
			// li
			for (var a in this._ysCells) {
				this._ysCells[a]._cell = null;
				this._ysCells[a]._year = null;
				this._ysCells[a].parentNode.removeChild(this._ysCells[a]);
				this._ysCells[a] = null;
			}
			this._ysCells = null;
			
			// ul
			while (this.ysCont.childNodes.length > 0) this.ysCont.removeChild(this.ysCont.lastChild);
			
			// div
			this.ysCont.parentNode.removeChild(this.ysCont);
			this.ysCont = null;
			
		}
		
		// hours selector
		if (type == "hours") {
			
			this.hsCont.onclick = this.hsCont.ontouchstart = null;
			this._hsActive = null;
			
			// li
			for (var a in this._hsCells) {
				this._hsCells[a]._cell = null;
				this._hsCells[a]._hours = null;
				this._hsCells[a].parentNode.removeChild(this._hsCells[a]);
				this._hsCells[a] = null;
			}
			this._hsCells = null;
			
			// ul
			while (this.hsCont.childNodes.length > 0) this.hsCont.removeChild(this.hsCont.lastChild);
			
			// div
			this.hsCont.parentNode.removeChild(this.hsCont);
			this.hsCont = null;
			
		}
		
		// minutes selector
		if (type == "minutes") {
			
			this.rsCont.onclick = this.rsCont.ontouchstart = null;
			this._rsActive = null;
			
			// li
			for (var a in this._rsCells) {
				this._rsCells[a]._cell = null;
				this._rsCells[a]._minutes = null;
				this._rsCells[a].parentNode.removeChild(this._rsCells[a]);
				this._rsCells[a] = null;
			}
			this._rsCells = null;
			
			// ul
			while (this.rsCont.childNodes.length > 0) this.rsCont.removeChild(this.rsCont.lastChild);
			
			// div
			this.rsCont.parentNode.removeChild(this.rsCont);
			this.rsCont = null;
			
		}
		
		
		this._sel._ta[type] = null;
	}
	
	this.setMinutesInterval = function(d) {
		if (!(d == 1 || d == 5 || d == 10 || d == 15)) return;
		this._minutesInterval = d;
		this._unloadSelector("minutes");
	}
	
	
	/* month selector */
	
	this._updateActiveMonth = function() {
		if (typeof(this._msActive) != "undefined" && typeof(this._msCells[this._msActive]) != "undefined") this._msCells[this._msActive].className = "dhtmlxcalendar_selector_cell";
		this._msActive = this._activeMonth.getMonth();
		this._msCells[this._msActive].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	/* year selector */
	
	this._updateActiveYear = function() {
		var i = this._activeMonth.getFullYear();
		if (this._ysCells[i]) this._ysCells[i].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	this._updateYearsList = function(d) {
		for (var a in this._ysCells) {
			this._ysCells[a] = null;
			delete this._ysCells[a];
		}
		//
		var i = 12*Math.floor(d.getFullYear()/12);
		for (var q=0; q<4; q++) {
			for (var w=0; w<3; w++) {
				this.ysCont.childNodes[q].childNodes[w].innerHTML = i;
				this.ysCont.childNodes[q].childNodes[w]._year = i;
				this.ysCont.childNodes[q].childNodes[w].className = "dhtmlxcalendar_selector_cell";
				this._ysCells[i++] = this.ysCont.childNodes[q].childNodes[w];
			}
		}
		this._updateActiveYear();
	}
	
	this._scrollYears = function(i) {
		var y = (i<0?this.ysCont.firstChild.firstChild._year:this.ysCont.lastChild.lastChild._year)+i;
		var d = new Date(y, this._activeMonth.getMonth(), 1, 0, 0, 0, 0);
		this._updateYearsList(d);
	}
	
	/* hours selector */
	
	// update hours in selector
	this._updateActiveHours = function() {
		if (typeof(this._hsActive) != "undefined" && typeof(this._hsCells[this._hsActive]) != "undefined") this._hsCells[this._hsActive].className = "dhtmlxcalendar_selector_cell";
		this._hsActive = this._activeDate.getHours();
		this._hsCells[this._hsActive].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	// update hours in calendar
	this._updateVisibleHours = function() {
		this.contTime.firstChild.firstChild.childNodes[1].innerHTML = this._fixLength(this._activeDate.getHours(),2);
	}
	
	/* minutes selector */
	
	// update minutes in selector
	this._updateActiveMinutes = function() {
		if (this._rsActive != null && typeof(this._rsActive) != "undefined" && typeof(this._rsCells[this._rsActive]) != "undefined") this._rsCells[this._rsActive].className = "dhtmlxcalendar_selector_cell";
		if (this._minutesInterval == 1) {
			this._rsActive = (this.getFormatedDate("%i").toString()).charAt(this._selectorMode==1?0:1);
		} else {
			this._rsActive = this._activeDate.getMinutes();
		}
		if (typeof(this._rsCells[this._rsActive]) != "undefined") this._rsCells[this._rsActive].className = "dhtmlxcalendar_selector_cell dhtmlxcalendar_selector_cell_active";
	}
	
	// update minutes in calendar
	this._updateVisibleMinutes = function(h) {
		var t = this._fixLength(this._activeDate.getMinutes(),2).toString();
		if (h == true) t = t.charAt(0)+"<span class='dhtmlxcalendar_selected_date'>"+t.charAt(1)+"</span>";
		this.contTime.firstChild.firstChild.childNodes[3].innerHTML = t;
		if (h == true) this.contTime.firstChild.firstChild.childNodes[3].lastChild._par = true;
	}
	
	/* some common functionality */
	
	this._fixLength = function(t, r) {
		while (String(t).length < r) t = "0"+String(t);
		return t;
	}
	
	this._dateFormat = "";
	this._dateFormatRE = null;
	
	this.setDateFormat = function(format) {
		
		// check value in inputs
		// for 1st call on init strTodate not defined
		var upd = {};
		if (this._strToDate != null) {
			for (var a in this.i) {
				if (this.i[a].input != null && this.i[a].input.value.length > 0) {
					var d = this._strToDate(this.i[a].input.value, this._dateFormat||this.langData[this.lang].dateformat||"%Y-%m-%d");
					if (d instanceof Date) upd[a] = d;
				}
			}
		}
		
		this._dateFormat = format;
		var k = String(this._dateFormat).replace(/%[a-zA-Z]+/g,function(t){
			var t2 = t.replace(/%/,"");
			switch (t2) {
				case "n": case "h": case "j": case "g": case "G": return "\\d{1,2}";
				case "m": case "d": case "H": case "i": case "s": case "y": return "\\d{2}";
				case "Y": return "\\d{4}";
				case "M": return "("+that.langData[that.lang].monthesSNames.join("|").toLowerCase()+"){1,}";
				case "F": return "("+that.langData[that.lang].monthesFNames.join("|").toLowerCase()+"){1,}";
				case "D": return "[a-z]{2}";
				case "a": case "A": return "AM|PM";
				case "u": return "\\d{1,6}";
				case "P": return "[\\+\\-]\\d{1,2}\\:\\d{1,2}";
			}
			return t;
		});
		
		this._dateFormatRE = new RegExp(k,"i");
		
		// update dates in inputs
		for (var a in upd) {
			this.i[a].input.value = this._dateToStr(upd[a]);
		}
		upd = null;
	}
	
	this.setDateFormat(this.langData[this.lang].dateformat||"%Y-%m-%d");
	
	this._updateDateStr = function(str) {
		// check if valid str
		if (!this._dateFormatRE || !str.match(this._dateFormatRE)) return;
		
		// input was not updated
		if (str == this.getFormatedDate()) return;
		
		var r = this._strToDate(str);
		if (!(r instanceof Date)) return;
		
		// cjeck if allow to modify input
		if (this.checkEvent("onBeforeChange")) {
			if (!this.callEvent("onBeforeChange",[new Date(r.getFullYear(),r.getMonth(),r.getDate(),r.getHours(),r.getMinutes(),r.getSeconds())])) {
				// revert value
				this._updateInp();
				return;
			}
		}
		
		this._nullDate = false;
		this._activeDate = r;
		this._drawMonth(this._nullDate?new Date():this._activeDate);
		
		this._updateVisibleMinutes();
		this._updateVisibleHours();
		
		if (this._sel && this._isSelectorVisible()) this._doOnSelectorShow(this._sel._t);
		this._doOnSelectorChange(true);
		
	}
	
	this.showMonth = function(d) {
		if (typeof(d) == "string") d = this._strToDate(d);
		if (!(d instanceof Date)) return;
		this._drawMonth(d);
	}
	
	this.setFormatedDate = function(format, str, a, return_only) {
		var date = this._strToDate(str, format);
		if (return_only) return date;
		this.setDate(date);
	}

	this.getFormatedDate = function(format, date){
		if (!(date && date instanceof Date)){
			if (this._nullDate) return ""; 
			date = new Date(this._activeDate);
		}
		return this._dateToStr(date, format);
	}
	
	/* week numbers */
	this.getWeekNumber = function(dateX) {
		
		if (typeof(dateX) == "string") dateX = this._strToDate(dateX);
		if (!(dateX instanceof Date)) return "Invalid Date";
		
		if (typeof(this._ftDay) == "undefined") this._ftDay = 4;
		
		var ws = this._wStart; // 1..7 = Mo-Su
		var we = ws+7;
		
		var ft = 4; // first thursday
		
		
		var x1_date = new Date(dateX.getFullYear(), 0, 1, 0, 0, 0, 0);// day-of-week, jan first
		var x1 = x1_date.getDay();
		if (x1 == 0) x1 = 7;
		
		// offset
		if (ft < ws) {
			ft += 7;
			x1 += 7;
		}
		
		// detect date of 1st week
		
		var i = 0; // week offset
		if (x1 >= ws && x1 <= ft) {
			// x1 belong 1st week
		} else {
			// x1 belong 2nd week
			i = 1;
		}
		var k = x1-ws;
		var w1 = new Date(dateX.getFullYear(), 0, 1-k+i*7, 0, 0, 0, 0);// 1st week start date
		
		// console.log("1st week of "+x.getFullYear()+" year starts from "+this.getFormatedDate("%M %d, %Y",w1));
		
		var d7 = 604800000; // 7 days in ms, 60*60*24*7*1000
		var x2 = new Date(dateX.getFullYear(), dateX.getMonth(), dateX.getDate()+1, 0, 0, 0, 0); // 2nd day to get interval
		
		var wn = Math.ceil((x2.getTime()-w1.getTime())/d7);
		
		// if 1st jan coincide with 52/53'd week of prev year, get week number of 1st day of current week
		if (wn == 0) {
			var curDate = new Date(dateX.getFullYear(), dateX.getMonth(), dateX.getDate(), 0, 0, 0, 0);
			var firstDay = curDate.getDay()-this._wStart;
			if (firstDay < 0) firstDay = firstDay+7;
			curDate.setDate(curDate.getDate()-firstDay);
			wn = this.getWeekNumber(curDate);
		}
		
		return wn;
		
	}
	
	this.showWeekNumbers = function() {
		this.base.firstChild.className = "dhtmlxcalendar_wn";
	}
	
	this.hideWeekNumbers = function() {
		this.base.firstChild.className = "";
	}
	
	/* show/hide calendar */
	
	// public show/hide
	
	this.show = function(id) {
		// if id not set - try show in container
		if (!id && this._hasParent) {
			this._show();
			return;
		}
		
		// show by real input id, added in 5.0
		if (typeof(id) == "string") {
			var i = document.getElementById(id);
			if (i != null && typeof(i._dhtmlxcalendar_uid) != "undefined" && this.i[i._dhtmlxcalendar_uid] != null) {
				this._show(i._dhtmlxcalendar_uid);
				return;
			}
		}
		
		// if input id not specified show near first found
		// if nothing found - do not show
		if (typeof(id) == "object" && typeof(id._dhtmlxcalendar_uid) != "undefined" && this.i[id._dhtmlxcalendar_uid] == id) {
			this._show(id._dhtmlxcalendar_uid);
			return;
		}
		if (typeof(id) == "undefined") { for (var a in this.i) if (!id) id = a; }
		if (!id) return;
		this._show(id);
	}
	
	this.hide = function() {
		if (this._isVisible()) this._hide();
	}
	
	this.isVisible = function() {
		return this._isVisible();
	}
	
	
	// private show/hide
	this._activeInp = null;
	
	this.pos = "bottom";
	this.setPosition = function(x, y) {
		this._px = null;
		this._py = null;
		if (x == "right" || x == "bottom") {
			this.pos = x;
		} else {
			this.pos = "int";
			if (typeof(x) != "undefined" && !isNaN(x)) {
				this.base.style.left = x+"px";
				this._px = x;
			}
			if (typeof(y) != "undefined" && !isNaN(y)) {
				this.base.style.top = y+"px";
				this._py = y;
			}
			this._ifrSize();
		}
	}
	
	this._show = function(inpId, autoHide) {
		if (autoHide === true && this._activeInp == inpId && this._isVisible()) {
			this._hide();
			return;
		}
		this.base.style.visibility = "hidden";
		this.base.style.display = "";
		if (!inpId) {
			if (this._px != null && this._py != null) {
				this.base.style.left = this._px+"px";
				this.base.style.top = this._py+"px";
			} else {
				this.base.style.left = "0px";
				this.base.style.top = "0px";
			}
		} else {
			if (this.base.className.indexOf("dhtmlxcalendar_in_input") == -1) this.base.className += " dhtmlxcalendar_in_input";
			var i = (this.i[inpId].input||this.i[inpId].button);
			var dim = window.dhx4.screenDim();
			var inp = {top: window.dhx4.absTop(i), left: window.dhx4.absLeft(i)};
			if (this.pos == "right") {
				this.base.style.left = inp.left+i.offsetWidth+"px";
				this.base.style.top = Math.min(inp.top, dim.bottom-this.base.offsetHeight)+"px";
			} else if (this.pos == "bottom") {
				var y0 = inp.top+i.offsetHeight+1;
				if (y0+this.base.offsetHeight > dim.bottom) {
					var ny0 = inp.top-this.base.offsetHeight;
					if (ny0 >= -20) y0 = ny0;
				}
				// checi overflow from right side
				var x = inp.left;
				if (x + this.base.offsetWidth > dim.right) x = Math.max(0, inp.left+i.offsetWidth-this.base.offsetWidth);
				//
				this.base.style.left = x+"px";
				this.base.style.top = y0+"px";
			} else {
				this.base.style.left = (this._px||0)+"px";
				this.base.style.top = (this._py||0)+"px";
			}
			this._activeInp = inpId;
			i = null;
		}
		this._hideSelector();
		this.base.style.visibility = "visible";
		this.base.style.zIndex = window.dhx4.zim.reserve(this.conf.zi);
		this._ifrSize();
		if (this._ifr) this._ifr.style.display = "";
		this.callEvent("onShow",[]);
	}
	
	this._hide = function() {
		if (this._lastHover != null) this._clearDayHover();
		this._hideSelector();
		this.base.style.display = "none";
		window.dhx4.zim.clear(this.conf.zi);
		if (this.base.className.indexOf("dhtmlxcalendar_in_input") >= 0) this.base.className = this.base.className.replace(/\s{0,}dhtmlxcalendar_in_input/gi, "");
		this._activeInp = null;
		if (this._ifr) this._ifr.style.display = "none";
		this.callEvent("onHide",[]);
	}
	
	this._isVisible = function() {
		return (this.base.style.display!="none");
	}
	
	this._rangeActive = false;
	this._rangeFrom = null;
	this._rangeTo = null;
	this._rangeSet = {};
	
	this.setInsensitiveDays = function(d) {
		
		// !works in append mode
		var t = this._extractDates(d);
		for (var q=0; q<t.length; q++) this._rangeSet[new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime()] = true;
		
		this._drawMonth(this._activeMonth);
		
	}
	
	this.clearInsensitiveDays = function() {
		this._clearRangeSet();
		this._drawMonth(this._activeMonth);
	}
	
	this._holidays = {};
	this.setHolidays = function(r) {
		if (r == null) {
			this._clearHolidays();
		} else if (r != null) {
			var t = this._extractDates(r);
			for (var q=0; q<t.length; q++) this._holidays[new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime()] = true;
		}
		this._drawMonth(this._activeMonth);
	}
	
	this._extractDates = function(r) {
		// r = array of dates or comma-separated string list
		// return array with dates
		if (typeof(r) == "string" || r instanceof Date) r = [r];
		var t = [];
		for (var q=0; q<r.length; q++) {
			if (typeof(r[q]) == "string") {
				var e = r[q].split(",");
				for (var w=0; w<e.length; w++) t.push(this._strToDate(e[w]));
			} else if (r[q] instanceof Date) {
				t.push(r[q]);
			}
		}
		return t;
	}
	
	this._clearRange = function() {
		this._rangeActive = false;
		this._rangeType = null;
		this._rangeFrom = null;
		this._rangeTo = null;
	}
	
	this._clearRangeSet = function() {
		for (var a in this._rangeSet) {
			this._rangeSet[a] = null;
			delete this._rangeSet[a];
		}
	}
	
	this._clearHolidays = function() {
		for (var a in this._holidays) {
			this._holidays[a] = null;
			delete this._holidays[a];
		}
	}
	
	this._isOutOfRange = function(time) {
		
		if (this._rangeSet[time] == true) return true;
		
		if (this._rangeActive) {
			
			if (this._rangeType == "in" && (time<this._rangeFrom || time>this._rangeTo)) return true;
			if (this._rangeType == "out" && (time>=this._rangeFrom && time<=this._rangeTo)) return true;
			if (this._rangeType == "from" && time<this._rangeFrom)return true;
			if (this._rangeType == "to" && time>this._rangeTo) return true;
		}
		
		var t0 = new Date(time);
		
		if (this._rangeWeek) {
			if (this._rangeWeekData[t0.getDay()] === true) return true;
		}
		
		if (this._rangeMonth) {
			if (this._rangeMonthData[t0.getDate()] === true) return true;
		}
		
		if (this._rangeYear) {
			if (this._rangeYearData[t0.getMonth()+"_"+t0.getDate()] === true) return true;
		}
		
		return false;
		
	}
	
	this.clearSensitiveRange = function() {
		this._clearRange();
		this._drawMonth(this._activeMonth);
	}
	
	this.setSensitiveRange = function(from, to, ins) {
		
		var f = false;
		
		// set range
		if (from != null && to != null) {
			
			if (!(from instanceof Date)) from = this._strToDate(from);
			if (!(to instanceof Date)) to = this._strToDate(to);
			
			if (from.getTime() > to.getTime()) return;
			
			this._rangeFrom = new Date(from.getFullYear(),from.getMonth(),from.getDate(),0,0,0,0).getTime();
			this._rangeTo = new Date(to.getFullYear(),to.getMonth(),to.getDate(),0,0,0,0).getTime();
			this._rangeActive = true;
			this._rangeType = "in";
			
			f = true;
		}
		
		// set range "from date"
		if (!f && from != null && to == null) {
			
			if (!(from instanceof Date)) from = this._strToDate(from);
			this._rangeFrom = new Date(from.getFullYear(),from.getMonth(),from.getDate(),0,0,0,0).getTime();
			this._rangeTo = null;
			
			if (ins === true) this._rangeFrom++;
			
			this._rangeActive = true;
			this._rangeType = "from";
			
			f = true;
			
		}
		
		// set range "to date"
		if (!f && from == null && to != null) {
			
			if (!(to instanceof Date)) to = this._strToDate(to);
			this._rangeFrom = null;
			this._rangeTo = new Date(to.getFullYear(),to.getMonth(),to.getDate(),0,0,0,0).getTime();
			
			if (ins === true) this._rangeTo--;
			
			this._rangeActive = true;
			this._rangeType = "to";
			
			f = true;
			
		}
		
		if (f) this._drawMonth(this._activeMonth);
	}
	
	this.setInsensitiveRange = function(from, to) {
		
		if (from != null && to != null) {
			
			if (!(from instanceof Date)) from = this._strToDate(from);
			if (!(to instanceof Date)) to = this._strToDate(to);
			
			if (from.getTime() > to.getTime()) return;
			
			this._rangeFrom = new Date(from.getFullYear(),from.getMonth(),from.getDate(),0,0,0,0).getTime();
			this._rangeTo = new Date(to.getFullYear(),to.getMonth(),to.getDate(),0,0,0,0).getTime();
			this._rangeActive = true;
			this._rangeType = "out";
			
			this._drawMonth(this._activeMonth);
			return;
		}
		
		if (from != null && to == null) {
			this.setSensitiveRange(null, from, true);
			return;
		}
		
		if (from == null && to != null) {
			this.setSensitiveRange(to, null, true);
			return;
		}
		
	}
	
	//
	this.disableDays = function(mode, d) {
		
		if (mode == "week") {
			
			// !! works in replace mode
			
			if (typeof(d) != "object" && typeof(d.length) == "undefined") d = [d];
			
			if (!this._rangeWeekData) this._rangeWeekData = {};
			for (var a in this._rangeWeekData) {
				this._rangeWeekData[a] = false;
				delete this._rangeWeekData[a];
			}
			
			for (var q=0; q<d.length; q++) {
				this._rangeWeekData[d[q]] = true;
				if (d[q] == 7) this._rangeWeekData[0] = true;
			}
			this._rangeWeek = true;
		}
		
		if (mode == "month") {
			
			// !! works in replace mode
			
			if (typeof(d) != "object" && typeof(d.length) == "undefined") d = [d];
			
			if (!this._rangeMonthData) this._rangeMonthData = {};
			for (var a in this._rangeMonthData) {
				this._rangeMonthData[a] = false;
				delete this._rangeMonthData[a];
			}
			for (var q=0; q<d.length; q++) this._rangeMonthData[d[q]] = true;
			
			this._rangeMonth = true;
		}
		
		if (mode == "year") {
			
			// !! works in replace mode
			
			var t = this._extractDates(d);
			
			if (!this._rangeYearData) this._rangeYearData = {};
			for (var a in this._rangeYearData) {
				this._rangeYearData[a] = false;
				delete this._rangeYearData[a];
			}
			for (var q=0; q<t.length; q++) this._rangeYearData[t[q].getMonth()+"_"+t[q].getDate()] = true;
			
			this._rangeYear = true;
		}
		
		this._drawMonth(this._activeMonth);
	}
	
	this.enableDays = function(mode) {
		
		if (mode == "week") {
			this._rangeWeek = false;
		}
		
		if (mode == "month") {
			this._rangeMonth = false;
		}
		
		if (mode == "year") {
			this._rangeYear = false;
		}
		
		this._drawMonth(this._activeMonth);
	}
	
	
	/* tooltips */
	
	this._tipData = {};
	this._tipTM = null;
	this._tipTMTime = 400;
	this._tipEvs = false;
	this._tipPopup = null;
	this._tipCellDate = null;
	this._tipCellDim = null;
	
	this.setTooltip = function(dateX, text, showIcon, usePopup) {
		
		var t = this._extractDates(dateX);
		for (var q=0; q<t.length; q++) {
			var k = new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime();
			this._tipData[k] = { text: text, showIcon: showIcon, usePopup: usePopup };
		}
		this._drawMonth(this._activeMonth);
	}
	
	this.clearTooltip = function(dateX) {
		
		var t = this._extractDates(dateX);
		for (var q=0; q<t.length; q++) {
			var k = new Date(t[q].getFullYear(),t[q].getMonth(),t[q].getDate(),0,0,0,0).getTime();
			this._tipData[k] = null;
			delete this._tipData[k];
		}
		this._drawMonth(this._activeMonth);
	}
	
	this._initTooltipPopup = function() {
		
		if (this._tipEvs) return;
		
		this.attachEvent("onMouseOver", function(d){
			var k = new Date(d.getFullYear(),d.getMonth(),d.getDate(),0,0,0,0).getTime();
			if (this._tipData[k] != null) {
				if (this._tipTM) window.clearTimeout(this._tipTM);
				this._tipCellDate = d;
				this._tipCellDim = this.getCellDimension(d);
				this._tipText = this._tipData[k].text;
				this._tipTM = window.setTimeout(this._showTooltipPopup,this._tipTMTime);
			}
		});
		
		this.attachEvent("onMouseOut", this._hideTooltipPopup);
		
		this._tipEvs = true;
	}
	this._showTooltipPopup = function(text,x,y,w,h) {
		if (!that._tipPopup) that._tipPopup = new dhtmlXPopup({mode:"top"});
		that._tipPopup.attachHTML(that._tipText);
		that._tipPopup.show(that._tipCellDim.x, that._tipCellDim.y, that._tipCellDim.w, that._tipCellDim.h);
		that.callEvent("onPopupShow",[that._tipCellDate]);
	}
	
	this._hideTooltipPopup = function() {
		if (this._tipTM) window.clearTimeout(this._tipTM);
		if (this._tipPopup != null && this._tipPopup.isVisible()) {
			this._tipPopup.hide();
			this.callEvent("onPopupHide",[this._tipCellDate]);
		}
	}
	
	this.getPopup = function() {
		return this._tipPopup;
	}
	
	this.getCellDimension = function(dateX) {
		
		if (typeof(dateX) == "string") dateX = this._strToDate(dateX);
		if (!(dateX instanceof Date)) return null;
		
		var t = new Date(dateX.getFullYear(),dateX.getMonth(),dateX.getDate(),0,0,0,0).getTime();
		
		var k = null;
		
		for (var q=0; q<this.contDates.childNodes.length; q++) {
			for (var w=0; w<this.contDates.childNodes[q].childNodes.length; w++) {
				var p = this.contDates.childNodes[q].childNodes[w];
				if (p._date != null && p._date.getTime() == t) k = { x: window.dhx4.absLeft(p), y: window.dhx4.absTop(p), w: p.offsetWidth, h: p.offsetHeight };
				p = null;
			}
		}
		
		return k;
	}
	
	/* other */
	this._updateFromInput = function(t) {
		if (this._nullInInput && ((t.value).replace(/\s/g,"")).length == 0) {
			if (this.checkEvent("onBeforeChange")) {
				if (!this.callEvent("onBeforeChange",[null])) {
					// revert value
					this._updateInp();
					return;
				}
			}
			this.setDate(null);
		} else {
			this._updateDateStr(t.value);
		}
		t = null;
	}
	
	// global events
	this._doOnClick = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		// completely close alien calendar (both selector and container) inly if any assigned input clicked
		// otherwise hide selector and container separately
		if (t._dhtmlxcalendar_uid && t._dhtmlxcalendar_uid != that._activeInp && that._isVisible() && that._activeInp) {
			that._hide();
			return;
		}
		if (!t._dhtmlxcalendar_uid || !that.i[t._dhtmlxcalendar_uid]) { // !that.i[t._dhtmlxcalendar_uid] means alien input, for several calendar instances
			if (that._isSelectorVisible()) that._hideSelector(); else if (!that._hasParent && that._isVisible()) that._hide();
		}
	}
	
	this._doOnKeyDown = function(e) {
		e = e||event;
		if (e.keyCode == 27 || e.keyCode == 13) {
			if (that._isSelectorVisible()) that._hideSelector(); else if (that._isVisible() && !that._hasParent) that._hide();
		}
	}
	
	// inputs events
	this._doOnInpClick = function(e) {
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		var t = (e.target||e.srcElement);
		if (!t._dhtmlxcalendar_uid) return;
		if (!that._listenerEnabled) {
			that._updateFromInput(t);
		}
		that._show(t._dhtmlxcalendar_uid, true);
	}
	
	this._doOnInpKeyUp = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		if (e.keyCode == 13 || !t._dhtmlxcalendar_uid) return;
		// otherwise try to update calendar's date
		if (!that._listenerEnabled) that._updateFromInput(t);
	}
	
	this._doOnBtnClick = function(e) {
		e = e||event;
		if (e.type == "touchstart" && e.preventDefault != null) e.preventDefault();
		var t = (e.target||e.srcElement);
		if (!t._dhtmlxcalendar_uid) return;
		if (that.i[t._dhtmlxcalendar_uid].input != null) that._updateFromInput(that.i[t._dhtmlxcalendar_uid].input);
		that._show(t._dhtmlxcalendar_uid, true);
	}
	
	this._doOnUnload = function() {
		if (that && that.unload) that.unload();
	}
	
	if (typeof(window.addEventListener) == "function") {
		document.body.addEventListener("click", that._doOnClick, false);
		window.addEventListener("keydown", that._doOnKeyDown, false);
		window.addEventListener("unload", that._doOnUnload, false);
		if (this.conf.touch == true) document.body.addEventListener("touchstart", that._doOnClick, false);
	} else {
		document.body.attachEvent("onclick", that._doOnClick);
		document.body.attachEvent("onkeydown", that._doOnKeyDown);
		window.attachEvent("onunload", that._doOnUnload);
	}
	
	this.attachObj = function(obj) {
		var a = window.dhx4.newId();
		if (typeof(obj) == "string") {
			// id
			this.i[a] = {input:document.getElementById(obj)};
		} else if (typeof(obj.tagName) != "undefined") {
			// input dom obj
			this.i[a] = {input:obj};
		} else if (typeof(obj) == "object" && (obj.input != null || obj.button != null)) {
			// object
			this.i[a] = {};
			if (obj.input != null) this.i[a].input = (typeof(obj.input)=="string"?document.getElementById(obj.input):obj.input);
			if (obj.button != null) this.i[a].button = (typeof(obj.button)=="string"?document.getElementById(obj.button):obj.button);
		}
		this._attachEventsToObject(a);
		return a;
	}
	
	this.detachObj = function(obj) {
		var a = null;
		if (this.i[obj] != null) {
			// direct id
			a = obj;
		} else if (typeof(obj) == "string") {
			// id
			obj = document.getElementById(obj);
			a = obj._dhtmlxcalendar_uid;
		} else if (typeof(obj.tagName) != "undefined") {
			// input dom element
			a = obj._dhtmlxcalendar_uid;
		} else if (typeof(obj) == "object" && (obj.input != null || obj.button != null)) {
			if (a == null && obj.input != null) a = (typeof(obj.input)=="string"?document.getElementById(obj.input):obj.input)._dhtmlxcalendar_uid;
			if (a == null && obj.button != null) a = (typeof(obj.button)=="string"?document.getElementById(obj.button):obj.button)._dhtmlxcalendar_uid;
		}
		if (a != null && this.i[a] != null) {
			this._detachEventsFromObject(a);
			for (var b in this.i[b]) {
				this.i[a][b]._dhtmlxcalendar_uid = null;
				this.i[a][b] = null;
				delete this.i[a][b];
			}
			this.i[a] = null;
			delete this.i[a];
			return true;
		}
		return false;
	}
	
	this._attachEventsToObject = function(a) {
		if (this.i[a].button != null) {
			this.i[a].button._dhtmlxcalendar_uid = a;
			if (typeof(window.addEventListener) == "function") {
				this.i[a].button.addEventListener("click", that._doOnBtnClick, false);
				if (this.conf.touch == true) this.i[a].button.addEventListener("touchstart", that._doOnBtnClick, false);
			} else {
				this.i[a].button.attachEvent("onclick", that._doOnBtnClick);
			}
		} else if (this.i[a].input != null) {
			this.i[a].input._dhtmlxcalendar_uid = a;
			if (typeof(window.addEventListener) == "function") {
				this.i[a].input.addEventListener("click", that._doOnInpClick, false);
				this.i[a].input.addEventListener("keyup", that._doOnInpKeyUp, false);
				if (this.conf.touch == true) this.i[a].input.addEventListener("touchstart", that._doOnInpClick, false);
			} else {
				this.i[a].input.attachEvent("onclick", that._doOnInpClick);
				this.i[a].input.attachEvent("onkeyup", that._doOnInpKeyUp);
			}
		}
	}
	
	this._detachEventsFromObject = function(a) {
		if (this.i[a].button != null) {
			if (typeof(window.addEventListener) == "function") {
				this.i[a].button.removeEventListener("click", that._doOnBtnClick, false);
				if (this.conf.touch == true) this.i[a].button.removeEventListener("touchstart", that._doOnBtnClick, false);
				
			} else {
				this.i[a].button.detachEvent("onclick", that._doOnBtnClick);
			}
		} else if (this.i[a].input != null) {
			if (typeof(window.addEventListener) == "function") {
				this.i[a].input.removeEventListener("click", that._doOnInpClick, false);
				this.i[a].input.removeEventListener("keyup", that._doOnInpKeyUp, false);
				if (this.conf.touch == true) this.i[a].input.removeEventListener("touchstart", that._doOnInpClick, false);
			} else {
				this.i[a].input.detachEvent("onclick", that._doOnInpClick);
				this.i[a].input.detachEvent("onkeyup", that._doOnInpKeyUp);
			}
		}
	}
	this._updateInp = function() {
		if (this.i != null && this._activeInp != null && this.i[this._activeInp] != null && this.i[this._activeInp].input != null) {
			this.i[this._activeInp].input.value = this.getFormatedDate();
		}
	}
	
	// listener
	this.enableListener = function(t) {
		if (!t) return;
		if (typeof(window.addEventListener) == "function") {
			t.addEventListener("focus", that._listenerEvFocus, false);
			t.addEventListener("blur", that._listenerEvBlur, false);
		} else {
			t.attachEvent("onfocus", that._listenerEvFocus);
			t.attachEvent("onblur", that._listenerEvBlur);
		}
		t = null;
	}
	
	this.disableListener = function(t) {
		if (!t) return;
		t._f0 = false;
		if (this._tmListener) window.clearTimeout(this._tmListener);
		if (typeof(window.addEventListener) == "function") {
			t.removeEventListener("focus", that._listenerEvFocus, false);
			t.removeEventListener("blur", that._listenerEvBlur, false);
		} else {
			t.detachEvent("onfocus", that._listenerEvFocus);
			t.detachEvent("onblur", that._listenerEvBlur);
		}
		t = null;
	}
	
	this._startListener = function(t) {
		if (this._tmListener) window.clearTimeout(this._tmListener);
		if (typeof(t._v1) == "undefined") t._v1 = t.value;
		if (t._v1 != t.value) {
			this._updateFromInput(t);
			t._v1 = t.value;
		}
		if (t._f0) this._tmListener = window.setTimeout(function(){that._startListener(t);},100);
	}
	
	this._listenerEvFocus = function(e) {
		e = e||event;
		var t = e.target||e.srcElement;
		t._f0 = true;
		that._startListener(t)
		t = null;
	}
	this._listenerEvBlur = function(e) {
		e = e||event;
		var t = e.target||e.srcElement;
		t._f0 = false;
		t = null;
	}
	
	
	//
	for (var a in this.i) this._attachEventsToObject(a);
	
	// events
	window.dhx4._eventable(this);
	
	// event wrappers
	this._evOnArrowClick = function(args) {
		return this.callEvent("onArrowClick", args);
	}
	this._evOnClick = function(args) {
		return this.callEvent("onClick", args);
	}
	this._evOnMouseOut = function(args) {
		return this.callEvent("onMouseOut", args);
	}
	this._evOnMouseOver = function(args) {
		return this.callEvent("onMouseOver", args);
	}
	
	
	
	/* unload */
	
	this.unload = function() {
		
		this._activeDate = null;
		this._activeDateCell = null;
		this._activeInp = null;
		this._activeMonth = null;
		this._dateFormat = null;
		this._dateFormatRE = null;
		this._lastHover = null;
		
		if (this._tmListener) window.clearTimeout(this._tmListener);
		this._tmListener = null;
		
		/* main events */
		
		if (typeof(window.addEventListener) == "function") {
			document.body.removeEventListener("click", that._doOnClick, false);
			window.removeEventListener("keydown", that._doOnKeyDown, false);
			window.removeEventListener("unload", that._doOnUnload, false);
			if (this.conf.touch == true) document.body.removeEventListener("touchstart", that._doOnClick, false);
		} else {
			document.body.detachEvent("onclick", that._doOnClick);
			document.body.detachEvent("onkeydown", that._doOnKeyDown);
			window.detachEvent("onunload", that._doOnKeyDown);
		}
		
		this._doOnClick = null;
		this._doOnKeyDown = null;
		this._doOnUnload = null;
		
		/* assigned inputs */
		
		for (var a in this.i) {
			// marker
			this.i[a]._dhtmlxcalendar_uid = null;
			
			// events
			this._detachEventsFromObject(a);
			this.disableListener(this.i[a].input);
			
			this.i[a] = null;
			delete this.i[a];
			
		}
		
		this.i = null;
		
		this._doOnInpClick = null;
		this._doOnInpKeyUp = null;
		
		/* clear events */
		window.dhx4._eventable(this, "clear");
		
		/* months */
		
		this.contMonth.onselectstart = null;
		
		// li
		this.contMonth.firstChild.firstChild.onclick = null;
		this.contMonth.firstChild.firstChild.ontouchstart = null;
		
		// arrows
		this.contMonth.firstChild.firstChild.firstChild.onmouseover = null;
		this.contMonth.firstChild.firstChild.firstChild.onmouseout = null;
		this.contMonth.firstChild.firstChild.lastChild.onmouseover = null;
		this.contMonth.firstChild.firstChild.lastChild.onmouseout = null;
		
		while (this.contMonth.firstChild.firstChild.childNodes.length > 0) this.contMonth.firstChild.firstChild.removeChild(this.contMonth.firstChild.firstChild.lastChild);
		
		// li
		this.contMonth.firstChild.removeChild(this.contMonth.firstChild.firstChild);
		
		// ul
		this.contMonth.removeChild(this.contMonth.firstChild);
		
		// div
		this.contMonth.parentNode.removeChild(this.contMonth);
		this.contMonth = null;
		
		/* days */
		
		// li
		while (this.contDays.firstChild.childNodes.length > 0) this.contDays.firstChild.removeChild(this.contDays.firstChild.lastChild);
		
		// ul
		this.contDays.removeChild(this.contDays.firstChild);
		
		// div
		this.contDays.parentNode.removeChild(this.contDays);
		this.contDays = null;
		
		/* dates */
		
		this.contDates.onclick = null;
		this.contDates.ontouchstart = null;
		this.contDates.onmouseover = null;
		this.contDates.onmouseout = null;
		
		while (this.contDates.childNodes.length > 0) {
			while (this.contDates.lastChild.childNodes.length > 0) {
				// li
				this.contDates.lastChild.lastChild._css_date = null;
				this.contDates.lastChild.lastChild._css_month = null;
				this.contDates.lastChild.lastChild._css_weekend = null;
				this.contDates.lastChild.lastChild._css_hover = null;
				this.contDates.lastChild.lastChild._date = null;
				this.contDates.lastChild.lastChild._q = null;
				this.contDates.lastChild.lastChild._w = null;
				this.contDates.lastChild.removeChild(this.contDates.lastChild.lastChild);
			}
			// ul
			this.contDates.removeChild(this.contDates.lastChild);
		}
		
		// div
		this.contDates.parentNode.removeChild(this.contDates);
		this.contDates = null;
		
		/* time */
		
		this.contTime.firstChild.firstChild.onclick = null;
		this.contTime.firstChild.firstChild.ontouchstart = null;
		
		// labels
		while (this.contTime.firstChild.firstChild.childNodes.length > 0) this.contTime.firstChild.firstChild.removeChild(this.contTime.firstChild.firstChild.lastChild);
		
		// li
		this.contTime.firstChild.removeChild(this.contTime.firstChild.firstChild);
		
		// ul
		this.contTime.removeChild(this.contTime.firstChild);
		
		// div
		this.contTime.parentNode.removeChild(this.contTime);
		this.contTime = null;
		
		
		this._lastHover = null;
		
		/* selector */
		
		this._unloadSelector("month");
		this._unloadSelector("year");
		this._unloadSelector("hours");
		this._unloadSelector("minutes");
		
		// selector cover
		if (this._selCover) {
			this._selCover.parentNode.removeChild(this._selCover);
			this._selCover = null;
		}
		
		// selector object
		if (this._sel) {
			
			for (var a in this._sel._ta) this._sel._ta[a] = null;
			this._sel._ta = null;
			this._sel._t = null;
			
			this._sel.onmouseover = null;
			this._sel.onmouseout = null;
			
			// td
			while (this._sel.firstChild.firstChild.firstChild.childNodes.length > 0) {
				this._sel.firstChild.firstChild.firstChild.lastChild.onclick = null;
				this._sel.firstChild.firstChild.firstChild.lastChild.onmouseover = null;
				this._sel.firstChild.firstChild.firstChild.lastChild.onmouseout = null;
				this._sel.firstChild.firstChild.firstChild.removeChild(this._sel.firstChild.firstChild.firstChild.lastChild);
			}
			
			// tr
			this._sel.firstChild.firstChild.removeChild(this._sel.firstChild.firstChild.firstChild);
			
			// tbody
			this._sel.firstChild.removeChild(this._sel.firstChild.firstChild);
			
			// table and arrow div
			while (this._sel.childNodes.length > 0) this._sel.removeChild(this._sel.lastChild);
			
			// object
			this._sel.parentNode.removeChild(this._sel);
			this._sel = null;
		}
		
		
		/* base */
		
		this.base.onclick = null;
		this.base.onmousedown = null;
		this.base.ontouchstart = null;
		this.base.onmouseout = null;
		this.base.parentNode.removeChild(this.base);
		this.base = null;
		
		/* methods */
		
		this._clearDayHover = null;
		this._clearSelHover = null;
		this._doOnSelectorChange = null;
		this._doOnSelectorShow = null;
		this._drawMonth = null;
		this._fixLength = null;
		this._ifrSize = null;
		this._hide = null;
		this._hideSelector = null;
		this._initSelector = null;
		this._isSelectorVisible = null;
		this._isVisible = null;
		this._scrollYears = null;
		this._show = null;
		this._showSelector = null;
		this._strToDate = null;
		this._updateActiveHours = null;
		this._updateActiveMinutes = null;
		this._updateActiveMonth = null;
		this._updateActiveYear = null;
		this._updateCellStyle = null;
		this._updateDateStr = null;
		this._updateVisibleHours = null;
		this._updateVisibleMinutes = null;
		this._updateYearsList = null;
		this.enableIframe = null;
		this.hide = null;
		this.hideTime = null;
		this.setDate = null;
		this.setDateFormat = null;
		this.setYearsRange = null;
		this.show = null;
		this.showTime = null;
		this.unload = null;
		
		/* popup */
		if (this._tipPopup != null) {
			this._tipPopup.unload();
			this._tipPopup = null;
		}
		
		for (var a in this) delete this[a];
		
		a = that = null;
		
	}
	
	
	// set init date
	this.setDate(this._activeDate);
	
	return this;
};

dhtmlXCalendarObject.prototype.lang = "en";
dhtmlXCalendarObject.prototype.langData = {
	"en": {
		dateformat: "%Y-%m-%d",
		hdrformat: "%F %Y",
		monthesFNames: ["January","February","March","April","May","June","July","August","September","October","November","December"],
		monthesSNames: ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],
		daysFNames: ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
		daysSNames: ["Su","Mo","Tu","We","Th","Fr","Sa"],
		weekstart: 1,
		weekname: "w",
		today: "Today",
		clear: "Clear"
	}
};

dhtmlXCalendarObject.prototype._buildMonthHdr = function(val) {
	var that = this;
	var z = function(t) {
		return (String(t).length==1?"0"+String(t):t);
	}
	var w = function(type, str) {
		return "<span class='dhtmlxcalendar_month_label_"+type+"'>"+str+"</span>";
	}
	var format = String(this.langData[this.lang].hdrformat||("%F %Y")).replace(/%[a-z]/gi, function(t){
		switch (t) {
			case "%m": return w("month", z(val.getMonth()+1));
			case "%n": return w("month", val.getMonth()+1);
			case "%M": return w("month", that.langData[that.lang].monthesSNames[val.getMonth()]);
			case "%F": return w("month", that.langData[that.lang].monthesFNames[val.getMonth()]);
			case "%y": return w("year", z(val.getYear()%100));
			case "%Y": return w("year", val.getFullYear());
			case "%%": return "%";
			default: return t;
		}
	});
	that = z = w = null;
	return format;
};

dhtmlXCalendarObject.prototype.enableIframe = function(mode) {
	if (mode == true) {
		if (!this._ifr) {
			this._ifr = document.createElement("IFRAME");
			this._ifr.frameBorder = 0;
			this._ifr.border = 0;
			this._ifr.setAttribute("src","javascript:false;");
			this._ifr.className = "dhtmlxcalendar_ifr";
			this._ifr.onload = function(){
				this.onload = null;
				this.contentWindow.document.open("text/html", "replace");
				this.contentWindow.document.write("<html><head><style>html,body{width:100%;height:100%;overflow:hidden;margin:0px;}</style></head><body</body></html>");
			}
			this.base.parentNode.insertBefore(this._ifr, this.base);
			this._ifrSize();
		}
	} else {
		if (this._ifr) {
			this._ifr.parentNode.removeChild(this._ifr);
			this._ifr = null;
		}
	}
};

dhtmlXCalendarObject.prototype._ifrSize = function() {
	if (this._ifr) {
		this._ifr.style.left = this.base.style.left;
		this._ifr.style.top = this.base.style.top;
		this._ifr.style.width = this.base.offsetWidth+"px";
		this._ifr.style.height = this.base.offsetHeight+"px";
	}
};

dhtmlxCalendarObject = dhtmlXCalendarObject;

dhtmlXCalendarObject.prototype._dateStrings = function() {
	var k = this.langData[this.lang];
	return {monthFullName: k.monthesFNames, monthShortName: k.monthesSNames, dayFullName: k.daysFNames, dayShortName: k.daysSNames};
};
dhtmlXCalendarObject.prototype._strToDate = function(val, format) {
	return window.dhx4.str2date(val, format||this._dateFormat, this._dateStrings());
};
dhtmlXCalendarObject.prototype._dateToStr = function(val, format) {
	return window.dhx4.date2str(val, format||this._dateFormat, this._dateStrings());
};

;
///<jscompress sourcefile="dhtmlxmenu.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXMenuObject(base, skin) {
	
	var that = this;
	
	// iframe
	this.conf = {
		skin: (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxmenu")||"material"),
		mode: "web",
		align: "left",
		is_touched: false,
		selected: -1,
		last_click: -1,
		fixed_pos: false, // should be used for frameset in IE
		rtl: false,
		icons_path: "",
		icons_css: false, // use css for icons or direct img links, added in 5.0
		arrow_ff_fix: (navigator.userAgent.indexOf("MSIE") >= 0 && document.compatMode=="BackCompat"), // border fixer for FF for arrows polygons
		live_id: window.dhx4.newId(),
		tags: {
			root: "menu",
			item: "item",
			text_ext: "itemtext",
			userdata: "userdata",
			tooltip: "tooltip",
			hotkey: "hotkey",
			href: "href"
		},
		autoload: {},
		hide_tm: {},
		// shows sublevel polygons from toplevel items with delay
		top_mode: true,
		top_tmtime: 200,
		// visible area
		v_enabled: false,
		v: {x1: null, x2: null, y1: null, y2: null},
		// open direction
		dir_toplv: "bottom",
		dir_sublv: "right",
		// overflow
		auto_overflow: false,
		overflow_limit: 0,
		of_utm: null, // scroll up - tm
		of_utime: 20, // scroll up - time
		of_ustep: 3, // scroll up - step
		of_dtm: null,
		of_dtime: 20,
		of_dstep: 3,
		of_ah: {dhx_skyblue: 24, dhx_web: 25, dhx_terrace: 27, material: 25}, // arrow height+oplygon top/bottom padding
		of_ih: {dhx_skyblue: 24, dhx_web: 24, dhx_terrace: 24, material: 30}, // item height
		// hide
		tm_sec: 400,
		tm_handler: null,
		// dyn load
		dload: false,
		dload_url: "",
		dload_icon: false, // show loading icon
		dload_params: {action: "loadMenu"}, // extra params
		dload_pid: "parentId", // parentId param name
		// skinbased offsets
		tl_botmarg: 1, // top level bottom margin
		tl_rmarg: 0, // right margin
		tl_ofsleft: 1, // offset left
		// context menu
		context: false,
		ctx_zoneid: false,
		ctx_autoshow: true, // default open action
		ctx_autohide: true, // default close action
		ctx_hideall: true, // true will hide all opened contextual menu polygons on mouseout, false - all except topleft
		ctx_zones: {},
		ctx_baseid: null, // add baseId as context zone
		// selected subitems
		selected_sub: [],
		opened_poly: []
	}
	
	if (typeof(base) == "object" && base != null && typeof(base.tagName) == "undefined") {
		
		// object-api init
		if (base.icons_path != null || base.icon_path != null) this.conf.icons_path = (base.icons_path||base.icon_path);
		if (base.skin != null) this.conf.skin = base.skin;
		if (base.visible_area) {
			this.conf.v_enabled = true;
			this.conf.v = {
				x1: base.visible_area.x1,
				x2: base.visible_area.x2,
				y1: base.visible_area.y1,
				y2: base.visible_area.y2
			};
		}
			
		for (var a in {json:1,xml:1,items:1,top_text:1,align:1,open_mode:1,overflow:1,dynamic:1,dynamic_icon:1,context:1,onload:1,onclick:1,oncheckboxclick:1,onradioclick:1,iconset:1}) {
			if (base[a] != null) this.conf.autoload[a] = base[a];
		}
		
		base = base.parent;
	}
	
	if (base == null) {
		this.base = document.body;
	} else {
		var baseObj = (typeof(base)=="string"?document.getElementById(base):base);
		if (baseObj != null) {
			this.base = baseObj;
			if (!this.base.id) this.base.id = "menuBaseId_"+new Date().getTime();
			this.base.className += " dhtmlxMenu_"+this.conf.skin+"_Middle dir_left";
			this.base._autoSkinUpdate = true;
			 // preserv default oncontextmenu for future restorin in case of context menu
			if (this.base.oncontextmenu) this.base._oldContextMenuHandler = this.base.oncontextmenu;
			//
			this.conf.ctx_baseid = this.base.id;
			this.base.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
			this.base.oncontextmenu = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
		} else {
			this.base = document.body;
		}
	}
	
	this.idPrefix = "";
	this.topId = "dhxWebMenuTopId";
	
	this.idPull = {};
	this.itemPull = {};
	this.userData = {};
	this.radio = {};
	//
	this.setSkin = function(skin) {
		var oldSkin = this.conf.skin;
		this.conf.skin = skin;
		switch (this.conf.skin){
			case "dhx_skyblue":
			case "dhx_web":
				this.conf.tl_botmarg = 2;
				this.conf.tl_rmarg = 1;
				this.conf.tl_ofsleft = 1;
				break;
			case "dhx_terrace":
			case "material":
				this.conf.tl_botmarg = 0;
				this.conf.tl_rmarg = 0;
				this.conf.tl_ofsleft = 0;
				break;
		}
		if (this.base._autoSkinUpdate) {
			this.base.className = this.base.className.replace("dhtmlxMenu_"+oldSkin+"_Middle", "")+" dhtmlxMenu_"+this.conf.skin+"_Middle";
		}
		
		for (var a in this.idPull) {
			this.idPull[a].className = String(this.idPull[a].className).replace(oldSkin, this.conf.skin);
			
		}
	}
	this.setSkin(this.conf.skin);
	//
	
	this._addSubItemToSelected = function(item, polygon) {
		var t = true;
		for (var q=0; q<this.conf.selected_sub.length; q++) { if ((this.conf.selected_sub[q][0] == item) && (this.conf.selected_sub[q][1] == polygon)) { t = false; } }
		if (t == true) { this.conf.selected_sub.push(new Array(item, polygon)); }
		return t;
	}
	this._removeSubItemFromSelected = function(item, polygon) {
		var m = new Array();
		var t = false;
		for (var q=0; q<this.conf.selected_sub.length; q++) { if ((this.conf.selected_sub[q][0] == item) && (this.conf.selected_sub[q][1] == polygon)) { t = true; } else { m[m.length] = this.conf.selected_sub[q]; } }
		if (t == true) { this.conf.selected_sub = m; }
		return t;
	}
	this._getSubItemToDeselectByPolygon = function(polygon) {
		var m = new Array();
		for (var q=0; q<this.conf.selected_sub.length; q++) {
			if (this.conf.selected_sub[q][1] == polygon) {
				m[m.length] = this.conf.selected_sub[q][0];
				m = m.concat(this._getSubItemToDeselectByPolygon(this.conf.selected_sub[q][0]));
				var t = true;
				for (var w=0; w<this.conf.opened_poly.length; w++) { if (this.conf.opened_poly[w] == this.conf.selected_sub[q][0]) { t = false; } }
				if (t == true) { this.conf.opened_poly[this.conf.opened_poly.length] = this.conf.selected_sub[q][0]; }
				this.conf.selected_sub[q][0] = -1;
				this.conf.selected_sub[q][1] = -1;
			}
		}
		return m;
	}
	
	this._hidePolygon = function(id) {
		if (this.idPull["polygon_" + id] != null) {
			// clear z-index
			if (this.idPull["polygon_"+id]._zId != null) {
				window.dhx4.zim.clear(this.idPull["polygon_"+id]._zId);
			}
			//
			if (typeof(this._menuEffect) != "undefined" && this._menuEffect !== false) {
				this._hidePolygonEffect("polygon_"+id);
			} else {
				// already hidden
				if (this.idPull["polygon_"+id].style.display == "none") return;
				//
				this.idPull["polygon_"+id].style.display = "none";
				if (this.idPull["arrowup_"+id] != null) this.idPull["arrowup_"+id].style.display = "none";
				if (this.idPull["arrowdown_"+id] != null) this.idPull["arrowdown_"+id].style.display = "none";
				this._updateItemComplexState(id, true, false);
				// hide ie6 cover
				if (window.dhx4.isIE6 && this.idPull["polygon_"+id+"_ie6cover"] != null) this.idPull["polygon_"+id+"_ie6cover"].style.display = "none";
			}
			// call event
			id = String(id).replace(this.idPrefix, "");
			if (id == this.topId) id = null;
			this.callEvent("onHide", [id]);
			
			// corners
			if (id != null && this.conf.skin == "dhx_terrace" && this.itemPull[this.idPrefix+id].parent == this.idPrefix+this.topId) {
				this._improveTerraceButton(this.idPrefix+id, true);
			}
			
		}
	}
	
	this._showPolygon = function(id, openType) {
		
		var itemCount = this._countVisiblePolygonItems(id);
		if (itemCount == 0) return;
		var pId = "polygon_"+id;
		if ((this.idPull[pId] != null) && (this.idPull[id] != null)) {
			
			if (this.conf.top_mode && this.conf.mode == "web" && !this.conf.context) {
				if (!this.idPull[id]._mouseOver && openType == this.conf.dir_toplv) return;
			}
			
			// detect visible area
			if (!this.conf.fixed_pos) this._autoDetectVisibleArea();
			
			// show arrows
			var arrUpH = 0;
			var arrDownH = 0;
			//
			var arrowUp = null;
			var arrowDown = null;
			
			// show polygon
			if (this.idPull[pId]._zId == null) {
				this.idPull[pId]._zId = window.dhx4.newId();
			}
			this.idPull[pId]._zInd = window.dhx4.zim.reserve(this.idPull[pId]._zId);
			
			this.idPull[pId].style.visibility = "hidden";
			this.idPull[pId].style.left = "0px";
			this.idPull[pId].style.top = "0px";
			this.idPull[pId].style.display = "";
			this.idPull[pId].style.zIndex = this.idPull[pId]._zInd;
			
			//
			if (this.conf.auto_overflow) {
				if (this.idPull[pId].childNodes[1].childNodes[0].offsetHeight > this.conf.v.y2-this.conf.v.y1) {
					var t0 = Math.max(Math.floor((this.conf.v.y2-this.conf.v.y1-this.conf.of_ah[this.conf.skin]*2)/this.conf.of_ih[this.conf.skin]),1); // (y2-y1-arrow_height*2)/item_height
					this.conf.overflow_limit = t0;
				} else {
					this.conf.overflow_limit = 0;
					
					if (this.idPull["arrowup_"+id] != null) this._removeUpArrow(String(id).replace(this.idPrefix,""));
					if (this.idPull["arrowdown_"+id] != null) this._removeDownArrow(String(id).replace(this.idPrefix,""));
				}
			}
			
			if (this.conf.overflow_limit > 0 && this.conf.overflow_limit < itemCount)  {
				
				// add overflow arrows if they not exists
				if (this.idPull["arrowup_"+id] == null) this._addUpArrow(String(id).replace(this.idPrefix,""));
				if (this.idPull["arrowdown_"+id] == null) this._addDownArrow(String(id).replace(this.idPrefix,""));
				
				// configure up arrow
				arrowUp = this.idPull["arrowup_"+id];
				arrowUp.style.display = "none";
				//arrUpH = arrowUp.offsetHeight;
				
				// configure bottom arrow
				arrowDown = this.idPull["arrowdown_"+id];
				arrowDown.style.display = "none";
				//arrDownH = arrowDown.offsetHeight;
				
			}
			
			if (this.conf.overflow_limit > 0 && this.conf.overflow_limit < itemCount)  {
				// set fixed size
				this.idPull[pId].childNodes[1].style.height = this.conf.of_ih[this.conf.skin]*this.conf.overflow_limit+"px";
				arrowUp.style.width = arrowDown.style.width = this.idPull[pId].childNodes[1].style.width = this.idPull[pId].childNodes[1].childNodes[0].offsetWidth+"px";
				this.idPull[pId].childNodes[1].scrollTop = 0;
				
				arrowUp.style.display = "";
				arrUpH = arrowUp.offsetHeight;
				
				arrowDown.style.display = "";
				arrDownH = arrowDown.offsetHeight;
					
			} else {
				// remove fixed size
				this.idPull[pId].childNodes[1].style.height = "";
				this.idPull[pId].childNodes[1].style.width = "";
			}
			
			
			if (this.itemPull[id] != null) {
				var parPoly = "polygon_"+this.itemPull[id]["parent"];
			} else if (this.conf.context) {
				var parPoly = this.idPull[this.idPrefix+this.topId];
			}
			
			// define position
			var srcX = (this.idPull[id].tagName != null ? window.dhx4.absLeft(this.idPull[id]) : this.idPull[id][0]);
			var srcY = (this.idPull[id].tagName != null ? window.dhx4.absTop(this.idPull[id]) : this.idPull[id][1]);
			var srcW = (this.idPull[id].tagName != null ? this.idPull[id].offsetWidth : 0);
			var srcH = (this.idPull[id].tagName != null ? this.idPull[id].offsetHeight : 0);
			
			var x = 0;
			var y = 0;
			var w = this.idPull[pId].offsetWidth;
			var h = this.idPull[pId].offsetHeight;
			
			// pos
			if (openType == "bottom") {
				if (this.conf.rtl) {
					x = srcX + (srcW!=null?srcW:0) - w;
				} else {
					if (this.conf.align == "right") {
						x = srcX + srcW - w;
					} else {
						x = srcX - 1 + (openType==this.conf.dir_toplv?this.conf.tl_rmarg:0);
					}
				}
				y = srcY - 1 + srcH + this.conf.tl_botmarg;
			}
			if (openType == "right") { x = srcX + srcW - 1; y = srcY + 2; }
			if (openType == "left") { x = srcX - this.idPull[pId].offsetWidth + 2; y = srcY + 2; }
			if (openType == "top") { x = srcX - 1; y = srcY - h + 2; }
			
			// overflow check
			if (this.conf.fixed_pos) {
				// use fixed document.body/window dimension if required
				var mx = 65536;
				var my = 65536;
			} else {
				var mx = (this.conf.v.x2!=null?this.conf.v.x2:0);
				var my = (this.conf.v.y2!=null?this.conf.v.y2:0);
				
				if (mx == 0) {
					if (window.innerWidth) {
						mx = window.innerWidth;
						my = window.innerHeight;
					} else {
						mx = document.body.offsetWidth;
						my = document.body.scrollHeight;
					}
				}
			}
			if (x+w > mx && !this.conf.rtl) {
				// no space on right, open to left
				x = srcX - w + 2;
			}
			if (x < this.conf.v.x1 && this.conf.rtl) {
				// no space on left, open to right
				x = srcX + srcW - 2;
			}
			if (x < 0) {
				// menu floats left
				x = 0;
			}
			if (y+h > my && this.conf.v.y2 != null) {
				y = Math.max(srcY + srcH - h + 2, (this.conf.v_enabled?this.conf.v.y1+2:2));
				// open from top level
				if (this.conf.context && this.idPrefix+this.topId == id && arrowDown != null) {
					// autoscroll prevent because menu mouse pointer will right over downarrow
					y = y-2;
				}
				if (this.itemPull[id] != null && !this.conf.context) {
					if (this.itemPull[id]["parent"] == this.idPrefix+this.topId) y = y - this.base.offsetHeight;
				}
			}
			//
			this.idPull[pId].style.left = x+"px";
			//this.idPull[pId].style.top = y+arrUpH+"px";
			this.idPull[pId].style.top = y+"px";
			//
			if (typeof(this._menuEffect) != "undefined" && this._menuEffect !== false) {
				this._showPolygonEffect(pId);
			} else {
				this.idPull[pId].style.visibility = "";
				
				if (this.conf.overflow_limit > 0 && this.conf.overflow_limit < itemCount)  {
					this.idPull[pId].childNodes[1].scrollTop = 0;
					this._checkArrowsState(id);
				}
				
				// show ie6 cover
				if (window.dhx4.isIE6) {
					var pIdIE6 = pId+"_ie6cover";
					if (this.idPull[pIdIE6] == null) {
						var ifr = document.createElement("IFRAME");
						ifr.className = "dhtmlxMenu_IE6CoverFix_"+this.conf.skin;
						ifr.frameBorder = 0;
						ifr.setAttribute("src", "javascript:false;");
						document.body.insertBefore(ifr, document.body.firstChild);
						this.idPull[pIdIE6] = ifr;
					}
					this.idPull[pIdIE6].style.left = x+"px";
					this.idPull[pIdIE6].style.top = y+"px";
					this.idPull[pIdIE6].style.width = this.idPull[pId].offsetWidth+"px";
					this.idPull[pIdIE6].style.height = this.idPull[pId].offsetHeight+"px";
					this.idPull[pIdIE6].style.zIndex = this.idPull[pId].style.zIndex-1;
					this.idPull[pIdIE6].style.display = "";
				}
			}
			
			id = String(id).replace(this.idPrefix, "");
			if (id == this.topId) id = null;
			this.callEvent("onShow", [id]);
			
			// corners
			if (id != null && this.conf.skin == "dhx_terrace" && this.itemPull[this.idPrefix+id].parent == this.idPrefix+this.topId) {
				this._improveTerraceButton(this.idPrefix+id, false);
			}
			
		}
	}
	
	this._redistribSubLevelSelection = function(id, parentId) {
		// clear previosly selected items
		while (this.conf.opened_poly.length > 0) this.conf.opened_poly.pop();
		// this.conf.opened_poly = new Array();
		var i = this._getSubItemToDeselectByPolygon(parentId);
		this._removeSubItemFromSelected(-1, -1);
		for (var q=0; q<i.length; q++) { if ((this.idPull[i[q]] != null) && (i[q] != id)) { if (this.itemPull[i[q]]["state"] == "enabled") { this.idPull[i[q]].className = "sub_item"; } } }
		// hide polygons
		for (var q=0; q<this.conf.opened_poly.length; q++) { if (this.conf.opened_poly[q] != parentId) { this._hidePolygon(this.conf.opened_poly[q]); } }
		// add new selection into list new
		if (this.itemPull[id]["state"] == "enabled") {
			this.idPull[id].className = "sub_item_selected";
			if (this.itemPull[id]["complex"] && this.conf.dload && (this.itemPull[id]["loaded"]=="no")) {
				if (this.conf.dload_icon == true) { this._updateLoaderIcon(id, true); }
				this.itemPull[id].loaded = "get";
				var xmlParentId = id.replace(this.idPrefix,"");
				this._dhxdataload.onBeforeXLS = function() {
					var p = {params:{}};
					p.params[this.conf.dload_pid] = xmlParentId;
					for (var a in this.conf.dload_params) p.params[a] = this.conf.dload_params[a];
					return p;
				};
				this.loadStruct(this.conf.dload_url);
			}
			// show
			if (this.itemPull[id]["complex"] || (this.conf.dload && (this.itemPull[id]["loaded"] == "yes"))) {
				// make arrow over
				if ((this.itemPull[id]["complex"]) && (this.idPull["polygon_" + id] != null))  {
					this._updateItemComplexState(id, true, true);
					this._showPolygon(id, this.conf.dir_sublv);
				}
			}
			this._addSubItemToSelected(id, parentId);
			this.conf.selected = id;
		}
	}
	
	this._doOnClick = function(id, type, casState) {
		this.conf.last_click = id;
		// href
		if (this.itemPull[this.idPrefix+id]["href_link"] != null && this.itemPull[this.idPrefix+id].state == "enabled") {
			var form = document.createElement("FORM");
			var k = String(this.itemPull[this.idPrefix+id]["href_link"]).split("?");
			form.action = k[0];
			if (k[1] != null) {
				var p = String(k[1]).split("&");
				for (var q=0; q<p.length; q++) {
					var j = String(p[q]).split("=");
					var m = document.createElement("INPUT");
					m.type = "hidden";
					m.name = (j[0]||"");
					m.value = (j[1]||"");
					form.appendChild(m);
				}
			}
			if (this.itemPull[this.idPrefix+id]["href_target"] != null) { form.target = this.itemPull[this.idPrefix+id]["href_target"]; }
			form.style.display = "none";
			document.body.appendChild(form);
			form.submit();
			if (form != null) {
				document.body.removeChild(form);
				form = null;
			}
			return;
		}
		//
		// some fixes
		if (type.charAt(0)=="c") return; // can't click on complex item
		if (type.charAt(1)=="d") return; // can't click on disabled item
		if (type.charAt(2)=="s") return; // can't click on separator
		//
		if (this.checkEvent("onClick")) {
			this.callEvent("onClick", [id, this.conf.ctx_zoneid, casState]);
		} else {
			if ((type.charAt(1) == "d") || (this.conf.mode == "win" && type.charAt(2) == "t")) return;
		}
		if (this.conf.context && this._isContextMenuVisible() && this.conf.ctx_autohide) {
			this._hideContextMenu();
		} else {
			// if menu unloaded from click event
			if (this._clearAndHide) this._clearAndHide();
		}
	}
	// onTouchMenu action - select topLevel item
	this._doOnTouchMenu = function(id) {
		if (this.conf.is_touched == false) {
			this.conf.is_touched = true;
			if (this.checkEvent("onTouch")) {
				this.callEvent("onTouch", [id]);
			}
		}
	}
	
	// return menu array of all nested objects
	this._searchMenuNode = function(node, menu) {
		var m = new Array();
		for (var q=0; q<menu.length; q++) {
			if (typeof(menu[q]) == "object") {
				if (menu[q].length == 5) { if (typeof(menu[q][0]) != "object") { if ((menu[q][0].replace(this.idPrefix, "") == node) && (q == 0)) { m = menu; } } }
				var j = this._searchMenuNode(node, menu[q]);
				if (j.length > 0) { m = j; }
			}
		}
		return m;
	}
	// return array of subitems for single menu object
	this._getMenuNodes = function(node) {
		var m = new Array;
		for (var a in this.itemPull) { if (this.itemPull[a]["parent"] == node) { m[m.length] = a; } }
		return m;
	}
	// generate random string with specified length
	this._genStr = function(w) {
		var s = "dhxId_";
		var z = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		for (var q=0; q<w; q++) s += z.charAt(Math.round(Math.random() * (z.length-1)));
		return s;
	}
	
	this.getItemType = function(id) {
		id = this.idPrefix+id;
		if (this.itemPull[id] == null) { return null; }
		return this.itemPull[id]["type"];
	}
	
	this.forEachItem = function(handler) {
		for (var a in this.itemPull) { handler(String(a).replace(this.idPrefix, "")); }
	}
	
	// clear selection and hide menu on onbody click event
	this._clearAndHide = function() {
		that.conf.selected = -1;
		that.conf.last_click = -1;
		while (that.conf.opened_poly.length > 0) { that.conf.opened_poly.pop(); }
		for (var q=0; q<that.conf.selected_sub.length; q++) {
			var id = that.conf.selected_sub[q][0];
			// clear all selection
			if (that.idPull[id] != null) {
				if (that.itemPull[id]["state"] == "enabled") {
					if (that.idPull[id].className == "sub_item_selected") that.idPull[id].className = "sub_item";
					if (that.idPull[id].className == "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Selected") {
						// custom css
						if (that.itemPull[id]["cssNormal"] != null) {
							that.idPull[id].className = that.itemPull[id]["cssNormal"];
						} else {
							// default css
							that.idPull[id].className = "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Normal";
						}
					}
				}
			}
			that._hidePolygon(id);
		}
		
		that.conf.is_touched = false;
		
		// hide all contextmenu polygons on mouseout
		if (that.conf.context && that.conf.ctx_hideall) that._hidePolygon(that.idPrefix+that.topId);
		
	}
	
	/* show sublevel item */
	this._showSubLevelItem = function(id,back) {
		if (document.getElementById("arrow_" + this.idPrefix + id) != null) { document.getElementById("arrow_" + this.idPrefix + id).style.display = (back?"none":""); }
		if (document.getElementById("image_" + this.idPrefix + id) != null) { document.getElementById("image_" + this.idPrefix + id).style.display = (back?"none":""); }
		if (document.getElementById(this.idPrefix + id) != null) { document.getElementById(this.idPrefix + id).style.display = (back?"":"none"); }
	}
	/* hide sublevel item */
	this._hideSubLevelItem = function(id) {
		this._showSubLevelItem(id,true)
	}
	// generating id prefix
	this.idPrefix = this._genStr(12)+"_";
	
	/* attach body events */
	this._bodyClick = function(e) {
		e = e||event;
		if (e.button == 2 || (window.dhx4.isOpera && e.ctrlKey == true)) return;
		if (that.conf.context) {
			if (that.conf.ctx_autohide && (!window.dhx4.isOpera || (that._isContextMenuVisible() && window.dhx4.isOpera))) that._hideContextMenu();
		} else {
			if (that._clearAndHide) that._clearAndHide();
		}
	}
	this._bodyContext = function(e) {
		e = e||event;
		var t = String((e.srcElement||e.target).className);
		if (t.search("dhtmlxMenu") != -1 && t.search("SubLevelArea") != -1) return;
		var toHide = true;
		var testZone = e.target || e.srcElement;
		while (testZone != null) {
			if (testZone.id != null) if (that.isContextZone(testZone.id)) toHide = false;
			if (testZone == document.body) toHide = false;
			testZone = testZone.parentNode;
		}
		if (toHide) that.hideContextMenu();
	}
	
	if (typeof(window.addEventListener) != "undefined") {
		window.addEventListener("click", this._bodyClick, false);
		window.addEventListener("contextmenu", this._bodyContext, false);
	} else {
		document.body.attachEvent("onclick", this._bodyClick);
		document.body.attachEvent("oncontextmenu", this._bodyContext);
	}
	dhx4.attachEvent("_onGridClick", this._bodyClick);
	
	this.unload = function() {
		
		window.dhx4._eventable(this, "clear");
		
		// remove menu from global store
		dhtmlXMenuObject.prototype.liveInst[this.conf.live_id] = null;
		try { delete dhtmlXMenuObject.prototype.liveInst[this.conf.live_id]; } catch(e) {}
		this.conf.live_id = null;
		
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("click", this._bodyClick, false);
			window.removeEventListener("contextmenu", this._bodyContext, false);
		} else {
			document.body.detachEvent("onclick", this._bodyClick);
			document.body.detachEvent("oncontextmenu", this._bodyContext);
		}
		this._bodyClick = null;
		this._bodyContext = null;
		
		// will recursively remove all items
		this.removeItem(this.idPrefix+this.topId, true);
		
		this.itemPull = null;
		this.idPull = null;
		
		// clear context zones
		if (this.conf.context) for (var a in this.conf.ctx_zones) this.removeContextZone(a);
		
		if (this.cont != null) {
			this.cont.className = "";
			this.cont.parentNode.removeChild(this.cont);
			this.cont = null;
		}
		
		if (this.base != null) {
			if (!this.conf.context) this.base.className = "";
			if (!this.conf.context) this.base.oncontextmenu = (this.base._oldContextMenuHandler||null);
			this.base.onselectstart = null;
			this.base = null;
		}
		
		for (var a in this) this[a] = null;
		that = null;
		
	}
	
	// register instance
	dhtmlXMenuObject.prototype.liveInst[this.conf.live_id] = this;
	
	window.dhx4._enableDataLoading(this, "_initObj", "_xmlToJson", this.conf.tags.root, {struct:true});
	window.dhx4._eventable(this);
	
	// autoload
	if (window.dhx4.s2b(this.conf.autoload.context) == true) this.renderAsContextMenu();
	
	if (this.conf.autoload.iconset == "awesome") {
		this.conf.icons_css = true;
	}

	if (this.conf.autoload.dynamic != null) {
		this.enableDynamicLoading(this.conf.autoload.dynamic, window.dhx4.s2b(this.conf.autoload.dynamic_icon));
	} else if (this.conf.autoload.items != null) {
		this.loadStruct(this.conf.autoload.items, this.conf.autoload.onload);
	} else if (this.conf.autoload.json != null) {
		this.loadStruct(this.conf.autoload.json, this.conf.autoload.onload);
	} else if (this.conf.autoload.xml != null) {
		this.loadStruct(this.conf.autoload.xml, this.conf.autoload.onload);
	}
	
	for (var a in {onclick:1,oncheckboxclick:1,onradioclick:1}) {
		if (this.conf.autoload[a] != null) {
			if (typeof(this.conf.autoload[a]) == "function") {
				this.attachEvent(a, this.conf.autoload[a]);
			} else if (typeof(window[this.conf.autoload[a]]) == "function") {
				this.attachEvent(a, window[this.conf.autoload[a]]);
			}
		}
	}
	
	if (this.conf.autoload.top_text != null) this.setTopText(this.conf.autoload.top_text);
	if (this.conf.autoload.align != null) this.setAlign(this.conf.autoload.align);
	if (this.conf.autoload.open_mode != null) this.setOpenMode(this.conf.autoload.open_mode);
	if (this.conf.autoload.overflow != null) this.setOverflowHeight(this.conf.autoload.overflow);
	
	//
	for (var a in this.conf.autoload) {
		this.conf.autoload[a] = null;
		delete this.conf.autoload[a];
	}
	this.conf.autoload = null;
	
	//
	return this;
	
};

dhtmlXMenuObject.prototype._init = function() {
	if (this._isInited == true) return;
	if (this.conf.dload) {
		this._dhxdataload.onBeforeXLS = function() {
			var p = {params:{}};
			for (var a in this.conf.dload_params) p.params[a] = this.conf.dload_params[a];
			return p;
		};
		this.loadStruct(this.conf.dload_url);
	} else {
		this._initTopLevelMenu();
		this._isInited = true;
	}
};

dhtmlXMenuObject.prototype._countVisiblePolygonItems = function(id) {
	
	var count = 0;
	
	for (var a in this.itemPull) {
		
		var par = this.itemPull[a]["parent"];
		var tp = this.itemPull[a]["type"];
		if (this.idPull[a] != null) {
			if (par == id && (tp == "item" || tp == "radio" || tp == "checkbox") && this.idPull[a].style.display != "none") {
				count++;
			}
		}
	}
	return count;
};

dhtmlXMenuObject.prototype._redefineComplexState = function(id) {
	// alert(id)
	if (this.idPrefix+this.topId == id) { return; }
	if ((this.idPull["polygon_"+id] != null) && (this.idPull[id] != null)) {
		var u = this._countVisiblePolygonItems(id);
		if ((u > 0) && (!this.itemPull[id]["complex"])) { this._updateItemComplexState(id, true, false); }
		if ((u == 0) && (this.itemPull[id]["complex"])) { this._updateItemComplexState(id, false, false); }
	}
};

dhtmlXMenuObject.prototype._updateItemComplexState = function(id, state, over) {
	// 0.2 FIX :: topLevel's items can have complex items with arrow
	if ((!this.conf.context) && (this._getItemLevelType(id.replace(this.idPrefix,"")) == "TopLevel")) {
		// 30.06.2008 fix > complex state for top level item, state only, no arrow
		this.itemPull[id]["complex"] = state;
		return;
	}
	if ((this.idPull[id] == null) || (this.itemPull[id] == null)) { return; }
	// 0.2 FIX :: end
	this.itemPull[id]["complex"] = state;
	// fixed in 0.4 for context
	if (id == this.idPrefix+this.topId) return;
	// end fix
	// try to retrieve arrow img object
	var arrowObj = null;
	
	
	var item = this.idPull[id].childNodes[this.conf.rtl?0:2];
	if (item.childNodes[0]) if (String(item.childNodes[0].className).search("complex_arrow") === 0) arrowObj = item.childNodes[0];
	
	if (this.itemPull[id]["complex"]) {
		// create arrow
		if (arrowObj == null) {
			arrowObj = document.createElement("DIV");
			arrowObj.className = "complex_arrow";
			arrowObj.id = "arrow_"+id;
			while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
			item.appendChild(arrowObj);
		}
		// over state added in 0.4
		
		if (this.conf.dload && (this.itemPull[id].loaded == "get") && this.conf.dload_icon) {
			// change arrow to loader
			if (arrowObj.className != "complex_arrow_loading") arrowObj.className = "complex_arrow_loading";
		} else {
			arrowObj.className = "complex_arrow";
		}
		
		return;
	}
	
	if ((!this.itemPull[id]["complex"]) && (arrowObj!=null)) {
		item.removeChild(arrowObj);
		if (this.itemPull[id]["hotkey_backup"] != null && this.setHotKey) { this.setHotKey(id.replace(this.idPrefix, ""), this.itemPull[id]["hotkey_backup"]); }
	}
	
};

dhtmlXMenuObject.prototype._getItemLevelType = function(id) {
	return (this.itemPull[this.idPrefix+id]["parent"]==this.idPrefix+this.topId?"TopLevel":"SubLevelArea");
};

dhtmlXMenuObject.prototype.setIconsPath = function(path) {
	this.conf.icons_path = path;
};

/* real-time update icon in menu */
dhtmlXMenuObject.prototype._updateItemImage = function(id, levelType) {
	// search existsing image
	id = this.idPrefix+id;
	
	var tp = this.itemPull[id]["type"];
	if (tp == "checkbox" || tp == "radio") return;
	
	var isTopLevel = (this.itemPull[id]["parent"] == this.idPrefix+this.topId && !this.conf.context);
	
	// search existing image
	var imgObj = null;
	if (isTopLevel) {
		for (var q=0; q<this.idPull[id].childNodes.length; q++) {
			if (imgObj == null && (this.idPull[id].childNodes[q].className || "") == "dhtmlxMenu_TopLevel_Item_Icon" || (this.idPull[id].childNodes[q].tagName||"").toLowerCase() == "i") {
				imgObj = this.idPull[id].childNodes[q];
			}
		}
	} else {
		try { var imgObj = this.idPull[id].childNodes[this.conf.rtl?2:0].childNodes[0]; } catch(e) { }
		if (!(imgObj != null && typeof(imgObj.className) != "undefined" && (imgObj.className == "sub_icon" || imgObj.tagName.toLowerCase() == "i"))) imgObj = null;
	}
	
	var imgSrc = this.itemPull[id][(this.itemPull[id]["state"]=="enabled"?"imgen":"imgdis")];
	
	if (imgSrc.length > 0) {
		if (imgObj != null) {
			if (this.conf.icons_css == true) {
				imgObj.className = this.conf.icons_path+imgSrc;
			} else {
				imgObj.src = this.conf.icons_path+imgSrc;
			}
		} else {
			if (isTopLevel) {
				if (this.conf.icons_css == true) {
					var imgObj = document.createElement("i");
					imgObj.className = this.conf.icons_path+imgSrc;
				} else {
					var imgObj = document.createElement("IMG");
					imgObj.className = "dhtmlxMenu_TopLevel_Item_Icon";
					imgObj.src = this.conf.icons_path+imgSrc;
					imgObj.border = "0";
					imgObj.id = "image_"+id;
				}
				if (!this.conf.rtl && this.idPull[id].childNodes.length > 0) this.idPull[id].insertBefore(imgObj,this.idPull[id].childNodes[0]); else this.idPull[id].appendChild(imgObj);				
			} else {
				if (this.conf.icons_css == true) {
					var item = this.idPull[id].childNodes[this.conf.rtl?2:0];
					item.innerHTML = "<i class='"+this.conf.icons_path+imgSrc+"'></i>";
				} else {
					var imgObj = document.createElement("IMG");
					imgObj.className = "sub_icon";
					imgObj.src = this.conf.icons_path+imgSrc;
					imgObj.border = "0";
					imgObj.id = "image_"+id;
					var item = this.idPull[id].childNodes[this.conf.rtl?2:0];
					while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
					item.appendChild(imgObj);
				}
			}
		}
	} else {
		if (imgObj != null) {
			if (isTopLevel) {
				imgObj.parentNode.removeChild(imgObj);
				imgObj = null;
			} else {
				var p = imgObj.parentNode;
				p.removeChild(imgObj);
				p.innerHTML = "&nbsp;";
				p = imgObj = null;
			}
		}
	}
};

// collect parents for remove complex item
dhtmlXMenuObject.prototype._getAllParents = function(id) {
	var parents = new Array();
	for (var a in this.itemPull) {
		if (this.itemPull[a]["parent"] == id) {
			parents[parents.length] = this.itemPull[a]["id"];
			if (this.itemPull[a]["complex"]) {
				var t = this._getAllParents(this.itemPull[a]["id"]);
				for (var q=0; q<t.length; q++) { parents[parents.length] = t[q]; }
			}
		}
	}
	return parents;
};

// visible area
dhtmlXMenuObject.prototype._autoDetectVisibleArea = function() {
	if (this.conf.v_enabled) return;
	var d = window.dhx4.screenDim();
	this.conf.v.x1 = d.left;
	this.conf.v.x2 = d.right;
	this.conf.v.y1 = d.top;
	this.conf.v.y2 = d.bottom;
};

dhtmlXMenuObject.prototype.getItemPosition = function(id) {
	id = this.idPrefix+id;
	var pos = -1;
	if (this.itemPull[id] == null) return pos;
	var parent = this.itemPull[id]["parent"];
	// var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.base);
	var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.cont);
	for (var q=0; q<obj.childNodes.length; q++) { if (obj.childNodes[q]==this.idPull["separator_"+id]||obj.childNodes[q]==this.idPull[id]) { pos = q; } }
	return pos;
};

dhtmlXMenuObject.prototype.setItemPosition = function(id, pos) {
	id = this.idPrefix+id;
	if (this.idPull[id] == null) { return; }
	// added in 0.4
	var isOnTopLevel = (this.itemPull[id]["parent"] == this.idPrefix+this.topId);
	//
	var itemData = this.idPull[id];
	var itemPos = this.getItemPosition(id.replace(this.idPrefix,""));
	var parent = this.itemPull[id]["parent"];
	// var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.base);
	var obj = (this.idPull["polygon_"+parent]!=null?this.idPull["polygon_"+parent].tbd:this.cont);
	obj.removeChild(obj.childNodes[itemPos]);
	if (pos < 0) pos = 0;
	// added in 0.4
	if (isOnTopLevel && pos < 1) { pos = 1; }
	//
	if (pos < obj.childNodes.length) { obj.insertBefore(itemData, obj.childNodes[pos]); } else { obj.appendChild(itemData); }
};

dhtmlXMenuObject.prototype.getParentId = function(id) {
	id = this.idPrefix+id;
	if (this.itemPull[id] == null) { return null; }
	return ((this.itemPull[id]["parent"]!=null?this.itemPull[id]["parent"]:this.topId).replace(this.idPrefix,""));
};


// hide any opened polygons
dhtmlXMenuObject.prototype.hide = function() {
	this._clearAndHide();
};
dhtmlXMenuObject.prototype.clearAll = function() {
	this.removeItem(this.idPrefix+this.topId, true);
	this._isInited = false;
	this.idPrefix = this._genStr(12)+"_";
	this.itemPull = {};
};

// dhtmlxmenu global store
if (typeof(dhtmlXMenuObject.prototype.liveInst) == "undefined") {
	dhtmlXMenuObject.prototype.liveInst = {};
};

dhtmlXMenuObject.prototype.setIconset = function(name) {
	this.conf.icons_css = (name == "awesome");
};
// redistrib selection in case of top node in real-time mode
dhtmlXMenuObject.prototype._redistribTopLevelSelection = function(id, parent) {
	// kick polygons and decelect before selected menues
	var i = this._getSubItemToDeselectByPolygon("parent");
	this._removeSubItemFromSelected(-1, -1);
	for (var q=0; q<i.length; q++) {
		if (i[q] != id) { this._hidePolygon(i[q]); }
		if ((this.idPull[i[q]] != null) && (i[q] != id)) { this.idPull[i[q]].className = this.idPull[i[q]].className.replace(/Selected/g, "Normal"); }
	}
	// check if enabled
	if (this.itemPull[this.idPrefix+id]["state"] == "enabled") {
		this.idPull[this.idPrefix+id].className = "dhtmlxMenu_"+this.conf.skin+"_TopLevel_Item_Selected";
		//
		this._addSubItemToSelected(this.idPrefix+id, "parent");
		this.conf.selected = (this.conf.mode=="win"?(this.conf.selected!=-1?id:this.conf.selected):id);
		if ((this.itemPull[this.idPrefix+id]["complex"]) && (this.conf.selected != -1)) { this._showPolygon(this.idPrefix+id, this.conf.dir_toplv); }
	}
};

dhtmlXMenuObject.prototype._initTopLevelMenu = function() {
	
	this.conf.dir_toplv = "bottom";
	this.conf.dir_sublv = (this.conf.rtl?"left":"right");
	if (this.conf.context) {
		this.idPull[this.idPrefix+this.topId] = new Array(0,0);
		this._addSubMenuPolygon(this.idPrefix+this.topId, this.idPrefix+this.topId);
	} else {
		var m = this._getMenuNodes(this.idPrefix + this.topId);
		for (var q=0; q<m.length; q++) {
			if (this.itemPull[m[q]]["type"] == "item") this._renderToplevelItem(m[q], null);
			if (this.itemPull[m[q]]["type"] == "separator") this._renderSeparator(m[q], null);
		}
	}
};

// add top menu item, complex define that submenues are in presence
dhtmlXMenuObject.prototype._renderToplevelItem = function(id, pos) {
	var that = this;
	var m = document.createElement("DIV");
	m.id = id;
	// custom css
	if (this.itemPull[id]["state"] == "enabled" && this.itemPull[id]["cssNormal"] != null) {
		m.className = this.itemPull[id]["cssNormal"];
	} else {
		m.className = "dhtmlxMenu_"+this.conf.skin+"_TopLevel_Item_"+(this.itemPull[id]["state"]=="enabled"?"Normal":"Disabled");
	}
	
	// text
	if (this.itemPull[id]["title"] != "") {
		var t1 = document.createElement("DIV");
		t1.className = "top_level_text";
		t1.innerHTML = this.itemPull[id]["title"];
		m.appendChild(t1);
	}
	// tooltip
	if (this.itemPull[id]["tip"].length > 0) m.title = this.itemPull[id]["tip"];
	//
	// image in top level
	if ((this.itemPull[id]["imgen"]!="")||(this.itemPull[id]["imgdis"]!="")) {
		var imgTop=this.itemPull[id][(this.itemPull[id]["state"]=="enabled")?"imgen":"imgdis"];
		if (imgTop) {
			if (this.conf.icons_css == true) {
				var i = document.createElement("i");
				i.className = this.conf.icons_path+imgTop;
				if (m.childNodes.length > 0 && !this.conf.rtl) m.insertBefore(i, m.childNodes[0]); else m.appendChild(i);
			} else {
				var img = document.createElement("IMG");
				img.border = "0";
				img.id = "image_"+id;
				img.src = this.conf.icons_path+imgTop;
				img.className = "dhtmlxMenu_TopLevel_Item_Icon";
				if (m.childNodes.length > 0 && !this.conf.rtl) m.insertBefore(img, m.childNodes[0]); else m.appendChild(img);
			}
		}
	}
	m.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	m.oncontextmenu = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	// add container for top-level items if not exists yet
	if (!this.cont) {
		this.cont = document.createElement("DIV");
		this.cont.dir = "ltr";
		this.cont.className = (this.conf.align=="right"?"align_right":"align_left");
		this.base.appendChild(this.cont);
	}
	// insert
	
	if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > this.cont.childNodes.length - 1) pos = null; }
	if (pos != null) this.cont.insertBefore(m, this.cont.childNodes[pos]); else this.cont.appendChild(m);
	
	this.idPull[m.id] = m;
	// create submenues
	if (this.itemPull[id]["complex"] && (!this.conf.dload)) this._addSubMenuPolygon(this.itemPull[id]["id"], this.itemPull[id]["id"]);
	// events
	m.onmouseover = function() {
		if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
		// kick polygons and decelect before selected menues
		var i = that._getSubItemToDeselectByPolygon("parent");
		that._removeSubItemFromSelected(-1, -1);
		for (var q=0; q<i.length; q++) {
			if (i[q] != this.id) { that._hidePolygon(i[q]); }
			if ((that.idPull[i[q]] != null) && (i[q] != this.id)) {
				// custom css
				if (that.itemPull[i[q]]["cssNormal"] != null) {
					that.idPull[i[q]].className = that.itemPull[i[q]]["cssNormal"];
				} else {
					if (that.idPull[i[q]].className == "sub_item_selected") that.idPull[i[q]].className = "sub_item";
					that.idPull[i[q]].className = that.idPull[i[q]].className.replace(/Selected/g, "Normal");
				}
			}
		}
		// check if enabled
		if (that.itemPull[this.id]["state"] == "enabled") {
			this.className = "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Selected";
			//
			that._addSubItemToSelected(this.id, "parent");
			that.conf.selected = (that.conf.mode=="win"?(that.conf.selected!=-1?this.id:that.conf.selected):this.id);
			if (that.conf.dload) {
				if (that.itemPull[this.id].loaded == "no") {
					this._dynLoadTM = new Date().getTime();
					that.itemPull[this.id].loaded = "get";
					var xmlParentId = this.id.replace(that.idPrefix,"");
					that._dhxdataload.onBeforeXLS = function() {
						var p = {params:{}};
						p.params[this.conf.dload_pid] = xmlParentId;
						for (var a in this.conf.dload_params) p.params[a] = this.conf.dload_params[a];
						return p;
					};
					that.loadStruct(that.conf.dload_url);
				}
				if (that.conf.top_mode && that.conf.mode == "web" && !that.conf.context) {
					this._mouseOver = true;
				}
			}
			if ((!that.conf.dload) || (that.conf.dload && (!that.itemPull[this.id]["loaded"] || that.itemPull[this.id]["loaded"]=="yes"))) {
				if ((that.itemPull[this.id]["complex"]) && (that.conf.selected != -1)) {
					if (that.conf.top_mode && that.conf.mode == "web" && !that.conf.context) {
						this._mouseOver = true;
						var showItemId = this.id;
						this._menuOpenTM = window.setTimeout(function(){that._showPolygon(showItemId, that.conf.dir_toplv);}, that.conf.top_tmtime);
					} else {
						that._showPolygon(this.id, that.conf.dir_toplv);
					}
				}
			}
		}
		that._doOnTouchMenu(this.id.replace(that.idPrefix, ""));
	}
	m.onmouseout = function() {
		if (!((that.itemPull[this.id]["complex"]) && (that.conf.selected != -1)) && (that.itemPull[this.id]["state"]=="enabled")) {
			// custom css
			
			if (that.itemPull[this.id]["cssNormal"] != null) {
				// alert(1)
				m.className = that.itemPull[this.id]["cssNormal"];
			} else {
				// default css
				m.className = "dhtmlxMenu_"+that.conf.skin+"_TopLevel_Item_Normal";
			}
		}
		if (that.conf.mode == "web") {
			window.clearTimeout(that.conf.tm_handler);
			that.conf.tm_handler = window.setTimeout(function(){that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
		}
		if (that.conf.top_mode && that.conf.mode == "web" && !that.conf.context) {
			this._mouseOver = false;
			window.clearTimeout(this._menuOpenTM);
		}
	}
	m.onclick = function(e) {
		if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
		// fix, added in 0.4
		if (that.conf.mode != "web" && that.itemPull[this.id]["state"] == "disabled") { return; }
		//
		e = e || event;
		e.cancelBubble = true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		
		if (that.conf.mode == "win") {
			if (that.itemPull[this.id]["complex"]) {
				if (that.conf.selected == this.id) { that.conf.selected = -1; var s = false; } else { that.conf.selected = this.id; var s = true; }
				if (s) { that._showPolygon(this.id, that.conf.dir_toplv); } else { that._hidePolygon(this.id); }
			}
		}
		var tc = (that.itemPull[this.id]["complex"]?"c":"-");
		var td = (that.itemPull[this.id]["state"]!="enabled"?"d":"-");
		var cas = {"ctrl": e.ctrlKey, "alt": e.altKey, "shift": e.shiftKey};
		that._doOnClick(this.id.replace(that.idPrefix, ""), tc+td+"t", cas);
		return false;
	}
	
	if (this.conf.skin == "dhx_terrace") {
		this._improveTerraceSkin();
	}
};

// recursively creates and adds submenu polygon
dhtmlXMenuObject.prototype._addSubMenuPolygon = function(id, parentId) {
	var s = this._renderSublevelPolygon(id, parentId);
	var j = this._getMenuNodes(parentId);
	for (q=0; q<j.length; q++) { if (this.itemPull[j[q]]["type"] == "separator") { this._renderSeparator(j[q], null); } else { this._renderSublevelItem(j[q], null); } }
	if (id == parentId) { var level = "topLevel"; } else { var level = "subLevel"; }
	for (var q=0; q<j.length; q++) { if (this.itemPull[j[q]]["complex"]) { this._addSubMenuPolygon(id, this.itemPull[j[q]]["id"]); } }
};

// inner: add single subpolygon/item/separator
dhtmlXMenuObject.prototype._renderSublevelPolygon = function(id, parentId) {
	var s = document.createElement("DIV");
	s.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_Polygon "+(this.conf.rtl?"dir_right":"");
	s.dir = "ltr";
	s.oncontextmenu = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; e.cancelBubble = true; return false; }
	s.id = "polygon_" + parentId;
	s.onclick = function(e) { e = e || event; e.cancelBubble = true; }
	s.style.display = "none";
	document.body.insertBefore(s, document.body.firstChild);
	//
	
	s.innerHTML = '<div style="position:relative;"></div>'+'<div style="position: relative; overflow:hidden;"></div>'+'<div style="position:relative;"></div>';
	
	var tbl = document.createElement("TABLE");
	tbl.className = "dhtmlxMebu_SubLevelArea_Tbl";
	tbl.cellSpacing = 0;
	tbl.cellPadding = 0;
	tbl.border = 0;
	var tbd = document.createElement("TBODY");
	tbl.appendChild(tbd);
	
	s.childNodes[1].appendChild(tbl);
	
	s.tbl = tbl;
	s.tbd = tbd;
	// polygon
	this.idPull[s.id] = s;
	if (this.sxDacProc != null) {
		this.idPull["sxDac_" + parentId] = new this.sxDacProc(s, s.className);
		if (window.dhx4.isIE) {
			this.idPull["sxDac_" + parentId]._setSpeed(this.dacSpeedIE);
			this.idPull["sxDac_" + parentId]._setCustomCycle(this.dacCyclesIE);
		} else {
			this.idPull["sxDac_" + parentId]._setSpeed(this.dacSpeed);
			this.idPull["sxDac_" + parentId]._setCustomCycle(this.dacCycles);
		}
	}
	return s;
};

dhtmlXMenuObject.prototype._renderSublevelItem = function(id, pos) {
	var that = this;
	
	var tr = document.createElement("TR");
	tr.className = (this.itemPull[id]["state"]=="enabled"?"sub_item":"sub_item_dis");
	
	// icon
	var t1 = document.createElement("TD");
	t1.className = "sub_item_icon";
	var tp = this.itemPull[id]["type"];
	var icon = this.itemPull[id][(this.itemPull[id]["state"]=="enabled"?"imgen":"imgdis")];
	if (icon != "") {
		if (tp=="checkbox"||tp=="radio") {
			var img = document.createElement("DIV");
			img.id = "image_"+this.itemPull[id]["id"];
			img.className = "sub_icon "+icon;
			t1.appendChild(img);
		}
		if (!(tp=="checkbox"||tp=="radio")) {
			if (this.conf.icons_css == true) {
				t1.innerHTML = "<i class='"+this.conf.icons_path+icon+"'></i>";
			} else {
				var img = document.createElement("IMG");
				img.id = "image_"+this.itemPull[id]["id"];
				img.className = "sub_icon";
				img.src = this.conf.icons_path+icon;
				t1.appendChild(img);
			}
		}
	} else {
		t1.innerHTML = "&nbsp;";
	}
	
	// text
	var t2 = document.createElement("TD");
	t2.className = "sub_item_text";
	if (this.itemPull[id]["title"] != "") {
		var t2t = document.createElement("DIV");
		t2t.className = "sub_item_text";
		t2t.innerHTML = this.itemPull[id]["title"];
		t2.appendChild(t2t);
	} else {
		t2.innerHTML = "&nbsp;";
	}
	
	// hotkey/sublevel arrow
	var t3 = document.createElement("TD");
	t3.className = "sub_item_hk";
	if (this.itemPull[id]["complex"]) {
		
		var arw = document.createElement("DIV");
		arw.className = "complex_arrow";
		arw.id = "arrow_"+this.itemPull[id]["id"];
		t3.appendChild(arw);
		
	} else {
		if (this.itemPull[id]["hotkey"].length > 0 && !this.itemPull[id]["complex"]) {
			var t3t = document.createElement("DIV");
			t3t.className = "sub_item_hk";
			t3t.innerHTML = this.itemPull[id]["hotkey"];
			t3.appendChild(t3t);
		} else {
			t3.innerHTML = "&nbsp;";
		}
	}
	tr.appendChild(this.conf.rtl?t3:t1);
	tr.appendChild(t2);
	tr.appendChild(this.conf.rtl?t1:t3);
	
	
	//
	tr.id = this.itemPull[id]["id"];
	tr.parent = this.itemPull[id]["parent"];
	// tooltip, added in 0.4
	if (this.itemPull[id]["tip"].length > 0) tr.title = this.itemPull[id]["tip"];
	//
	tr.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	tr.onmouseover = function(e) {
		if (that.conf.hide_tm[this.id]) window.clearTimeout(that.conf.hide_tm[this.id]);
		if (that.conf.mode == "web") window.clearTimeout(that.conf.tm_handler);
		if (!this._visible) that._redistribSubLevelSelection(this.id, this.parent); // if not visible
		this._visible = true;
	}
	tr.onmouseout = function() {
		if (that.conf.mode == "web") {
			if (that.conf.tm_handler) window.clearTimeout(that.conf.tm_handler);
			that.conf.tm_handler = window.setTimeout(function(){if(that&&that._clearAndHide)that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
		}
		var k = this;
		if (that.conf.hide_tm[this.id]) window.clearTimeout(that.conf.hide_tm[this.id]);
		that.conf.hide_tm[this.id] = window.setTimeout(function(){k._visible=false;}, 50);
	}
	tr.onclick = function(e) {
		// added in 0.4, preven complex closing if user event not defined
		if (!that.checkEvent("onClick") && that.itemPull[this.id]["complex"]) return;
		//
		e = e || event; e.cancelBubble = true;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		tc = (that.itemPull[this.id]["complex"]?"c":"-");
		td = (that.itemPull[this.id]["state"]=="enabled"?"-":"d");
		var cas = {"ctrl": e.ctrlKey, "alt": e.altKey, "shift": e.shiftKey};
		switch (that.itemPull[this.id]["type"]) {
			case "checkbox":
				that._checkboxOnClickHandler(this.id.replace(that.idPrefix, ""), tc+td+"n", cas);
				break;
			case "radio":
				that._radioOnClickHandler(this.id.replace(that.idPrefix, ""), tc+td+"n", cas);
				break;
			case "item":
				that._doOnClick(this.id.replace(that.idPrefix, ""), tc+td+"n", cas);
				break;
		}
		return false;
	}
	// add
	var polygon = this.idPull["polygon_"+this.itemPull[id]["parent"]];
	if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > polygon.tbd.childNodes.length - 1) pos = null; }
	if (pos != null && polygon.tbd.childNodes[pos] != null) polygon.tbd.insertBefore(tr, polygon.tbd.childNodes[pos]); else polygon.tbd.appendChild(tr);
	this.idPull[tr.id] = tr;
};

dhtmlXMenuObject.prototype._renderSeparator = function(id, pos) {
	var level = (this.conf.context?"SubLevelArea":(this.itemPull[id]["parent"]==this.idPrefix+this.topId?"TopLevel":"SubLevelArea"));
	if (level == "TopLevel" && this.conf.context) return;
	
	var that = this;
	
	if (level != "TopLevel") {
		var tr = document.createElement("TR");
		tr.className = "sub_sep";
		var td = document.createElement("TD");
		td.colSpan = "3";
		tr.appendChild(td);
	}
	
	var k = document.createElement("DIV");
	k.id = "separator_"+id;
	k.className = (level=="TopLevel"?"top_sep":"sub_sep");
	k.onselectstart = function(e) { e = e || event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; }
	k.onclick = function(e) {
		e = e || event; e.cancelBubble = true;
		var cas = {"ctrl": e.ctrlKey, "alt": e.altKey, "shift": e.shiftKey};
		that._doOnClick(this.id.replace("separator_" + that.idPrefix, ""), "--s", cas);
	}
	if (level == "TopLevel") {
		if (pos != null) {
			pos++; if (pos < 0) { pos = 0; }
			// if (this.base.childNodes[pos] != null) { this.base.insertBefore(k, this.base.childNodes[pos]); } else { this.base.appendChild(k); }
			if (this.cont.childNodes[pos] != null) { this.cont.insertBefore(k, this.cont.childNodes[pos]); } else { this.cont.appendChild(k); }
		} else {
			// add as a last item
			// var last = this.base.childNodes[this.base.childNodes.length-1];
			var last = this.cont.childNodes[this.cont.childNodes.length-1];
			// if (String(last).search("TopLevel_Text") == -1) { this.base.appendChild(k); } else { this.base.insertBefore(k, last); }
			if (String(last).search("TopLevel_Text") == -1) { this.cont.appendChild(k); } else { this.cont.insertBefore(k, last); }
		}
		this.idPull[k.id] = k;
	} else {
		var polygon = this.idPull["polygon_"+this.itemPull[id]["parent"]];
		if (pos != null) { pos++; if (pos < 0) pos = 0; if (pos > polygon.tbd.childNodes.length - 1) pos = null; }
		if (pos != null && polygon.tbd.childNodes[pos] != null) polygon.tbd.insertBefore(tr, polygon.tbd.childNodes[pos]); else polygon.tbd.appendChild(tr);
		td.appendChild(k);
		this.idPull[k.id] = tr;
	}
};

dhtmlXMenuObject.prototype.addNewSeparator = function(nextToId, itemId) {
	itemId = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	var parentId = this.idPrefix+this.getParentId(nextToId);
	
	this._addItemIntoGlobalStrorage(itemId, parentId, "", "separator", false, "", "");
	this._renderSeparator(itemId, this.getItemPosition(nextToId));
};


dhtmlXMenuObject.prototype._initObj = function(items, nested, parentId) {
	
	if (!(items instanceof Array)) {
		parentId = items.parentId;
		if (parentId != null && String(parentId).indexOf(this.idPrefix) !== 0) parentId = this.idPrefix+String(parentId);
		items = items.items;
	}
	
	for (var q=0; q<items.length; q++) {
		
		// api-init, items w/o id
		if (typeof(items[q].id) == "undefined" || items[q].id == null) {
			items[q].id = this._genStr(24);
		}
		
		// empty text fix
		if (items[q].text == null) items[q].text = "";
		
		// api-init, add idPrefix
		if (String(items[q].id).indexOf(this.idPrefix) !== 0) {
			items[q].id = this.idPrefix+String(items[q].id);
		}
		
		var k = {type: "item", tip: "", hotkey: "", state: "enabled", imgen: "", imgdis: ""};
		for (var a in k) { if (typeof(items[q][a]) == "undefined") items[q][a] = k[a]; }
		
		//
		if (items[q].imgen == "" && items[q].img != null) items[q].imgen = items[q].img;
		if (items[q].imgdis == "" && items[q].img_disabled != null) items[q].imgdis = items[q].img_disabled;
		if (items[q].title == null && items[q].text != null) items[q].title = items[q].text;
		
		// hrefs
		if (items[q].href != null) {
			if (items[q].href.link != null) items[q].href_link = items[q].href.link;
			if (items[q].href.target != null) items[q].href_target = items[q].href.target;
		}
		
		// userdata
		if (items[q].userdata != null) {
			for (var a in items[q].userdata) this.userData[items[q].id+"_"+a] = items[q].userdata[a];
		}

		
		// en/dis
		if (typeof(items[q].enabled) != "undefined" && window.dhx4.s2b(items[q].enabled) == false) {
			items[q].state = "disabled";
		} else if (typeof(items[q].disabled) != "undefined" && window.dhx4.s2b(items[q].disabled) == true) {
			items[q].state = "disabled";
		}
		
		//
		if (typeof(items[q].parent) == "undefined") {
			items[q].parent = (parentId != null ? parentId : this.idPrefix+this.topId);
		}
		
		
		// checkbox
		if (items[q].type == "checkbox") {
			items[q].checked = window.dhx4.s2b(items[q].checked);
			items[q].imgen = items[q].imgdis = "chbx_"+(items[q].checked?"1":"0"); // set classname
		}
		// radio
		if (items[q].type == "radio") {
			items[q].checked = window.dhx4.s2b(items[q].checked);
			items[q].imgen = items[q].imgdis = "rdbt_"+(items[q].checked?"1":"0");
			// group
			if (typeof(items[q].group) == "undefined" || items[q].group == null) items[q].group = this._genStr(24);
			if (this.radio[items[q].group] == null) this.radio[items[q].group] = [];
			this.radio[items[q].group].push(items[q].id);
		}
		
		//
		this.itemPull[items[q].id] = items[q];
		if (items[q].items != null && items[q].items.length > 0) {
			this.itemPull[items[q].id].complex = true;
			this._initObj(items[q].items, true, items[q].id);
		} else if (this.conf.dload && items[q].complex == true) {
			this.itemPull[items[q].id].loaded = "no";
		}
		this.itemPull[items[q].id].items = null;
		
	}
	
	if (nested !== true) {
		if (this.conf.dload == true) {
			if (parentId == null) {
				this._initTopLevelMenu();
			} else {
				this._addSubMenuPolygon(parentId, parentId);
				if (this.conf.selected == parentId) {
					var isTop = (this.itemPull[parentId].parent == this.idPrefix+this.topId);
					var level = (isTop && !this.conf.context ? this.conf.dir_toplv:this.conf.dir_sublv);
					var isShow = false;
					if (isTop && this.conf.top_mode && this.conf.mode == "web" && !this.conf.context) {
						var item = this.idPull[parentId];
						if (item._mouseOver == true) {
							var delay = this.conf.top_tmtime - (new Date().getTime()-item._dynLoadTM);
							if (delay > 1) {
								var pId = parentId;
								var that = this;
								item._menuOpenTM = window.setTimeout(function(){
									that._showPolygon(pId, level);
									that = pId = null;
								}, delay);
								isShow = true;
							}
						}
					}
					if (!isShow) this._showPolygon(parentId, level);
				}
				
				this.itemPull[parentId].loaded = "yes";
				if (this.conf.dload_icon == true) this._updateLoaderIcon(parentId, false);
			}
		} else {
			this._init();
		}
	}
	
};

dhtmlXMenuObject.prototype._xmlToJson = function(xml, parentId) {
	
	var items = [];
	
	if (parentId == null) {
		var root = xml.getElementsByTagName(this.conf.tags.root);
		if (root == null || (root != null && root.length == 0)) return {items:[]};
		root = root[0];
	} else {
		root = xml;
	}
	
	if (root.getAttribute("parentId") != null) {
		parentId = this.idPrefix+root.getAttribute("parentId");
	}
	
	for (var q=0; q<root.childNodes.length; q++) {
		if (typeof(root.childNodes[q].tagName) != "undefined" && String(root.childNodes[q].tagName).toLowerCase() == this.conf.tags.item) {
			var r = root.childNodes[q];
			var item = {
				// basic
				id: this.idPrefix+(r.getAttribute("id")||this._genStr(24)),
				title: r.getAttribute("text")||"",
				// images
				imgen: r.getAttribute("img")||"",
				imgdis: r.getAttribute("imgdis")||"",
				tip: "",
				hotkey: "",
				//
				type: r.getAttribute("type")||"item"
			};
			// custom css
			if (r.getAttribute("cssNormal") != null) {
				item.cssNormal = r.getAttribute("cssNormal");
			}
			// checkbox
			if (item.type == "checkbox") item.checked = r.getAttribute("checked");
			// radio
			if (item.type == "radio") {
				item.checked = r.getAttribute("checked");
				item.group = r.getAttribute("group");
			}
			// en/dis
			item.state = "enabled";
			if (r.getAttribute("enabled") != null && window.dhx4.s2b(r.getAttribute("enabled")) == false) {
				item.state = "disabled";
			} else if (r.getAttribute("disabled") != null && window.dhx4.s2b(r.getAttribute("disabled")) == true) {
				item.state = "disabled";
			}
			
			item.parent = (parentId != null ? parentId : this.idPrefix+this.topId);
			// is complex item
			if (this.conf.dload) {
				item.complex = (r.getAttribute("complex") != null);
				if (item.complex) item.loaded = "no";
			} else {
				var i = this._xmlToJson(r, item.id);
				item.items = i.items;
				item.complex = (item.items.length > 0);
			}
			
			// misc
			for (var w=0; w<r.childNodes.length; w++) {
				if (typeof(r.childNodes[w].tagName) != "undefined") {
					var t = String(r.childNodes[w].tagName||"").toLowerCase();
					// userdata
					if (t == this.conf.tags.userdata) {
						var d = r.childNodes[w];
						if (d.getAttribute("name") != null) {
							this.userData[item.id+"_"+d.getAttribute("name")] = (d.firstChild != null && d.firstChild.nodeValue != null ? d.firstChild.nodeValue : "");
						}
					}
					// extended text
					if (t == this.conf.tags.text_ext) {
						item.title = r.childNodes[w].firstChild.nodeValue;
					}
					// tooltips
					if (t == this.conf.tags.tooltip) {
						item.tip = r.childNodes[w].firstChild.nodeValue;
					}
					// hotkeys
					if (t == this.conf.tags.hotkey) {
						item.hotkey = r.childNodes[w].firstChild.nodeValue;
					}
					// hrefs
					if (t == this.conf.tags.href && item.type == "item") {
						item.href_link = r.childNodes[w].firstChild.nodeValue;
						if (r.childNodes[w].getAttribute("target") != null) {
							item.href_target = r.childNodes[w].getAttribute("target");
						}
					}
				}
			}
			items.push(item);
		}
	}
	
	var r = {
		parentId: parentId,//(root.getAttribute("parentId")||null),
		items: items
	};
	
	return r;
};

// dynload
dhtmlXMenuObject.prototype.enableDynamicLoading = function(url, icon) {
	this.conf.dload = true;
	this.conf.dload_url = url;
	this.conf.dload_sign = (String(this.conf.dload_url).search(/\?/)==-1?"?":"&");
	this.conf.dload_icon = icon;
	this._init();
};

dhtmlXMenuObject.prototype._updateLoaderIcon = function(id, state) {
	
	if (this.idPull[id] == null) return;
	if (String(this.idPull[id].className).search("TopLevel_Item") >= 0) return;
	// get arrow
	var ind = (this.conf.rtl?0:2);
	if (!this.idPull[id].childNodes[ind]) return;
	if (!this.idPull[id].childNodes[ind].childNodes[0]) return;
	var aNode = this.idPull[id].childNodes[ind].childNodes[0];
	if (String(aNode.className).search("complex_arrow") === 0) aNode.className = "complex_arrow"+(state?"_loading":"");

};



// add/remove
dhtmlXMenuObject.prototype.addNewSibling = function(nextToId, itemId, itemText, disabled, imgEnabled, imgDisabled) {
	var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	var parentId = this.idPrefix+(nextToId!=null?this.getParentId(nextToId):this.topId);
	
	this._addItemIntoGlobalStrorage(id, parentId, itemText, "item", disabled, imgEnabled, imgDisabled);
	if ((parentId == this.idPrefix+this.topId) && (!this.conf.context)) {
		this._renderToplevelItem(id, this.getItemPosition(nextToId));
	} else {
		this._renderSublevelItem(id, this.getItemPosition(nextToId));
	}
};

dhtmlXMenuObject.prototype.addNewChild = function(parentId, pos, itemId, itemText, disabled, imgEnabled, imgDisabled) {
	if (parentId == null) {
		if (this.conf.context) {
			parentId = this.topId;
		} else {
			this.addNewSibling(parentId, itemId, itemText, disabled, imgEnabled, imgDisabled);
			if (pos != null) this.setItemPosition(itemId, pos);
			return;
		}
	}
	itemId = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	// remove hotkey, added in 0.4
	if (this.setHotKey) this.setHotKey(parentId, "");
	//
	parentId = this.idPrefix+parentId;
	this._addItemIntoGlobalStrorage(itemId, parentId, itemText, "item", disabled, imgEnabled, imgDisabled);
	if (this.idPull["polygon_"+parentId] == null) { this._renderSublevelPolygon(parentId, parentId); }
	this._renderSublevelItem(itemId, pos-1);
	
	this._redefineComplexState(parentId);
};

dhtmlXMenuObject.prototype.removeItem = function(id, _isTId, _recCall) {
	if (!_isTId) id = this.idPrefix + id;
	
	var pId = null;
	
	if (id != this.idPrefix+this.topId) {
		
		if (this.itemPull[id] == null) return;
		
		// effects
		if (this.idPull["polygon_"+id] && this.idPull["polygon_"+id]._tmShow) window.clearTimeout(this.idPull["polygon_"+id]._tmShow);
		
		// separator top
		var t = this.itemPull[id]["type"];
		
		if (t == "separator") {
			var item = this.idPull["separator_"+id];
			if (this.itemPull[id]["parent"] == this.idPrefix+this.topId) {
				item.onclick = null;
				item.onselectstart = null;
				item.id = null;
				item.parentNode.removeChild(item);
			} else {
				item.childNodes[0].childNodes[0].onclick = null;
				item.childNodes[0].childNodes[0].onselectstart = null;
				item.childNodes[0].childNodes[0].id = null;
				item.childNodes[0].removeChild(item.childNodes[0].childNodes[0]);
				item.removeChild(item.childNodes[0]);
				item.parentNode.removeChild(item);
			}
			this.idPull["separator_"+id] = null;
			this.itemPull[id] = null;
			delete this.idPull["separator_"+id];
			delete this.itemPull[id];
			item = null;
		} else {
			// item checkbox radio
			pId = this.itemPull[id]["parent"];
			var item = this.idPull[id];
			item.onclick = null;
			item.oncontextmenu = null;
			item.onmouseover = null;
			item.onmouseout = null;
			item.onselectstart = null;
			item.id = null;
			while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
			item.parentNode.removeChild(item);
			this.idPull[id] = null;
			this.itemPull[id] = null;
			delete this.idPull[id];
			delete this.itemPull[id];
			item = null;
			
		}
		t = null;
	}
	
	// clear nested items
	for (var a in this.itemPull) if (this.itemPull[a]["parent"] == id) this.removeItem(a, true, true);
	
	// check if empty polygon left
	var p2 = new Array(id);
	if (pId != null && !_recCall) {
		if (this.idPull["polygon_"+pId] != null) {
			if (this.idPull["polygon_"+pId].tbd.childNodes.length == 0) {
				p2.push(pId);
				this._updateItemComplexState(pId, false, false);
			}
		}
	}
	
	// delete nested polygons and parent's if any
	for (var q=0; q<p2.length; q++) {
		if (this.idPull["polygon_"+p2[q]]) {
			var p = this.idPull["polygon_"+p2[q]];
			p.onclick = null;
			p.oncontextmenu = null;
			p.tbl.removeChild(p.tbd);
			p.tbd = null;
			p.childNodes[1].removeChild(p.tbl);
			p.tbl = null;
			p.id = null;
			p.parentNode.removeChild(p);
			p = null;
			if (window.dhx4.isIE6) {
				var pc = "polygon_"+p2[q]+"_ie6cover";
				if (this.idPull[pc] != null) { document.body.removeChild(this.idPull[pc]); delete this.idPull[pc]; }
			}
			if (this.idPull["arrowup_"+id] != null && this._removeArrow) this._removeArrow("arrowup_"+id);
			if (this.idPull["arrowdown_"+id] != null && this._removeArrow) this._removeArrow("arrowdown_"+id);
			//
			this.idPull["polygon_"+p2[q]] = null;
			delete this.idPull["polygon_"+p2[q]];
		}
	}
	p2 = null;
	
	// update corners
	if (this.conf.skin == "dhx_terrace" && arguments.length == 1) this._improveTerraceSkin();
	
};


// add item to storage
dhtmlXMenuObject.prototype._addItemIntoGlobalStrorage = function(itemId, itemParentId, itemText, itemType, disabled, img, imgDis) {
	var item = {
		id:	itemId,
		title:	itemText,
		imgen:	(img!=null?img:""),
		imgdis:	(imgDis!=null?imgDis:""),
		type:	itemType,
		state:	(disabled==true?"disabled":"enabled"),
		parent:	itemParentId,
		complex:false,
		hotkey:	"",
		tip:	""};
	this.itemPull[item.id] = item;
};

dhtmlXMenuObject.prototype.renderAsContextMenu = function() {
	this.conf.context = true;
	if (this.base._autoSkinUpdate == true) {
		this.base.className = this.base.className.replace("dhtmlxMenu_"+this.conf.skin+"_Middle","");
		this.base._autoSkinUpdate = false;
	}
	if (this.conf.ctx_baseid != null) { this.addContextZone(this.conf.ctx_baseid); }
};

dhtmlXMenuObject.prototype.addContextZone = function(zoneId) {
	if (zoneId == document.body) {
		zoneId = "document.body."+this.idPrefix;
		var zone = document.body;
	} else if (typeof(zoneId) == "string") {
		var zone = document.getElementById(zoneId);
	} else {
		var zone = zoneId;
	}
	var zoneExists = false;
	for (var a in this.conf.ctx_zones) { zoneExists = zoneExists || (a == zoneId) || (this.conf.ctx_zones[a] == zone); }
	if (zoneExists == true) return false;
	this.conf.ctx_zones[zoneId] = zone;
	var that = this;
	if (window.dhx4.isOpera) {
		this.operaContext = function(e){ that._doOnContextMenuOpera(e, that); }
		zone.addEventListener("mouseup", this.operaContext, false);
		//
	} else {
		if (zone.oncontextmenu != null && !zone._oldContextMenuHandler) zone._oldContextMenuHandler = zone.oncontextmenu;
		zone.oncontextmenu = function(e) {
			// autoclose any other opened context menues
			for (var q in dhtmlXMenuObject.prototype.liveInst) {
				if (q != that.conf.live_id) {
					if (dhtmlXMenuObject.prototype.liveInst[q].context) {
						dhtmlXMenuObject.prototype.liveInst[q]._hideContextMenu();
					}
				}
			}
			//
			e = e||event;
			e.cancelBubble = true;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			that._doOnContextBeforeCall(e, this);
			return false;
		}
	}
};
dhtmlXMenuObject.prototype._doOnContextMenuOpera = function(e, that) {
	// autoclose any other opened context menues
	for (var q in dhtmlXMenuObject.prototype.liveInst) {
		if (q != that.conf.live_id) {
			if (dhtmlXMenuObject.prototype.liveInst[q].context) {
				dhtmlXMenuObject.prototype.liveInst[q]._hideContextMenu();
			}
		}
	}
	//
	e.cancelBubble = true;
	if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
	if (e.button == 0 && e.ctrlKey == true) { that._doOnContextBeforeCall(e, this); }
	return false;
};

dhtmlXMenuObject.prototype.removeContextZone = function(zoneId) {
	if (!this.isContextZone(zoneId)) return false;
	if (zoneId == document.body) zoneId = "document.body."+this.idPrefix;
	var zone = this.conf.ctx_zones[zoneId];
	if (window.dhx4.isOpera) {
		zone.removeEventListener("mouseup", this.operaContext, false);
	} else {
		zone.oncontextmenu = (zone._oldContextMenuHandler!=null?zone._oldContextMenuHandler:null);
		zone._oldContextMenuHandler = null;
	}
	try {
		this.conf.ctx_zones[zoneId] = null;
		delete this.conf.ctx_zones[zoneId];
 	} catch(e){}
	return true;
};

dhtmlXMenuObject.prototype.isContextZone = function(zoneId) {
	if (zoneId == document.body && this.conf.ctx_zones["document.body."+this.idPrefix] != null) return true;
	var isZone = false;
	if (this.conf.ctx_zones[zoneId] != null) { if (this.conf.ctx_zones[zoneId] == document.getElementById(zoneId)) isZone = true; }
	return isZone;
};
dhtmlXMenuObject.prototype._isContextMenuVisible = function() {
	if (this.idPull["polygon_"+this.idPrefix+this.topId] == null) return false;
	return (this.idPull["polygon_"+this.idPrefix+this.topId].style.display == "");
};
dhtmlXMenuObject.prototype._showContextMenu = function(x, y, zoneId) {
	// hide any opened context menu/polygons
	this._clearAndHide();
	// open
	if (this.idPull["polygon_"+this.idPrefix+this.topId] == null) return false;
	window.clearTimeout(this.conf.tm_handler);
	this.idPull[this.idPrefix+this.topId] = new Array(x, y);
	this._showPolygon(this.idPrefix+this.topId, "bottom");
	this.callEvent("onContextMenu", [zoneId]);
};
dhtmlXMenuObject.prototype._hideContextMenu = function() {
	if (this.idPull["polygon_"+this.idPrefix+this.topId] == null) return false;
	this._clearAndHide();
	this._hidePolygon(this.idPrefix+this.topId);
};

dhtmlXMenuObject.prototype._doOnContextBeforeCall = function(e, cZone) {
	this.conf.ctx_zoneid = cZone.id;
	this._clearAndHide();
	this._hideContextMenu();
	
	// scroll settings
	if (window.dhx4.isChrome == true || window.dhx4.isEdge == true || window.dhx4.isOpera == true || window.dhx4.isIE11 == true) {
		var mx = window.dhx4.absLeft(e.target)+e.offsetX;
		var my = window.dhx4.absTop(e.target)+e.offsetY;
	} else if (window.dhx4.isIE6 == true || window.dhx4.isIE7 == true || window.dhx4.isIE == true) { // old IE or emulation
		var mx = window.dhx4.absLeft(e.srcElement)+e.x||0;
		var my = window.dhx4.absTop(e.srcElement)+e.y||0;
	} else { // the rest
		var p = (e.srcElement||e.target);
		var px = (window.dhx4.isIE||window.dhx4.isKHTML?e.offsetX:e.layerX);
		var py = (window.dhx4.isIE||window.dhx4.isKHTML?e.offsetY:e.layerY);
		var mx = window.dhx4.absLeft(p)+px;
		var my = window.dhx4.absTop(p)+py;
	}
	
	if (this.checkEvent("onBeforeContextMenu")) {
		if (this.callEvent("onBeforeContextMenu", [cZone.id,e])) {
			if (this.conf.ctx_autoshow) {
				this._showContextMenu(mx, my, cZone.id);
				this.callEvent("onAfterContextMenu", [cZone.id,e]);
			}
		}
	} else {
		if (this.conf.ctx_autoshow) {
			this._showContextMenu(mx, my, cZone.id);
			this.callEvent("onAfterContextMenu", [cZone.id]);
		}
	}
};

dhtmlXMenuObject.prototype.showContextMenu = function(x, y) {
	this._showContextMenu(x, y, false);
};

dhtmlXMenuObject.prototype.hideContextMenu = function() {
	this._hideContextMenu();
};

dhtmlXMenuObject.prototype.setAutoShowMode = function(mode) {
	this.conf.ctx_autoshow = (mode==true?true:false);
};

dhtmlXMenuObject.prototype.setAutoHideMode = function(mode) {
	this.conf.ctx_autohide = (mode==true?true:false);
};

dhtmlXMenuObject.prototype.setContextMenuHideAllMode = function(mode) {
	this.conf.ctx_hideall = (mode==true?true:false);
};

dhtmlXMenuObject.prototype.getContextMenuHideAllMode = function() {
	return this.conf.ctx_hideall;
};

dhtmlXMenuObject.prototype._improveTerraceSkin = function() {
	
	for (var a in this.itemPull) {
		
		if (this.itemPull[a].parent == this.idPrefix+this.topId && this.idPull[a] != null) { // this.idPull[a] will null for separator
			
			var bl = false;
			var br = false;
			
			// left side, first item, not sep
			if (this.idPull[a].parentNode.firstChild == this.idPull[a]) {
				bl = true;
			}
			
			// right side, last item, not sep
			if (this.idPull[a].parentNode.lastChild == this.idPull[a]) {
				br = true;
			}
			
			// check siblings
			for (var b in this.itemPull) {
				if (this.itemPull[b].type == "separator" && this.itemPull[b].parent == this.idPrefix+this.topId) {
					if (this.idPull[a].nextSibling == this.idPull["separator_"+b]) {
						br = true;
					}
					if (this.idPull[a].previousSibling == this.idPull["separator_"+b]) {
						bl = true;
					}
				}
			}
			
			this.idPull[a].style.borderLeftWidth = (bl?"1px":"0px");
			this.idPull[a].style.borderTopLeftRadius = this.idPull[a].style.borderBottomLeftRadius = (bl?"3px":"0px");
			
			this.idPull[a].style.borderTopRightRadius = this.idPull[a].style.borderBottomRightRadius = (br?"3px":"0px");
			
			this.idPull[a]._bl = bl;
			this.idPull[a]._br = br;
			
		}
	}
	
};

dhtmlXMenuObject.prototype._improveTerraceButton = function(id, state) {
	if (state) {
		this.idPull[id].style.borderBottomLeftRadius = (this.idPull[id]._bl ? "3px" : "0px");
		this.idPull[id].style.borderBottomRightRadius = (this.idPull[id]._br ? "3px" : "0px");
	} else {
		this.idPull[id].style.borderBottomLeftRadius = "0px";
		this.idPull[id].style.borderBottomRightRadius = "0px";
	}
};

if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype._createNode_menu = function(obj, type, htmlString, append, node) {
		
		if (typeof(node) != "undefined") {
			obj = node;
		} else {
			obj = document.createElement("DIV");
			obj.className = "dhx_cell_menu_"+(this.conf.borders?"def":"no_borders");
			obj.appendChild(document.createElement("DIV"));
		}
		
		this.cell.insertBefore(obj, this.cell.childNodes[this.conf.idx.toolbar||this.conf.idx.cont]); // before toolbar or before cont, 0=hdr
		
		this.conf.ofs_nodes.t.menu = true;
		this._updateIdx();
		// adjust cont will performed after toolbar init
		
		return obj;
		
	};
	
	dhtmlXCellObject.prototype.attachMenu = function(conf) {
		
		if (this.dataNodes.menu) return; // return this.dataNodes.menu?
		
		this.callEvent("_onBeforeContentAttach", ["menu"]);
		
		if (typeof(conf) == "undefined") conf = {};
		if (typeof(conf.skin) == "undefined") conf.skin = this.conf.skin;
		conf.parent = this._attachObject("menu").firstChild;
		
		this.dataNodes.menu = new dhtmlXMenuObject(conf);
		this._adjustCont(this._idd);
		
		conf.parent = null;
		conf = null;
		
		this.callEvent("_onContentAttach", []);
		
		return this.dataNodes.menu;
		
	};
	
	dhtmlXCellObject.prototype.detachMenu = function() {
		
		if (this.dataNodes.menu == null) return;
		
		if (typeof(this.dataNodes.menu.unload) == "function") this.dataNodes.menu.unload();
		this.dataNodes.menu = null;
		delete this.dataNodes.menu;
		
		this._detachObject("menu");
		
	};
	
	dhtmlXCellObject.prototype.showMenu = function() {
		this._mtbShowHide("menu", "");
	};
	
	dhtmlXCellObject.prototype.hideMenu = function() {
		this._mtbShowHide("menu", "none");
	};
	
	dhtmlXCellObject.prototype.getAttachedMenu = function() {
		return this.dataNodes.menu;
	};
	
}

;
///<jscompress sourcefile="dhtmlxmenu_ext.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

// enable/disable

dhtmlXMenuObject.prototype.setItemEnabled = function(id) {
	this._changeItemState(id, "enabled", this._getItemLevelType(id));
};
dhtmlXMenuObject.prototype.setItemDisabled = function(id) {
	this._changeItemState(id, "disabled", this._getItemLevelType(id));
};
dhtmlXMenuObject.prototype.isItemEnabled = function(id) {
	return (this.itemPull[this.idPrefix+id]!=null?(this.itemPull[this.idPrefix+id]["state"]=="enabled"):false);
};

// enable/disable sublevel item
dhtmlXMenuObject.prototype._changeItemState = function(id, newState, levelType) {
	var t = false;
	var j = this.idPrefix + id;
	if ((this.itemPull[j] != null) && (this.idPull[j] != null)) {
		if (this.itemPull[j]["state"] != newState) {
			this.itemPull[j]["state"] = newState;
			if (this.itemPull[j]["parent"] == this.idPrefix+this.topId && !this.conf.context) {
				this.idPull[j].className = "dhtmlxMenu_"+this.conf.skin+"_TopLevel_Item_"+(this.itemPull[j]["state"]=="enabled"?"Normal":"Disabled");
			} else {
				this.idPull[j].className = "sub_item"+(this.itemPull[j]["state"]=="enabled"?"":"_dis");
			}
			
			this._updateItemComplexState(this.idPrefix+id, this.itemPull[this.idPrefix+id]["complex"], false);
			this._updateItemImage(id, levelType);
			// if changeItemState attached to onClick event and changing applies to selected item all selection should be reparsed
			if ((this.idPrefix + this.conf.last_click == j) && (levelType != "TopLevel")) {
				this._redistribSubLevelSelection(j, this.itemPull[j]["parent"]);
			}
			if (levelType == "TopLevel" && !this.conf.context) { // rebuild style.left and show nested polygons
				// this._redistribTopLevelSelection(id, "parent");
			}
		}
	}
	return t;
};


// set-get text
dhtmlXMenuObject.prototype.getItemText = function(id) {
	return (this.itemPull[this.idPrefix+id]!=null?this.itemPull[this.idPrefix+id]["title"]:"");
};

dhtmlXMenuObject.prototype.setItemText = function(id, text) {
	id = this.idPrefix + id;
	if ((this.itemPull[id] != null) && (this.idPull[id] != null)) {
		this._clearAndHide();
		this.itemPull[id]["title"] = text;
		if (this.itemPull[id]["parent"] == this.idPrefix+this.topId && !this.conf.context) {
			// top level
			var tObj = null;
			for (var q=0; q<this.idPull[id].childNodes.length; q++) {
				try { if (this.idPull[id].childNodes[q].className == "top_level_text") tObj = this.idPull[id].childNodes[q]; } catch(e) {}
			}
			if (String(this.itemPull[id]["title"]).length == "" || this.itemPull[id]["title"] == null) {
				if (tObj != null) tObj.parentNode.removeChild(tObj);
			} else {
				if (!tObj) {
					tObj = document.createElement("DIV");
					tObj.className = "top_level_text";
					if (this.conf.rtl && this.idPull[id].childNodes.length > 0) this.idPull[id].insertBefore(tObj,this.idPull[id].childNodes[0]); else this.idPull[id].appendChild(tObj);
				}
				tObj.innerHTML = this.itemPull[id]["title"];
			}
		} else {
			// sub level
			var tObj = null;
			for (var q=0; q<this.idPull[id].childNodes[1].childNodes.length; q++) {
				if (String(this.idPull[id].childNodes[1].childNodes[q].className||"") == "sub_item_text") tObj = this.idPull[id].childNodes[1].childNodes[q];
			}
			if (String(this.itemPull[id]["title"]).length == "" || this.itemPull[id]["title"] == null) {
				if (tObj) {
					tObj.parentNode.removeChild(tObj);
					tObj = null;
					this.idPull[id].childNodes[1].innerHTML = "&nbsp;";
				}
			} else {
				if (!tObj) {
					tObj = document.createElement("DIV");
					tObj.className = "sub_item_text";
					this.idPull[id].childNodes[1].innerHTML = "";
					this.idPull[id].childNodes[1].appendChild(tObj);
				}
				tObj.innerHTML = this.itemPull[id]["title"];
			}
		}
	}
};

// load from html
dhtmlXMenuObject.prototype.loadFromHTML = function(objId, clearAfterAdd, onLoad) {
	
	var t = this.conf.tags.item;
	this.conf.tags.item = "div";
	
	var node = (typeof(objId)=="string"?document.getElementById(objId):objId);
	var items = this._xmlToJson(node, this.idPrefix+this.topId);
	this._initObj(items);
	
	this.conf.tags.item = t;
	
	if (clearAfterAdd) node.parentNode.removeChild(node);
	node = objOd = null;
	
	if (onload != null) {
		if (typeof(onLoad) == "function") {
			onLoad();
		} else if (typeof(window[onLoad]) == "function") {
			window[onLoad]();
		}
	}
};

// show/hide items
dhtmlXMenuObject.prototype.hideItem = function(id) {
	this._changeItemVisible(id, false);
};

dhtmlXMenuObject.prototype.showItem = function(id) {
	this._changeItemVisible(id, true);
};

dhtmlXMenuObject.prototype.isItemHidden = function(id) {
	var isHidden = null;
	if (this.idPull[this.idPrefix+id] != null) { isHidden = (this.idPull[this.idPrefix+id].style.display == "none"); }
	return isHidden;
};

dhtmlXMenuObject.prototype._changeItemVisible = function(id, visible) {
	var itemId = this.idPrefix+id;
	if (this.itemPull[itemId] == null) return;
	if (this.itemPull[itemId]["type"] == "separator") { itemId = "separator_"+itemId; }
	if (this.idPull[itemId] == null) return;
	this.idPull[itemId].style.display = (visible?"":"none");
	this._redefineComplexState(this.itemPull[this.idPrefix+id]["parent"]);
};

// userdata
dhtmlXMenuObject.prototype.setUserData = function(id, name, value) {
	this.userData[this.idPrefix+id+"_"+name] = value;
};

dhtmlXMenuObject.prototype.getUserData = function(id, name) {
	return (this.userData[this.idPrefix+id+"_"+name]!=null?this.userData[this.idPrefix+id+"_"+name]:null);
};

// open-mode (win/web)
dhtmlXMenuObject.prototype.setOpenMode = function(mode) {
	this.conf.mode = (mode=="win"?"win":"web");
};

// web-mode timeout
dhtmlXMenuObject.prototype.setWebModeTimeout = function(tm) {
	this.conf.tm_sec = (!isNaN(tm)?tm:400);
};

// icons
dhtmlXMenuObject.prototype.getItemImage = function(id) {
	var imgs = new Array(null, null);
	id = this.idPrefix+id;
	if (this.itemPull[id]["type"] == "item") {
		imgs[0] = this.itemPull[id]["imgen"];
		imgs[1] = this.itemPull[id]["imgdis"];
	}
	return imgs;
};

dhtmlXMenuObject.prototype.setItemImage = function(id, img, imgDis) {
	if (this.itemPull[this.idPrefix+id]["type"] != "item") return;
	this.itemPull[this.idPrefix+id]["imgen"] = img;
	this.itemPull[this.idPrefix+id]["imgdis"] = imgDis;
	this._updateItemImage(id, this._getItemLevelType(id));
};

dhtmlXMenuObject.prototype.clearItemImage = function(id) {
	this.setItemImage(id, "", "");
};

// visible area
dhtmlXMenuObject.prototype.setVisibleArea = function(x1, x2, y1, y2) {
	this.conf.v_enabled = true;
	this.conf.v.x1 = x1;
	this.conf.v.x2 = x2;
	this.conf.v.y1 = y1;
	this.conf.v.y2 = y2;
};

// tooltips
dhtmlXMenuObject.prototype.setTooltip = function(id, tip) {
	id = this.idPrefix+id;
	if (!(this.itemPull[id] != null && this.idPull[id] != null)) return;
	this.idPull[id].title = (tip.length > 0 ? tip : null);
	this.itemPull[id]["tip"] = tip;
};

dhtmlXMenuObject.prototype.getTooltip = function(id) {
	if (this.itemPull[this.idPrefix+id] == null) return null;
	return this.itemPull[this.idPrefix+id]["tip"];
};



dhtmlXMenuObject.prototype.setTopText = function(text) {
	if (this.conf.context) return;
	if (this._topText == null) {
		this._topText = document.createElement("DIV");
		this._topText.className = "dhtmlxMenu_TopLevel_Text_"+(this.conf.rtl?"left":(this.conf.align=="left"?"right":"left"));
		this.base.appendChild(this._topText);
	}
	this._topText.innerHTML = text;
};

dhtmlXMenuObject.prototype.setAlign = function(align) {
	if (this.conf.align == align) return;
	if (align == "left" || align == "right") {
		// if (this.setRTL) this.setRTL(false);
		this.conf.align = align;
		if (this.cont) this.cont.className = (this.conf.align=="right"?"align_right":"align_left");
		if (this._topText != null) this._topText.className = "dhtmlxMenu_TopLevel_Text_"+(this.conf.align=="left"?"right":"left");
	}
};

dhtmlXMenuObject.prototype.setHref = function(itemId, href, target) {
	if (this.itemPull[this.idPrefix+itemId] == null) return;
	this.itemPull[this.idPrefix+itemId]["href_link"] = href;
	if (target != null) this.itemPull[this.idPrefix+itemId]["href_target"] = target;
};

dhtmlXMenuObject.prototype.clearHref = function(itemId) {
	if (this.itemPull[this.idPrefix+itemId] == null) return;
	delete this.itemPull[this.idPrefix+itemId]["href_link"];
	delete this.itemPull[this.idPrefix+itemId]["href_target"];
};
/*
File [id="file"] -> Open [id="open"] -> Last Save [id="lastsave"]
getCircuit("lastsave") will return Array("file", "open", "lastsave");
*/

dhtmlXMenuObject.prototype.getCircuit = function(id) {
	var parents = new Array(id);
	while (this.getParentId(id) != this.topId) {
		id = this.getParentId(id);
		parents[parents.length] = id;
	}
	return parents.reverse();
};

// checkboxes
dhtmlXMenuObject.prototype._getCheckboxState = function(id) {
	if (this.itemPull[this.idPrefix+id] == null) return null;
	return this.itemPull[this.idPrefix+id]["checked"];
};

dhtmlXMenuObject.prototype._setCheckboxState = function(id, state) {
	if (this.itemPull[this.idPrefix+id] == null) return;
	this.itemPull[this.idPrefix+id]["checked"] = state;
};

dhtmlXMenuObject.prototype._updateCheckboxImage = function(id) {
	if (this.idPull[this.idPrefix+id] == null) return;
	this.itemPull[this.idPrefix+id]["imgen"] = "chbx_"+(this._getCheckboxState(id)?"1":"0");
	this.itemPull[this.idPrefix+id]["imgdis"] = this.itemPull[this.idPrefix+id]["imgen"];
	try { this.idPull[this.idPrefix+id].childNodes[(this.conf.rtl?2:0)].childNodes[0].className = "sub_icon "+this.itemPull[this.idPrefix+id]["imgen"]; } catch(e){}
};

dhtmlXMenuObject.prototype._checkboxOnClickHandler = function(id, type, casState) {
	if (type.charAt(1)=="d") return;
	if (this.itemPull[this.idPrefix+id] == null) return;
	var state = this._getCheckboxState(id);
	if (this.checkEvent("onCheckboxClick")) {
		if (this.callEvent("onCheckboxClick", [id, state, this.conf.ctx_zoneid, casState])) {
			this.setCheckboxState(id, !state);
		}
	} else {
		this.setCheckboxState(id, !state);
	}
	// call onClick if exists
	if (this.checkEvent("onClick")) this.callEvent("onClick", [id]);
};

dhtmlXMenuObject.prototype.setCheckboxState = function(id, state) {
	this._setCheckboxState(id, state);
	this._updateCheckboxImage(id);
};

dhtmlXMenuObject.prototype.getCheckboxState = function(id) {
	return this._getCheckboxState(id);
};

dhtmlXMenuObject.prototype.addCheckbox = function(mode, nextToId, pos, itemId, itemText, state, disabled) {
	// checks
	if (this.conf.context && nextToId == this.topId) {
		// adding checkbox as first element to context menu
		// do nothing
	} else {
		if (this.itemPull[this.idPrefix+nextToId] == null) return;
		if (mode == "child" && this.itemPull[this.idPrefix+nextToId]["type"] != "item") return;
	}
	//
	var img = "chbx_"+(state?"1":"0");
	var imgDis = img;
	//
	
	if (mode == "sibling") {
		
		var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
		var parentId = this.idPrefix+this.getParentId(nextToId);
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "checkbox", disabled, img, imgDis);
		this.itemPull[id]["checked"] = state;
		this._renderSublevelItem(id, this.getItemPosition(nextToId));
	} else {
		
		var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
		var parentId = this.idPrefix+nextToId;
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "checkbox", disabled, img, imgDis);
		this.itemPull[id]["checked"] = state;
		if (this.idPull["polygon_"+parentId] == null) { this._renderSublevelPolygon(parentId, parentId); }
		this._renderSublevelItem(id, pos-1);
		this._redefineComplexState(parentId);
	}
};


// hot-keys
dhtmlXMenuObject.prototype.setHotKey = function(id, hkey) {
	
	id = this.idPrefix+id;
	
	if (!(this.itemPull[id] != null && this.idPull[id] != null)) return;
	if (this.itemPull[id]["parent"] == this.idPrefix+this.topId && !this.conf.context) return;
	if (this.itemPull[id]["complex"]) return;
	var t = this.itemPull[id]["type"];
	if (!(t == "item" || t == "checkbox" || t == "radio")) return;
	
	// retrieve obj
	var hkObj = null;
	try { if (this.idPull[id].childNodes[this.conf.rtl?0:2].childNodes[0].className == "sub_item_hk") hkObj = this.idPull[id].childNodes[this.conf.rtl?0:2].childNodes[0]; } catch(e){}
	
	if (hkey.length == 0) {
		// remove if exists
		this.itemPull[id]["hotkey_backup"] = this.itemPull[id]["hotkey"];
		this.itemPull[id]["hotkey"] = "";
		if (hkObj != null) hkObj.parentNode.removeChild(hkObj);
		
	} else {
		
		// add if needed or change
		this.itemPull[id]["hotkey"] = hkey;
		this.itemPull[id]["hotkey_backup"] = null;
		//
		if (hkObj == null) {
			hkObj = document.createElement("DIV");
			hkObj.className = "sub_item_hk";
			var item = this.idPull[id].childNodes[this.conf.rtl?0:2];
			while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
			item.appendChild(hkObj);
		}
		hkObj.innerHTML = hkey;

	}
};

dhtmlXMenuObject.prototype.getHotKey = function(id) {
	if (this.itemPull[this.idPrefix+id] == null) return null;
	return this.itemPull[this.idPrefix+id]["hotkey"];
};


// overflow control
dhtmlXMenuObject.prototype._clearAllSelectedSubItemsInPolygon = function(polygon) {
	var subIds = this._getSubItemToDeselectByPolygon(polygon);
	// hide opened polygons and selected items
	for (var q=0; q<this.conf.opened_poly.length; q++) {
		if (this.conf.opened_poly[q] != polygon) this._hidePolygon(this.conf.opened_poly[q]);
	}
	for (var q=0; q<subIds.length; q++) {
		if (this.idPull[subIds[q]] != null && this.itemPull[subIds[q]]["state"] == "enabled") {
			this.idPull[subIds[q]].className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_Item_Normal";
		}
	}
};

// define normal/disabled arrows in polygon
dhtmlXMenuObject.prototype._checkArrowsState = function(id) {
	var polygon = this.idPull["polygon_"+id].childNodes[1];
	var arrowUp = this.idPull["arrowup_"+id];
	var arrowDown = this.idPull["arrowdown_"+id];
	if (polygon.scrollTop == 0) {
		arrowUp.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowUp_Disabled";
	} else {
		arrowUp.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowUp" + (arrowUp.over ? "_Over" : "");
	}
	if (polygon.scrollTop + polygon.offsetHeight < polygon.scrollHeight) {
		arrowDown.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowDown" + (arrowDown.over ? "_Over" : "");
	} else {
		arrowDown.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowDown_Disabled";
	}
	polygon = arrowUp = arrowDown = null;
};

// add up-limit-arrow
dhtmlXMenuObject.prototype._addUpArrow = function(id) {
	var that = this;
	var arrow = document.createElement("DIV");
	arrow.pId = this.idPrefix+id;
	arrow.id = "arrowup_"+this.idPrefix+id;
	arrow.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowUp";
	
	arrow.over = false;
	arrow.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	arrow.oncontextmenu = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	// actions
	arrow.onmouseover = function() {
		if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
		that._clearAllSelectedSubItemsInPolygon(this.pId);
		if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp_Disabled") return;
		this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp_Over";
		this.over = true;
		that._canScrollUp = true;
		that._doScrollUp(this.pId, true);
	}
	arrow.onmouseout = function() {
		if (that.conf.mode == "web") {
			window.clearTimeout(that.conf.tm_handler);
			that.conf.tm_handler = window.setTimeout(function(){that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
		}
		this.over = false;
		that._canScrollUp = false;
		if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp_Disabled") return;
		this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowUp";
		window.clearTimeout(that.conf.of_utm);
	}
	arrow.onclick = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	
	var polygon = this.idPull["polygon_"+this.idPrefix+id];
	polygon.childNodes[0].appendChild(arrow);
	
	this.idPull[arrow.id] = arrow;
	polygon = arrow = null;
};

dhtmlXMenuObject.prototype._addDownArrow = function(id) {
	
	var that = this;
	var arrow = document.createElement("DIV");
	arrow.pId = this.idPrefix+id;
	arrow.id = "arrowdown_"+this.idPrefix+id;
	arrow.className = "dhtmlxMenu_"+this.conf.skin+"_SubLevelArea_ArrowDown";
	
	arrow.over = false;
	arrow.onselectstart = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	arrow.oncontextmenu = function(e) { e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false; return false; }
	
	// actions
	arrow.onmouseover = function() {
		if (that.conf.mode == "web") { window.clearTimeout(that.conf.tm_handler); }
		that._clearAllSelectedSubItemsInPolygon(this.pId);
		if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown_Disabled") return;
		this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown_Over";
		this.over = true;
		that._canScrollDown = true;
		that._doScrollDown(this.pId, true);
	}
	arrow.onmouseout = function() {
		if (that.conf.mode == "web") {
			window.clearTimeout(that.conf.tm_handler);
			that.conf.tm_handler = window.setTimeout(function(){that._clearAndHide();}, that.conf.tm_sec, "JavaScript");
		}
		this.over = false;
		that._canScrollDown = false;
		if (this.className == "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown_Disabled") return;
		this.className = "dhtmlxMenu_"+that.conf.skin+"_SubLevelArea_ArrowDown";
		window.clearTimeout(that.conf.of_dtm);
	}
	arrow.onclick = function(e) {
		e = e||event;
		if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
		e.cancelBubble = true;
		return false;
	}
	
	var polygon = this.idPull["polygon_"+this.idPrefix+id];
	polygon.childNodes[2].appendChild(arrow);
	
	this.idPull[arrow.id] = arrow;
	polygon = arrow = null;
};

dhtmlXMenuObject.prototype._removeUpArrow = function(id) {
	var fullId = "arrowup_"+this.idPrefix+id;
	this._removeArrow(fullId);
};

dhtmlXMenuObject.prototype._removeDownArrow = function(id) {
	var fullId = "arrowdown_"+this.idPrefix+id;
	this._removeArrow(fullId);
};

dhtmlXMenuObject.prototype._removeArrow = function(fullId) {
	var arrow = this.idPull[fullId];
	arrow.onselectstart = null;
	arrow.oncontextmenu = null;
	arrow.onmouseover = null;
	arrow.onmouseout = null;
	arrow.onclick = null;
	if (arrow.parentNode) arrow.parentNode.removeChild(arrow);
	arrow = null;
	this.idPull[fullId] = null;
	try { delete this.idPull[fullId]; } catch(e) {}
};

dhtmlXMenuObject.prototype._isArrowExists = function(id) {
	if (this.idPull["arrowup_"+id] != null && this.idPull["arrowdown_"+id] != null) return true;
	return false;
};

// scroll down
dhtmlXMenuObject.prototype._doScrollUp = function(id, checkArrows) {
	var polygon = this.idPull["polygon_"+id].childNodes[1];
	if (this._canScrollUp && polygon.scrollTop > 0) {
		var theEnd = false;
		var nextScrollTop = polygon.scrollTop - this.conf.of_ustep;
		if (nextScrollTop < 0) {
			theEnd = true;
			nextScrollTop = 0;
		}
		polygon.scrollTop = nextScrollTop;
		if (!theEnd) {
			var that = this;
			this.conf.of_utm = window.setTimeout(function() {
				that._doScrollUp(id, false);
				that = null;
			}, this.conf.of_utime);
		} else {
			checkArrows = true;
		}
	} else {
		this._canScrollUp = false;
		this._checkArrowsState(id);
	}
	if (checkArrows) {
		this._checkArrowsState(id);
	}
};

dhtmlXMenuObject.prototype._doScrollDown = function(id, checkArrows) {
	var polygon = this.idPull["polygon_"+id].childNodes[1];
	if (this._canScrollDown && polygon.scrollTop + polygon.offsetHeight <= polygon.scrollHeight) {
		var theEnd = false;
		var nextScrollTop = polygon.scrollTop + this.conf.of_dstep;
		if (nextScrollTop + polygon.offsetHeight >= polygon.scrollHeight) {
			theEnd = true;
			nextScrollTop = polygon.scrollHeight - polygon.offsetHeight;
		}
		polygon.scrollTop = nextScrollTop;
		if (!theEnd) {
			var that = this;
			this.conf.of_dtm = window.setTimeout(function() {
				that._doScrollDown(id, false);
				that = null;
			}, this.conf.of_dtime);
		} else {
			checkArrows = true;
		}
	} else {
		this._canScrollDown = false;
		this._checkArrowsState(id);
	}
	if (checkArrows) {
		this._checkArrowsState(id);
	}
};

dhtmlXMenuObject.prototype._countPolygonItems = function(id) {
	var count = 0;
	for (var a in this.itemPull) {
		var par = this.itemPull[a]["parent"];
		var tp = this.itemPull[a]["type"];
		if (par == this.idPrefix+id && (tp == "item" || tp == "radio" || tp == "checkbox")) { count++; }
	}
	return count;
};

dhtmlXMenuObject.prototype.setOverflowHeight = function(itemsNum) {
	
	// set auto overflow mode
	if (itemsNum === "auto") {
		this.conf.overflow_limit = 0;
		this.conf.auto_overflow = true;
		return;
	}
	
	// no existing limitation, now new limitation
	if (this.conf.overflow_limit == 0 && itemsNum <= 0) return;
	
	// hide menu to prevent visible changes
	this._clearAndHide();
	
	// redefine existing limitation, arrows will added automatically with showPlygon
	if (this.conf.overflow_limit >= 0 && itemsNum > 0) {
		this.conf.overflow_limit = itemsNum;
		return;
	}
	
	// remove existing limitation
	if (this.conf.overflow_limit > 0 && itemsNum <= 0) {
		for (var a in this.itemPull) {
			if (this._isArrowExists(a)) {
				var b = String(a).replace(this.idPrefix, "");
				this._removeUpArrow(b);
				this._removeDownArrow(b);
				// remove polygon's height
				this.idPull["polygon_"+a].childNodes[1].style.height = "";
			}
		}
		this.conf.overflow_limit = 0;
		return;
	}
};


// radiobuttons
dhtmlXMenuObject.prototype._getRadioImgObj = function(id) {
	try { var imgObj = this.idPull[this.idPrefix+id].childNodes[(this.conf.rtl?2:0)].childNodes[0] } catch(e) { var imgObj = null; }
	return imgObj;
};

dhtmlXMenuObject.prototype._setRadioState = function(id, state) {
	// if (this.itemPull[this.idPrefix+id]["state"] != "enabled") return;
	var imgObj = this._getRadioImgObj(id);
	if (imgObj != null) {
		// fix, added in 0.4
		var rObj = this.itemPull[this.idPrefix+id];
		rObj["checked"] = state;
		rObj["imgen"] = "rdbt_"+(rObj["checked"]?"1":"0");
		rObj["imgdis"] = rObj["imgen"];
		imgObj.className = "sub_icon "+rObj["imgen"];
	}
};

dhtmlXMenuObject.prototype._radioOnClickHandler = function(id, type, casState) {
	if (type.charAt(1)=="d" || this.itemPull[this.idPrefix+id]["group"]==null) return;
	// deselect all from the same group
	var group = this.itemPull[this.idPrefix+id]["group"];
	if (this.checkEvent("onRadioClick")) {
		if (this.callEvent("onRadioClick", [group, this.getRadioChecked(group), id, this.conf.ctx_zoneid, casState])) {
			this.setRadioChecked(group, id);
		}
	} else {
		this.setRadioChecked(group, id);
	}
	// call onClick if exists
	if (this.checkEvent("onClick")) this.callEvent("onClick", [id]);
};

dhtmlXMenuObject.prototype.getRadioChecked = function(group) {
	var id = null;
	for (var q=0; q<this.radio[group].length; q++) {
		var itemId = this.radio[group][q].replace(this.idPrefix, "");
		var imgObj = this._getRadioImgObj(itemId);
		if (imgObj != null) {
			var checked = (imgObj.className).match(/rdbt_1$/gi);
			if (checked != null) id = itemId;
		}
	}
	return id;
};

dhtmlXMenuObject.prototype.setRadioChecked = function(group, id) {
	if (this.radio[group] == null) return;
	for (var q=0; q<this.radio[group].length; q++) {
		var itemId = this.radio[group][q].replace(this.idPrefix, "");
		this._setRadioState(itemId, (itemId==id));
	}
}

dhtmlXMenuObject.prototype.addRadioButton = function(mode, nextToId, pos, itemId, itemText, group, state, disabled) {
	// radiobutton
	if (this.conf.context && nextToId == this.topId) {
		// adding radiobutton as first element to context menu
		// do nothing
	} else {
		if (this.itemPull[this.idPrefix+nextToId] == null) return;
		if (mode == "child" && this.itemPull[this.idPrefix+nextToId]["type"] != "item") return;
	}
	
	var id = this.idPrefix+(itemId!=null?itemId:this._genStr(24));
	var img = "rdbt_"+(state?"1":"0");
	var imgDis = img;
	//
	if (mode == "sibling") {
		var parentId = this.idPrefix+this.getParentId(nextToId);
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "radio", disabled, img, imgDis);
		this._renderSublevelItem(id, this.getItemPosition(nextToId));
	} else {
		var parentId = this.idPrefix+nextToId;
		this._addItemIntoGlobalStrorage(id, parentId, itemText, "radio", disabled, img, imgDis);
		if (this.idPull["polygon_"+parentId] == null) { this._renderSublevelPolygon(parentId, parentId); }
		this._renderSublevelItem(id, pos-1);
		this._redefineComplexState(parentId);
	}
	//
	var gr = (group!=null?group:this._genStr(24));
	this.itemPull[id]["group"] = gr;
	//
	if (this.radio[gr]==null) { this.radio[gr] = new Array(); }
	this.radio[gr][this.radio[gr].length] = id;
	//
	if (state == true) this.setRadioChecked(gr, String(id).replace(this.idPrefix, ""));
};


// serialize
dhtmlXMenuObject.prototype.serialize = function() {
	var xml = "<menu>"+this._readLevel(this.idPrefix+this.topId)+"</menu>";
	return xml;
};

dhtmlXMenuObject.prototype._readLevel = function(parentId) {
	var xml = "";
	for (var a in this.itemPull) {
		if (this.itemPull[a]["parent"] == parentId) {
			var imgEn = "";
			var imgDis = "";
			var hotKey = "";
			var itemId = String(this.itemPull[a]["id"]).replace(this.idPrefix,"");
			var itemType = "";
			var itemText = (this.itemPull[a]["title"]!=""?' text="'+this.itemPull[a]["title"]+'"':"");
			var itemState = "";
			if (this.itemPull[a]["type"] == "item") {
				if (this.itemPull[a]["imgen"] != "") imgEn = ' img="'+this.itemPull[a]["imgen"]+'"';
				if (this.itemPull[a]["imgdis"] != "") imgDis = ' imgdis="'+this.itemPull[a]["imgdis"]+'"';
				if (this.itemPull[a]["hotkey"] != "") hotKey = '<hotkey>'+this.itemPull[a]["hotkey"]+'</hotkey>';
			}
			if (this.itemPull[a]["type"] == "separator") {
				itemType = ' type="separator"';
			} else {
				if (this.itemPull[a]["state"] == "disabled") itemState = ' enabled="false"';
			}
			if (this.itemPull[a]["type"] == "checkbox") {
				itemType = ' type="checkbox"'+(this.itemPull[a]["checked"]?' checked="true"':"");
			}
			if (this.itemPull[a]["type"] == "radio") {
				itemType = ' type="radio" group="'+this.itemPull[a]["group"]+'" '+(this.itemPull[a]["checked"]?' checked="true"':"");
			}
			xml += "<item id='"+itemId+"'"+itemText+itemType+imgEn+imgDis+itemState+">";
			xml += hotKey;
			if (this.itemPull[a]["complex"]) xml += this._readLevel(a);
			xml += "</item>";
		}
	}
	return xml;
};

;
///<jscompress sourcefile="dhtmlxmenu_effects.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

// effects: opacity, slide
dhtmlXMenuObject.prototype.enableEffect = function(name, maxOpacity, effectSpeed) {
	
	this._menuEffect = (name=="opacity"||name=="slide"||name=="slide+"?name:false);
	
	this._pOpStyleIE = (navigator.userAgent.search(/MSIE\s[678]\.0/gi)>=0); // opacity was added in IE9
	
	for (var a in this.idPull) {
		if (a.search(/polygon/) === 0) {
			this._pOpacityApply(a,(this._pOpStyleIE?100:1));
			this.idPull[a].style.height = "";
		}
		
	}
	
	// opacity max value
	this._pOpMax = (typeof(maxOpacity)=="undefined"?100:maxOpacity)/(this._pOpStyleIE?1:100);
	
	// opacity css styles
	this._pOpStyleName = (this._pOpStyleIE?"filter":"opacity");
	this._pOpStyleValue = (this._pOpStyleIE?"progid:DXImageTransform.Microsoft.Alpha(Opacity=#)":"#");
	
	
	// count of steps to open full polygon
	this._pSlSteps = (this._pOpStyleIE?10:20);
	
	// timeout to open polygon
	this._pSlTMTimeMax = effectSpeed||50;
	
};

// extended show
dhtmlXMenuObject.prototype._showPolygonEffect = function(pId) {
	this._pShowHide(pId, true);
};

// extended hide
dhtmlXMenuObject.prototype._hidePolygonEffect = function(pId) {
	this._pShowHide(pId, false);
};

// apply opacity css
dhtmlXMenuObject.prototype._pOpacityApply = function(pId, val) {
	this.idPull[pId].style[this._pOpStyleName] = String(this._pOpStyleValue).replace("#", val||this.idPull[pId]._op);
};

dhtmlXMenuObject.prototype._pShowHide = function(pId, mode) {
	
	if (!this.idPull) return;
	
	// check if mode in progress
	if (this.idPull[pId]._tmShow != null) {
		if ((this.idPull[pId]._step_h > 0 && mode == true) || (this.idPull[pId]._step_h < 0 && mode == false)) return;
		window.clearTimeout(this.idPull[pId]._tmShow);
		this.idPull[pId]._tmShow = null;
		this.idPull[pId]._max_h = null;
	}
	
	if (mode == false && (this.idPull[pId].style.visibility == "hidden" || this.idPull[pId].style.display == "none")) return;
	
	if (mode == true && this.idPull[pId].style.display == "none") {
		this.idPull[pId].style.visibility = "hidden";
		this.idPull[pId].style.display = "";
	}
	
	// init values or show-hide revert
	if (this.idPull[pId]._max_h == null) {
		
		this.idPull[pId]._max_h = parseInt(this.idPull[pId].offsetHeight);
		this.idPull[pId]._h = (mode==true?0:this.idPull[pId]._max_h);
		this.idPull[pId]._step_h = Math.round(this.idPull[pId]._max_h/this._pSlSteps)*(mode==true?1:-1);
		if (this.idPull[pId]._step_h == 0) return;
		this.idPull[pId]._step_tm = Math.round(this._pSlTMTimeMax/this._pSlSteps);
		
		if (this._menuEffect == "slide+" || this._menuEffect == "opacity") {
			this.idPull[pId].op_tm = this.idPull[pId]._step_tm;
			this.idPull[pId].op_step = (this._pOpMax/this._pSlSteps)*(mode==true?1:-1);
			if (this._pOpStyleIE) this.idPull[pId].op_step = Math.round(this.idPull[pId].op_step);
			this.idPull[pId]._op = (mode==true?0:this._pOpMax);
			this._pOpacityApply(pId);
		} else {
			this.idPull[pId]._op = (this._pOpStyleIE?100:1);
			this._pOpacityApply(pId);
		}
		
		// show first time
		if (this._menuEffect.search(/slide/) === 0) this.idPull[pId].style.height = "0px";
		this.idPull[pId].style.visibility = "visible";
		
	}
	
	// run cycle
	this._pEffectSet(pId, this.idPull[pId]._h+this.idPull[pId]._step_h);
	
};

dhtmlXMenuObject.prototype._pEffectSet = function(pId, t) {
	
	if (!this.idPull) return;
	
	if (this.idPull[pId]._tmShow) window.clearTimeout(this.idPull[pId]._tmShow);
	
	// check and apply next step
	this.idPull[pId]._h = Math.max(0,Math.min(t,this.idPull[pId]._max_h));
	if (this._menuEffect.search(/slide/) === 0) this.idPull[pId].style.height = this.idPull[pId]._h+"px";
	
	t += this.idPull[pId]._step_h;
	
	if (this._menuEffect == "slide+" || this._menuEffect == "opacity") {
		this.idPull[pId]._op = Math.max(0,Math.min(this._pOpMax,this.idPull[pId]._op+this.idPull[pId].op_step));
		this._pOpacityApply(pId);
	}
	
	if ((this.idPull[pId]._step_h > 0 && t <= this.idPull[pId]._max_h) || (this.idPull[pId]._step_h < 0 && t >= 0)) {
		// continue
		var k = this;
		this.idPull[pId]._tmShow = window.setTimeout(function(){k._pEffectSet(pId,t);}, this.idPull[pId]._step_tm);
	} else {
		
		// clear height
		if (this._menuEffect.search(/slide/) === 0) this.idPull[pId].style.height = "";
		
		// hide completed
		if (this.idPull[pId]._step_h < 0) this.idPull[pId].style.visibility = "hidden";
		
		if (this._menuEffect == "slide+" || this._menuEffect == "opacity") {
			this.idPull[pId]._op = (this.idPull[pId]._step_h<0?(this._pOpStyleIE?100:1):this._pOpMax);
			this._pOpacityApply(pId);
		}
		
		// clear values
		this.idPull[pId]._tmShow = null;
		this.idPull[pId]._h = null;
		this.idPull[pId]._max_h = null;
		///this.idPull[pId]._step_h = null;
		this.idPull[pId]._step_tm = null;
	}
	
};


;
///<jscompress sourcefile="dhtmlxtree.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*_TOPICS_
@0:Initialization
@1:Selection control
@2:Add/delete
@3:Private
@4:Node/level control
@5:Checkboxes/user data manipulation
@6:Appearence control
@7: Handlers
*/

function xmlPointer(data){
	this.d=data;
}
xmlPointer.prototype={
	text:function(){ if (!_isFF) return this.d.xml; var x = new XMLSerializer();   return x.serializeToString(this.d); },
	get:function(name){return this.d.getAttribute(name); },
	exists:function(){return !!this.d },
	content:function(){return this.d.firstChild?(this.d.firstChild.wholeText||this.d.firstChild.data):""; }, // <4k in FF
	each:function(name,f,t,i){  var a=this.d.childNodes; var c=new xmlPointer(); if (a.length) for (i=i||0; i<a.length; i++) if (a[i].tagName==name) { c.d=a[i]; if(f.apply(t,[c,i])==-1) return; } },
	get_all:function(){ var a={}; var b=this.d.attributes; for (var i=0; i<b.length; i++) a[b[i].name]=b[i].value; return a; },
	sub:function(name){ var a=this.d.childNodes; var c=new xmlPointer(); if (a.length) for (var i=0; i<a.length; i++) if (a[i].tagName==name) { c.d=a[i]; return c; } },
	up:function(name){ return new xmlPointer(this.d.parentNode);  },
	set:function(name,val){ this.d.setAttribute(name,val);  },
	clone:function(name){ return new xmlPointer(this.d); },
	sub_exists:function(name){ var a=this.d.childNodes; if (a.length) for (var i=0; i<a.length; i++) if (a[i].tagName==name) return true;  return false;  },
	through:function(name,rule,v,f,t){  var a=this.d.childNodes; if (a.length) for (var i=0; i<a.length; i++) { if (a[i].tagName==name && a[i].getAttribute(rule)!=null && a[i].getAttribute(rule)!="" &&  (!v || a[i].getAttribute(rule)==v )) { var c=new xmlPointer(a[i]);  f.apply(t,[c,i]); } var w=this.d; this.d=a[i]; this.through(name,rule,v,f,t); this.d=w;  } }
}



/**
*     @desc: tree constructor
*     @param: htmlObject - parent html object or id of parent html object
*     @param: width - tree width
*     @param: height - tree height
*     @param: rootId - id of virtual root node (same as tree node id attribute in xml)
*     @type: public
*     @topic: 0
*/
function dhtmlXTreeObject(htmlObject, width, height, rootId){
  if (dhtmlxEvent.initTouch)
    dhtmlxEvent.initTouch();

	if (_isIE) try { document.execCommand("BackgroundImageCache", false, true); } catch (e){}
	if (typeof(htmlObject)!="object")
      this.parentObject=document.getElementById(htmlObject);
	else
      this.parentObject=htmlObject;

	this.parentObject.style.overflow="hidden";
   	this._itim_dg=true;
    this.dlmtr=",";
    this.dropLower=false;
	  this.enableIEImageFix(true);

   this.xmlstate=0;
   this.mytype="tree";
   this.smcheck=true;   //smart checkboxes
   this.width=width;
   this.height=height;
   this.rootId=rootId;
   this.childCalc=null;
      this.def_img_x="18px";
      this.def_img_y="18px";
      this.def_line_img_x="18px";
      this.def_line_img_y="24px";

    this._dragged=new Array();
   this._selected=new Array();

   this.style_pointer="pointer";
   
   this._aimgs=true;
   this.htmlcA=" [";
   this.htmlcB="]";
   this.lWin=window;
   this.cMenu=0;
   this.mlitems=0;
   this.iconURL="";
   this.dadmode=0;
   this.slowParse=false;
   this.autoScroll=true;
   this.hfMode=0;
   this.nodeCut=new Array();
   this.XMLsource=0;
   this.XMLloadingWarning=0;
   this._idpull={};
   this._pullSize=0;
   this.treeLinesOn=true;
   this.tscheck=false;
   this.timgen=true;
   this.dpcpy=false;
   this._ld_id=null;
   this._dynDeleteBranches={};
	this._oie_onXLE=[];
   this.imPath=window.dhx_globalImgPath||""; 
   this.checkArray=new Array("iconUncheckAll.gif","iconCheckAll.gif","iconCheckGray.gif","iconUncheckDis.gif","iconCheckDis.gif","iconCheckDis.gif");
   this.radioArray=new Array("radio_off.gif","radio_on.gif","radio_on.gif","radio_off.gif","radio_on.gif","radio_on.gif");

   this.lineArray=new Array("line2.gif","line3.gif","line4.gif","blank.gif","blank.gif","line1.gif");
   this.minusArray=new Array("minus2.gif","minus3.gif","minus4.gif","minus.gif","minus5.gif");
   this.plusArray=new Array("plus2.gif","plus3.gif","plus4.gif","plus.gif","plus5.gif");
   this.imageArray=new Array("leaf.gif","folderOpen.gif","folderClosed.gif");
   this.cutImg= new Array(0,0,0);
   this.cutImage="but_cut.gif";
   
   dhx4._eventable(this);

   this.dragger= new dhtmlDragAndDropObject();
//create root
   this.htmlNode=new dhtmlXTreeItemObject(this.rootId,"",0,this);
   this.htmlNode.htmlNode.childNodes[0].childNodes[0].style.display="none";
   this.htmlNode.htmlNode.childNodes[0].childNodes[0].childNodes[0].className="hiddenRow";
//init tree structures
   this.allTree=this._createSelf();
   this.allTree.appendChild(this.htmlNode.htmlNode);

   if (dhtmlx.$customScroll)
      dhtmlx.CustomScroll.enable(this);

    if(_isFF){
         this.allTree.childNodes[0].width="100%";
         this.allTree.childNodes[0].style.overflow="hidden";
    }

   var self=this;
   this.allTree.onselectstart=new Function("return false;");
   if (_isMacOS)
		this.allTree.oncontextmenu = function(e){ 
			return self._doContClick(e||window.event, true); 
		};   
   this.allTree.onmousedown = function(e){ return self._doContClick(e||window.event); };  
   
   this.XMLLoader=this._parseXMLTree;
   if (_isIE) this.preventIECashing(true);

//#__pro_feature:01112006{
//#complex_move:01112006{
   this.selectionBar=document.createElement("DIV");
   this.selectionBar.className="selectionBar";
   this.selectionBar.innerHTML="&nbsp;";
   this.selectionBar.style.display="none";
   this.allTree.appendChild(this.selectionBar);
//#}
//#}

    
    if (window.addEventListener) window.addEventListener("unload",function(){try{  self.destructor(); } catch(e){}},false);
    if (window.attachEvent) window.attachEvent("onunload",function(){ try{ self.destructor(); } catch(e){}});

	this.setImagesPath=this.setImagePath;
	this.setIconsPath=this.setIconPath;

	this.setSkin(window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxtree")||"material");
	if (dhtmlx.image_path) {
		var path = dhtmlx.image_path;
		var sk = this.parentObject.className.match(/dhxtree_dhx_([a-z_]*)/i);
		if (sk != null && sk[1] != null) path += "dhxtree_"+sk[1]+"/";
		this.setImagePath(path);
	}

   return this;
};


/**
*     @desc: set default data transfer mode 
*     @param: mode - data mode (json,xml,csv)
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setDataMode=function(mode){
		this._datamode=mode;
}


	
dhtmlXTreeObject.prototype._doContClick=function(ev, force){
	if (!force && ev.button!=2) {
		if(this._acMenu){
			if (this._acMenu.hideContextMenu)
				this._acMenu.hideContextMenu()
			else
				this.cMenu._contextEnd();
		}
		return true;
	}
	
 	

	
	var el=(_isIE?ev.srcElement:ev.target);
	while ((el)&&(el.tagName!="BODY")) {
		if (el.parentObject) break;
    	 el=el.parentNode;
	 }
    	
    if ((!el)||(!el.parentObject)) return true;
    
    var obj=el.parentObject;
    
    if (!this.callEvent("onRightClick",[obj.id,ev]))
        (ev.srcElement||ev.target).oncontextmenu = function(e){ (e||event).cancelBubble=true; return false; };
        
    	this._acMenu=(obj.cMenu||this.cMenu);
        if (this._acMenu){
       		if (!(this.callEvent("onBeforeContextMenu", [
					obj.id
				]))) return true; 	
				if(!_isMacOS)
	        (ev.srcElement||ev.target).oncontextmenu = function(e){ (e||event).cancelBubble=true; return false; };
	               
			if (this._acMenu.showContextMenu){

var dEl0=window.document.documentElement;
var dEl1=window.document.body;
var corrector = new Array((dEl0.scrollLeft||dEl1.scrollLeft),(dEl0.scrollTop||dEl1.scrollTop));
if (_isIE){
	var x= ev.clientX+corrector[0];
	var y = ev.clientY+corrector[1];
} else {
	var x= ev.pageX;
	var y = ev.pageY;
}
				
				this._acMenu.showContextMenu(x-1,y-1)
				this.contextID=obj.id;
				ev.cancelBubble=true;
				this._acMenu._skip_hide=true;
			} else {
				el.contextMenuId=obj.id;
				el.contextMenu=this._acMenu;
				el.a=this._acMenu._contextStart;
				el.a(el, ev);
				el.a=null;
			}
	        	
			return false;           
    	}
    return true;
}


/**
*     @desc: replace IMG tag with background images - solve problem with IE image caching , not works for IE6 SP1
*     @param: mode - true/false - enable/disable fix
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.enableIEImageFix=function(mode){
	if (!mode){

	this._getImg=function(id){ return document.createElement((id==this.rootId)?"div":"img"); }
	//this._setSrc=function(a,b){ a.src=b; }
	this._setSrc=function(a,b){ a.src=b; }
	this._getSrc=function(a){ return a.src; }
	}	else	{

	this._getImg=function(){ var z=document.createElement("DIV"); z.innerHTML="&nbsp;"; z.className="dhx_bg_img_fix"; return z; }
	this._setSrc=function(a,b){ a.style.backgroundImage="url("+b+")"; }
	this._getSrc=function(a){ var z=a.style.backgroundImage;  return z.substr(4,z.length-5).replace(/(^")|("$)/g,""); }
	}
}

/**
*	@desc: deletes tree and clears memory
*	@type: public
*/
dhtmlXTreeObject.prototype.destructor=function(){
    for (var a in this._idpull){
        var z=this._idpull[a];
		if (!z) continue;
        z.parentObject=null;z.treeNod=null;z.childNodes=null;z.span=null;z.tr.nodem=null;z.tr=null;z.htmlNode.objBelong=null;z.htmlNode=null;
        this._idpull[a]=null;
        }
    this.parentObject.innerHTML="";
    
    this.allTree.onselectstart = null;
    this.allTree.oncontextmenu = null;
    this.allTree.onmousedown = null;
        
    for(var a in this){
        this[a]=null;
        }
}

function cObject(){
    return this;
}
cObject.prototype= new Object;
cObject.prototype.clone = function () {
       function _dummy(){};
       _dummy.prototype=this;
       return new _dummy();
    }

/**
*   @desc: tree node constructor
*   @param: itemId - node id
*   @param: itemText - node label
*   @param: parentObject - parent item object
*   @param: treeObject - tree object
*   @param: actionHandler - onclick event handler(optional)
*   @param: mode - do not show images
*   @type: private
*   @topic: 0
*/
function dhtmlXTreeItemObject(itemId,itemText,parentObject,treeObject,actionHandler,mode){
   this.htmlNode="";
   this.acolor="";
   this.scolor="";
   this.tr=0;
   this.childsCount=0;
   this.tempDOMM=0;
   this.tempDOMU=0;
   this.dragSpan=0;
   this.dragMove=0;
   this.span=0;
   this.closeble=1;
   this.childNodes=new Array();
   this.userData=new cObject();


   this.checkstate=0;
   this.treeNod=treeObject;
   this.label=itemText;
   this.parentObject=parentObject;
   this.actionHandler=actionHandler;
   this.images=new Array(treeObject.imageArray[0],treeObject.imageArray[1],treeObject.imageArray[2]);


   this.id=treeObject._globalIdStorageAdd(itemId,this);
   if (this.treeNod.checkBoxOff ) this.htmlNode=this.treeNod._createItem(1,this,mode);
   else  this.htmlNode=this.treeNod._createItem(0,this,mode);

   this.htmlNode.objBelong=this;
   return this;
   };   


/**
*     @desc: register node
*     @type: private
*     @param: itemId - node id
*     @param: itemObject - node object
*     @topic: 3  
*/
   dhtmlXTreeObject.prototype._globalIdStorageAdd=function(itemId,itemObject){
      if (this._globalIdStorageFind(itemId,1,1)) {   itemId=itemId +"_"+(new Date()).valueOf(); return this._globalIdStorageAdd(itemId,itemObject); }
	  	 this._idpull[itemId]=itemObject;
         this._pullSize++;
      return itemId;
   };

/**
*     @desc: unregister node
*     @type: private
*     @param: itemId - node id
*     @topic: 3
*/
   dhtmlXTreeObject.prototype._globalIdStorageSub=function(itemId){
        if (this._idpull[itemId]){
		    this._unselectItem(this._idpull[itemId]);
			this._idpull[itemId]=null;
			this._pullSize--;
        }
		if ((this._locker)&&(this._locker[itemId])) this._locker[itemId]=false;
   };
   
/**
*     @desc: return node object
*     @param: itemId - node id
*     @type: private
*     @topic: 3
*/
   dhtmlXTreeObject.prototype._globalIdStorageFind=function(itemId,skipXMLSearch,skipParsing,isreparse){
		var z=this._idpull[itemId];
        if (z){
//#__pro_feature:01112006{
//#smart_parsing:01112006{
            if ((z.unParsed)&&(!skipParsing))
                    {
                    this.reParse(z,0);
                    }
            if (this._srnd && !z.htmlNode) this._buildSRND(z,skipParsing);
                if ((isreparse)&&(this._edsbpsA)){
                    for (var j=0; j<this._edsbpsA.length; j++)
                        if (this._edsbpsA[j][2]==itemId){
                            dhx4.callEvent("ongetItemError",["Requested item still in parsing process.",itemId]);
                            return null;
                        }
                    }
//#}
//#}
            return z;
            }
//#__pro_feature:01112006{
//#smart_parsing:01112006{
      if ((this.slowParse)&&(itemId!=0)&&(!skipXMLSearch)) return this.preParse(itemId);
      else
//#}
//#}
	  	return null;
   };
//#__pro_feature:01112006{
//#smart_parsing:01112006{
dhtmlXTreeObject.prototype._getSubItemsXML=function(p){
      var z=[];
      p.each("item",function(c){
      	z.push(c.get("id"));
      },this)
      return z.join(this.dlmtr);
    }

/**
*     @desc: enable/disable smart XML parsing mode (usefull for big, well structured XML)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableSmartXMLParsing=function(mode) { this.slowParse=dhx4.s2b(mode); };
   dhtmlXTreeObject.prototype.findXML=function(node,par,val){  }

dhtmlXTreeObject.prototype._getAllCheckedXML=function(p,list,mode){
	var z=[];
	
	if (mode==2)
		p.through("item","checked",-1,function(c){
			z.push(c.get("id"));
  		},this);
  	
  	if (mode==1)
  		p.through("item","id",null,function(c){
  			if (c.get("checked") && (c.get("checked") !=-1))
			z.push(c.get("id"));
  		},this);
  		
	if (mode==0)
  		p.through("item","id",null,function(c){
			if (!c.get("checked") || c.get("checked")==0 )
			z.push(c.get("id"));
  		},this);  		
    if(z.length)
  		return list+(list?this.dlmtr:"")+z.join(this.dlmtr);
      if (list) return list; else return "";
   };


/**
*     @desc: change state of node's checkbox and all childnodes checkboxes
*     @type: private
*     @param: itemId - target node id
*     @param: state - checkbox state
*     @param: sNode - target node object (optional, used by private methods)
*     @topic: 5
*/
   dhtmlXTreeObject.prototype._setSubCheckedXML=function(state,p){
	   	var val= state?"1":"";
	   	p.through("item","id",null,function(c){
			if (!c.get("disabled") || c.get("disabled")==0 )
	   		    c.set("checked",val);
	   	},this);
}

       dhtmlXTreeObject.prototype._getAllScraggyItemsXML=function(p,x){
        var z=[];
        var fff=function(c){
	   		if (!c.sub_exists("item"))
	   			z.push(c.get("id"));
	   		else
	   			c.each("item",fff,this);
		   	}
	    fff(p);
        return z.join(",");
    }
    
   dhtmlXTreeObject.prototype._getAllFatItemsXML=function(p,x){
        var z=[];
        var fff=function(c){
	   		if (!c.sub_exists("item"))
	   			return;
   			z.push(c.get("id"));
   			c.each("item",fff,this);
		   	}
	    fff(p);
        return z.join(",");
    }

dhtmlXTreeObject.prototype._getAllSubItemsXML=function(itemId,z,p){
      var z=[];
      p.through("item","id",null,function(c){
      	z.push(c.get("id"));
      },this)
      return z.join(",");
    }

/**
*     @desc: parse stored xml
*     @param: node - XML node
*     @type: private
*     @edition: Professional
*     @topic: 3  
*/
 dhtmlXTreeObject.prototype.reParse=function(node){
        var that=this;
      if (!this.parsCount) that.callEvent("onXLS",[that,node.id]);
      this.xmlstate=1;

      var tmp=node.unParsed;
      node.unParsed=0;
//               if (confirm("reParse "+node.id)) { window.asdasd.asdasd(); }
      this.XMLloadingWarning=1;
        var oldpid=this.parsingOn;
		var oldmd=this.waitUpdateXML;
		var oldpa=this.parsedArray;

		this.parsedArray=new Array();
	  	this.waitUpdateXML=false;
      this.parsingOn=node.id;
      this.parsedArray=new Array();

         this.setCheckList="";
         this._parse(tmp,node.id,2);
         var chArr=this.setCheckList.split(this.dlmtr);

      for (var i=0; i<this.parsedArray.length; i++)
         node.htmlNode.childNodes[0].appendChild(this.parsedArray[i]);
      
	  if (tmp.get("order") && tmp.get("order")!="none")
	  	 	this._reorderBranch(node,tmp.get("order"),true);
	  	 	
            this.oldsmcheck=this.smcheck;
            this.smcheck=false;

         for (var n=0; n<chArr.length; n++)
            if (chArr[n])  this.setCheck(chArr[n],1);
            this.smcheck=this.oldsmcheck;

      this.parsingOn=oldpid;
	  this.waitUpdateXML=oldmd;
	  this.parsedArray=oldpa;  	  
      this.XMLloadingWarning=0;
      this._redrawFrom(this,node);
      if (this._srnd && !node._sready)
      	this.prepareSR(node.id);
      this.xmlstate=0;
      return true;
   }

/**
*     @desc: search for item in unparsed chunks
*     @param: itemId - item ID
*     @type: private
*     @edition: Professional
*     @topic: 3
*/
dhtmlXTreeObject.prototype.preParse=function(itemId){
   if (!itemId || !this._p) return null; 
   var result=false;
   this._p.clone().through("item","id",itemId,function(c){
   		this._globalIdStorageFind(c.up().get("id"));
   		return result=true;
   	},this);
   	if (result){
   		var n=this._globalIdStorageFind(itemId,true,false);
   		if (!n)
   			dhx4.callEvent("ongetItemError",["The item "+itemId+" not operable. Seems you have non-unique|incorrect IDs in tree's XML.",itemId]);
   	}
   	return n;
}

//#}
//#}

/**
*     @desc: escape string
*     @param: itemId - item ID
*     @type: private
*     @topic: 3
*/
   dhtmlXTreeObject.prototype._escape=function(str){
        switch(this.utfesc){
        case "none":
            return str;
            break;
        case "utf8":
         return encodeURIComponent(str);
            break;
        default:
         return escape(str);
            break;
        }
   }



/**
*     @desc: create and return  new line in tree
*     @type: private
*     @param: htmlObject - parent Node object
*     @param: node - item object
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype._drawNewTr=function(htmlObject,node)
   {
      var tr =document.createElement('tr');
      var td1=document.createElement('td');
      var td2=document.createElement('td');
      td1.appendChild(document.createTextNode(" "));
      td2.colSpan=3;
      td2.appendChild(htmlObject);
      tr.appendChild(td1);  tr.appendChild(td2);
      return tr;
   };
/**
*     @desc: load tree from xml string
*     @type: public
*     @param: xmlString - XML string
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.parse=function(xmlString,afterCall,type){
      if (typeof afterCall == "string"){
        type = afterCall;
        afterCall = null;
      }

      if (type === "json")
        return this._loadJSONObject(xmlString, afterCall)
      else if (type === "csv")
        return this._loadCSVString(xmlString, afterCall);
      else if (type === "jsarray")
        return this._loadJSArray(xmlString, afterCall);

      var that=this;
      if (!this.parsCount) this.callEvent("onXLS",[that,null]);
      this.xmlstate=1;
      this.XMLLoader({ responseXML:dhx4.ajax.parse(xmlString)}, afterCall);
    };

    dhtmlXTreeObject.prototype.loadXMLString = function(){
      if (window.console && window.console.info)
        window.console.info("loadXMLString was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
      return this.parse.apply(this, arguments);
    }

/**
*     @desc: load tree from xml file
*     @type: public
*     @param: file - link to XML file
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
	dhtmlXTreeObject.prototype.load=function(file,afterCall,type){ 
    if (typeof afterCall == "string"){
      type = afterCall;
      afterCall = null;
    }

    type = type || this._datamode;
    if (type === "json")
      return this._loadJSON(file, afterCall)
    else if (type === "csv")
      return this._loadCSV(file, afterCall);
    else if (type === "jsarray")
      return this._loadJSArrayFile(xmlString, afterCall);

      var that=this;
      if (!this.parsCount) this.callEvent("onXLS",[that,this._ld_id]);
      this._ld_id=null;
      this.xmlstate=1;
      this.XMLLoader=this._parseXMLTree;

      var self = this;
      dhx4.ajax.get(file, function(data){
        self.XMLLoader(data.xmlDoc, afterCall);
        self = null;
      });
   };
   dhtmlXTreeObject.prototype.loadXML = function(){
      if (window.console && window.console.info)
        window.console.info("loadXML was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
      return this.load.apply(this, arguments);
   }
/**
*     @desc: create new child node
*     @type: private
*     @param: parentObject - parent node object
*     @param: itemId - new node id
*     @param: itemText - new node text
*     @param: itemActionHandler - function fired on node select event
*     @param: image1 - image for node without children;
*     @param: image2 - image for closed node;
*     @param: image3 - image for opened node
*     @param: optionStr - string of otions
*     @param: childs - node childs flag (for dynamical trees) (optional)
*     @param: beforeNode - node, after which new node will be inserted (optional)
*     @topic: 2
*/
   dhtmlXTreeObject.prototype._attachChildNode=function(parentObject,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,childs,beforeNode,afterNode){

         if (beforeNode && beforeNode.parentObject) parentObject=beforeNode.parentObject;
         if (((parentObject.XMLload==0)&&(this.XMLsource))&&(!this.XMLloadingWarning))
         {
            parentObject.XMLload=1;
                this._loadDynXML(parentObject.id);

         }

         var Count=parentObject.childsCount;
         var Nodes=parentObject.childNodes;


            if (afterNode && afterNode.tr.previousSibling){
            if (afterNode.tr.previousSibling.previousSibling){
               beforeNode=afterNode.tr.previousSibling.nodem;
               }
            else
               optionStr=optionStr.replace("TOP","")+",TOP";
               }

         if (beforeNode)
            {
            var ik,jk;
            for (ik=0; ik<Count; ik++)
               if (Nodes[ik]==beforeNode)
               {
               for (jk=Count; jk!=ik; jk--)
                  Nodes[1+jk]=Nodes[jk];
               break;
               }
            ik++;
            Count=ik;
            }


         if (optionStr) {
             var tempStr=optionStr.split(",");
            for (var i=0; i<tempStr.length; i++)
            {
               switch(tempStr[i])
               {
                  case "TOP": if (parentObject.childsCount>0) { beforeNode=new Object; beforeNode.tr=parentObject.childNodes[0].tr.previousSibling; }
				  	 parentObject._has_top=true;
                     for  (ik=Count; ik>0; ik--)
                        Nodes[ik]=Nodes[ik-1];
                        Count=0;
                     break;
               }
            };
          };

        	var n;
		if (!(n=this._idpull[itemId]) || n.span!=-1){
         	n=Nodes[Count]=new dhtmlXTreeItemObject(itemId,itemText,parentObject,this,itemActionHandler,1);
         	itemId = Nodes[Count].id;
         	parentObject.childsCount++;
     	}
        
        if(!n.htmlNode) {
           n.label=itemText;
		   n.htmlNode=this._createItem((this.checkBoxOff?1:0),n);
   		   n.htmlNode.objBelong=n;
   		  }

         if(image1) n.images[0]=image1;
         if(image2) n.images[1]=image2;
         if(image3) n.images[2]=image3;

		
         var tr=this._drawNewTr(n.htmlNode);
         if ((this.XMLloadingWarning)||(this._hAdI))
            n.htmlNode.parentNode.parentNode.style.display="none";

           
            if ((beforeNode)&&beforeNode.tr&&(beforeNode.tr.nextSibling))
               parentObject.htmlNode.childNodes[0].insertBefore(tr,beforeNode.tr.nextSibling);
            else
               if (this.parsingOn==parentObject.id){
                  this.parsedArray[this.parsedArray.length]=tr;
                        }
               else
                   parentObject.htmlNode.childNodes[0].appendChild(tr);


               if ((beforeNode)&&(!beforeNode.span)) beforeNode=null;

            if (this.XMLsource) if ((childs)&&(childs!=0)) n.XMLload=0; else n.XMLload=1;
            n.tr=tr;
            tr.nodem=n;

            if (parentObject.itemId==0)
                tr.childNodes[0].className="hiddenRow";

            if ((parentObject._r_logic)||(this._frbtr))
                this._setSrc(n.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0],this.imPath+this.radioArray[0]);


          if (optionStr) {
             var tempStr=optionStr.split(",");

            for (var i=0; i<tempStr.length; i++)
            {
               switch(tempStr[i])
               {
                     case "SELECT": this.selectItem(itemId,false); break;
                  case "CALL": this.selectItem(itemId,true);   break;
                  case "CHILD":  n.XMLload=0;  break;
                  case "CHECKED":
                     if (this.XMLloadingWarning)
                        this.setCheckList+=this.dlmtr+itemId;
                     else
                        this.setCheck(itemId,1);
                        break;
                  case "HCHECKED":
                        this._setCheck(n,"unsure");
                        break;                        
                  case "OPEN": n.openMe=1;  break;
               }
            };
          };

      if (!this.XMLloadingWarning)
      {
             if ((this._getOpenState(parentObject)<0)&&(!this._hAdI)) this.openItem(parentObject.id);

             if (beforeNode)
                {
             this._correctPlus(beforeNode);
             this._correctLine(beforeNode);
                }
             this._correctPlus(parentObject);
             this._correctLine(parentObject);
             this._correctPlus(n);
             if (parentObject.childsCount>=2)
             {
                   this._correctPlus(Nodes[parentObject.childsCount-2]);
                   this._correctLine(Nodes[parentObject.childsCount-2]);
             }
             if (parentObject.childsCount!=2) this._correctPlus(Nodes[0]);

         if (this.tscheck) this._correctCheckStates(parentObject);

            if (this._onradh){
				if (this.xmlstate==1){
					var old=this.onXLE;
					this.onXLE=function(id){ this._onradh(itemId); if (old) old(id); }
					}
				else
					this._onradh(itemId);
			}

      }
   return n;
};


//#__pro_feature:01112006{
//#context_menu:01112006{

/**
*     @desc: enable context menu
*     @param: menu - dhtmlXMenu object
*     @edition: Professional
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableContextMenu=function(menu){  if (menu) this.cMenu=menu; };

/**
*     @desc: set context menu to individual nodes
*     @type: public
*     @param: itemId - node id
*     @param: cMenu - context menu object
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setItemContextMenu=function(itemId,cMenu){
   var l=itemId.toString().split(this.dlmtr);
   for (var i=0; i<l.length; i++)
      {
      var temp=this._globalIdStorageFind(l[i]);
      if (!temp) continue;
      temp.cMenu=cMenu;
      }
}

//#}
//#}

/**
*     @desc: create new node as a child to specified with parentId
*     @type: deprecated
*     @param: parentId - parent node id
*     @param: itemId - new node id
*     @param: itemText - new node text
*     @param: itemActionHandler - function fired on node select event (optional)
*     @param: image1 - image for node without children; (optional)
*     @param: image2 - image for closed node; (optional)
*     @param: image3 - image for opened node (optional)
*     @param: optionStr - options string (optional)            
*     @param: children - node children flag (for dynamical trees) (optional)
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype.insertNewItem=function(parentId,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children){
      var parentObject=this._globalIdStorageFind(parentId);
      if (!parentObject) return (-1);
      var nodez=this._attachChildNode(parentObject,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children);
      if(!this._idpull[this.rootId].XMLload)
         this._idpull[this.rootId].XMLload = 1;
//#__pro_feature:01112006{
//#child_calc:01112006{
      if ((!this.XMLloadingWarning)&&(this.childCalc))  this._fixChildCountLabel(parentObject);
//#}
//#}
        return nodez;
   };
/**
*     @desc: create new node as a child to specified with parentId
*     @type: public
*     @param: parentId - parent node id
*     @param: itemId - new node id
*     @param: itemText - new node label
*     @param: itemActionHandler - function fired on node select event (optional)
*     @param: image1 - image for node without children; (optional)
*     @param: image2 - image for closed node; (optional)
*     @param: image3 - image for opened node (optional)
*     @param: optionStr - options string (optional)            
*     @param: children - node children flag (for dynamical trees) (optional)
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype.insertNewChild=function(parentId,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children){
      return this.insertNewItem(parentId,itemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children);
   }   
/**  
*     @desc: parse xml
*     @type: private
*     @param: dhtmlObject - jsTree object
*     @param: node - top XML node
*     @param: parentId - parent node id
*     @param: level - level of tree
*     @topic: 2
*/
	dhtmlXTreeObject.prototype._parseXMLTree=function(xml, callback){
		var p=new xmlPointer(dhx4.ajax.xmltop("tree", xml));
		this._parse(p);
		this._p=p;
    if (callback) callback.call(this, xml);
	}
	
	dhtmlXTreeObject.prototype._parseItem=function(c,temp,preNode,befNode){ 
		var id;
		if (this._srnd && (!this._idpull[id=c.get("id")] || !this._idpull[id].span))
		{
			this._addItemSRND(temp.id,id,c);
			return; 
		}
		
  var a=c.get_all();
        
        if ((typeof(this.waitUpdateXML)=="object")&&(!this.waitUpdateXML[a.id])){
			this._parse(c,a.id,1);
			return;
		}    

//#__pro_feature:01112006{
			if ((a.text===null)||(typeof(a.text)=="undefined")){
				a.text=c.sub("itemtext");
				if (a.text) a.text=a.text.content();
			}
//#}
              



                  var zST=[];
                  if (a.select) zST.push("SELECT");
                  if (a.top) zST.push("TOP");
                  if (a.call) this.nodeAskingCall=a.id;
                  if (a.checked==-1) zST.push("HCHECKED");
                     else if (a.checked) zST.push("CHECKED");
                  if (a.open) zST.push("OPEN");
	
    	          if (this.waitUpdateXML){
				  		if (this._globalIdStorageFind(a.id))
	    	            	var newNode=this.updateItem(a.id,a.text,a.im0,a.im1,a.im2,a.checked,a.child);
						else{
							if (this.npl==0) zST.push("TOP");
							else preNode=temp.childNodes[this.npl];

		                    var newNode=this._attachChildNode(temp,a.id,a.text,0,a.im0,a.im1,a.im2,zST.join(","),a.child,0,preNode);
                        a.id = newNode.id;
							preNode=null;
						}
					 }
                  else
                     var newNode=this._attachChildNode(temp,a.id,a.text,0,a.im0,a.im1,a.im2,zST.join(","),a.child,(befNode||0),preNode);
                  if (a.tooltip)
					newNode.span.parentNode.parentNode.title=a.tooltip;

                  if (a.style)
                            if (newNode.span.style.cssText)
                                newNode.span.style.cssText+=(";"+a.style);
                            else
                                newNode.span.setAttribute("style",newNode.span.getAttribute("style")+"; "+a.style);

                        if (a.radio) newNode._r_logic=true;

                  if (a.nocheckbox){
                  	 var check_node=newNode.span.parentNode.previousSibling.previousSibling;
                     check_node.style.display="none";
                     newNode.nocheckbox=true;
                  }
                        if (a.disabled){
                            if (a.checked!=null) this._setCheck(newNode,a.checked);
                            this.disableCheckbox(newNode,1);
                            }

				
                  newNode._acc=a.child||0;

                  if (this.parserExtension) this.parserExtension._parseExtension.call(this,c,a,(temp?temp.id:0));

                  this.setItemColor(newNode,a.aCol,a.sCol);
                  if (a.locked=="1")    this.lockItem(newNode.id,true,true);

                  if ((a.imwidth)||(a.imheight))   this.setIconSize(a.imwidth,a.imheight,newNode);
                  if ((a.closeable=="0")||(a.closeable=="1"))  this.setItemCloseable(newNode,a.closeable);
                  var zcall="";
                  if (a.topoffset) this.setItemTopOffset(newNode,a.topoffset);
                  if ((!this.slowParse)||(typeof(this.waitUpdateXML)=="object")){ 
                  	if (c.sub_exists("item"))
                    	zcall=this._parse(c,a.id,1);
                  }
//#__pro_feature:01112006{
//#smart_parsing:01112006{
                  else {
                  	if ((!newNode.childsCount) && c.sub_exists("item"))
                      newNode.unParsed=c.clone();
                     
						c.each("userdata",function(u){
							this.setUserData(a.id,u.get("name"),u.content());
						},this);
     	  	      }
//#}                     
//#}
                  if (zcall!="") this.nodeAskingCall=zcall;

   
        c.each("userdata",function(u){
    	  		this.setUserData(c.get("id"),u.get("name"),u.content());
 	  	  },this)
		
		
	}
   	dhtmlXTreeObject.prototype._parse=function(p,parentId,level,start){ 
   		if (this._srnd && !this.parentObject.offsetHeight) {
   			var self=this;
   			return window.setTimeout(function(){
   				self._parse(p,parentId,level,start);
   			},100);
   		}
		if (!p.exists()) return;
		
		this.skipLock=true; //disable item locking
		//loading flags
		
		
		if (!parentId) {          //top level  
			parentId=p.get("id");
			
	  // deleting child items for refreshed branches
	  if(this._dynDeleteBranches[parentId]){
		 this.deleteChildItems(parentId);
		 this._dynDeleteBranches[parentId]--;
		 if(!this._dynDeleteBranches[parentId]){
			delete this._dynDeleteBranches[parentId];
		 }	
	  }
	  
      var skey = p.get("dhx_security");
      if (skey)
          dhtmlx.security_key = skey;

			if (p.get("radio"))
				this.htmlNode._r_logic=true;
			this.parsingOn=parentId;                 
			this.parsedArray=new Array();
			this.setCheckList="";
			this.nodeAskingCall="";
		}
		
		var temp=this._globalIdStorageFind(parentId);
		if (!temp) return dhx4.callEvent("onDataStructureError",["XML refers to not existing parent"]);

		this.parsCount=this.parsCount?(this.parsCount+1):1;
		this.XMLloadingWarning=1;

		if ((temp.childsCount)&&(!start)&&(!this._edsbps)&&(!temp._has_top))
            var preNode=0;//temp.childNodes[temp.childsCount-1];
        else
            var preNode=0;

        this.npl=0;

		p.each("item",function(c,i){
				
		temp.XMLload=1;
				
          this._parseItem(c,temp,0,preNode); 
 	  	  
//#__pro_feature:01112006{
//#distributed_load:01112006{
              if ((this._edsbps)&&(this.npl==this._edsbpsC)){
                this._distributedStart(p,i+1,parentId,level,temp.childsCount);
                return -1;
              }
//#}
//#}
              this.npl++;
         

 	  	  
      },this,start);


      if (!level) {
      	  p.each("userdata",function(u){
    	  		this.setUserData(p.get("id"),u.get("name"),u.content());
 	  	  },this);
 	  	  
	  	 temp.XMLload=1;
         if (this.waitUpdateXML){
            this.waitUpdateXML=false;
			for (var i=temp.childsCount-1; i>=0; i--)
				if (temp.childNodes[i]._dmark)
					this.deleteItem(temp.childNodes[i].id);
			}

         var parsedNodeTop=this._globalIdStorageFind(this.parsingOn);

         for (var i=0; i<this.parsedArray.length; i++)
               temp.htmlNode.childNodes[0].appendChild(this.parsedArray[i]);
		this.parsedArray = [];
		
         this.lastLoadedXMLId=parentId;
         this.XMLloadingWarning=0;

         var chArr=this.setCheckList.split(this.dlmtr);
         for (var n=0; n<chArr.length; n++)
            if (chArr[n]) this.setCheck(chArr[n],1);

               if ((this.XMLsource)&&(this.tscheck)&&(this.smcheck)&&(temp.id!=this.rootId)){
                if (temp.checkstate===0)
                    this._setSubChecked(0,temp);
                else if (temp.checkstate===1)
                    this._setSubChecked(1,temp);
            }

         this._redrawFrom(this,null,start)
		 if (p.get("order") && p.get("order")!="none")
	  	 	this._reorderBranch(temp,p.get("order"),true);
	  	 	
	  	 if (this.nodeAskingCall!="") this.callEvent("onClick",[this.nodeAskingCall,this.getSelectedItemId()]); 
         if (this._branchUpdate) this._branchUpdateNext(p);
	     }


      if (this.parsCount==1) {
      	 this.parsingOn=null;
//#__pro_feature:01112006{
//#smart_parsing:01112006{
          //if ((this.slowParse)&&(this.parsingOn==this.rootId))
         if (this._srnd && temp.id!=this.rootId){
 	  	 	this.prepareSR(temp.id);
 	  	 	if (this.XMLsource) this.openItem(temp.id)
 	  	 }
 	  	 
            p.through("item","open",null,function(c){
            	this.openItem(c.get("id"));
            	},this);
//#}
//#}

         
         if ((!this._edsbps)||(!this._edsbpsA.length)){
         		var that=this;
               	window.setTimeout( function(){  that.callEvent("onXLE",[that,parentId]); },1);
                this.xmlstate=0;
                }
             this.skipLock=false;
         }
      this.parsCount--;

//#__pro_feature:01112006{
//#distributed_load:01112006{
		var that=this;
        if (this._edsbps) window.setTimeout(function(){ that._distributedStep(parentId); },this._edsbpsD);
//#}
//#}

        
		
		if (!level && this.onXLE) this.onXLE(this,parentId);
      return this.nodeAskingCall;
  };
  

dhtmlXTreeObject.prototype._branchUpdateNext=function(p){
	p.each("item",function(c){
		var nid=c.get("id");
		if (this._idpull[nid] && (!this._idpull[nid].XMLload))  return;
		this._branchUpdate++;
		this.smartRefreshItem(c.get("id"),c);
	},this)
	this._branchUpdate--;
} 

  dhtmlXTreeObject.prototype.checkUserData=function(node,parentId){
      if ((node.nodeType==1)&&(node.tagName == "userdata"))
      {
         var name=node.getAttribute("name");
            if ((name)&&(node.childNodes[0]))
               this.setUserData(parentId,name,node.childNodes[0].data);
      }
  }




/**  
*     @desc: reset tree images from selected level
*     @type: private
*     @param: dhtmlObject - tree
*     @param: itemObject - current item
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._redrawFrom=function(dhtmlObject,itemObject,start,visMode){
      if (!itemObject) {
      var tempx=dhtmlObject._globalIdStorageFind(dhtmlObject.lastLoadedXMLId);
      dhtmlObject.lastLoadedXMLId=-1;
      if (!tempx) return 0;
      }
      else tempx=itemObject;
      var acc=0;
      for (var i=(start?start-1:0); i<tempx.childsCount; i++)
      {
	  	 if ((!this._branchUpdate)||(this._getOpenState(tempx)==1))
	         if ((!itemObject)||(visMode==1)) tempx.childNodes[i].htmlNode.parentNode.parentNode.style.display="";
         if (tempx.childNodes[i].openMe==1)
            {
            this._openItem(tempx.childNodes[i]);
            tempx.childNodes[i].openMe=0;
            }

         dhtmlObject._redrawFrom(dhtmlObject,tempx.childNodes[i]);
//#__pro_feature:01112006{
//#child_calc:01112006{
      if (this.childCalc!=null){

      if ((tempx.childNodes[i].unParsed)||((!tempx.childNodes[i].XMLload)&&(this.XMLsource)))
      {

         if (tempx.childNodes[i]._acc)
         tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+tempx.childNodes[i]._acc+this.htmlcB;
         else
         tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label;
      }
         if ((tempx.childNodes[i].childNodes.length)&&(this.childCalc))
         {
            if (this.childCalc==1)
               {
               tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+tempx.childNodes[i].childsCount+this.htmlcB;
               }
            if (this.childCalc==2)
               {
               var zCount=tempx.childNodes[i].childsCount-(tempx.childNodes[i].pureChilds||0);
               if (zCount)
                  tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+zCount+this.htmlcB;
               if (tempx.pureChilds) tempx.pureChilds++; else tempx.pureChilds=1;
               }
            if (this.childCalc==3)
               {
               tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+tempx.childNodes[i]._acc+this.htmlcB;
               }
            if (this.childCalc==4)
               {
               var zCount=tempx.childNodes[i]._acc;
               if (zCount)
                  tempx.childNodes[i].span.innerHTML=tempx.childNodes[i].label+this.htmlcA+zCount+this.htmlcB;
               }               
         }
            else if (this.childCalc==4)   {
               acc++;
               }   
            
         acc+=tempx.childNodes[i]._acc;
         
         if (this.childCalc==3){
            acc++;
         }

         }
//#}
//#}

      };

      if ((!tempx.unParsed)&&((tempx.XMLload)||(!this.XMLsource)))
      tempx._acc=acc;
      dhtmlObject._correctLine(tempx);
      dhtmlObject._correctPlus(tempx);
//#__pro_feature:01112006{
//#child_calc:01112006{
      if ((this.childCalc)&&(!itemObject)) dhtmlObject._fixChildCountLabel(tempx);
//#}
//#}
   };

/**
*     @desc: create and return main html element of tree
*     @type: private
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype._createSelf=function(){
      var div=document.createElement('div');
      div.className="containerTableStyle";
      div.style.width=this.width;
      div.style.height=this.height;
      this.parentObject.appendChild(div);
      return div;
   };

/**
*     @desc: collapse target node
*     @type: private
*     @param: itemObject - item object
*     @topic: 4  
*/
   dhtmlXTreeObject.prototype._xcloseAll=function(itemObject)
   {
        if (itemObject.unParsed) return;
      if (this.rootId!=itemObject.id) {
      		if (!itemObject.htmlNode) return;//srnd
          var Nodes=itemObject.htmlNode.childNodes[0].childNodes;
            var Count=Nodes.length;

          for (var i=1; i<Count; i++)
             Nodes[i].style.display="none";

          this._correctPlus(itemObject);
      }

       for (var i=0; i<itemObject.childsCount; i++)
            if (itemObject.childNodes[i].childsCount)
             this._xcloseAll(itemObject.childNodes[i]);
   };
/**
*     @desc: expand target node
*     @type: private
*     @param: itemObject - item object
*     @topic: 4
*/      
   dhtmlXTreeObject.prototype._xopenAll=function(itemObject)
   {
      this._HideShow(itemObject,2);
      for (var i=0; i<itemObject.childsCount; i++)
         this._xopenAll(itemObject.childNodes[i]);
   };      
/**  
*     @desc: set correct tree-line and node images
*     @type: private
*     @param: itemObject - item object
*     @topic: 6  
*/
dhtmlXTreeObject.prototype._correctPlus=function(itemObject){
	if (!itemObject.htmlNode) return;
        var imsrc=itemObject.htmlNode.childNodes[0].childNodes[0].childNodes[0].lastChild;
        var imsrc2=itemObject.htmlNode.childNodes[0].childNodes[0].childNodes[2].childNodes[0];
        
        var workArray=this.lineArray;
        if ((this.XMLsource)&&(!itemObject.XMLload)) {
        	var workArray=this.plusArray;
        	this._setSrc(imsrc2,this.iconURL+itemObject.images[2]);
                if (this._txtimg) return (imsrc.innerHTML="[+]");
        } else if ((itemObject.childsCount)||(itemObject.unParsed)) {
        	if ((itemObject.htmlNode.childNodes[0].childNodes[1])&&( itemObject.htmlNode.childNodes[0].childNodes[1].style.display!="none" )) {
        		if (!itemObject.wsign) var workArray=this.minusArray;
        		this._setSrc(imsrc2,this.iconURL+itemObject.images[1]);
        		if (this._txtimg) return (imsrc.innerHTML="[-]");
        	} else {
        		if (!itemObject.wsign) var workArray=this.plusArray;
        		this._setSrc(imsrc2,this.iconURL+itemObject.images[2]);
        		if (this._txtimg) return (imsrc.innerHTML="[+]");
        	}
        } else {
        	this._setSrc(imsrc2,this.iconURL+itemObject.images[0]);
        }
        
        
        var tempNum=2;
        if (!itemObject.treeNod.treeLinesOn) {
        	this._setSrc(imsrc,this.imPath+workArray[3]);
        } else {
        	if (itemObject.parentObject) tempNum=this._getCountStatus(itemObject.id,itemObject.parentObject);
        	this._setSrc(imsrc,this.imPath+workArray[tempNum]);
        }
};

/**
*     @desc: set correct tree-line images
*     @type: private
*     @param: itemObject - item object
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._correctLine=function(itemObject){
   	  if (!itemObject.htmlNode) return;
      var sNode=itemObject.parentObject;
      if (sNode)
         if ((this._getLineStatus(itemObject.id,sNode)==0)||(!this.treeLinesOn))
               for(var i=1; i<=itemObject.childsCount; i++){
                  if (!itemObject.htmlNode.childNodes[0].childNodes[i]) break;
                  itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundImage="";
                  itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundRepeat="";
                }
            else
               for(var i=1; i<=itemObject.childsCount; i++){
               	 if (!itemObject.htmlNode.childNodes[0].childNodes[i]) break;
               	 itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundImage="url("+this.imPath+this.lineArray[5]+")";
               	 itemObject.htmlNode.childNodes[0].childNodes[i].childNodes[0].style.backgroundRepeat="repeat-y";
	     }
   };
/**
*     @desc: return type of node
*     @type: private
*     @param: itemId - item id
*     @param: itemObject - parent node object
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getCountStatus=function(itemId,itemObject){
      if (itemObject.childsCount<=1) { if (itemObject.id==this.rootId) return 4; else  return 0; }

      if (itemObject.childNodes[0].id==itemId) if (itemObject.id==this.rootId) return 2; else return 1;
      if (itemObject.childNodes[itemObject.childsCount-1].id==itemId) return 0;

      return 1;
   };
/**
*     @desc: return type of node
*     @type: private
*     @param: itemId - node id        
*     @param: itemObject - parent node object
*     @topic: 6
*/      
   dhtmlXTreeObject.prototype._getLineStatus =function(itemId,itemObject){
         if (itemObject.childNodes[itemObject.childsCount-1].id==itemId) return 0;
         return 1;
      }

/**  
*     @desc: open/close node 
*     @type: private
*     @param: itemObject - node object        
*     @param: mode - open/close mode [1-close 2-open](optional)
*     @topic: 6
*/      
   dhtmlXTreeObject.prototype._HideShow=function(itemObject,mode){
      if (this._locker && !this.skipLock && this._locker[itemObject.id]) return;
      if ((this.XMLsource)&&(!itemObject.XMLload)) {
            if (mode==1) return; //close for not loaded node - ignore it
            itemObject.XMLload=1;
            this._loadDynXML(itemObject.id);
            return; };
//#__pro_feature:01112006{
//#smart_parsing:01112006{
        if (itemObject.unParsed) this.reParse(itemObject);
//#}
//#}
      var Nodes=itemObject.htmlNode.childNodes[0].childNodes; var Count=Nodes.length;
      if (Count>1){
         if ( ( (Nodes[1].style.display!="none") || (mode==1) ) && (mode!=2) ) {
//nb:solves standard doctype prb in IE
          this.allTree.childNodes[0].border = "1";
          this.allTree.childNodes[0].border = "0";
         nodestyle="none";
         }
         else  nodestyle="";

      for (var i=1; i<Count; i++)
         Nodes[i].style.display=nodestyle;
      }
      this._correctPlus(itemObject);
   }

/**
*     @desc: return node state
*     @type: private
*     @param: itemObject - node object        
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getOpenState=function(itemObject){
   	  if (!itemObject.htmlNode) return 0; //srnd
   	  var z=itemObject.htmlNode.childNodes[0].childNodes;
      if (z.length<=1) return 0;
      if    (z[1].style.display!="none") return 1;
      else return -1;
   }

   

/**  
*     @desc: ondblclick item  event handler
*     @type: private
*     @topic: 0  
*/      
   dhtmlXTreeObject.prototype.onRowClick2=function(){
   	  var that=this.parentObject.treeNod;
      if (!that.callEvent("onDblClick",[this.parentObject.id,that])) return false;
      if ((this.parentObject.closeble)&&(this.parentObject.closeble!="0"))
         that._HideShow(this.parentObject);
      else
         that._HideShow(this.parentObject,2);

   	if    (that.checkEvent("onOpenEnd"))
           if (!that.xmlstate)
				that.callEvent("onOpenEnd",[this.parentObject.id,that._getOpenState(this.parentObject)]);
            else{
                that._oie_onXLE.push(that.onXLE);
                that.onXLE=that._epnFHe;
                }
    	return false;
   };
/**
*     @desc: onclick item event handler
*     @type: private
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.onRowClick=function(){ 
    var that=this.parentObject.treeNod;
	  if (!that.callEvent("onOpenStart",[this.parentObject.id,that._getOpenState(this.parentObject)])) return 0;
      if ((this.parentObject.closeble)&&(this.parentObject.closeble!="0"))
         that._HideShow(this.parentObject);
      else
         that._HideShow(this.parentObject,2);

	
   if    (that.checkEvent("onOpenEnd"))
           if (!that.xmlstate)
				that.callEvent("onOpenEnd",[this.parentObject.id,that._getOpenState(this.parentObject)]);
            else{
                that._oie_onXLE.push(that.onXLE);
                that.onXLE=that._epnFHe;
                }

   };

      dhtmlXTreeObject.prototype._epnFHe=function(that,id,flag){
      	if (id!=this.rootId)
	  		this.callEvent("onOpenEnd",[id,that.getOpenState(id)]);
        that.onXLE=that._oie_onXLE.pop();
        
        if (!flag && !that._oie_onXLE.length)
			if (that.onXLE) that.onXLE(that,id);
    }



/**
*     @desc: onclick item image event handler
*     @type: private
*     @edition: Professional
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.onRowClickDown=function(e){
            e=e||window.event;
         var that=this.parentObject.treeNod;
         that._selectItem(this.parentObject,e);
      };


/*****
SELECTION
*****/

/**
*     @desc: retun selected item id
*     @type: public
*     @return: id of selected item
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.getSelectedItemId=function()
   {
        var str=new Array();
        for (var i=0; i<this._selected.length; i++) str[i]=this._selected[i].id;
      return (str.join(this.dlmtr));
   };

/**
*     @desc: visual select item in tree
*     @type: private
*     @param: node - tree item object
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._selectItem=function(node,e){
   		if (this.checkEvent("onSelect")) this._onSSCFold=this.getSelectedItemId();
//#__pro_feature:01112006{
//#multiselect:01112006{
        if ((!this._amsel)||(!e)||((!e.ctrlKey)&&(!e.metaKey)&&(!e.shiftKey)))
//#}
//#}
            this._unselectItems();
//#__pro_feature:01112006{
//#multiselect:01112006{
            if ((node.i_sel)&&(this._amsel)&&(e)&&(e.ctrlKey || e.metaKey))
                this._unselectItem(node);
            else
            if ((!node.i_sel)&&((!this._amselS)||(this._selected.length==0)||(this._selected[0].parentObject==node.parentObject)))
                if ((this._amsel)&&(e)&&(e.shiftKey)&&(this._selected.length!=0)&&(this._selected[this._selected.length-1].parentObject==node.parentObject)){
                    var a=this._getIndex(this._selected[this._selected.length-1]);
                    var b=this._getIndex(node);
                    if (b<a) { var c=a; a=b; b=c; }
                    for (var i=a; i<=b; i++)
                        if (!node.parentObject.childNodes[i].i_sel)
                            this._markItem(node.parentObject.childNodes[i]);
                    }
                else
//#}
//#}
					this._markItem(node);
		if (this.checkEvent("onSelect")) {
		   	var z=this.getSelectedItemId();
			if (z!=this._onSSCFold)
				this.callEvent("onSelect",[z]);
		}
    }
    dhtmlXTreeObject.prototype._markItem=function(node){
              if (node.scolor)  node.span.style.color=node.scolor;
              node.span.className = "selectedTreeRow";
              node.span.parentNode.parentNode.className = "selectedTreeRowFull";
             node.i_sel=true;
             this._selected[this._selected.length]=node;
    }

/**
*     @desc: retun node index in children collection by Id
*     @type: public
*     @param: itemId - node id
*     @return: node index
*     @topic: 2
*/
   dhtmlXTreeObject.prototype.getIndexById=function(itemId){
         var z=this._globalIdStorageFind(itemId);
         if (!z) return null;
         return this._getIndex(z);
   };
   dhtmlXTreeObject.prototype._getIndex=function(w){
        var z=w.parentObject;
        for (var i=0; i<z.childsCount; i++)
            if (z.childNodes[i]==w) return i;
   };





/**
*     @desc: visual unselect item in tree
*     @type: private
*     @param: node - tree item object
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._unselectItem=function(node){
        if ((node)&&(node.i_sel))
            {

          node.span.className="standartTreeRow";
          node.span.parentNode.parentNode.className = "";
          if (node.acolor)  node.span.style.color=node.acolor;
            node.i_sel=false;
            for (var i=0; i<this._selected.length; i++)
                    if (!this._selected[i].i_sel) {
                        this._selected.splice(i,1);
                        break;
                 }
            }
       }

/**
*     @desc: visual unselect items in tree
*     @type: private
*     @param: node - tree item object
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._unselectItems=function(){
      for (var i=0; i<this._selected.length; i++){
            var node=this._selected[i];
         node.span.className="standartTreeRow";
         node.span.parentNode.parentNode.className = "";
          if (node.acolor)  node.span.style.color=node.acolor;
         node.i_sel=false;
         }
         this._selected=new Array();
       }


/**  
*     @desc: select node text event handler
*     @type: private
*     @param: e - event object
*     @param: htmlObject - node object     
*     @param: mode - if false - call onSelect event
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.onRowSelect=function(e,htmlObject,mode){
      e=e||window.event;

        var obj=this.parentObject;
      if (htmlObject) obj=htmlObject.parentObject;
        var that=obj.treeNod;

        var lastId=that.getSelectedItemId();
		if ((!e)||(!e.skipUnSel))
	        that._selectItem(obj,e);

      if (!mode) {	 	
         if (obj.actionHandler) obj.actionHandler(obj.id,lastId);
		 else that.callEvent("onClick",[obj.id,lastId]);
         }
   };




   
/**
*     @desc: fix checkbox state
*     @type: private
*     @topic: 0
*/
dhtmlXTreeObject.prototype._correctCheckStates=function(dhtmlObject){
	
   if (!this.tscheck) return;
   if (!dhtmlObject) return;
   if (dhtmlObject.id==this.rootId) return;
   //calculate state
   var act=dhtmlObject.childNodes;
   var flag1=0; var flag2=0;
   if (dhtmlObject.childsCount==0) return;
   for (var i=0; i<dhtmlObject.childsCount; i++){
   	  if (act[i].dscheck) continue;
      if (act[i].checkstate==0) flag1=1;
      else if (act[i].checkstate==1) flag2=1;
         else { flag1=1; flag2=1; break; }
		 }

   if ((flag1)&&(flag2)) this._setCheck(dhtmlObject,"unsure");
   else if (flag1)  this._setCheck(dhtmlObject,false);
      else  this._setCheck(dhtmlObject,true);

      this._correctCheckStates(dhtmlObject.parentObject);
}

/**
*     @desc: checbox select action
*     @type: private
*     @topic: 0
*/   
   dhtmlXTreeObject.prototype.onCheckBoxClick=function(e){
	   	  if (!this.treeNod.callEvent("onBeforeCheck",[this.parentObject.id,this.parentObject.checkstate]))
	   	  	return;
   	  
      if (this.parentObject.dscheck) return true;
      if (this.treeNod.tscheck)
         if (this.parentObject.checkstate==1) this.treeNod._setSubChecked(false,this.parentObject);
         else this.treeNod._setSubChecked(true,this.parentObject);
      else
         if (this.parentObject.checkstate==1) this.treeNod._setCheck(this.parentObject,false);
         else this.treeNod._setCheck(this.parentObject,true);
      this.treeNod._correctCheckStates(this.parentObject.parentObject);

      return this.treeNod.callEvent("onCheck",[this.parentObject.id,this.parentObject.checkstate]);
   };
/**
*     @desc: create HTML elements for tree node
*     @type: private
*     @param: acheck - enable/disable checkbox
*     @param: itemObject - item object
*     @param: mode - mode
*     @topic: 0
*/
dhtmlXTreeObject.prototype._createItem=function(acheck,itemObject,mode){
	
	var table=document.createElement('table');
	table.cellSpacing = 0;
	table.cellPadding = 0;
	table.border = 0;
	
	if (this.hfMode) table.style.tableLayout="fixed";
	table.style.margin = 0;
	table.style.padding = 0;
	
	var tbody=document.createElement('tbody');
	var tr=document.createElement('tr');
	
	var td1=document.createElement('td');
	td1.className="standartTreeImage";
	
	if(this._txtimg){
		var img0=document.createElement("div");
		td1.appendChild(img0);
		img0.className="dhx_tree_textSign";
	} else {
		var img0 = this._getImg(itemObject.id);
		img0.border = "0";
		if (img0.tagName == "IMG") {
			img0.align="absmiddle";
		}
		td1.appendChild(img0);
		img0.style.padding = 0;
		img0.style.margin = 0;
    img0.style.width = this.def_line_img_x;
    //img0.style.height = this.def_line_img_y;
	}
	
	var td11=document.createElement('td');
	//         var inp=document.createElement("input");            inp.type="checkbox"; inp.style.width="12px"; inp.style.height="12px";
	var inp=this._getImg(this.cBROf?this.rootId:itemObject.id);
	inp.checked=0; this._setSrc(inp,this.imPath+this.checkArray[0]); inp.style.width="18px"; inp.style.height="18px";
	//can cause problems with hide/show check
	
	if (!acheck) td11.style.display="none";
	
	// td11.className="standartTreeImage";
	//if (acheck)
	td11.appendChild(inp);
	if ((!this.cBROf)&&(inp.tagName=="IMG")) inp.align="absmiddle";
	inp.onclick=this.onCheckBoxClick;
	inp.treeNod=this;
	inp.parentObject=itemObject;
	if (!window._KHTMLrv) td11.width="20px";
	else td11.width="16px";
	
	var td12=document.createElement('td');
	td12.className="standartTreeImage";
	var img=this._getImg(this.timgen?itemObject.id:this.rootId);
	img.onmousedown=this._preventNsDrag; img.ondragstart=this._preventNsDrag;
	img.border="0";
	if (this._aimgs){
		img.parentObject=itemObject;
		if (img.tagName=="IMG") img.align="absmiddle";
	img.onclick=this.onRowSelect; }
	if (!mode) this._setSrc(img,this.iconURL+this.imageArray[0]);
	td12.appendChild(img); img.style.padding=0; img.style.margin=0;
	if (this.timgen)
	{  
	td12.style.width=img.style.width=this.def_img_x; img.style.height=this.def_img_y; }
	else
	{
                img.style.width="0px"; img.style.height="0px";
                if (_isOpera || window._KHTMLrv )    td12.style.display="none";
        }
        
        
        var td2=document.createElement('td');
        td2.className="dhxTextCell standartTreeRow";
        
        itemObject.span=document.createElement('span');
        itemObject.span.className="standartTreeRow";
        if (this.mlitems) {
        	itemObject.span.style.width=this.mlitems;
        	//	if (!_isIE)
        	itemObject.span.style.display="block";
        }
        else td2.noWrap=true;
        if (dhx4.isIE8) td2.style.width="99999px";
        else if (!window._KHTMLrv) td2.style.width="100%";
        
        //      itemObject.span.appendChild(document.createTextNode(itemObject.label));
        itemObject.span.innerHTML=itemObject.label;
        td2.appendChild(itemObject.span);
        td2.parentObject=itemObject;        td1.parentObject=itemObject;
        td2.onclick=this.onRowSelect; td1.onclick=this.onRowClick; td2.ondblclick=this.onRowClick2;
        if (this.ettip)
        	tr.title=itemObject.label;
        
        if (this.dragAndDropOff) {
        	if (this._aimgs) { this.dragger.addDraggableItem(td12,this); td12.parentObject=itemObject; }
        	this.dragger.addDraggableItem(td2,this);
        }
        
        itemObject.span.style.paddingLeft="5px";      itemObject.span.style.paddingRight="5px";   td2.style.verticalAlign="";
        td2.style.fontSize="10pt";       td2.style.cursor=this.style_pointer;
        tr.appendChild(td1);            tr.appendChild(td11);            tr.appendChild(td12);
        tr.appendChild(td2);
        tbody.appendChild(tr);
        table.appendChild(tbody);
        
        if (this.ehlt || this.checkEvent("onMouseIn") || this.checkEvent("onMouseOut")){//highlighting
		tr.onmousemove=this._itemMouseIn;
		tr[(_isIE)?"onmouseleave":"onmouseout"]=this._itemMouseOut;
	}
	return table;
};
   

/**  
*     @desc: set path to images directory
*     @param: newPath - path to images directory (related to the page with tree or absolute http url)
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.setImagePath=function( newPath ){ this.imPath=newPath; this.iconURL=newPath; };
    /**
	*   @desc: set path to external images used as tree icons
	*   @type: public
	*   @param: path - url (or relative path) of images folder with closing "/"
	*   @topic: 0,7
	*/
	dhtmlXTreeObject.prototype.setIconPath=function(path){
		this.iconURL=path;
	}	   

//#__pro_feature:01112006{
//#child_calc:01112006{

/**
*     @desc: return count of leafs
*     @param: itemNode -  node object
*     @type: private
*     @edition: Professional
*     @topic: 4
*/
   dhtmlXTreeObject.prototype._getLeafCount=function(itemNode){
      var a=0;
      for (var b=0; b<itemNode.childsCount; b++)
         if (itemNode.childNodes[b].childsCount==0) a++;
      return a;
   }

/**
*     @desc: get value of child counter (child counter must be enabled)
*     @type: private
*     @param: itemId - id of selected item
*     @edition: Professional
*     @return: counter value (related to counter mode)
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getChildCounterValue=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      if ((temp.unParsed)||((!temp.XMLload)&&(this.XMLsource)))
      return temp._acc
      switch(this.childCalc)
      {
         case 1: return temp.childsCount; break;
         case 2: return this._getLeafCount(temp); break;
         case 3: return temp._acc; break;
         case 4: return temp._acc; break;
      }
   }

  /**
*     @desc: fix node child counter
*     @param: itemNode -  node object
*     @type: private
*     @edition: Professional
*     @topic: 4
*/
   dhtmlXTreeObject.prototype._fixChildCountLabel=function(itemNode,index){
      if (this.childCalc==null) return;
      if ((itemNode.unParsed)||((!itemNode.XMLload)&&(this.XMLsource)))
      {
         if (itemNode._acc)
         itemNode.span.innerHTML=itemNode.label+this.htmlcA+itemNode._acc+this.htmlcB;
         else
         itemNode.span.innerHTML=itemNode.label;

      return;
      }

      switch(this.childCalc){
         case 1:
            if (itemNode.childsCount!=0)
               itemNode.span.innerHTML=itemNode.label+this.htmlcA+itemNode.childsCount+this.htmlcB;
            else itemNode.span.innerHTML=itemNode.label;
            break;
         case 2:
            var z=this._getLeafCount(itemNode);
            if (z!=0)
               itemNode.span.innerHTML=itemNode.label+this.htmlcA+z+this.htmlcB;
            else itemNode.span.innerHTML=itemNode.label;
            break;
         case 3:
            if (itemNode.childsCount!=0)
               {
               var bcc=0;
               for (var a=0; a<itemNode.childsCount; a++)   {
                  if (!itemNode.childNodes[a]._acc) itemNode.childNodes[a]._acc=0;
                  bcc+=itemNode.childNodes[a]._acc*1;      }
                  bcc+=itemNode.childsCount*1;

               itemNode.span.innerHTML=itemNode.label+this.htmlcA+bcc+this.htmlcB;
               itemNode._acc=bcc;
               }
            else { itemNode.span.innerHTML=itemNode.label;   itemNode._acc=0; }
            if ((itemNode.parentObject)&&(itemNode.parentObject!=this.htmlNode))
               this._fixChildCountLabel(itemNode.parentObject);
            break;
         case 4:
            if (itemNode.childsCount!=0)
               {
               var bcc=0;
               for (var a=0; a<itemNode.childsCount; a++)   {
                  if (!itemNode.childNodes[a]._acc) itemNode.childNodes[a]._acc=1;
                  bcc+=itemNode.childNodes[a]._acc*1;      }

               itemNode.span.innerHTML=itemNode.label+this.htmlcA+bcc+this.htmlcB;
               itemNode._acc=bcc;
               }
            else { itemNode.span.innerHTML=itemNode.label;   itemNode._acc=1; }
            if ((itemNode.parentObject)&&(itemNode.parentObject!=this.htmlNode))
               this._fixChildCountLabel(itemNode.parentObject);
            break;
      }
   }

/**
*     @desc: set children calculation mode
*     @param: mode - mode name as string . Possible values: child - children, no recursive; leafs - children without subchildren, no recursive;  ,childrec - children, recursive; leafsrec - children without subchildren, recursive; disabled (disabled by default)
*     @type: public
*     @edition: Professional
*     @topic: 0
*/ 
   dhtmlXTreeObject.prototype.setChildCalcMode=function( mode ){
      switch(mode){
         case "child": this.childCalc=1; break;
         case "leafs": this.childCalc=2; break;
         case "childrec": this.childCalc=3; break;
         case "leafsrec": this.childCalc=4; break;
         case "disabled": this.childCalc=null; break;
         default: this.childCalc=4;
      }
    }
/**
*     @desc: set children calculation prefix and postfix
*     @param: htmlA - postfix ([ - by default)
*     @param: htmlB - postfix (] - by default)
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.setChildCalcHTML=function( htmlA,htmlB ){
      this.htmlcA=htmlA;      this.htmlcB=htmlB;
    }
//#}
//#}

/**
*     @desc: set function called when tree node selected
*     @param: (function) func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onRightClick
*     @depricated: use grid.attachEvent("onRightClick",func); instead
*     @eventdesc:  Event occurs after right mouse button was clicked.
         Assigning this handler can disable default context menu, and incompattible with dhtmlXMenu integration.
*     @eventparam: (string) ID of clicked item
*     @eventparam: (object) event object
*/
   dhtmlXTreeObject.prototype.setOnRightClickHandler=function(func){  this.attachEvent("onRightClick",func);   };

/**
*     @desc: set function called when tree node clicked, also can be forced to call from API
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onClick
*     @depricated: use grid.attachEvent("onClick",func); instead
*     @eventdesc: Event raises immideatly after text part of item in tree was clicked, but after default onClick functionality was processed.
              Richt mouse button click can be catched by onRightClick event handler.
*     @eventparam:  ID of clicked item
*     @eventparam:  ID of previously selected item
*/
   dhtmlXTreeObject.prototype.setOnClickHandler=function(func){  this.attachEvent("onClick",func);  };

/**
*     @desc: set function called when tree node selected or unselected, include any select change caused by any functionality
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onSelect
*     @depricated: use grid.attachEvent("onSelect",func); instead
*     @eventdesc: Event raises immideatly after selection in tree was changed
*     @eventparam:  selected item ID ( list of IDs in case of multiselection)
*/
   dhtmlXTreeObject.prototype.setOnSelectStateChange=function(func){  this.attachEvent("onSelect",func); };


/**
*     @desc: enables dynamic loading from XML
*     @type: public
*     @param: filePath - name of script returning XML; in case of virtual loading - user defined function
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.setXMLAutoLoading=function(filePath){  this.XMLsource=filePath; };

   /**
*     @desc: set function called before checkbox checked/unchecked
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onCheck
*     @depricated: use tree.attachEvent("onCheck",func); instead
*     @eventdesc: Event raises right before item in tree was checked/unchecked. can be canceled (return false from event handler)
*     @eventparam: ID of item which will be checked/unchecked
*     @eventparam: Current checkbox state. 1 - item checked, 0 - item unchecked.
*		@eventreturn: true - confirm changing checked state; false - deny chaning checked state;
*/
   dhtmlXTreeObject.prototype.setOnCheckHandler=function(func){ this.attachEvent("onCheck",func);  };


/**
*     @desc: set function called before tree node opened/closed
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event:  onOpen
*     @depricated: use grid.attachEvent("onOpenStart",func); instead
*     @eventdesc: Event raises immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event does not occur if node was opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. 0 - item has not children, -1 - item closed, 1 - item opened.
*     @eventreturn: true - confirm opening/closing; false - deny opening/closing;
*/
   dhtmlXTreeObject.prototype.setOnOpenHandler=function(func){  this.attachEvent("onOpenStart",func);   };
/**
*     @desc: set function called before tree node opened/closed
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event:  onOpenStart
*     @depricated: use grid.attachEvent("onOpenStart",func); instead
*     @eventdesc: Event raises immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event not raised if node opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. 0 - item has not children, -1 - item closed, 1 - item opened.
*     @eventreturn: true - confirm opening/closing; false - deny opening/closing;
*/
   dhtmlXTreeObject.prototype.setOnOpenStartHandler=function(func){  this.attachEvent("onOpenStart",func);    };

/**
*     @desc: set function called after tree node opened/closed
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event:  onOpenEnd
*     @depricated: use grid.attachEvent("onOpenEnd",func); instead
*     @eventdesc: Event raises immideatly after item in tree was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event not raised if node opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. 0 - item has not children, -1 - item closed, 1 - item opened.
*/
   dhtmlXTreeObject.prototype.setOnOpenEndHandler=function(func){  this.attachEvent("onOpenEnd",func);  };

   /**
*     @desc: set function called when tree node double clicked
*     @param: func - event handling function
*     @type: public
*     @topic: 0,7
*     @event: onDblClick
*     @depricated: use grid.attachEvent("onDblClick",func); instead
*     @eventdesc: Event raised immideatly after item in tree was doubleclicked, before default onDblClick functionality was processed.
         Beware using both onClick and onDblClick events, because component can  generate onClick event before onDblClick event while doubleclicking item in tree.
         ( that behavior depend on used browser )
*     @eventparam:  ID of item which was doubleclicked
*     @eventreturn:  true - confirm opening/closing; false - deny opening/closing;
*/
   dhtmlXTreeObject.prototype.setOnDblClickHandler=function(func){ this.attachEvent("onDblClick",func);   };









   /**
*     @desc: expand target node and all sub nodes
*     @type: public
*     @param: itemId - node id
*     @topic: 4
*/
   dhtmlXTreeObject.prototype.openAllItems=function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      this._xopenAll(temp);
   };
   
/**
*     @desc: return open/close state
*     @type: public
*     @param: itemId - node id
*     @return: -1 - close, 1 - opened, 0 - node doesn't have children
*     @topic: 4
*/   
   dhtmlXTreeObject.prototype.getOpenState=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return "";
      return this._getOpenState(temp);
   };

/**  
*     @desc: collapse target node and all sub nodes
*     @type: public
*     @param: itemId - node id
*     @topic: 4  
*/
   dhtmlXTreeObject.prototype.closeAllItems=function(itemId)
   {
        if (itemId===window.undefined) itemId=this.rootId;
        
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      this._xcloseAll(temp);

//nb:solves standard doctype prb in IE
         this.allTree.childNodes[0].border = "1";
       this.allTree.childNodes[0].border = "0";

   };
   
   
/**
*     @desc: set user data for target node
*     @type: public
*     @param: itemId - target node id
*     @param: name - key for user data
*     @param: value - user data value
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.setUserData=function(itemId,name,value){
      var sNode=this._globalIdStorageFind(itemId,0,true);
         if (!sNode) return;
         if(name=="hint")
			 sNode.htmlNode.childNodes[0].childNodes[0].title=value;
            if (typeof(sNode.userData["t_"+name])=="undefined"){
                 if (!sNode._userdatalist) sNode._userdatalist=name;
                else sNode._userdatalist+=","+name;
            }
            sNode.userData["t_"+name]=value;
   };
   
/**  
*     @desc: get user data from target node
*     @type: public
*     @param: itemId - target node id
*     @param: name - key for user data
*     @return: value of user data
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getUserData=function(itemId,name){
      var sNode=this._globalIdStorageFind(itemId,0,true);
      if (!sNode) return;
      return sNode.userData["t_"+name];
   };




/**
*     @desc: get node color (text color)
*     @param: itemId - id of node
*     @type: public
*     @return: color of node (empty string for default color);
*     @topic: 6  
*/   
   dhtmlXTreeObject.prototype.getItemColor=function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;

      var res= new Object();
      if (temp.acolor) res.acolor=temp.acolor;
      if (temp.scolor) res.scolor=temp.scolor;      
      return res;
   };
/**  
*     @desc: set node text color
*     @param: itemId - id of node
*     @param: defaultColor - node color
*     @param: selectedColor - selected node color
*     @type: public
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.setItemColor=function(itemId,defaultColor,selectedColor)
   {
      if ((itemId)&&(itemId.span))
         var temp=itemId;
      else
         var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
         else {
         if (temp.i_sel)
            {  if (selectedColor || defaultColor) temp.span.style.color=selectedColor || defaultColor; }
         else
            {  if (defaultColor) temp.span.style.color=defaultColor;  }

         if (selectedColor) temp.scolor=selectedColor;
         if (defaultColor) temp.acolor=defaultColor;
         }
   };

/**
*     @desc: return node text
*     @param: itemId - id of node
*     @type: public
*     @return: text of item (with HTML formatting, if any)
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.getItemText=function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      return(temp.htmlNode.childNodes[0].childNodes[0].childNodes[3].childNodes[0].innerHTML);
   };
/**  
*     @desc: return parent item id
*     @param: itemId - id of node
*     @type: public
*     @return: id of parent item
*     @topic: 4
*/         
   dhtmlXTreeObject.prototype.getParentId=function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId);
      if ((!temp)||(!temp.parentObject)) return "";
      return temp.parentObject.id;
   };



/**  
*     @desc: change item id
*     @type: public
*     @param: itemId - old node id
*     @param: newItemId - new node id        
*     @topic: 4
*/    
   dhtmlXTreeObject.prototype.changeItemId=function(itemId,newItemId)
   {
   	if (itemId==newItemId) return;
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
        temp.id=newItemId;
        temp.span.contextMenuId=newItemId;
        this._idpull[newItemId]=this._idpull[itemId];
        delete this._idpull[itemId];
   };


/**
*     @desc: mark selected item as cut
*     @type: public
*     @topic: 2  
*/    
   dhtmlXTreeObject.prototype.doCut=function(){
      if (this.nodeCut) this.clearCut();
      this.nodeCut=(new Array()).concat(this._selected);
        for (var i=0; i<this.nodeCut.length; i++){
          var tempa=this.nodeCut[i];
            tempa._cimgs=new Array();
          tempa._cimgs[0]=tempa.images[0];
          tempa._cimgs[1]=tempa.images[1];
          tempa._cimgs[2]=tempa.images[2];
          tempa.images[0]=tempa.images[1]=tempa.images[2]=this.cutImage;
          this._correctPlus(tempa);
        }
   };

/**
*     @desc: insert previously cut branch
*     @param: itemId - id of new parent node
*     @type: public
*     @topic: 2  
*/    
   dhtmlXTreeObject.prototype.doPaste=function(itemId){
      var tobj=this._globalIdStorageFind(itemId);
      if (!tobj) return 0;
        for (var i=0; i<this.nodeCut.length; i++){
               if (this._checkPNodes(tobj,this.nodeCut[i])) continue;
                this._moveNode(this.nodeCut[i],tobj);
               }
      this.clearCut();
   };

/**  
*     @desc: clear cut
*     @type: public
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype.clearCut=function(){
      for (var i=0; i<this.nodeCut.length; i++)
         {
          var tempa=this.nodeCut[i];
          tempa.images[0]=tempa._cimgs[0];
          tempa.images[1]=tempa._cimgs[1];
          tempa.images[2]=tempa._cimgs[2];
          this._correctPlus(tempa);
         }
          this.nodeCut=new Array();
   };
   


   /**  
*     @desc: move node with subnodes
*     @type: private
*     @param: itemObject - moved node object
*     @param: targetObject - new parent node
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype._moveNode=function(itemObject,targetObject){
//#__pro_feature:01112006{
//#complex_move:01112006{
      var mode=this.dadmodec;
      if (mode==1)
        {
            var z=targetObject;
         if (this.dadmodefix<0)
         {

                while (true){
            z=this._getPrevNode(z);
            if ((z==-1)) { z=this.htmlNode; break; }
                if ((z.tr==0)||(z.tr.style.display=="")||(!z.parentObject)) break;
                }

                var nodeA=z;
                var nodeB=targetObject;

            }
            else
            {
				if ((z.tr)&&(z.tr.nextSibling)&&(z.tr.nextSibling.nodem)&&(this._getOpenState(z)<1)){
  				 	z = z.tr.nextSibling.nodem;
				}
           		else{
					if(this._getOpenState(z)<1)
						z=this.htmlNode;
					else{
						z=this._getNextNode(z);
						if ((z==-1)) z=this.htmlNode;
					}

				}
				
                var nodeB=z;
                var nodeA=targetObject;
            }


            if (this._getNodeLevel(nodeA,0)>this._getNodeLevel(nodeB,0))
                {
                if (!this.dropLower)
                    return this._moveNodeTo(itemObject,nodeA.parentObject);
                else
                    if  (nodeB.id!=this.rootId)
                        return this._moveNodeTo(itemObject,nodeB.parentObject,nodeB);
                    else
                        return this._moveNodeTo(itemObject,this.htmlNode,null);
                }
            else
                {
                return this._moveNodeTo(itemObject,nodeB.parentObject,nodeB);
                }


      }
      else
//#}
//#}
	  return this._moveNodeTo(itemObject,targetObject);

   }

   /**
*     @desc: fix order of nodes in collection
*     @type: private
*     @param: target - parent item node
*     @param: zParent - before node
*     @edition: Professional
*     @topic: 2
*/

dhtmlXTreeObject.prototype._fixNodesCollection=function(target,zParent){
      var flag=0; var icount=0;
      var Nodes=target.childNodes;
      var Count=target.childsCount-1;

      if (zParent==Nodes[Count]) return;
      for (var i=0; i<Count; i++)
         if (Nodes[i]==Nodes[Count]) {  Nodes[i]=Nodes[i+1]; Nodes[i+1]=Nodes[Count]; }

//         Count=target.childsCount;
      for (var i=0; i<Count+1; i++)      
         {
         if (flag) { 
            var temp=Nodes[i];
            Nodes[i]=flag; 
            flag=temp; 
               }
         else 
         if (Nodes[i]==zParent) {   flag=Nodes[i]; Nodes[i]=Nodes[Count];  }
         }
   };
   
/**  
*     @desc: recreate branch
*     @type: private
*     @param: itemObject - moved node object
*     @param: targetObject - new parent node
*     @param: level - top level flag
*     @param: beforeNode - node for sibling mode
*     @mode: mode - DragAndDrop mode (0 - as child, 1 as sibling)
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype._recreateBranch=function(itemObject,targetObject,beforeNode,level){
    var i; var st="";
    if (beforeNode){
    for (i=0; i<targetObject.childsCount; i++)
        if (targetObject.childNodes[i]==beforeNode) break;

    if (i!=0)
        beforeNode=targetObject.childNodes[i-1];
    else{
        st="TOP";
        beforeNode="";
        }
    }

   var t2=this._onradh; this._onradh=null;
   var newNode=this._attachChildNode(targetObject,itemObject.id,itemObject.label,0,itemObject.images[0],itemObject.images[1],itemObject.images[2],st,0,beforeNode);

   //copy user data
   newNode._userdatalist=itemObject._userdatalist;
   newNode.userData=itemObject.userData.clone();
   if(itemObject._attrs){
	   newNode._attrs={};
	   for(var attr in itemObject._attrs)
		   newNode._attrs[attr] = itemObject._attrs[attr];
	}

   newNode.XMLload=itemObject.XMLload;
   if (t2){
   	this._onradh=t2; this._onradh(newNode.id); }

//#__pro_feature:01112006{
//#smart_parsing:01112006{
   //copy unparsed chunk
      if (itemObject.treeNod.dpcpy) itemObject.treeNod._globalIdStorageFind(itemObject.id);
      else newNode.unParsed=itemObject.unParsed;
      this._correctPlus(newNode);
      //this._correctLine(newNode);
   
//#}
//#}
   for (var i=0; i<itemObject.childsCount; i++)
      this._recreateBranch(itemObject.childNodes[i],newNode,0,1);

//#__pro_feature:01112006{
//#child_calc:01112006{
      if ((!level)&&(this.childCalc)) { this._redrawFrom(this,targetObject);  }
//#}
//#}
   return newNode;
}

/**
*     @desc: move single node
*     @type: private
*     @param: itemObject - moved node object
*     @param: targetObject - new parent node
*     @mode: mode - DragAndDrop mode (0 - as child, 1 as sibling)
*     @topic: 2
*/
   dhtmlXTreeObject.prototype._moveNodeTo=function(itemObject,targetObject,beforeNode){
    //return;
    if   (itemObject.treeNod._nonTrivialNode)
        return itemObject.treeNod._nonTrivialNode(this,targetObject,beforeNode,itemObject);

	if (this._checkPNodes(targetObject,itemObject))
   		return false;
                           		
    if    (targetObject.mytype)
       var framesMove=(itemObject.treeNod.lWin!=targetObject.lWin);
    else
          var framesMove=(itemObject.treeNod.lWin!=targetObject.treeNod.lWin);

   if (!this.callEvent("onDrag",[itemObject.id,targetObject.id,(beforeNode?beforeNode.id:null),itemObject.treeNod,targetObject.treeNod])) return false;
      if ((targetObject.XMLload==0)&&(this.XMLsource))
         {
         targetObject.XMLload=1;
            this._loadDynXML(targetObject.id);
         }
	this.openItem(targetObject.id);

   var oldTree=itemObject.treeNod;
   var c=itemObject.parentObject.childsCount;
   var z=itemObject.parentObject;
   

   if ((framesMove)||(oldTree.dpcpy)) {//interframe drag flag
        var _otiid=itemObject.id;
      itemObject=this._recreateBranch(itemObject,targetObject,beforeNode);
        if (!oldTree.dpcpy) oldTree.deleteItem(_otiid);
        }
   else
      {
	
      var Count=targetObject.childsCount; var Nodes=targetObject.childNodes;
      	   	if (Count==0) targetObject._open=true;
      		oldTree._unselectItem(itemObject);
           Nodes[Count]=itemObject;
            itemObject.treeNod=targetObject.treeNod;
            targetObject.childsCount++;         
			
            var tr=this._drawNewTr(Nodes[Count].htmlNode);

            if (!beforeNode)
               {
                  targetObject.htmlNode.childNodes[0].appendChild(tr);
               if (this.dadmode==1) this._fixNodesCollection(targetObject,beforeNode);
               }
            else
               {
               targetObject.htmlNode.childNodes[0].insertBefore(tr,beforeNode.tr);
               this._fixNodesCollection(targetObject,beforeNode);
               Nodes=targetObject.childNodes;
               }

			
         }

            if ((!oldTree.dpcpy)&&(!framesMove))   {
                var zir=itemObject.tr;

                if ((document.all)&&(navigator.appVersion.search(/MSIE\ 5\.0/gi)!=-1))
                    {
                    window.setTimeout(function() { zir.parentNode.removeChild(zir); } , 250 );
                    }
                else   //if (zir.parentNode) zir.parentNode.removeChild(zir,true);

                itemObject.parentObject.htmlNode.childNodes[0].removeChild(itemObject.tr);

                //itemObject.tr.removeNode(true);
            if ((!beforeNode)||(targetObject!=itemObject.parentObject)){
               for (var i=0; i<z.childsCount; i++){
                  if (z.childNodes[i].id==itemObject.id) {
                  z.childNodes[i]=0;
                  break;            }}}
               else z.childNodes[z.childsCount-1]=0;

            oldTree._compressChildList(z.childsCount,z.childNodes);
            z.childsCount--;
            }


      if ((!framesMove)&&(!oldTree.dpcpy)) {
       itemObject.tr=tr;
      tr.nodem=itemObject;
      itemObject.parentObject=targetObject;

      if (oldTree!=targetObject.treeNod) {
	    if(itemObject.treeNod._registerBranch(itemObject,oldTree)) return;      this._clearStyles(itemObject);  this._redrawFrom(this,itemObject.parentObject);
		if(this._onradh) this._onradh(itemObject.id);
		   };

      this._correctPlus(targetObject);
      this._correctLine(targetObject);

      this._correctLine(itemObject);
      this._correctPlus(itemObject);

         //fix target siblings
      if (beforeNode)
      {

         this._correctPlus(beforeNode);
         //this._correctLine(beforeNode);
      }
      else 
      if (targetObject.childsCount>=2)
      {

         this._correctPlus(Nodes[targetObject.childsCount-2]);
         this._correctLine(Nodes[targetObject.childsCount-2]);
      }
      
      this._correctPlus(Nodes[targetObject.childsCount-1]);
      //this._correctLine(Nodes[targetObject.childsCount-1]);


      if (this.tscheck) this._correctCheckStates(targetObject);
      if (oldTree.tscheck) oldTree._correctCheckStates(z);

      }

      //fix source parent

      if (c>1) { oldTree._correctPlus(z.childNodes[c-2]);
               oldTree._correctLine(z.childNodes[c-2]);
               }


//      if (z.childsCount==0)
          oldTree._correctPlus(z);
            oldTree._correctLine(z);

//#__pro_feature:01112006{
//#child_calc:01112006{
      this._fixChildCountLabel(targetObject);
      oldTree._fixChildCountLabel(z);
//#}
//#}
      this.callEvent("onDrop",[itemObject.id,targetObject.id,(beforeNode?beforeNode.id:null),oldTree,targetObject.treeNod]);
      return itemObject.id;
   };

   

/**
*     @desc: recursive set default styles for node
*     @type: private
*     @param: itemObject - target node object
*     @topic: 6  
*/   
   dhtmlXTreeObject.prototype._clearStyles=function(itemObject){
   		if (!itemObject.htmlNode) return; //some weird case in SRND mode
         var td1=itemObject.htmlNode.childNodes[0].childNodes[0].childNodes[1];
         var td3=td1.nextSibling.nextSibling;

         itemObject.span.innerHTML=itemObject.label;
		 itemObject.i_sel=false;

   		 if (itemObject._aimgs)
	         this.dragger.removeDraggableItem(td1.nextSibling);

         if (this.checkBoxOff) {
		 	td1.childNodes[0].style.display="";
			td1.childNodes[0].onclick=this.onCheckBoxClick;
			this._setSrc(td1.childNodes[0],this.imPath+this.checkArray[itemObject.checkstate]);
			}
         else td1.style.display="none";
         td1.childNodes[0].treeNod=this;

         this.dragger.removeDraggableItem(td3);
         if (this.dragAndDropOff) this.dragger.addDraggableItem(td3,this);
		 if (this._aimgs) this.dragger.addDraggableItem(td1.nextSibling,this);
		 		 
         td3.childNodes[0].className="standartTreeRow";
         td3.parentNode.className = "";
         td3.onclick=this.onRowSelect; td3.ondblclick=this.onRowClick2;
         td1.previousSibling.onclick=this.onRowClick;

         this._correctLine(itemObject);
         this._correctPlus(itemObject);
         for (var i=0; i<itemObject.childsCount; i++) this._clearStyles(itemObject.childNodes[i]); 

   };
/**
*     @desc: register node and all children nodes
*     @type: private
*     @param: itemObject - node object
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype._registerBranch=function(itemObject,oldTree){
      if (oldTree) oldTree._globalIdStorageSub(itemObject.id);
      itemObject.id=this._globalIdStorageAdd(itemObject.id,itemObject);
      itemObject.treeNod=this;
         for (var i=0; i<itemObject.childsCount; i++)
            this._registerBranch(itemObject.childNodes[i],oldTree);
      return 0;
   };

   
/**  
*     @desc: enable three state checkboxes
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.enableThreeStateCheckboxes=function(mode) { this.tscheck=dhx4.s2b(mode); };


/**
*     @desc: set function called when mouse is over tree node
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onMouseIn
*     @depricated: use grid.attachEvent("onMouseIn",func); instead
*     @eventdesc: Event raised immideatly after mouse started moving over item
*     @eventparam:  ID of item
*/
   dhtmlXTreeObject.prototype.setOnMouseInHandler=function(func){
    	this.ehlt=true;
   		this.attachEvent("onMouseIn",func);
	};

/**
*     @desc: set function called when mouse is out of tree node
*     @param: func - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event: onMouseOut
*     @depricated: use grid.attachEvent("onMouseOut",func); instead
*     @eventdesc: Event raised immideatly after mouse moved out of item
*     @eventparam:  ID of clicked item
*/
   dhtmlXTreeObject.prototype.setOnMouseOutHandler=function(func){
		this.ehlt=true;
   		this.attachEvent("onMouseOut",func);
	};





//#__pro_feature:01112006{
/**
*     @desc: enable drag without removing (copy instead of move)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition:Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableMercyDrag=function(mode){ this.dpcpy=dhx4.s2b(mode); };
//#}



/**
*     @desc: enable tree images
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 0  
*/         
   dhtmlXTreeObject.prototype.enableTreeImages=function(mode) { this.timgen=dhx4.s2b(mode); };
   

   
/**
*     @desc: enable mode with fixed tables (looks better, but has no horisontal scrollbar)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: private
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.enableFixedMode=function(mode) { this.hfMode=dhx4.s2b(mode); };
   
/**  
*     @desc: show/hide checkboxes (all checkboxes in tree)
*     @type: public
*     @param: mode - true/false
*     @param: hidden - if set to true, checkboxes not rendered but can be shown by showItemCheckbox
*     @topic: 0  
*/
   dhtmlXTreeObject.prototype.enableCheckBoxes=function(mode, hidden){ this.checkBoxOff=dhx4.s2b(mode); this.cBROf=(!(this.checkBoxOff||dhx4.s2b(hidden))); 
   	};
/**
*     @desc: set default images for nodes (must be called before XML loading)
*     @type: public
*     @param: a0 - image for node without children;
*     @param: a1 - image for closed node;
*     @param: a2 - image for opened node                  
*     @topic: 6  
*/
   dhtmlXTreeObject.prototype.setStdImages=function(image1,image2,image3){
                  this.imageArray[0]=image1; this.imageArray[1]=image2; this.imageArray[2]=image3;};

/**
*     @desc: enable/disable tree lines (parent-child threads)
*     @type: public
*     @param: mode - enable/disable tree lines
*     @topic: 6
*/                  
   dhtmlXTreeObject.prototype.enableTreeLines=function(mode){
      this.treeLinesOn=dhx4.s2b(mode);
   }

/**
*     @desc: set images used for parent-child threads drawing (lines, plus, minus)
*     @type: public
*     @param: arrayName - name of array: plus, minus
*     @param: image1 - line crossed image
*     @param: image2 - image with top line
*     @param: image3 - image with bottom line
*     @param: image4 - image without line
*     @param: image5 - single root image
*     @topic: 6
*/      
   dhtmlXTreeObject.prototype.setImageArrays=function(arrayName,image1,image2,image3,image4,image5){
      switch(arrayName){
      case "plus": this.plusArray[0]=image1; this.plusArray[1]=image2; this.plusArray[2]=image3; this.plusArray[3]=image4; this.plusArray[4]=image5; break;
      case "minus": this.minusArray[0]=image1; this.minusArray[1]=image2; this.minusArray[2]=image3; this.minusArray[3]=image4;  this.minusArray[4]=image5; break;
      }
   };

/**  
*     @desc: expand node
*     @param: itemId - id of node
*     @type: public
*     @topic: 4
*/ 
   dhtmlXTreeObject.prototype.openItem=function(itemId){
     this.skipLock = true;
	   var temp=this._globalIdStorageFind(itemId);
	   if (!temp) return 0;
	   else return this._openItem(temp);
	   this.skipLock = false;
   };

/**  
*     @desc: expand node
*     @param: item - tree node object
*     @type: private
*     @editing: pro
*     @topic: 4  
*/ 
   dhtmlXTreeObject.prototype._openItem=function(item){
   		   var state=this._getOpenState(item);
		   if ((state<0)||(((this.XMLsource)&&(!item.XMLload)))){
	           if    (!this.callEvent("onOpenStart",[item.id,state])) return 0;
	           this._HideShow(item,2);
				   if    (this.checkEvent("onOpenEnd")){ 
						   if (this.onXLE==this._epnFHe) this._epnFHe(this,item.id,true);
	                       if (!this.xmlstate || !this.XMLsource)
	                       		this.callEvent("onOpenEnd",[item.id,this._getOpenState(item)]);
	                        else{
	                            this._oie_onXLE.push(this.onXLE);
	                            this.onXLE=this._epnFHe;
	                            }
							}
			   } else if (this._srnd) this._HideShow(item,2);
           if (item.parentObject && !this._skip_open_parent) this._openItem(item.parentObject);
   };
   
/**  
*     @desc: collapse node
*     @param: itemId - id of node
*     @type: public
*     @topic: 4  
*/
   dhtmlXTreeObject.prototype.closeItem=function(itemId){
	   if (this.rootId==itemId) return 0;
	   this.skipLock = true;
	   var temp=this._globalIdStorageFind(itemId);
	   if (!temp) return 0;
	   if (temp.closeble)
		   this._HideShow(temp,1);
	   this.skipLock = false;
   };
   
   

   
   
   
   
   

   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
      
/**
*     @desc: get node level (position in hierarchy)
*     @param: itemId - id of node
*     @type: public
*     @return: node level (0 if no such item in hierarchy - probably super root)
*     @topic: 4
*/
   dhtmlXTreeObject.prototype.getLevel=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      return this._getNodeLevel(temp,0);
   };
   
      

/**  
*     @desc: prevent node from closing
*     @param: itemId - id of node
*     @param: flag -  if 0 - node can't be closed, else node can be closed
*     @type: public
*     @topic: 4  
*/ 
   dhtmlXTreeObject.prototype.setItemCloseable=function(itemId,flag)
   {
      flag=dhx4.s2b(flag);
      if ((itemId)&&(itemId.span)) 
         var temp=itemId;
      else      
         var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
         temp.closeble=flag;
   };

   /**  
*     @desc: recursive function used for node level calculation
*     @param: itemObject - pointer to node object
*     @param: count - counter of levels        
*     @type: private
*     @topic: 4  
*/   
   dhtmlXTreeObject.prototype._getNodeLevel=function(itemObject,count){
      if (itemObject.parentObject) return this._getNodeLevel(itemObject.parentObject,count+1);
      return(count);
   };
   
   /**  
*     @desc: return number of children
*     @param: itemId - id of node
*     @type: public
*     @return: number of child items for loaded branches; true - for not loaded branches
*     @topic: 4
*/
   dhtmlXTreeObject.prototype.hasChildren=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      else 
         {
            if ( (this.XMLsource)&&(!temp.XMLload) ) return true;
            else 
               return temp.childsCount;
         };
   };
   

   /**
*     @desc: get number of leafs (nodes without children)
*     @param: itemNode -  node object
*     @type: private
*     @edition: Professional
*     @topic: 4
*/
   dhtmlXTreeObject.prototype._getLeafCount=function(itemNode){
      var a=0;
      for (var b=0; b<itemNode.childsCount; b++)
         if (itemNode.childNodes[b].childsCount==0) a++;
      return a;
   }

   
/**
*     @desc: set new node text (HTML allowed)
*     @param: itemId - id of node
*     @param: newLabel - node text
*     @param: newTooltip - (optional)tooltip for the node
*     @type: public
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.setItemText=function(itemId,newLabel,newTooltip)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
      temp.label=newLabel;
      temp.span.innerHTML=newLabel;
//#__pro_feature:01112006{
//#child_calc:01112006{
        if (this.childCalc) this._fixChildCountLabel(temp);
//#}
//#}
	      temp.span.parentNode.parentNode.title=newTooltip||"";
   };

/**
*     @desc: get item's tooltip
*     @param: itemId - id of node
*     @type: public
*     @topic: 6
*/
    dhtmlXTreeObject.prototype.getItemTooltip=function(itemId){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return "";
	  return (temp.span.parentNode.parentNode._dhx_title||temp.span.parentNode.parentNode.title||"");
   };

/**  
*     @desc: refresh tree branch from xml (XML with child nodes rerequested from server)
*     @param: itemId - id of node, if not defined tree super root used.
*     @type: public
*     @topic: 6  
*/
   dhtmlXTreeObject.prototype.refreshItem=function(itemId){
      if (!itemId) itemId=this.rootId;
      var temp=this._globalIdStorageFind(itemId);
	  this._dynDeleteBranches[itemId] = (this._dynDeleteBranches[itemId]||0) + 1;
      this._loadDynXML(itemId);
   };

   /**  
*     @desc: set item images
*     @param: itemId - id of node
*     @param: image1 - node without children icon
*     @param: image2 - closed node icon          
*     @param: image3 - open node icon         
*     @type: public
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.setItemImage2=function(itemId, image1,image2,image3){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
            temp.images[1]=image2;
            temp.images[2]=image3;
            temp.images[0]=image1;
      this._correctPlus(temp);
   };
/**
*     @desc: set item icons (mostly usefull for childless nodes)
*     @param: itemId - id of node
*     @param: image1 - node without children icon or closed node icon (if image2 specified)
*     @param: image2 - open node icon (optional)        
*     @type: public
*     @topic: 6  
*/   
   dhtmlXTreeObject.prototype.setItemImage=function(itemId,image1,image2)
   {
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;
         if (image2)
         {
            temp.images[1]=image1;
            temp.images[2]=image2;
         }
         else temp.images[0]=image1;
      this._correctPlus(temp);
   };


/**
*     @desc: Returns the list of all subitems Ids from the next level of tree, separated by commas.
*     @param: itemId - id of node
*     @type: public
*     @return: list of all subitems from the next level of tree, separated by commas.
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.getSubItems =function(itemId)
   {
      var temp=this._globalIdStorageFind(itemId,0,1);
      if (!temp) return 0;
//#__pro_feature:01112006{
//#smart_parsing:01112006{
        if(temp.unParsed)
            return (this._getSubItemsXML(temp.unParsed));
//#}
//#}
      var z="";
      for (i=0; i<temp.childsCount; i++){
         if (!z) z= ""+temp.childNodes[i].id;
            else z+=this.dlmtr+temp.childNodes[i].id;

                                                         }

      return z;
   };




/**
*     @desc: Returns the list of all sub items from all next levels of tree, separated by commas.
*     @param: itemId - id of node
*     @edition: Professional
*     @type: private
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getAllScraggyItems =function(node)
   {
      var z="";
      for (var i=0; i<node.childsCount; i++)
        {
            if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
            {
                    if (node.childNodes[i].unParsed)
                        var zb=this._getAllScraggyItemsXML(node.childNodes[i].unParsed,1);
                    else
                       var zb=this._getAllScraggyItems(node.childNodes[i])

                 if (zb)
                        if (z) z+=this.dlmtr+zb;
                        else z=zb;
         }
            else
               if (!z) z=""+node.childNodes[i].id;
             else z+=this.dlmtr+node.childNodes[i].id;
         }
          return z;
   };





/**
*     @desc: Returns the list of all children items from all next levels of tree, separated by commas.
*     @param: itemId - id of node
*     @type: private
*     @edition: Professional
*     @topic: 6
*/

   dhtmlXTreeObject.prototype._getAllFatItems =function(node)
   {
      var z="";
      for (var i=0; i<node.childsCount; i++)
        {
            if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
            {
             if (!z) z=""+node.childNodes[i].id;
                else z+=this.dlmtr+node.childNodes[i].id;

                    if (node.childNodes[i].unParsed)
                        var zb=this._getAllFatItemsXML(node.childNodes[i].unParsed,1);
                    else
                       var zb=this._getAllFatItems(node.childNodes[i])

                 if (zb) z+=this.dlmtr+zb;
         }
         }
          return z;
   };


/**
*     @desc: Returns the list of all children items from all next levels of tree, separated by commas.
*     @param: itemId - id of node
*     @type: private
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getAllSubItems =function(itemId,z,node)
   {
      if (node) temp=node;
      else {
      var temp=this._globalIdStorageFind(itemId);
         };
      if (!temp) return 0;

      z="";
      for (var i=0; i<temp.childsCount; i++)
         {
         if (!z) z=""+temp.childNodes[i].id;
            else z+=this.dlmtr+temp.childNodes[i].id;
         var zb=this._getAllSubItems(0,z,temp.childNodes[i])

         if (zb) z+=this.dlmtr+zb;
         }

//#__pro_feature:01112006{
//#smart_parsing:01112006{
        if (temp.unParsed)
            z=this._getAllSubItemsXML(itemId,z,temp.unParsed);
//#}
//#}
          return z;
   };




   
/**  
*     @desc: select node ( and optionaly fire onselect event)
*     @type: public
*     @param: itemId - node id
*     @param: mode - If true, script function for selected node will be called.
*     @param: preserve - preserve earlier selected nodes
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.selectItem=function(itemId,mode,preserve){
      mode=dhx4.s2b(mode);
         var temp=this._globalIdStorageFind(itemId);
      if ((!temp)||(!temp.parentObject)) return 0;

            if (this.XMLloadingWarning)
                temp.parentObject.openMe=1;
            else
             	this._openItem(temp.parentObject);

      //temp.onRowSelect(0,temp.htmlNode.childNodes[0].childNodes[0].childNodes[3],mode);
        var ze=null;
        if (preserve)  {
			ze=new Object; ze.ctrlKey=true;
			if (temp.i_sel) ze.skipUnSel=true;
		}
      if (mode)
         this.onRowSelect(ze,temp.htmlNode.childNodes[0].childNodes[0].childNodes[3],false);
      else
         this.onRowSelect(ze,temp.htmlNode.childNodes[0].childNodes[0].childNodes[3],true);
   };
   
/**
*     @desc: retun selected node text
*     @type: public
*     @return: text of selected node (or list of all selected nodes text if more than one selected)
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.getSelectedItemText=function()
   {
        var str=new Array();
        for (var i=0; i<this._selected.length; i++) str[i]=this._selected[i].span.innerHTML;
      return (str.join(this.dlmtr));
   };




/**  
*     @desc: correct childNode list after node deleting
*     @type: private
*     @param: Count - childNodes collection length        
*     @param: Nodes - childNodes collection
*     @topic: 4  
*/   
   dhtmlXTreeObject.prototype._compressChildList=function(Count,Nodes)
   {
      Count--;
      for (var i=0; i<Count; i++)
      {
         if (Nodes[i]==0) { Nodes[i]=Nodes[i+1]; Nodes[i+1]=0;}
      };
   };
/**  
*     @desc: delete node
*     @type: private
*     @param: itemId - target node id
*     @param: htmlObject - target node object        
*     @param: skip - node unregistration mode (optional, used by private methods)
*     @topic: 2
*/      
   dhtmlXTreeObject.prototype._deleteNode=function(itemId,htmlObject,skip){
   if ((!htmlObject)||(!htmlObject.parentObject)) return 0;
   var tempos=0; var tempos2=0;
   if (htmlObject.tr.nextSibling)  tempos=htmlObject.tr.nextSibling.nodem;
   if (htmlObject.tr.previousSibling)  tempos2=htmlObject.tr.previousSibling.nodem;
   
      var sN=htmlObject.parentObject;
      var Count=sN.childsCount;
      var Nodes=sN.childNodes;
            for (var i=0; i<Count; i++)
            {
               if (Nodes[i].id==itemId) { 
               if (!skip) sN.htmlNode.childNodes[0].removeChild(Nodes[i].tr);
               Nodes[i]=0;
               break;
               }
            }
      this._compressChildList(Count,Nodes);
      if (!skip) {
        sN.childsCount--;
                 }

      if (tempos) {
      this._correctPlus(tempos);
      this._correctLine(tempos);
               }
      if (tempos2) {
      this._correctPlus(tempos2);
      this._correctLine(tempos2);
               }
      if (this.tscheck) this._correctCheckStates(sN);

      if (!skip) {
        this._globalIdStorageRecSub(htmlObject);
                 }
   };
/**
*     @desc: set state of node's checkbox
*     @type: public
*     @param: itemId - target node id
*     @param: state - checkbox state (0/1/"unsure")
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.setCheck=function(itemId,state){
      var sNode=this._globalIdStorageFind(itemId,0,1);
      if (!sNode) return;

        if (state==="unsure")
            this._setCheck(sNode,state);
        else
        {
      state=dhx4.s2b(state);
        if ((this.tscheck)&&(this.smcheck)) this._setSubChecked(state,sNode);
      else this._setCheck(sNode,state);
        }
      if (this.smcheck)
         this._correctCheckStates(sNode.parentObject);
   };

   dhtmlXTreeObject.prototype._setCheck=function(sNode,state){
   		if (!sNode) return;
        if (((sNode.parentObject._r_logic)||(this._frbtr))&&(state))
			if (this._frbtrs){
				if (this._frbtrL)   this.setCheck(this._frbtrL.id,0);
				this._frbtrL=sNode;
			} else
    	        for (var i=0; i<sNode.parentObject.childsCount; i++)
	                this._setCheck(sNode.parentObject.childNodes[i],0);

      var z=sNode.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0];

      if (state=="unsure") sNode.checkstate=2;
      else if (state) sNode.checkstate=1; else sNode.checkstate=0;
      if (sNode.dscheck) sNode.checkstate=sNode.dscheck;
      this._setSrc(z,this.imPath+((sNode.parentObject._r_logic||this._frbtr)?this.radioArray:this.checkArray)[sNode.checkstate]);
   };

/**
*     @desc: change state of node's checkbox and all children checkboxes
*     @type: public
*     @param: itemId - target node id
*     @param: state - checkbox state
*     @topic: 5
*/
dhtmlXTreeObject.prototype.setSubChecked=function(itemId,state){
   var sNode=this._globalIdStorageFind(itemId);
   this._setSubChecked(state,sNode);
   this._correctCheckStates(sNode.parentObject);
}



/**  
*     @desc: change state of node's checkbox and all childnodes checkboxes
*     @type: private
*     @param: itemId - target node id
*     @param: state - checkbox state
*     @param: sNode - target node object (optional, used by private methods)
*     @topic: 5  
*/
   dhtmlXTreeObject.prototype._setSubChecked=function(state,sNode){
      state=dhx4.s2b(state);
      if (!sNode) return;
        if (((sNode.parentObject._r_logic)||(this._frbtr))&&(state))
            for (var i=0; i<sNode.parentObject.childsCount; i++)
                this._setSubChecked(0,sNode.parentObject.childNodes[i]);

//#__pro_feature:01112006{
//#smart_parsing:01112006{
      if (sNode.unParsed)
         this._setSubCheckedXML(state,sNode.unParsed)
//#}
//#}
        if (sNode._r_logic||this._frbtr)
           this._setSubChecked(state,sNode.childNodes[0]);
        else
      for (var i=0; i<sNode.childsCount; i++)
         {
             this._setSubChecked(state,sNode.childNodes[i]);
         };
      var z=sNode.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0];

      if (state) sNode.checkstate=1;
      else    sNode.checkstate=0;
      if (sNode.dscheck)  sNode.checkstate=sNode.dscheck;



      this._setSrc(z,this.imPath+((sNode.parentObject._r_logic||this._frbtr)?this.radioArray:this.checkArray)[sNode.checkstate]);
   };

/**
*     @desc: get state of nodes's checkbox
*     @type: public
*     @param: itemId - target node id
*     @return: node state (0 - unchecked,1 - checked, 2 - third state)
*     @topic: 5  
*/      
   dhtmlXTreeObject.prototype.isItemChecked=function(itemId){
      var sNode=this._globalIdStorageFind(itemId);
      if (!sNode) return;      
      return   sNode.checkstate;
   };







/**
*     @desc: delete all children of node
*     @type: public
*     @param: itemId - node id
*     @topic: 2
*/
    dhtmlXTreeObject.prototype.deleteChildItems=function(itemId)
   {
      var sNode=this._globalIdStorageFind(itemId);
      if (!sNode) return;
      var j=sNode.childsCount;
      for (var i=0; i<j; i++)
      {
         this._deleteNode(sNode.childNodes[0].id,sNode.childNodes[0]);
      };
   };

/**
*     @desc: delete node
*     @type: public
*     @param: itemId - node id
*     @param: selectParent - If true parent of deleted item get selection, else no selected items leaving in tree.
*     @topic: 2  
*/      
dhtmlXTreeObject.prototype.deleteItem=function(itemId,selectParent){
    if ((!this._onrdlh)||(this._onrdlh(itemId))){
		var z=this._deleteItem(itemId,selectParent);
//#__pro_feature:01112006{
//#child_calc:01112006{
    if (z)
        this._fixChildCountLabel(z);
//#}
//#}
	}

    //nb:solves standard doctype prb in IE
      this.allTree.childNodes[0].border = "1";
      this.allTree.childNodes[0].border = "0";
}
/**
*     @desc: delete node
*     @type: private
*     @param: id - node id
*     @param: selectParent - If true parent of deleted item get selection, else no selected items leaving in tree.
*     @param: skip - unregistering mode (optional, used by private methods)        
*     @topic: 2  
*/
dhtmlXTreeObject.prototype._deleteItem=function(itemId,selectParent,skip){
      selectParent=dhx4.s2b(selectParent);
      var sNode=this._globalIdStorageFind(itemId);
      if (!sNode) return;
        var pid=this.getParentId(itemId);

      var zTemp=sNode.parentObject;
      this._deleteNode(itemId,sNode,skip);
      if(this._editCell&&this._editCell.id==itemId)
     	this._editCell = null;
      this._correctPlus(zTemp);
      this._correctLine(zTemp);

      if  ((selectParent)&&(pid!=this.rootId)) this.selectItem(pid,1);
      return    zTemp;
   };

/**
*     @desc: uregister all child nodes of target node
*     @type: private
*     @param: itemObject - node object
*     @topic: 3  
*/      
   dhtmlXTreeObject.prototype._globalIdStorageRecSub=function(itemObject){
      for(var i=0; i<itemObject.childsCount; i++)
      {
         this._globalIdStorageRecSub(itemObject.childNodes[i]);
         this._globalIdStorageSub(itemObject.childNodes[i].id);
      };
      this._globalIdStorageSub(itemObject.id);

      	  /*anti memory leaking*/
	  	var z=itemObject;
//		var par=z.span.parentNode.parentNode.childNodes;
//		par[0].parentObject=null;
//		par[1].childNodes[0].parentObject=null;
//		par[2].childNodes[0].parentObject=null;
//		par[2].childNodes[0].treeNod=null;
//		par[2].parentObject=null;
//		par[3].parentObject=null;
		z.span=null;
		z.tr.nodem=null;
		z.tr=null;
		z.htmlNode=null;
   };

/**  
*     @desc: create new node next to specified
*     @type: public
*     @param: itemId - node id
*     @param: newItemId - new node id
*     @param: itemText - new node text
*     @param: itemActionHandler - function fired on node select event (optional)
*     @param: image1 - image for node without children; (optional)
*     @param: image2 - image for closed node; (optional)
*     @param: image3 - image for opened node (optional)
*     @param: optionStr - options string (optional)            
*     @param: children - node children flag (for dynamical trees) (optional)
*     @topic: 2  
*/
   dhtmlXTreeObject.prototype.insertNewNext=function(itemId,newItemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children){
      var sNode=this._globalIdStorageFind(itemId);
      if ((!sNode)||(!sNode.parentObject)) return (0);

      var nodez=this._attachChildNode(0,newItemId,itemText,itemActionHandler,image1,image2,image3,optionStr,children,sNode);
//#__pro_feature:01112006{
//#child_calc:01112006{
      if ((!this.XMLloadingWarning)&&(this.childCalc))  this._fixChildCountLabel(sNode.parentObject);
//#}
//#}
        return nodez;
   };


   
/**
*     @desc: retun node id by index
*     @type: public
*     @param: itemId - parent node id
*     @param: index - index of node, 0 based
*     @return: node id
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.getItemIdByIndex=function(itemId,index){
       var z=this._globalIdStorageFind(itemId);
       if ((!z)||(index>=z.childsCount)) return null;
          return z.childNodes[index].id;
   };

/**
*     @desc: retun child node id by index
*     @type: public
*     @param: itemId - parent node id        
*     @param: index - index of child node
*     @return: node id
*     @topic: 1
*/      
   dhtmlXTreeObject.prototype.getChildItemIdByIndex=function(itemId,index){
       var z=this._globalIdStorageFind(itemId);
       if ((!z)||(index>=z.childsCount)) return null;
          return z.childNodes[index].id;
   };



   

/**
*     @desc: set function called when drag-and-drop event occured
*     @param: aFunc - event handling function
*     @type: deprecated
*     @topic: 0,7
*     @event:    onDrag
*     @depricated: use grid.attachEvent("onDrag",func); instead
*     @eventdesc: Event occured after item was dragged and droped on another item, but before item moving processed.
      Event also raised while programmatic moving nodes.
*     @eventparam:  ID of source item
*     @eventparam:  ID of target item
*     @eventparam:  if node droped as sibling then contain id of item before whitch source node will be inserted
*     @eventparam:  source Tree object
*     @eventparam:  target Tree object
*     @eventreturn:  true - confirm drag-and-drop; false - deny drag-and-drop;
*/
   dhtmlXTreeObject.prototype.setDragHandler=function(func){ this.attachEvent("onDrag",func); };
   
   /**
*     @desc: clear selection from node
*     @param: htmlNode - pointer to node object
*     @type: private
*     @topic: 1
*/
    dhtmlXTreeObject.prototype._clearMove=function(){
		if (this._lastMark){
	   		this._lastMark.className=this._lastMark.className.replace(/dragAndDropRow/g,"");
	   		this._lastMark=null;
		}
//#__pro_feature:01112006{
//#complex_move:01112006{
		this.selectionBar.style.display="none";
//#}
//#}
		this.allTree.className=this.allTree.className.replace(" selectionBox","");
   };

   /**  
*     @desc: enable/disable drag-and-drop
*     @type: public
*     @param: mode - enabled/disabled [ can be true/false/temporary_disabled - last value mean that tree can be D-n-D can be switched to true later ]
*     @param: rmode - enabled/disabled drag and drop on super root
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableDragAndDrop=function(mode,rmode){
        if  (mode=="temporary_disabled"){
            this.dADTempOff=false;
            mode=true;                  }
        else
            this.dADTempOff=true;

      this.dragAndDropOff=dhx4.s2b(mode);
         if (this.dragAndDropOff) this.dragger.addDragLanding(this.allTree,this);
        if (arguments.length>1)
            this._ddronr=(!dhx4.s2b(rmode));
       };   

/**
*     @desc: set selection on node
*     @param: node - pointer to node object
*     @type: private
*     @topic: 1
*/    
   dhtmlXTreeObject.prototype._setMove=function(htmlNode,x,y){
      if (htmlNode.parentObject.span) {
      //window.status=x;
      var a1=dhx4.absTop(htmlNode);
      var a2=dhx4.absTop(this.allTree)-this.allTree.scrollTop;

      this.dadmodec=this.dadmode;//this.dadmode;
      this.dadmodefix=0;
//#__pro_feature:01112006{
//#complex_move:01112006{
      if (this.dadmode==2)
      {

      var z=y-a1+(document.body.scrollTop||document.documentElement.scrollTop)-2-htmlNode.offsetHeight/2;
      if ((Math.abs(z)-htmlNode.offsetHeight/6)>0)
      {
         this.dadmodec=1;
         //sibbling zone
         if (z<0)
            this.dadmodefix=0-htmlNode.offsetHeight;
      }
      else this.dadmodec=0;

      }
      if (this.dadmodec==0)
         {
//#}
//#} 

			var zN=htmlNode.parentObject.span;
			zN.className+=" dragAndDropRow";
			this._lastMark=zN;
//#__pro_feature:01112006{
//#complex_move:01112006{
         }
      else{
 	  	 this._clearMove();
         this.selectionBar.style.top=(a1-a2+((parseInt(htmlNode.parentObject.span.parentNode.parentNode.offsetHeight)||18)-1)+this.dadmodefix)+"px";
         this.selectionBar.style.left="5px";
           if (this.allTree.offsetWidth>20)
                this.selectionBar.style.width=(this.allTree.offsetWidth-(_isFF?30:25))+"px";
         this.selectionBar.style.display="";
         }
//#}
//#}
         this._autoScroll(null,a1,a2);

      }
   };

dhtmlXTreeObject.prototype._autoScroll=function(node,a1,a2){
         if (this.autoScroll)
         {
		 	if (node){
				a1=dhx4.absTop(node);
	      		a2=dhx4.absTop(this.allTree)-this.allTree.scrollTop;
			}
            //scroll down
            if ( (a1-a2-parseInt(this.allTree.scrollTop))>(parseInt(this.allTree.offsetHeight)-50) )
               this.allTree.scrollTop=parseInt(this.allTree.scrollTop)+20;
            //scroll top
            if ( (a1-a2)<(parseInt(this.allTree.scrollTop)+30) )
               this.allTree.scrollTop=parseInt(this.allTree.scrollTop)-20;
         }
}

/**
*     @desc: create html element for dragging
*     @type: private
*     @param: htmlObject - html node object
*     @topic: 1
*/
dhtmlXTreeObject.prototype._createDragNode=function(htmlObject,e){
      if (!this.dADTempOff) return null;

     var obj=htmlObject.parentObject;
     if (!this.callEvent("onBeforeDrag",[obj.id, e])) return null;
    if (!obj.i_sel){

         this._selectItem(obj,e);
}
//#__pro_feature:01112006{
//#multiselect:01112006{
      this._checkMSelectionLogic();
//#}
//#}
      var dragSpan=document.createElement('div');

            var text=new Array();
            if (this._itim_dg)
                    for (var i=0; i<this._selected.length; i++)
                        text[i]="<table cellspacing='0' cellpadding='0'><tr><td><img width='18px' height='18px' src='"+this._getSrc(this._selected[i].span.parentNode.previousSibling.childNodes[0])+"'></td><td>"+this._selected[i].span.innerHTML+"</td></tr></table>";
            else
                text=this.getSelectedItemText().split(this.dlmtr);

            dragSpan.innerHTML=text.join("");
         dragSpan.style.position="absolute";
         dragSpan.className="dragSpanDiv";
      this._dragged=(new Array()).concat(this._selected);
     return dragSpan;
}



/**  
*     @desc: focus item in tree
*     @type: private
*     @param: item - node object
*     @edition: Professional
*     @topic: 0  
*/
dhtmlXTreeObject.prototype._focusNode=function(item){
	var z=dhx4.absTop(item.htmlNode)-dhx4.absTop(this.allTree);
	if ((z>(this.allTree.offsetHeight-30)) || (z<0))
		this.allTree.scrollTop=z+this.allTree.scrollTop;
};




              








///DragAndDrop

dhtmlXTreeObject.prototype._preventNsDrag=function(e){
   if ((e)&&(e.preventDefault)) { e.preventDefault(); return false; }
   return false;
}

dhtmlXTreeObject.prototype._drag=function(sourceHtmlObject,dhtmlObject,targetHtmlObject){
      if (this._autoOpenTimer) clearTimeout(this._autoOpenTimer);

      if (!targetHtmlObject.parentObject){
            targetHtmlObject=this.htmlNode.htmlNode.childNodes[0].childNodes[0].childNodes[1].childNodes[0];
            this.dadmodec=0;
            }

      this._clearMove();
      var z=sourceHtmlObject.parentObject.treeNod;
        if ((z)&&(z._clearMove))   z._clearMove("");

       if ((!this.dragMove)||(this.dragMove()))
          {
              if ((!z)||(!z._clearMove)||(!z._dragged)) var col=new Array(sourceHtmlObject.parentObject);
              else var col=z._dragged;
				var trg=targetHtmlObject.parentObject;

                for (var i=0; i<col.length; i++){
                   var newID=this._moveNode(col[i],trg);
				   if ((this.dadmodec)&&(newID!==false)) trg=this._globalIdStorageFind(newID,true,true);
                   if ((newID)&&(!this._sADnD)) this.selectItem(newID,0,1);
                }

         }
        if (z) z._dragged=new Array();


}

dhtmlXTreeObject.prototype._dragIn=function(htmlObject,shtmlObject,x,y){

                    if (!this.dADTempOff) return 0;
                    var fobj=shtmlObject.parentObject;
                    var tobj=htmlObject.parentObject;
	                if ((!tobj)&&(this._ddronr)) return;
                    if (!this.callEvent("onDragIn",[fobj.id,tobj?tobj.id:null,fobj.treeNod,this])){
                    	if (tobj) this._autoScroll(htmlObject);
                    	return 0;
                    }
						

					if (!tobj) 
		            	this.allTree.className+=" selectionBox";
					else
					{
	                    if (fobj.childNodes==null){
		                	this._setMove(htmlObject,x,y);
        	             	return htmlObject;
                    	}

	                    var stree=fobj.treeNod;
    	                for (var i=0; i<stree._dragged.length; i++)
                        	if (this._checkPNodes(tobj,stree._dragged[i])){
						   		this._autoScroll(htmlObject);
                           		return 0;
							}
//#__pro_feature:01112006{
//#complex_move:01112006{	 
				this.selectionBar.parentNode.removeChild(this.selectionBar);
				tobj.span.parentNode.appendChild(this.selectionBar);
//#}
//#}
                       this._setMove(htmlObject,x,y);
                       if (this._getOpenState(tobj)<=0){
                           var self = this;
                           this._autoOpenId=tobj.id;
                           this._autoOpenTimer=window.setTimeout(function(){
                             self._autoOpenItem(null, self);
                             self = null;
                           }, 1000);
                       }
					}
					
				return htmlObject;

}
dhtmlXTreeObject.prototype._autoOpenItem=function(e,treeObject){
   treeObject.openItem(treeObject._autoOpenId);
};
dhtmlXTreeObject.prototype._dragOut=function(htmlObject){
this._clearMove();
if (this._autoOpenTimer) clearTimeout(this._autoOpenTimer);
 }


//#__pro_feature:01112006{

/**  
*     @desc: return next node
*     @type: private
*     @param: item - node object
*     @param: mode - inner flag
*     @return: next node or -1
*     @topic: 2
*/
dhtmlXTreeObject.prototype._getNextNode=function(item,mode){
   if ((!mode)&&(item.childsCount)) return item.childNodes[0];
   if (item==this.htmlNode)
      return -1;
   if ((item.tr)&&(item.tr.nextSibling)&&(item.tr.nextSibling.nodem))
   return item.tr.nextSibling.nodem;

   return this._getNextNode(item.parentObject,true);
};

/**  
*     @desc: return last child of item (include all sub-child collections)
*     @type: private
*     @param: item - node object
*     @topic: 2  
*/
dhtmlXTreeObject.prototype._lastChild=function(item){
   if (item.childsCount)
      return this._lastChild(item.childNodes[item.childsCount-1]);
   else return item;
};

/**  
*     @desc: return previous node
*     @type: private
*     @param: item - node object
*     @param: mode - inner flag
*     @return: previous node or -1
*     @topic: 2  
*/
dhtmlXTreeObject.prototype._getPrevNode=function(node,mode){
   if ((node.tr)&&(node.tr.previousSibling)&&(node.tr.previousSibling.nodem))
   return this._lastChild(node.tr.previousSibling.nodem);

   if (node.parentObject)
      return node.parentObject;
   else return -1;
};



//#find_item:01112006{

/**
*     @desc: find tree item by text, select and focus it
*     @type: public
*     @param: searchStr - search text
*     @param: direction - 0: top -> bottom; 1: bottom -> top
*     @param: top - 1: start searching from top
*     @return: node id
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.findItem=function(searchStr,direction,top){
   var z=this._findNodeByLabel(searchStr,direction,(top?this.htmlNode:null));
   if (z){
      this.selectItem(z.id,true);
      this._focusNode(z);
      return z.id;
      }
      else return null;
}

/**  
*     @desc: find tree item by text
*     @type: public
*     @param: searchStr - search text
*     @param: direction - 0: top -> bottom; 1: bottom -> top
*     @param: top - 1: start searching from top
*     @return: node id
*     @edition: Professional
*     @topic: 2  
*/
dhtmlXTreeObject.prototype.findItemIdByLabel=function(searchStr,direction,top){
   var z=this._findNodeByLabel(searchStr,direction,(top?this.htmlNode:null));
   if (z)
      return z.id
   else return null;
}

//#smart_parsing:01112006{
/**  
*     @desc: find tree item by text in unParsed XML
*     @type: private
*     @param: node - start xml node
*     @param: field - name of xml attribute
*     @param: cvalue - search text
*     @return: true/false
*     @topic: 2  
*/
dhtmlXTreeObject.prototype.findStrInXML=function(node,field,cvalue){ 
   if (!node.childNodes && node.item) return this.findStrInJSON(node,field,cvalue);
   if(!node.childNodes)
       return false;
   for (var i=0; i<node.childNodes.length; i++)
   {
   if (node.childNodes[i].nodeType==1)
      {
      	
        var z=node.childNodes[i].getAttribute(field);
        if (!z && node.childNodes[i].tagName=="itemtext")  z=node.childNodes[i].firstChild.data; 
      if ((z)&&(z.toLowerCase().search(cvalue)!=-1))
         return true;
      if (this.findStrInXML(node.childNodes[i],field,cvalue)) return true;
      }
   }
   return false;
}
dhtmlXTreeObject.prototype.findStrInJSON=function(node,field,cvalue){ 
   for (var i=0; i<node.item.length; i++)
   {
	    var z=node.item[i].text;
        if ((z)&&(z.toLowerCase().search(cvalue)!=-1))
         return true;
      if (node.item[i].item && this.findStrInJSON(node.item[i],field,cvalue)) return true;
   }
   return false;
}
//#}

/**  
*     @desc: find tree item by text
*     @type: private
*     @param: searchStr - search text
*     @param: direction - 0: top -> bottom; 1: bottom -> top
*     @param: fromNode - node from which search begin
*     @return: node id
*     @topic: 2  
*/
dhtmlXTreeObject.prototype._findNodeByLabel=function(searchStr,direction,fromNode){
   //trim
   var searchStr=searchStr.replace(new RegExp("^( )+"),"").replace(new RegExp("( )+$"),"");
   searchStr =  new RegExp(searchStr.replace(/([\^\.\?\*\+\\\[\]\(\)]{1})/gi,"\\$1").replace(/ /gi,".*"),"gi");

   //get start node
   if (!fromNode)
      {
      fromNode=this._selected[0];
      if (!fromNode) fromNode=this.htmlNode;
      }

   var startNode=fromNode;

   //first step
   if (!direction){
      if ((fromNode.unParsed)&&(this.findStrInXML(fromNode.unParsed.d,"text",searchStr)))
      this.reParse(fromNode);
   fromNode=this._getNextNode(startNode);
   if (fromNode==-1) fromNode=this.htmlNode.childNodes[0];
   }
   else
   {
      var z2=this._getPrevNode(startNode);
      if (z2==-1) z2=this._lastChild(this.htmlNode);
      if ((z2.unParsed)&&(this.findStrInXML(z2.unParsed.d,"text",searchStr)))
      {   this.reParse(z2); fromNode=this._getPrevNode(startNode); }
      else fromNode=z2;
      if (fromNode==-1) fromNode=this._lastChild(this.htmlNode);
   }



   while ((fromNode)&&(fromNode!=startNode)){
      if ((fromNode.label)&&(fromNode.label.search(searchStr)!=-1))
            return (fromNode);

      if (!direction){
      if (fromNode==-1) { if (startNode==this.htmlNode) break; fromNode=this.htmlNode.childNodes[0]; }
      if ((fromNode.unParsed)&&(this.findStrInXML(fromNode.unParsed.d,"text",searchStr)))
         this.reParse(fromNode);
      fromNode=this._getNextNode(fromNode);
      if (fromNode==-1) fromNode=this.htmlNode;
      }
      else
      {
      var z2=this._getPrevNode(fromNode);
      if (z2==-1) z2=this._lastChild(this.htmlNode);
      if ((z2.unParsed)&&(this.findStrInXML(z2.unParsed.d,"text",searchStr)))
         {   this.reParse(z2); fromNode=this._getPrevNode(fromNode); }
      else fromNode=z2;
      if (fromNode==-1) fromNode=this._lastChild(this.htmlNode);
      }
   }
   return null;
};

//#}
//#}


//#complex_move:01112006{

/**
*     @desc: move item (inside of tree)
*     @type:  public
*     @param: itemId - item Id
*     @param: mode - moving mode (left,up,down,item_child,item_sibling,item_sibling_next,up_strict,down_strict)
*     @param: targetId - target Node in item_child and item_sibling mode
*     @param: targetTree - used for moving between trees (optional)
*     @return: node id
*     @topic: 2
*/
dhtmlXTreeObject.prototype.moveItem=function(itemId,mode,targetId,targetTree)
{
	var sNode=this._globalIdStorageFind(itemId);
	if (!sNode) return (0);
	var resultId = null;
	switch(mode){
		case "right":
			alert('Not supported yet');
			break;
		case "item_child":
			var tNode=(targetTree||this)._globalIdStorageFind(targetId);
			if (!tNode) return (0);
			resultId = (targetTree||this)._moveNodeTo(sNode,tNode,0);
			break;
		case "item_sibling":
			var tNode=(targetTree||this)._globalIdStorageFind(targetId);
			if (!tNode) return (0);
			resultId = (targetTree||this)._moveNodeTo(sNode,tNode.parentObject,tNode);
			break;
		case "item_sibling_next":
			var tNode=(targetTree||this)._globalIdStorageFind(targetId);
			if (!tNode) return (0);
			if ((tNode.tr)&&(tNode.tr.nextSibling)&&(tNode.tr.nextSibling.nodem))
				resultId = (targetTree||this)._moveNodeTo(sNode,tNode.parentObject,tNode.tr.nextSibling.nodem);
			else
				resultId = (targetTree||this)._moveNodeTo(sNode,tNode.parentObject);
			break;
		case "left":
			if (sNode.parentObject.parentObject)
				resultId = this._moveNodeTo(sNode,sNode.parentObject.parentObject,sNode.parentObject);
			break;
		case "up":
			var z=this._getPrevNode(sNode);
			if ((z==-1)||(!z.parentObject)) return null;
			resultId = this._moveNodeTo(sNode,z.parentObject,z);
			break;
		case "up_strict":
			var z=this._getIndex(sNode);
			if (z!=0)
				resultId = this._moveNodeTo(sNode,sNode.parentObject,sNode.parentObject.childNodes[z-1]);
			break;
		case "down_strict":
			var z=this._getIndex(sNode);
			var count=sNode.parentObject.childsCount-2;
			if (z==count)
				resultId = this._moveNodeTo(sNode,sNode.parentObject);
			else if (z<count)
				resultId = this._moveNodeTo(sNode,sNode.parentObject,sNode.parentObject.childNodes[z+2]);
			break;
		case "down":
			var z=this._getNextNode(this._lastChild(sNode));
			if ((z==-1)||(!z.parentObject)) return;
			if (z.parentObject==sNode.parentObject)
				var z=this._getNextNode(z);
			if (z==-1){
				resultId = this._moveNodeTo(sNode,sNode.parentObject);
			}
			else{
				if ((z==-1)||(!z.parentObject)) return;
				resultId = this._moveNodeTo(sNode,z.parentObject,z);
			}
			break;
	}
	if (_isIE && _isIE<8){
		this.allTree.childNodes[0].border = "1";
		this.allTree.childNodes[0].border = "0";
	}
	return resultId;
}

//#__pro_feature:01112006{

/**
*     @desc: set Drag-And-Drop behavior (child - drop as chils, sibling - drop as sibling, complex - complex drop behaviour )
*     @type: public
*     @edition: Professional
*     @param: mode - behavior name (child,sibling,complex)
*     @param: select - select droped node after drag-n-drop, true by default
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.setDragBehavior=function(mode,select){
		this._sADnD=(!dhx4.s2b(select));
		switch (mode) {
			case "child": this.dadmode=0; break;
			case "sibling": this.dadmode=1; break;
			case "complex": this.dadmode=2; break;
		}    };




//#}
//#}







/**
*     @desc: load xml for tree branch
*     @param: id - id of parent node
*     @param: src - path to xml, optional
*     @type: private
*     @topic: 1
*/
   dhtmlXTreeObject.prototype._loadDynXML=function(id,src) {
   		src=src||this.XMLsource;
        var sn=(new Date()).valueOf();
        this._ld_id=id;
//#__pro_feature:01112006{
        if (this.xmlalb=="function"){
            if (src) src(this._escape(id));
            }
        else
        if (this.xmlalb=="name")
            this.load(src+this._escape(id));
        else
        if (this.xmlalb=="xmlname")
            this.load(src+this._escape(id)+".xml?uid="+sn);
        else
//#}
            this.load(src+dhtmlx.url(src)+"uid="+sn+"&id="+this._escape(id));
        };


//#__pro_feature:01112006{
//#multiselect:01112006{
/**
*     @desc: enable multiselection
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @param: strict - 1 - on, 0 - off; in strict mode only items on the same level can be selected
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableMultiselection=function(mode,strict) {
        this._amsel=dhx4.s2b(mode);
        this._amselS=dhx4.s2b(strict);
        };

/**
*     @desc: check logic of selection
*     @type: private
*     @edition: Professional
*     @topic: 0
*/
dhtmlXTreeObject.prototype._checkMSelectionLogic=function() {
            var usl=new Array();
         for (var i=0; i<this._selected.length; i++)
            for (var j=0; j<this._selected.length; j++)
                  if ((i!=j)&&(this._checkPNodes(this._selected[j],this._selected[i])))
                            usl[usl.length]=this._selected[j];

         for (var i=0; i<usl.length; i++)
             this._unselectItem(usl[i]);

         };
//#}
//#}




/**
*     @desc: check possibility of drag-and-drop
*     @type: private
*     @param: itemId - draged node id
*     @param: htmlObject - droped node object
*     @param: shtmlObject - sourse node object
*     @topic: 6
*/
    dhtmlXTreeObject.prototype._checkPNodes=function(item1,item2){
      if (this._dcheckf) return false;
      if (item2==item1) return 1
      if (item1.parentObject) return this._checkPNodes(item1.parentObject,item2); else return 0;
   };
   dhtmlXTreeObject.prototype.disableDropCheck = function(mode){
      this._dcheckf = dhx4.s2b(mode);
   };


//#__pro_feature:01112006{
//#distributed_load:01112006{

/**
*     @desc: enable distributed parsing of big tree (items loaded portion by portion with some timeouts)
*     @type: public
*     @edition: Professional
*     @param: mode - true/false
*     @param: count - critical count to start distibuting (optional)
*     @param: delay - delay between distributed calls, ms (optional)
*     @topic: 2
*/
dhtmlXTreeObject.prototype.enableDistributedParsing=function(mode,count,delay){
    this._edsbps=dhx4.s2b(mode);
    this._edsbpsA=new Array();
    this._edsbpsC=count||10;
    this._edsbpsD=delay||250;
}
/**
*     @desc: get current state of distributed parsing
*     @type: public
*     @edition: Professional
*     @returns: true - still parsing; false - parsing finished
*     @topic: 2
*/
dhtmlXTreeObject.prototype.getDistributedParsingState=function(){
    return (!((!this._edsbpsA)||(!this._edsbpsA.length)));
}
/**
*     @desc: get current parsing state of item
*     @type: public
*     @edition: Professional
*     @returns: 1 - item already parsed; 0 - item not parsed yet; -1 - item in parsing process
*     @topic: 2
*/
dhtmlXTreeObject.prototype.getItemParsingState=function(itemId){
    var z=this._globalIdStorageFind(itemId,true,true)
    if (!z) return 0;
    if (this._edsbpsA)
        for (var i=0; i<this._edsbpsA.length; i++)
            if (this._edsbpsA[i][2]==itemId) return -1;

    return 1;
}

dhtmlXTreeObject.prototype._distributedStart=function(node,start,parentId,level,start2){
    if (!this._edsbpsA)
        this._edsbpsA=new Array();
    this._edsbpsA[this._edsbpsA.length]=[node,start,parentId,level,start2];
}

dhtmlXTreeObject.prototype._distributedStep=function(pId){
    var self=this;
    if ((!this._edsbpsA)||(!this._edsbpsA.length)) {
         self.XMLloadingWarning=0;
         return;
         }
    var z=this._edsbpsA[0];
    this.parsedArray=new Array();
    this._parse(z[0],z[2],z[3],z[1]);
    var zkx=this._globalIdStorageFind(z[2]);
    this._redrawFrom(this,zkx,z[4],this._getOpenState(zkx));
    var chArr=this.setCheckList.split(this.dlmtr);
   for (var n=0; n<chArr.length; n++)
      if (chArr[n]) this.setCheck(chArr[n],1);

    this._edsbpsA=(new Array()).concat(this._edsbpsA.slice(1));


    if ((!this._edsbpsA.length)){
         window.setTimeout( function(){ if (self.onXLE) self.onXLE(self,pId); self.callEvent("onXLE",[self,pId]); },1);
            self.xmlstate=0;
            }
}

//#}
//#}




//#__pro_feature:01112006{

/**
*     @desc: replace images with text signs
*     @type: public
*     @param: mode - true/false
*     @edition: Professional
*     @topic: 1
*/
dhtmlXTreeObject.prototype.enableTextSigns=function(mode){
    this._txtimg=dhx4.s2b(mode);
}

//#}

/**
*   @desc:  prevent caching in IE  by adding random value to URL string
*   @param: mode - enable/disable random value ( disabled by default )
*   @type: public
*   @topic: 0
*/
dhtmlXTreeObject.prototype.preventIECaching=function(mode){
      dhx4.ajax.cache = !mode;
}
dhtmlXTreeObject.prototype.preventIECashing=dhtmlXTreeObject.prototype.preventIECaching;





/**
*     @desc: disable checkbox
*     @param: itemId - Id of tree item
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.disableCheckbox=function(itemId,mode) {
            if (typeof(itemId)!="object")
             var sNode=this._globalIdStorageFind(itemId,0,1);
            else
                var sNode=itemId;
         if (!sNode) return;
            sNode.dscheck=dhx4.s2b(mode)?(((sNode.checkstate||0)%3)+3):((sNode.checkstate>2)?(sNode.checkstate-3):sNode.checkstate);
            this._setCheck(sNode);
                if (sNode.dscheck<3) sNode.dscheck=false;
         };

//#__pro_feature:01112006{


/**
*     @desc: refresh specified tree branch (get XML from server, add new nodes, remove not used nodes)
*     @param: itemId -  top node in branch
*     @param: source - server side script , optional
*     @type: public
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.smartRefreshBranch=function(itemId,source){
   		this._branchUpdate=1;
		this.smartRefreshItem(itemId,source);
   }

/**
*     @desc: refresh specified tree item (get XML from server, add new nodes, remove not used nodes)
*     @param: itemId -  top node in branch
*     @param: source - server side script , optional
*     @type: public
*     @edition: Professional
*     @topic: 6
*/
dhtmlXTreeObject.prototype.smartRefreshItem=function(itemId,source){
		var sNode=this._globalIdStorageFind(itemId);
		for (var i=0; i<sNode.childsCount; i++)
			sNode.childNodes[i]._dmark=true;

		this.waitUpdateXML=true;
		if (source && source.exists)
			this._parse(source,itemId);
		else
			this._loadDynXML(itemId,source);
};


/**
*     @desc: refresh specified tree nodes (get XML from server and updat only nodes included in itemIdList)
*     @param: itemIdList - list of node identificators
*     @param: source - server side script
*     @type: public
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.refreshItems=function(itemIdList,source){
   		var z=itemIdList.toString().split(this.dlmtr);
		this.waitUpdateXML=new Array();
		for (var i=0; i<z.length; i++)
			this.waitUpdateXML[z[i]]=true;
        this.load((source||this.XMLsource)+dhtmlx.url(source||this.XMLsource)+"ids="+this._escape(itemIdList));
   };


/**
*     @desc: update item properties
*     @param: itemId - list of node identificators
*     @param: name - list of node identificators, optional
*     @param: im0 - list of node identificators, optional
*     @param: im1 - list of node identificators, optional
*     @param: im2 - list of node identificators, optional
*     @param: achecked - list of node identificators, optional
*     @param: child - child attribute for dynamic loading
*     @type: public
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.updateItem=function(itemId,name,im0,im1,im2,achecked,child){
      var sNode=this._globalIdStorageFind(itemId);
	  sNode.userData=new cObject(); 
      if (name) sNode.label=name;
      sNode.images=new Array(im0||this.imageArray[0],im1||this.imageArray[1],im2||this.imageArray[2]);
	  this.setItemText(itemId,name);
      if (achecked) this._setCheck(sNode,true);
	  if(child=="1" && !this.hasChildren(itemId)) sNode.XMLload = 0;
      this._correctPlus(sNode);
	  sNode._dmark=false;
      return sNode;
   };

/**
*     @desc: set function called after drag-and-drap event occured
*     @param: func - event handling function
*     @type: deprecated
*     @edition: Professional
*     @topic: 0,7
*     @event:  onDrop
*     @depricated: use grid.attachEvent("onDrop",func); instead
*     @eventdesc:  Event raised after drag-and-drop processed. Event also raised while programmatic moving nodes.
*     @eventparam:  ID of source item (ID after inserting in tree, my be not equal to initial ID)
*     @eventparam:  ID of target item
*     @eventparam:  if node droped as sibling then contain id of item before whitch source node will be inserted
*     @eventparam:  source Tree object
*     @eventparam:  target Tree object
*/
   dhtmlXTreeObject.prototype.setDropHandler=function(func){  this.attachEvent("onDrop",func);  };

/**
*     @desc: set function called before xml loading/parsing started
*     @param: func - event handling function
*     @type: deprecated
*     @edition: Professional
*     @topic: 0,7
*     @event:  onXLS
*     @depricated: use grid.attachEvent("onXLS",func); instead
*     @eventdesc: event fired simultaneously with starting XML parsing
*     @eventparam: tree object
*     @eventparam: item id, for which xml loaded
*/
   dhtmlXTreeObject.prototype.setOnLoadingStart=function(func){    this.attachEvent("onXLS",func);  };
      /**
*     @desc: set function called after xml loading/parsing ended
*     @param: func - event handling function
*     @type: deprecated
*     @edition: Professional
*     @topic: 0,7
*     @event:  onXLE
*     @depricated: use grid.attachEvent("onXLE",func); instead
*     @eventdesc: event fired simultaneously with ending XML parsing, new items already available in tree
*     @eventparam: tree object
*     @eventparam: last parsed parent id
*/
     dhtmlXTreeObject.prototype.setOnLoadingEnd=function(func){  this.attachEvent("onXLE",func); };



/**
*     @desc: define which script be called on dynamic loading
*     @param: mode - id for some_script?id=item_id ;  name for  some_scriptitem_id, xmlname for  some_scriptitem_id.xml ; function for calling user defined handler
*     @type: public
*     @edition: Professional
*     @topic: 1
*/
   dhtmlXTreeObject.prototype.setXMLAutoLoadingBehaviour=function(mode) {
            this.xmlalb=mode;
         };


/**
*     @desc: enable smart checkboxes ,true by default (auto checking children and parents for 3-state checkboxes)
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableSmartCheckboxes=function(mode) { this.smcheck=dhx4.s2b(mode); };

/**
*     @desc: return current state of XML loading
*     @type: public
*     @edition: Professional
*     @return: current state, true - xml loading now
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.getXMLState=function(){ return (this.xmlstate==1); };

/**
*     @desc: set top offset for item
*     @type: public
*     @param: itemId - id of item
*     @param: value - value of top offset in px
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setItemTopOffset=function(itemId,value){
    var node;
    if (typeof(itemId)!="object")
        node=this._globalIdStorageFind(itemId);
    else
        node=itemId;
    var z=node.span.parentNode.parentNode;
    node.span.style.paddingBottom="1px";
  
    for (var i=0; i<z.childNodes.length; i++){
        if (i!=0){
      
            if (_isIE){
                z.childNodes[i].style.height="18px";
                z.childNodes[i].style.paddingTop=parseInt(value)+"px";
            }else
                z.childNodes[i].style.height=18+parseInt(value)+"px";
        }
        else{
            var w=z.childNodes[i].firstChild;
            if (z.childNodes[i].firstChild.tagName!='DIV'){
              w=document.createElement("DIV");
              z.childNodes[i].insertBefore(w,z.childNodes[i].firstChild);
            }
            
            if ((node.parentObject.id!=this.rootId || node.parentObject.childNodes[0]!=node) && this.treeLinesOn){
                z.childNodes[i].style.backgroundImage="url("+this.imPath+this.lineArray[5]+")";
            }
            w.innerHTML="&nbsp;";
            w.style.overflow='hidden';
            
        }
        
        w.style.verticalAlign = z.childNodes[i].style.verticalAlign="bottom";
        if (_isIE){
            this.allTree.childNodes[0].border = "1";
            this.allTree.childNodes[0].border = "0";
        }
    }
}

/**
*     @desc: set size of icons
*     @type:  public
*     @param: newWidth - new icon width
*     @param: newHeight - new icon height
*     @param: itemId - item Id, if skipped set default value for all new icons, optional
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setIconSize=function(newWidth,newHeight,itemId)
{
      if (itemId){
         if ((itemId)&&(itemId.span))
            var sNode=itemId;
         else
            var sNode=this._globalIdStorageFind(itemId);

         if (!sNode) return (0);
         var img=sNode.span.parentNode.previousSibling.childNodes[0];
            if (newWidth) {
            	img.style.width=newWidth+"px";
            	if (window._KHTMLrv) img.parentNode.style.width=newWidth+"px";
        	}
            if (newHeight) {
            	img.style.height=newHeight+"px";
            	if (window._KHTMLrv) img.parentNode.style.height=newHeight+"px";
        	}
         }
      else{
         this.def_img_x=newWidth+"px";
         this.def_img_y=newHeight+"px";
      }
}

/**
*     @desc: get url of item image
*     @type: public
*     @param: itemId - id of item
*     @param: imageInd - index of image ( 0 - leaf, 1 - closed folder, 2 - opened folder)
*     @param: value - value of top offset
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.getItemImage=function(itemId,imageInd,fullPath){
    var node=this._globalIdStorageFind(itemId);
    if (!node) return "";
    var img=node.images[imageInd||0];
    if (fullPath) img=this.iconURL+img;
    return img;
}

/**
*     @desc: replace checkboxes with radio buttons
*     @type: public
*     @param: mode - true/false
*     @param: itemId - node for which replacement called (optional)
*     @edition: Professional
*     @topic: 1
*/
dhtmlXTreeObject.prototype.enableRadioButtons=function(itemId,mode){
    if (arguments.length==1){
        this._frbtr=dhx4.s2b(itemId);
        this.checkBoxOff=this.checkBoxOff||this._frbtr;
        return;
        }


    var node=this._globalIdStorageFind(itemId);
    if (!node) return "";
    mode=dhx4.s2b(mode);
    if ((mode)&&(!node._r_logic)){
            node._r_logic=true;
            for (var i=0; i<node.childsCount; i++)
                this._setCheck(node.childNodes[i],node.childNodes[i].checkstate);
        }

    if ((!mode)&&(node._r_logic)){
            node._r_logic=false;
            for (var i=0; i<node.childsCount; i++)
                this._setCheck(node.childNodes[i],node.childNodes[i].checkstate);
        }
}
/**
*     @desc: replace checkboxes with radio buttons
*     @type: public
*     @param: mode - true/false
*     @param: itemId - node for which replacement called (optional)
*     @edition: Professional
*     @topic: 1
*/
dhtmlXTreeObject.prototype.enableSingleRadioMode=function(mode){
     this._frbtrs=dhx4.s2b(mode);
}


/**
*     @desc: configure if parent node will be expanded immideatly after child item added
*     @type: public
*     @param: mode - true/false
*     @edition: Professional
*     @topic: 2
*/
dhtmlXTreeObject.prototype.openOnItemAdded=function(mode){
    this._hAdI=!dhx4.s2b(mode);
}
dhtmlXTreeObject.prototype.openOnItemAdding=function(mode){
    this._hAdI=!dhx4.s2b(mode);
}

/**
*     @desc: enable multi line items
*     @beforeInit: 1
*     @param: width - text width, if equls zero then use single lines items;
*     @type: public
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableMultiLineItems=function(width) { if (width===true) this.mlitems="100%"; else this.mlitems=width; }

/**
*     @desc: enable auto tooltips (node text as tooltip)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @edition:Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableAutoTooltips=function(mode) { this.ettip=dhx4.s2b(mode); };


/**
*     @desc: unselect item in tree
*     @type: public
*     @param: itemId - used in multi selection tree (optional)
*     @edition: Professional
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.clearSelection=function(itemId){
       if (itemId)
            this._unselectItem(this._globalIdStorageFind(itemId));
            else
            this._unselectItems();
            }

/**
*     @desc: show/hide (+/-) icon (works only for individual items, not for entire tree )
*     @type: public
*     @param: itemId - id of selected item
*     @param: state - show state : 0/1
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.showItemSign=function(itemId,state){
      var temp=this._globalIdStorageFind(itemId);
      if (!temp) return 0;

      var z=temp.span.parentNode.previousSibling.previousSibling.previousSibling;
      if (!dhx4.s2b(state)){
         this._openItem(temp)
         temp.closeble=false;
         temp.wsign=true;
      }
      else
      {
         temp.closeble=true;
         temp.wsign=false;
      }
      this._correctPlus(temp);
   }
/**
*     @desc: show/hide checkbox for tree item (works only for individual items, not for entire tree )
*     @type: public
*     @param: itemId - id of selected item, optional, set null to change states of all items
*     @param: state - checkbox show state : 0/1
*     @edition: Professional
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.showItemCheckbox=function(itemId,state){
      if (!itemId)
		for (var a in this._idpull)
			this.showItemCheckbox(this._idpull[a],state);

      if (typeof(itemId)!="object")
	      itemId=this._globalIdStorageFind(itemId,0,0);

      if (!itemId) return 0;
   	  itemId.nocheckbox=!dhx4.s2b(state);
      var t=itemId.span.parentNode.previousSibling.previousSibling.childNodes[0];
      t.parentNode.style.display=(!itemId.nocheckbox)?"":"none";
   }

/**
*     @desc: set list separator ("," by default)
*     @type: public
*     @param: separator - char or string to use for separating items in lists
*     @edition: Professional
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setListDelimeter=function(separator){
    this.dlmtr=separator;
}

//#}


/**
*     @desc: set escaping mode (used for escaping ID in requests)
*     @param: mode - escaping mode ("utf8" for UTF escaping)
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.setEscapingMode=function(mode){
        this.utfesc=mode;
        }


/**
*     @desc: enable item highlighting (item text highlited on mouseover)
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableHighlighting=function(mode) { this.ehlt=true; this.ehlta=dhx4.s2b(mode); };

/**
*     @desc: called on mouse out
*     @type: private
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._itemMouseOut=function(){
   		var that=this.childNodes[3].parentObject;
		var tree=that.treeNod;
 		tree.callEvent("onMouseOut",[that.id]);
		if (that.id==tree._l_onMSI) tree._l_onMSI=null;
        if (!tree.ehlta) return;
 	    that.span.className=that.span.className.replace("_lor","");
   }
/**
*     @desc: called on mouse in
*     @type: private
*     @topic: 0
*/
   dhtmlXTreeObject.prototype._itemMouseIn=function(){
   		var that=this.childNodes[3].parentObject;
		var tree=that.treeNod;

		if (tree._l_onMSI!=that.id) tree.callEvent("onMouseIn",[that.id]);
		tree._l_onMSI=that.id;
        if (!tree.ehlta) return;
 	    that.span.className=that.span.className.replace("_lor","");
 	    that.span.className=that.span.className.replace(/((standart|selected)TreeRow)/,"$1_lor");
   }

/**
*     @desc: enable active images (clickable and dragable). By default only text part of the node is active
*     @beforeInit: 1
*     @param: mode - 1 - on, 0 - off;
*     @type: public
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableActiveImages=function(mode){this._aimgs=dhx4.s2b(mode); };

/**
*     @desc: focus item in tree (scroll to it if necessary)
*     @type: public
*     @param: itemId - item Id
*     @topic: 0
*/
dhtmlXTreeObject.prototype.focusItem=function(itemId){
      var sNode=this._globalIdStorageFind(itemId);
      if (!sNode) return (0);
      this._focusNode(sNode);
   };


/**
*     @desc: Returns the list of all children from all next levels of tree, separated by default delimiter.
*     @param: itemId - id of node
*     @type: public
*     @return: list of all children items from all next levels of tree, separated by default delimiter
*     @topic: 6
*/
   dhtmlXTreeObject.prototype.getAllSubItems =function(itemId){
      return this._getAllSubItems(itemId);
   }

/**
*     @desc: Returns the list of all items which doesn't have child nodes.
*     @type: public
*     @return: list of all items which doesn't have child nodes.
*     @topic: 6
*/
	dhtmlXTreeObject.prototype.getAllChildless =function(){
		return this._getAllScraggyItems(this.htmlNode);
	}
	dhtmlXTreeObject.prototype.getAllLeafs=dhtmlXTreeObject.prototype.getAllChildless;


/**
*     @desc: Returns the list of all children from all next levels of tree, separated by default delimiter.
*     @param: itemId - id of node
*     @edition: Professional
*     @type: private
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getAllScraggyItems =function(node)
   {
      var z="";
      for (var i=0; i<node.childsCount; i++)
        {
            if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
            {
                    if (node.childNodes[i].unParsed)
                        var zb=this._getAllScraggyItemsXML(node.childNodes[i].unParsed,1);
                    else
                       var zb=this._getAllScraggyItems(node.childNodes[i])

                 if (zb)
                        if (z) z+=this.dlmtr+zb;
                        else z=zb;
         }
            else
               if (!z) z=""+node.childNodes[i].id;
             else z+=this.dlmtr+node.childNodes[i].id;
         }
          return z;
   };





/**
*     @desc: Returns the list of all children from all next levels of tree, separated by default delimiter.
*     @param: itemId - id of node
*     @type: private
*     @edition: Professional
*     @topic: 6
*/
   dhtmlXTreeObject.prototype._getAllFatItems =function(node)
   {
      var z="";
      for (var i=0; i<node.childsCount; i++)
        {
            if ((node.childNodes[i].unParsed)||(node.childNodes[i].childsCount>0))
            {
             if (!z) z=""+node.childNodes[i].id;
                else z+=this.dlmtr+node.childNodes[i].id;

                    if (node.childNodes[i].unParsed)
                        var zb=this._getAllFatItemsXML(node.childNodes[i].unParsed,1);
                    else
                       var zb=this._getAllFatItems(node.childNodes[i])

                 if (zb) z+=this.dlmtr+zb;
         }
         }
          return z;
   };

/**
*     @desc: Returns the list of all items which have child nodes, separated by default delimiter.
*     @type: public
*     @return: list of all items which has child nodes, separated by default delimiter.
*     @topic: 6
*/
	dhtmlXTreeObject.prototype.getAllItemsWithKids =function(){
		return this._getAllFatItems(this.htmlNode);
	}
	dhtmlXTreeObject.prototype.getAllFatItems=dhtmlXTreeObject.prototype.getAllItemsWithKids;



/**
*     @desc: return list of identificators of nodes with checked checkboxes, separated by default delimiter
*     @type: public
*     @return: list of ID of items with checked checkboxes, separated by default delimiter
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getAllChecked=function(){
      return this._getAllChecked("","",1);
   }
/**
*     @desc: return list of identificators of nodes with unchecked checkboxes, separated by default delimiter
*     @type: public
*     @return: list of ID of items with unchecked checkboxes, separated by default delimiter
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getAllUnchecked=function(itemId){
        if (itemId)
            itemId=this._globalIdStorageFind(itemId);
      return this._getAllChecked(itemId,"",0);
    }


/**
*     @desc: return list of identificators of nodes with third state checkboxes, separated by default delimiter
*     @type: public
*     @return: list of ID of items with third state checkboxes, separated by default delimiter
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getAllPartiallyChecked=function(){
      return this._getAllChecked("","",2);
   }


/**
*     @desc: return list of identificators of nodes with checked and third state checkboxes, separated by default delimiter
*     @type: public
*     @return: list of ID of items with checked and third state checkboxes, separated by default delimiter
*     @topic: 5
*/
   dhtmlXTreeObject.prototype.getAllCheckedBranches=function(){
        var temp = [this._getAllChecked("","",1)];
        var second = this._getAllChecked("","",2);
        if (second) temp.push(second);
        return temp.join(this.dlmtr);
   }

/**
*     @desc: return list of identificators of nodes with checked checkboxes
*     @type: private
*     @param: node - node object (optional, used by private methods)
*     @param: list - initial identificators list (optional, used by private methods)
*     @topic: 5
*/
   dhtmlXTreeObject.prototype._getAllChecked=function(htmlNode,list,mode){
      if (!htmlNode) htmlNode=this.htmlNode;

      if (htmlNode.checkstate==mode)
         if (!htmlNode.nocheckbox)  { if (list) list+=this.dlmtr+htmlNode.id; else list=""+htmlNode.id;  }
      var j=htmlNode.childsCount;
      for (var i=0; i<j; i++)
      {
         list=this._getAllChecked(htmlNode.childNodes[i],list,mode);
      };
//#__pro_feature:01112006{
//#smart_parsing:01112006{
        if  (htmlNode.unParsed)
            list=this._getAllCheckedXML(htmlNode.unParsed,list,mode);
//#}
//#}

      if (list) return list; else return "";
   };

/**
*     @desc: set individual item style
*     @type: public
*     @param: itemId - node id
*     @param: styleString - valid CSS string
*     @param: resetCss - reset current style : 0/1
*     @topic: 2
*/
dhtmlXTreeObject.prototype.setItemStyle=function(itemId,style_string,resetCss){ 
	var resetCss= resetCss|| false; 
	var temp=this._globalIdStorageFind(itemId); 
	if (!temp) return 0; 
	if (!temp.span.style.cssText) 
		temp.span.setAttribute("style",temp.span.getAttribute("style")+"; "+style_string); 
	else 
		temp.span.style.cssText = resetCss? style_string : temp.span.style.cssText+";"+style_string; 
}

/**
*     @desc: enable draging item image with item text
*     @type: public
*     @param: mode - true/false
*     @topic: 1
*/
dhtmlXTreeObject.prototype.enableImageDrag=function(mode){
    this._itim_dg=dhx4.s2b(mode);
}

/**
*     @desc: set function called when tree item draged over another item
*     @param: func - event handling function
*     @type: depricated
*     @edition: Professional
*     @topic: 4
*     @event: onDragIn
*     @depricated: use grid.attachEvent("onDragIn",func); instead
*     @eventdesc: Event raised when item draged other other dropable target
*     @eventparam:  ID draged item
*     @eventparam:  ID potencial drop landing
*     @eventparam:  source object
*     @eventparam:  target object
*     @eventreturn: true - allow drop; false - deny drop;
*/
	dhtmlXTreeObject.prototype.setOnDragIn=function(func){
		this.attachEvent("onDragIn",func);
        };

/**
*     @desc: enable/disable auto scrolling while drag-and-drop
*     @type: public
*     @param: mode - enabled/disabled
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.enableDragAndDropScrolling=function(mode){ this.autoScroll=dhx4.s2b(mode); };


dhtmlXTreeObject.prototype.setSkin=function(name){
	var tmp = this.parentObject.className.replace(/dhxtree_[^ ]*/gi,"");
  this.parentObject.className= tmp+" dhxtree_"+name;
  if (name == "dhx_terrace" || name == "dhx_web" || name == "material"){
    this.enableTreeLines(false);
  }
  if (name == "material")
    this.setIconSize("25", "25");
};

//tree
(function(){
	
	dhtmlx.extend_api("dhtmlXTreeObject",{
		_init:function(obj){
			return [obj.parent,(obj.width||"100%"),(obj.height||"100%"),(obj.root_id||0)];
		},
		auto_save_selection:"enableAutoSavingSelected",
		auto_tooltip:"enableAutoTooltips",
		checkbox:"enableCheckBoxes",
		checkbox_3_state:"enableThreeStateCheckboxes",
		checkbox_smart:"enableSmartCheckboxes",
		context_menu:"enableContextMenu",
		distributed_parsing:"enableDistributedParsing",
		drag:"enableDragAndDrop",
		drag_copy:"enableMercyDrag",
		drag_image:"enableImageDrag",
		drag_scroll:"enableDragAndDropScrolling",
		editor:"enableItemEditor",
		hover:"enableHighlighting",
		images:"enableTreeImages",
		image_fix:"enableIEImageFix",
		image_path:"setImagePath",
		lines:"enableTreeLines",
		loading_item:"enableLoadingItem",
		multiline:"enableMultiLineItems",
		multiselect:"enableMultiselection",
		navigation:"enableKeyboardNavigation",
		radio:"enableRadioButtons",
		radio_single:"enableSingleRadioMode",
		rtl:"enableRTL",
		search:"enableKeySearch",
		smart_parsing:"enableSmartXMLParsing",
		smart_rendering:"enableSmartRendering",
		text_icons:"enableTextSigns",
		xml:"loadXML",
		skin:"setSkin"
	},{});
	
})();

dhtmlXTreeObject.prototype._dp_init=function(dp){
	dp.attachEvent("insertCallback", function(upd, id, parent) {
		var data = dhx4.ajax.xpath(".//item",upd);
		var text = data[0].getAttribute('text');
		this.obj.insertNewItem(parent, id, text, 0, 0, 0, 0, "CHILD");
	});

	dp.attachEvent("updateCallback", function(upd, id, parent) {
		var data = dhx4.ajax.xpath(".//item",upd);
		var text = data[0].getAttribute('text');
		this.obj.setItemText(id, text);
		if (this.obj.getParentId(id) != parent) {
			this.obj.moveItem(id, 'item_child', parent);
		}
		this.setUpdated(id, true, 'updated');
	});

	dp.attachEvent("deleteCallback", function(upd, id, parent) {
		this.obj.setUserData(id, this.action_param, "true_deleted");
		this.obj.deleteItem(id, false);
	});
	
	dp._methods=["setItemStyle","","changeItemId","deleteItem"];
    this.attachEvent("onEdit",function(state,id){
        if (state==3)
            dp.setUpdated(id,true)
		return true;
	});
    this.attachEvent("onDrop",function(id,id_2,id_3,tree_1,tree_2){
    	if (tree_1==tree_2)
        	dp.setUpdated(id,true);
    });
    this._onrdlh=function(rowId){
		var z=dp.getState(rowId);
		if (z=="inserted") {  dp.set_invalid(rowId,false); dp.setUpdated(rowId,false);	return true; }
		if (z=="true_deleted")  { dp.setUpdated(rowId,false); return true; }

		dp.setUpdated(rowId,true,"deleted")
		return false;
	};
	this._onradh=function(rowId){
		dp.setUpdated(rowId,true,"inserted")
	};
	dp._getRowData=function(rowId){
		var data = {};
		var z=this.obj._globalIdStorageFind(rowId);
		var z2=z.parentObject;
			
		var i=0;
		for (i=0; i<z2.childsCount; i++)
			if (z2.childNodes[i]==z) break;
		
		data["tr_id"] = z.id;
		data["tr_pid"] = z2.id;
		data["tr_order"] = i;
		data["tr_text"] = z.span.innerHTML;
		
		z2=(z._userdatalist||"").split(",");
		for (i=0; i<z2.length; i++)
			data[z2[i]]=z.userData["t_"+z2[i]];
			
    	return data;
	};	
};

//(c)dhtmlx ltd. www.dhtmlx.com
if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype.attachTree = function(rootId) {
		
		this.callEvent("_onBeforeContentAttach",["tree"]);
		
		var obj = document.createElement("DIV");
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.style.position = "relative";
		obj.style.overflow = "hidden";
		
		this._attachObject(obj);
		
		this.dataType = "tree";
		this.dataObj = new dhtmlXTreeObject(obj, "100%", "100%", (rootId||0));
		this.dataObj.setSkin(this.conf.skin);
		
		// cosmetic fix
		this.dataObj.allTree.childNodes[0].style.marginTop = "2px";
		this.dataObj.allTree.childNodes[0].style.marginBottom = "2px";
		
		//obj.style.overflow = "auto";
		obj = null;
		
		this.callEvent("_onContentAttach",[]);
		
		return this.dataObj;
		
	};
	
}

;
///<jscompress sourcefile="dhtmlxtree_dragin.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*     @desc: adds drag-n-drop capabilities (with possibility to drop into dhtmlxTree) to HTML object. 
*     @param: obj - HTML object, or HTML object ID
*     @param: func - custom drag processor function, optional
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.makeDraggable=function(obj,func){
	if (typeof(obj)!="object")
		obj=document.getElementById(obj);

    dragger=new dhtmlDragAndDropObject();
	dropper=new dhx_dragSomethingInTree();

    dragger.addDraggableItem(obj,dropper);
    obj.dragLanding=null;
    obj.ondragstart=dropper._preventNsDrag;
    obj.onselectstart=new Function("return false;");

    obj.parentObject=new Object;
    obj.parentObject.img=obj;
    obj.parentObject.treeNod=dropper;
	dropper._customDrop=func;
}
dhtmlXTreeObject.prototype.makeDragable=dhtmlXTreeObject.prototype.makeDraggable;
/**
*     @desc: adds drag-n-drop capabilities (with possibility to drop into dhtmlxTree) to all HTML items with dragInDhtmlXTree attribute
*     @param: func - custom drag processor function, optional
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.makeAllDraggable=function(func){
	var z=document.getElementsByTagName("div");
	for (var i=0; i<z.length; i++)
		if (z[i].getAttribute("dragInDhtmlXTree"))
			this.makeDragable(z[i],func);
}

function dhx_dragSomethingInTree(){
	this.lWin=window;
	//this function creates a HTML object which will be used while drag-n-drop
    this._createDragNode=function(node){
    	var dragSpan=document.createElement('div');
        dragSpan.style.position="absolute";
        dragSpan.innerHTML=(node.innerHTML||node.value);
        dragSpan.className="dragSpanDiv";
        return dragSpan;
    };
	//this function necessary for correct browser support
	//doesn't change anything in it
    this._preventNsDrag=function(e){
    	(e||window.event).cancelBubble=true;
        if ((e)&&(e.preventDefault)) { e.preventDefault(); return false; }
        return false;
    }
	//this function contains a reaction on drop operation
	//the tree don't know what to do with custom item
	//so you must define this reaction
    this._nonTrivialNode=function(tree,item,bitem,source){
		if (this._customDrop) return this._customDrop(tree,source.img.id,item.id,bitem?bitem.id:null);

        var image=(source.img.getAttribute("image")||"");
		var id=source.img.id||"new";
		var text=(source.img.getAttribute("text")||(_isIE?source.img.innerText:source.img.textContent));
        tree[bitem?"insertNewNext":"insertNewItem"](bitem?bitem.id:item.id,id,text,"",image,image,image);
     }
}
//(c)dhtmlx ltd. www.dhtmlx.com
;
///<jscompress sourcefile="dhtmlxtree_ed.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
Purpose: item edit extension
*/


/**
*     @desc: enable editing of item text
*     @param:  mode - true/false
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.enableItemEditor=function(mode){
        this._eItEd=dhx4.s2b(mode);
        if (!this._eItEdFlag){

            this._edn_click_IE=true;
            this._edn_dblclick=true;
            this._ie_aFunc=this.aFunc;
            this._ie_dblclickFuncHandler=this.dblclickFuncHandler;

            this.setOnDblClickHandler(function (a,b) {
                if (this._edn_dblclick) this._editItem(a,b);
                return true;
				});

            this.setOnClickHandler(function (a,b) {
                this._stopEditItem(a,b);
                    if ((this.ed_hist_clcik==a)&&(this._edn_click_IE))
                        this._editItem(a,b);
                this.ed_hist_clcik=a;
                return true;
                });

            this._eItEdFlag=true;

            }
        };

/**
*     @desc: set onEdit handler ( multi handler event)
*     @param:  func - function which will be called on edit related events
*     @type: depricated
*     @event:  onEdit
*     @depricated: use grid.attachEvent("onEdit",func); instead
*     @eventdesc: Event occurs on 4 different stages of edit process: before editing started (cancelable), after editing started, before closing (cancelable), after closed
*     @eventparam: state - 0 before editing started , 1 after editing started, 2 before closing, 3 after closed
*     @eventparam: id - id of edited items
*     @eventparam: tree - tree object
*     @eventparam: value - for stage 0 and 2, value of editor
*     @eventreturn: for stages 0 and 2; true - confirm opening/closing, false - deny opening/closing;  text - edit value
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setOnEditHandler=function(func){
		this.attachEvent("onEdit",func);
        };



/**
*     @desc: define which events must start editing
*     @param:  click_IE - click on already selected item - true/false [true by default]
*     @param:  dblclick - on double click
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.setEditStartAction=function(click_IE, dblclick){
        this._edn_click_IE=dhx4.s2b(click_IE);
        this._edn_dblclick=dhx4.s2b(dblclick);
        };

dhtmlXTreeObject.prototype._stopEdit=function(a,mode){
    if  (this._editCell){
        this.dADTempOff=this.dADTempOffEd;
        if (this._editCell.id!=a){
			
			var editText=true;
			if(!mode){
	            editText=this.callEvent("onEdit",[2,this._editCell.id,this,this._editCell.span.childNodes[0].value]);
			}
			else{
				editText = false;
				this.callEvent("onEditCancel",[this._editCell.id,this._editCell._oldValue]);
			}
	        if (editText===true)
	           	editText=this._editCell.span.childNodes[0].value;
	        else if (editText===false) editText=this._editCell._oldValue;
	        
			var changed = (editText!=this._editCell._oldValue);
	        this._editCell.span.innerHTML=editText;
	        this._editCell.label=this._editCell.span.innerHTML;
			var cSS=this._editCell.i_sel?"selectedTreeRow":"standartTreeRow";
	        this._editCell.span.className=cSS;
	        this._editCell.span.parentNode.className="standartTreeRow";
	        this._editCell.span.style.paddingRight=this._editCell.span.style.paddingLeft='5px';
	        this._editCell.span.onclick=this._editCell.span.ondblclick=function(){};
	        
	        var id=this._editCell.id; 
	        if (this.childCalc)  this._fixChildCountLabel(this._editCell);
	        this._editCell=null;
	        
			if(!mode)
	        	this.callEvent("onEdit",[3,id,this,changed]);
	        
			if (this._enblkbrd){
				this.parentObject.lastChild.focus();
				this.parentObject.lastChild.focus();
			}
        }
    }
}

dhtmlXTreeObject.prototype._stopEditItem=function(id,tree){
    this._stopEdit(id);
};

/**
*     @desc:  switch currently edited item back to normal view
*     @type: public
*     @topic: 0
*/

dhtmlXTreeObject.prototype.stopEdit=function(mode){
    if (this._editCell)
        this._stopEdit(this._editCell.id+"_non",mode);
}

/**
*     @desc: open editor for specified item
*     @param:  id - item ID
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.editItem=function(id){
    this._editItem(id,this);
}

dhtmlXTreeObject.prototype._editItem=function(id,tree){
    if (this._eItEd){
        this._stopEdit();
        var temp=this._globalIdStorageFind(id);
		if (!temp) return;
				
	    var editText = this.callEvent("onEdit",[0,id,this,temp.span.innerHTML]);
        if (editText===true)
            editText = (typeof temp.span.innerText!="undefined"?temp.span.innerText:temp.span.textContent);
        else if (editText===false) return;
        this.dADTempOffEd=this.dADTempOff;
        this.dADTempOff=false;


        this._editCell=temp;
        temp._oldValue=editText;
        temp.span.innerHTML="<input type='text' class='intreeeditRow' />";
        temp.span.style.paddingRight=temp.span.style.paddingLeft='0px';
        temp.span.onclick = temp.span.ondblclick= function(e){
			(e||event).cancelBubble = true;
		}

        temp.span.childNodes[0].value=editText;

        temp.span.childNodes[0].onselectstart=function(e){
            (e||event).cancelBubble=true;
            return true;
        }
        temp.span.childNodes[0].onmousedown=function(e){
            (e||event).cancelBubble=true;
            return true;
        }

        temp.span.childNodes[0].focus();
        temp.span.childNodes[0].focus();
//		temp.span.childNodes[0].select();
        temp.span.onclick=function (e){ (e||event).cancelBubble=true; return false; };
        temp.span.className="";
        temp.span.parentNode.className="";

        var self=this;

        temp.span.childNodes[0].onkeydown=function(e){
            if (!e) e=window.event;
            if (e.keyCode==13){
				 e.cancelBubble=true;
				 self._stopEdit(window.undefined);	
			}
			else if (e.keyCode==27){
				self._stopEdit(window.undefined, true);
			}
			(e||event).cancelBubble=true;
        }
        this.callEvent("onEdit",[1,id,this]);
    }
};
//(c)dhtmlx ltd. www.dhtmlx.com

;
///<jscompress sourcefile="dhtmlxtree_json.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function jsonPointer(data,parent){
	this.d=data;
	this.dp=parent;
}
jsonPointer.prototype={
	text:function(){ var afff=function(n){ var p=[]; for(var i=0; i<n.length; i++) p.push("{"+sfff(n[i])+"}"); return p.join(","); }; var sfff=function(n){ var p=[]; for (var a in n) if (typeof(n[a])=="object"){ if (a.length) p.push('"'+a+'":['+afff(n[a])+"]");  else p.push('"'+a+'":{'+sfff(n[a])+"}"); }else p.push('"'+a+'":"'+n[a]+'"'); return p.join(","); }; return "{"+sfff(this.d)+"}"; },
	get:function(name){return this.d[name]; },
	exists:function(){return !!this.d },
	content:function(){return this.d.content; },
	each:function(name,f,t){  var a=this.d[name]; var c=new jsonPointer(); if (a) for (var i=0; i<a.length; i++) { c.d=a[i]; f.apply(t,[c,i]); } },
	get_all:function(){ return this.d; },
	sub:function(name){ return new jsonPointer(this.d[name],this.d) },
	sub_exists:function(name){ return !!this.d[name]; },
	each_x:function(name,rule,f,t,i){  var a=this.d[name]; var c=new jsonPointer(0,this.d); if (a) for (i=i||0; i<a.length; i++) if (a[i][rule]) { c.d=a[i]; if(f.apply(t,[c,i])==-1) return; } },
	up:function(name){ return new jsonPointer(this.dp,this.d);  },
	set:function(name,val){ this.d[name]=val;  },
	clone:function(name){ return new jsonPointer(this.d,this.dp); },
	through:function(name,rule,v,f,t){  var a=this.d[name]; if (a.length) for (var i=0; i<a.length; i++) { if (a[i][rule]!=null && a[i][rule]!="" &&  (!v || a[i][rule]==v )) { 
		var c=new jsonPointer(a[i],this.d);  f.apply(t,[c,i]); }  var w=this.d; this.d=a[i]; 
		if (this.sub_exists(name)) this.through(name,rule,v,f,t); this.d=w;   } }
}

/**
*     @desc: load tree from js array file|stream
*     @type: public
*     @param: file - link to JSArray file
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
dhtmlXTreeObject.prototype.loadJSArrayFile=function(file,callback){
  if (window.console && window.console.info)
    window.console.info("loadJSArrayFile was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
	return this._loadJSArrayFile(file, callback);
};
   dhtmlXTreeObject.prototype._loadJSArrayFile=function(file,callback){
      if (!this.parsCount) this.callEvent("onXLS",[this,this._ld_id]); this._ld_id=null; this.xmlstate=1;
      var that=this;
      
      this.XMLLoader=function(xml, callback){
      	eval("var z="+xml.responseText);
      	this._loadJSArray(z);
      	if (callback) callback.call(this, xml);
      };

      dhx4.ajax.get(file, function(obj){
      	that.XMLLoader(obj.xmlDoc, callback);
      });
   };
   
/**
*     @desc: load tree from csv file|stream
*     @type: public
*     @param: file - link to CSV file
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
dhtmlXTreeObject.prototype.loadCSV=function(file,callback){
  if (window.console && window.console.info)
    window.console.info("loadCSV was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
	return this._loadCSV(file, callback);
};
   dhtmlXTreeObject.prototype._loadCSV=function(file,callback){
      if (!this.parsCount) this.callEvent("onXLS",[this,this._ld_id]); this._ld_id=null; this.xmlstate=1;
      var that=this;
	  this.XMLLoader=function(xml, callback){
      	this._loadCSVString(xml.responseText);
      	if (callback) callback.call(this, xml);
      };

      dhx4.ajax.get(file, function(obj){
      	that.XMLLoader(obj.xmlDoc, callback);
      });
   };
   
/**
*     @desc: load tree from js array object
*     @type: public
*     @param: ar - js array
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/  
dhtmlXTreeObject.prototype.loadJSArray=function(file,callback){
  if (window.console && window.console.info)
    window.console.info("loadJSArray was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
	return this._loadJSArray(file, callback);
};
dhtmlXTreeObject.prototype._loadJSArray=function(ar,afterCall){

	//array id,parentid,text
	var z=[];
	for (var i=0; i<ar.length; i++){
		if (!z[ar[i][1]]) z[ar[i][1]]=[];
		z[ar[i][1]].push({id:ar[i][0],text:ar[i][2]});
	}
	
	var top={id: this.rootId};
	var f=function(top,f){
		if (z[top.id]){
			top.item=z[top.id];
			for (var j=0; j<top.item.length; j++)
				f(top.item[j],f);
		}
	}
	f(top,f);
	this._loadJSONObject(top,afterCall);
}


/**
*     @desc: load tree from csv string
*     @type: public
*     @param: csv - csv string 
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
dhtmlXTreeObject.prototype.loadCSVString=function(file,callback){
  if (window.console && window.console.info)
    window.console.info("loadCSVString was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
	return this._loadCSVString(file, callback);
};
dhtmlXTreeObject.prototype._loadCSVString=function(csv,afterCall){
	//array id,parentid,text
	var z=[];
	var ar=csv.split("\n");
	for (var i=0; i<ar.length; i++){
		var t=ar[i].split(",");
		if (!z[t[1]]) z[t[1]]=[];
		z[t[1]].push({id:t[0],text:t[2]});
	}
	
	var top={id: this.rootId};
	var f=function(top,f){
		if (z[top.id]){
			top.item=z[top.id];
			for (var j=0; j<top.item.length; j++)
				f(top.item[j],f);
		}
	}
	f(top,f);
	this._loadJSONObject(top,afterCall);
}


/**
*     @desc: load tree from json object
*     @type: public
*     @param: json - json object
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.loadJSONObject=function(file,callback){
	  if (window.console && window.console.info)
        window.console.info("loadJSONObject was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
    	return this._loadJSONObject(file, callback);
   };
   dhtmlXTreeObject.prototype._loadJSONObject=function(json,afterCall){
      if (!this.parsCount) this.callEvent("onXLS",[this,null]);this.xmlstate=1;
      var p=new jsonPointer(json);
	  this._parse(p);
	  this._p=p;
      if (afterCall) afterCall();
   };
   

/**   
*     @desc: load tree from json file
*     @type: public
*     @param: file - link to JSON file
*     @param: afterCall - function which will be called after xml loading
*     @topic: 0
*/
   dhtmlXTreeObject.prototype.loadJSON=function(file,callback){
	  if (window.console && window.console.info)
        window.console.info("loadJSON was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");
    	return this._loadJSON(file, callback);
   };
   dhtmlXTreeObject.prototype._loadJSON=function(file,callback){
	  if (!this.parsCount) this.callEvent("onXLS",[this,this._ld_id]); this._ld_id=null; this.xmlstate=1;
      var that=this;
      
      this.XMLLoader=function(xml, callback){
      	try {
			eval("var t="+xml.responseText);
		} catch(e){
				dhx4.callEvent("onLoadXMLerror",["Incorrect JSON",
					(xml),
					this
				]);
				return;
		}
      	var p=new jsonPointer(t);
      	this._parse(p);
      	this._p=p;
      	if (callback) callback.call(this, xml);
      };
      
      dhx4.ajax.get(file, function(obj){
      	that.XMLLoader(obj.xmlDoc, callback);
      });
   };   
   
   
/**   
*     @desc: return tree as json string
*     @type: public
*     @topic: 0
*/
dhtmlXTreeObject.prototype.serializeTreeToJSON=function(){
	var out=['{"id":"'+this.rootId+'", "item":['];
	var p=[];
		for (var i=0; i<this.htmlNode.childsCount; i++)
			p.push(this._serializeItemJSON(this.htmlNode.childNodes[i]));
	out.push(p.join(","));
	out.push("]}");	
	return out.join("");
};
dhtmlXTreeObject.prototype._serializeItemJSON=function(itemNode){
	var out=[];
	if (itemNode.unParsed)
			return (itemNode.unParsed.text());
  
	if (this._selected.length)
		var lid=this._selected[0].id;
	else lid="";
    var text=itemNode.span.innerHTML;

	text=text.replace(/\"/g, "\\\"", text);

	if (!this._xfullXML)
		out.push('{ "id":"'+itemNode.id+'", '+(this._getOpenState(itemNode)==1?' "open":"1", ':'')+(lid==itemNode.id?' "select":"1",':'')+' "text":"'+text+'"'+( ((this.XMLsource)&&(itemNode.XMLload==0))?', "child":"1" ':''));
	else
		out.push('{ "id":"'+itemNode.id+'", '+(this._getOpenState(itemNode)==1?' "open":"1", ':'')+(lid==itemNode.id?' "select":"1",':'')+' "text":"'+text+'", "im0":"'+itemNode.images[0]+'", "im1":"'+itemNode.images[1]+'", "im2":"'+itemNode.images[2]+'" '+(itemNode.acolor?(', "aCol":"'+itemNode.acolor+'" '):'')+(itemNode.scolor?(', "sCol":"'+itemNode.scolor+'" '):'')+(itemNode.checkstate==1?', "checked":"1" ':(itemNode.checkstate==2?', "checked":"-1"':''))+(itemNode.closeable?', "closeable":"1" ':'')+( ((this.XMLsource)&&(itemNode.XMLload==0))?', "child":"1" ':''));

	if ((this._xuserData)&&(itemNode._userdatalist))
		{
			out.push(', "userdata":[');
			var names=itemNode._userdatalist.split(",");
			var p=[];
			for  (var i=0; i<names.length; i++)
				p.push('{ "name":"'+names[i]+'" , "content":"'+itemNode.userData["t_"+names[i]]+'" }');
			out.push(p.join(",")); out.push("]");
		}
		
		if (itemNode.childsCount){
			out.push(', "item":[');
			var p=[];
		for (var i=0; i<itemNode.childsCount; i++)
			p.push(this._serializeItemJSON(itemNode.childNodes[i]));
			out.push(p.join(","));
			out.push("]\n");
		}
			
		out.push("}\n")
	return out.join("");
}   
//(c)dhtmlx ltd. www.dhtmlx.com
;
///<jscompress sourcefile="dhtmlxtreeview.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXTreeView(conf) {
	
	// console.log("add cache for kids for removeItem");
	// console.log("add unload");
	
	var that = this;
	
	if (typeof(conf) == "object" && conf.tagName == null) {
		// api-init
	} else {
		conf = {parent: conf, clear: true};
	}
	
	this.base = (typeof(conf.parent)=="string"?document.getElementById(conf.parent):conf.parent);
	
	if (this.base != document.body) {
		while (this.base.childNodes.length > 0) this.base.removeChild(this.base.lastChild);
	}
	
	this.conf = {
		skin: (conf.skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxtreeview")||"material"),
	        tree_id: window.dhx4.newId(), // register tree in common pull
	        ofs: {w: 1, h: 0}, // skyblue only
		adjust_base: false,
		icons: this.icons[(typeof(conf.iconset) == "string" && this.icons[conf.iconset] != null && this.icons[conf.iconset].r == true ? conf.iconset : "tree_native")],
		autoload: {
			url: null, // will set automaticaly from 1st loadStruct
			mode: "id" // user function allowed here
		},
		selected: {},
		ud: {}, // usersdata
		idx: {sign:0,icon:1,text:2}, // icons index
		silent: false, // do not callEvent if true
		// macos related for selection
		is_mac: (navigator.platform.match(/^mac/i) != null && typeof(window.addEventListener) == "function"),
		mac_cmd_key: false
	};
	
	this.setSkin(this.conf.skin);
	
	this.cont = document.createElement("DIV");
	this.cont.className = "dhxtreeview_cont";
	this.base.appendChild(this.cont);
	
	this.area = document.createElement("DIV");
	this.area.className = "dhxtreeview_area";
	this.cont.appendChild(this.area);
	
	this.cont.onclick = function(e) {
		e = e||event;
		that.callEvent("_onTreeClick", [e, {stop:false}]);
	}
	
	this.cont.ondblclick = function(e) {
		e = e||event;
		var t = (e.target||e.srcElement);
		if (t.className.match(/dhxtreeview_item_label/) != null) {
			that._openCloseItem(t.parentNode.parentNode._itemId, true);
		}
	}
	
	
	this.items = {};
	
	this._addItem = function(id, pId, data, index) {
		
		var level = (pId!=null?this.items[pId].level+1:1);
		
		var t = document.createElement("DIV");
		t.className = "dhxtreeview_item";
		t.innerHTML = "<div class='dhxtreeview_item_text'></div>";
		
		if (index != null && index < 0) data.index = 0;
		
		if (pId == null) {
			var node = this.area;
		} else {
			var k = this.items[pId].kids;
			if (k == false) this._initKidsNode(pId);
			this.items[pId].kids_request = false; // do not use dyn load if at least 1 child is present
			var node = this.items[pId].item.lastChild.firstChild;
		}
		
		if (index != null && node.childNodes[index] != null) {
			node.insertBefore(t, node.childNodes[index]);
		} else {
			node.appendChild(t);
		}
		node = null;
		
		t._itemId = id;
		t._treeId = this.conf.tree_id;
		
		if (window.dhx4.isIE == true) {
			t.onselectstart = function(e){
				e = e||event;
				if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			}
		}
		
		this.items[id] = {
			id: id,
			pId: pId,
			treeId: this.conf.tree_id,
			text: data.text,
			item: t,
			level: level,
			kids: false, // true/false if any kid
			opened: window.dhx4.s2b(data.open),
			userdata: window.dhx4._copyObj(data.userdata||{}),
			half_opened: false // true/false to change sign only, used for dyn.load
		};
		
		this.callEvent("_onItemRendered", [id, data]);
		
		t.firstChild.innerHTML = this._getItemHtml(id);
		t = null;
		
		// pre-select
		if (window.dhx4.s2b(data.select) == true) this._setSelected(id, true);
		
		this.callEvent("_onItemInited", [id, data]);
		
	}
	
	this.addItem = function(id, text, parentId, index) {
		if (this.items[id] != null) return;
		if (parentId != null && this.items[parentId] == null) parentId = null;
		this._addItem(id, parentId, {text: text}, index);
		this._callPublicEvent("onAddItem", [id, text, parentId, index]);
	}
	
	this._removeSingleItem = function(id) {
		if (window.dhx4.isIE == true) this.items[id].item.onselectstart = null;
		this.items[id].item.parentNode.removeChild(this.items[id].item);
		
		for (var a in this.items[id]) {
			this.items[id][a] = null;
			delete this.items[id][a];
		}
		
		delete this.items[id];
		
		// clear selection if any
		if (this.conf.selected[id] == true) delete this.conf.selected[id];
	}
	
	this._removeItem = function(id) {
		var pid = this.items[id].pId;
		var count = -1;

		// remove nested
		for (var a in this.items) {
			if (this.items[a].pId == id) this._removeItem(a);
			if (this.items[a]&&this.items[a].pId == pid) count++;
		}
		
		if (id != null) this._removeSingleItem(id);
		if (pid && !count)
			this._clearKidsNode(pid);
	}
	
	this.deleteItem = function(id) {
		if (this.items[id] == null) return;
		if (!this._callPublicEvent("onBeforeDeleteItem", [id])) return;
		this._removeItem(id);
		this._callPublicEvent("onDeleteItem", [id]);
	}
	
	this.clearAll = function() {
		this._removeItem(null);
		if (this.conf.unloading != true) this._fixAreaWidth();
	}
	
	this._initKidsNode = function(id) {
		
		var p;
		
		if (this.items[id].item.lastChild.className.match(/dhxtreeview_kids_cont/) == null) {
		
			p = document.createElement("DIV");
			p.className = "dhxtreeview_kids_cont";
			p.innerHTML = "<div style='position:relative;'></div>";
			
			p.style.opacity = "1";
			
			if (this.items[id].opened != true) {
				if (this.conf.transProp != false) {
					p.style.height = "0px";
					p.style.opacity = "0";
					p.firstChild.style.display = "none";
				} else {
					p.style.display = "none";
				}
			}
			
			this.items[id].item.appendChild(p);
			
		}
		
		this.items[id].kids = true;
		this._iconUpdate(id);
		this._signUpdate(id);
		
		p = null;
	}
	
	this._clearKidsNode = function(id) {
		
		if (this.items[id].item.lastChild.className.match(/dhxtreeview_kids_cont/) != null) {
			this.items[id].item.removeChild(this.items[id].item.lastChild);
		}
		
		this.items[id].kids = false;
		this._iconUpdate(id);
		this._signUpdate(id);
		
	}
	
	// open/colse
	this.openItem = function(id, anim) {
		if (this.items[id].opened != true) {
			if (typeof(anim) == "undefined") anim = true;
			this._openCloseItem(id, anim);
		}
	}
	this.closeItem = function(id, anim) {
		if (this.items[id].opened == true) {
			if (typeof(anim) == "undefined") anim = true;
			this._openCloseItem(id, anim);
		}
	}
	
	this._openCloseItem = function(id, anim) {
		
		if (this.callEvent("_onBeforeOpen", [id]) !== true) return;
		
		if (!(this.items[id].kids == true || this.items[id].kids_request == true)) return false;
		
		if (this.items[id].half_opened == true) {
			this.items[id].half_opened = false;
			this._signUpdate(id);
			return;
		}
		
		if (anim && this.conf.transProp != false) {
			
			if (!this.items[id].transEv) {
				this.items[id].item.lastChild.addEventListener(this.conf.transEv, this._doOnTrEnd);
				this.items[id].transEv = true;
			}
			
			if (this.items[id].opened == true) {
				
				// close
				
				this.items[id].transMode = "close";
				
				this.items[id].item.lastChild.style.overflow = "hidden";
				this.items[id].item.lastChild.style.height = this.items[id].item.lastChild.childNodes[0].offsetHeight+"px";
				
				window.setTimeout(function(){
						
					that.items[id].item.lastChild.style[that.conf.transProp] = that.conf.transValueHeight;
					that.items[id].item.lastChild.style.height = "0px";
					that.items[id].item.lastChild.style.opacity = "0";
					
					that.items[id].opened = false;
					that._iconUpdate(id);
					that._signUpdate(id);
					
				},50);
				
			} else {
				
				// open
				
				this.items[id].transMode = "open";
				
				this.items[id].item.lastChild.style[this.conf.transProp] = this.conf.transValueHeight;
				
				this.items[id].item.lastChild.childNodes[0].style.display = "";
				this.items[id].item.lastChild.style.overflow = "hidden";
				
				this.items[id].item.lastChild.style.height = this.items[id].item.lastChild.childNodes[0].offsetHeight+"px";
				this.items[id].item.lastChild.style.opacity = "1";
				
				this.items[id].opened = true;
				this._iconUpdate(id);
				this._signUpdate(id);
			}
			
			
		} else {
			
			// open/close
			this.items[id].opened = !this.items[id].opened;
			this.items[id].item.lastChild.style.display = (this.items[id].opened==true ? "" : "none");
			
			// add for dnd
			this.items[id].item.lastChild.childNodes[0].style.display = this.items[id].item.lastChild.style.display;
			this.items[id].item.lastChild.style.height = (this.items[id].opened==true?"":"0px");
			this.items[id].item.lastChild.style.opacity = (this.items[id].opened==true?1:0);
			// end for dnd
			
			this._iconUpdate(id);
			this._signUpdate(id);
			this._fixAreaWidth();
		}
	}
	
	this._doOnTrEnd = function() {
		
		var id = this.parentNode._itemId;
		that.items[id].item.lastChild.style[that.conf.transProp] = "";
		
		if (that.items[id].transMode == "close") {
			that.items[id].item.lastChild.childNodes[0].style.display = "none";
			//that._iconUpdate(id);
		} else {
			that.items[id].item.lastChild.style.height = "";
			that.items[id].item.lastChild.style.overflow = "";
		}
		that._fixAreaWidth();
	}
	
	// dimension
	this.setSizes = function() {
		// adjust top-parent, used in window when tree has border
		if (this.conf.adjust_base == true) {
			this.base.style.width = this.base.parentNode.clientWidth-2+"px";
			this.base.style.height = this.base.parentNode.clientHeight-2+"px";
		}
		//
		this.cont.style.left = this.conf.ofs.w+"px";
		this.cont.style.top = this.conf.ofs.h+"px";
		this.cont.style.width = this.base.clientWidth-this.conf.ofs.w*2+"px";
		this.cont.style.height = this.base.clientHeight-this.conf.ofs.h*2+"px";
		//
		this._fixAreaWidth();
	}
	
	this._fixAreaWidth = function(r) {
		this.area.style.width = "100%";
		if (this.cont.scrollWidth != this.cont.clientWidth) {
			this.area.style.width = this.cont.scrollWidth+1+"px";
		}
		if (window.dhx4.isIE7 == true && r !== false) { // extra loop for ie7 to fix scroll artefacts
			window.setTimeout(function(){that._fixAreaWidth(false);},1);
		}
	}
	
	
	this.setSizes();
	
	dhx4._eventable(this);
	
	// transition
	var k = window.dhx4.transDetect();
	this.conf.transProp = k.transProp;
	this.conf.transEv = k.transEv;
	this.conf.transValueHeight = "height 0.15s";
	k = null;
	
	// macos multiselect
	if (this.conf.is_mac == true) {
		this._macOnKey = function(e) {
			if (((window.dhx4.isKHTML || window.dhx4.isChrome || window.dhx4.isOpera) && (e.keyCode == 91 || e.keyCode == 93)) || (window.dhx4.isFF && e.keyCode == 224)) {
				that.conf.mac_cmd_key = (e.type == "keydown");
			}
		}
		window.addEventListener("keydown", this._macOnKey, false);
		window.addEventListener("keyup", this._macOnKey, false);
	}
	
	// extra modules to init if any
	for (var a in this.modules) {
		if (this.modules[a].init != null) this[this.modules[a].init](conf);
	}
	
	this.unload = function() {
		
		this.conf.unloading = true;
		
		this.cont.onclick = null;
		this.cont.ondblclick = null;
		
		this.clearAll();
		
		if (this.conf.is_mac == true) {
			window.removeEventListener("keydown", this._macOnKey, false);
			window.removeEventListener("keyup", this._macOnKey, false);
		}
		
		// extra modules to unload if any
		for (var a in this.modules) {
			if (this.modules[a].unload != null) this[this.modules[a].unload]();
		}
		
		this.area.parentNode.removeChild(this.area);
		this.area = null;
		
		this.cont.parentNode.removeChild(this.cont);
		this.cont = null;
		
		this.base.className = String(this.base.className).replace(new RegExp("\s{0,}dhxtreeview_"+(this.conf.skin||"")), "");
		
		window.dhx4._eventable(this, "clear");
		
		for (var a in this) this[a] = null;
		
		that = null;
		
	}
	
	// autoload/etc
	if (conf.items != null || conf.json != null || conf.xml != null) {
		this.loadStruct(conf.items||conf.json||conf.xml, conf.onload);
	}
	
	return this;
	
};

dhtmlXTreeView.prototype.modules = {};

// misc
dhtmlXTreeView.prototype.setSkin = function(skin) {
	this.base.className = String(this.base.className).replace(new RegExp("\s{0,}dhxtreeview_"+(this.conf.skin||"")), "") + " dhxtreeview_"+skin;
	this.conf.skin = skin;
	this.conf.icon_width = dhx4.readFromCss("dhxtreeview_"+this.conf.skin+" dhxtreeview_icon_width");
	this.conf.ofs = (this.conf.skin == "dhx_skyblue" ? {w:1, h:0} : {w:0, h:0});
};

dhtmlXTreeView.prototype.setItemText = function(id, text) {
	if (this.items[id] != null) {
		this.items[id].text = text;
		this.items[id].item.firstChild.childNodes[this.conf.idx.text].innerHTML = text;
		this._callPublicEvent("onTextChange", [id, text]);
	}
};
dhtmlXTreeView.prototype.getItemText = function(id) {
	return this.items[id].text;
};

//

dhtmlXTreeView.prototype.getParentId = function(id) {
	return this.items[id].pId;
};
dhtmlXTreeView.prototype.getSubItems = function(parentId) {
	var t = [];
	for (var a in this.items) {
		if (this.items[a].pId == parentId) t.push(a);
	}
	return t;
};

// render item html
dhtmlXTreeView.prototype._refreshItemHtml = function(id, updSign, updIcon) {
	this.items[id].item.firstChild.innerHTML = this._getItemHtml(id);
	if (updSign == true) this._signUpdate(id);
	if (updIcon == true) this._iconUpdate(id);
};
dhtmlXTreeView.prototype._getItemHtml = function(id) {
	var html = [];
	var nodeIndex = 0;
	for (var a in this.conf.idx) {
		var data = this["_itemHtml_"+a](id, nodeIndex);
		if (data.nodeText !== false) {
			html.push(data.nodeText);
			nodeIndex += data.nodeIndex;
		}
	}
	return html.join("");
};
dhtmlXTreeView.prototype._getIconOfs = function(id, index) {
	return ((this.items[id].level-1+index)*this.conf.icon_width);
};
dhtmlXTreeView.prototype._itemHtml_text = function(id, nodeIndex) {
	return {
		nodeIndex: 1,
		nodeText: "<div class='dhxtreeview_item_label' style='left:"+this._getIconOfs(id, nodeIndex)+"px;'>"+this.items[id].text+"</div>"
	};
};

// userdata
dhtmlXTreeView.prototype.setUserData = function(id, name, value) {
	var item = this.items[id];
	if (item) item.userdata[name] = value;
};
dhtmlXTreeView.prototype.getUserData = function(id, name) {
	var item = this.items[id];
	if (item && !name) return item.userdata;
	return item ? (item.userdata[name]||null) : null;
};

// events extension
dhtmlXTreeView.prototype.silent = function(f) {
	this.conf.silent = true;
	if (typeof(f) == "function") f.apply(window, [this]);
	this.conf.silent = false;
};
dhtmlXTreeView.prototype._callPublicEvent = function() {
	return (this.conf.silent == false ? this.callEvent.apply(this, arguments) : true);
};
if (typeof(window.dhtmlXCellObject) == "function") {
	
	dhtmlXCellObject.prototype.attachTreeView = function(conf) {
		
		this.callEvent("_onBeforeContentAttach", ["treeview"]);
		
		var obj = document.createElement("DIV");
		obj.style.position = "relative";
		obj.style.overflow = "hidden";
		obj.style.width = "100%";
		obj.style.height = "100%";
		
		this._attachObject(obj);
		
		var treeConf = {parent: obj, skin: this.conf.skin};
		if (conf != null && typeof(conf) == "object") {
			for (var a in conf) { if (typeof(treeConf[a]) == "undefined") treeConf[a] = conf[a]; }
		}
		
		this.dataType = "treeview";
		this.dataObj = new dhtmlXTreeView(treeConf);
		
		// draw border if attached to window
		if (typeof(window.dhtmlXWindowsCell) == "function" && this instanceof window.dhtmlXWindowsCell) {
			obj.className += " dhxtreeview_with_border";
			this.dataObj.conf.adjust_base = true;
			this.dataObj.setSizes();
		}
		
		treeConf.parent = null;
		treeConf = obj = conf = null;
		
		this.callEvent("_onContentAttach", []);
		
		return this.dataObj;
		
	};
	
}
// register checkboxes module
dhtmlXTreeView.prototype.modules.chbx = {
	init: "_chbxInit"
};

// public
dhtmlXTreeView.prototype.enableCheckboxes = function(mode) {
	mode = (mode==true);
	if (this.conf.enable_chbx != mode) {
		this.conf.enable_chbx = mode;
		this._chbxUpdIndex();
		for (var a in this.items) this._refreshItemHtml(a, true, true);
	}
};

dhtmlXTreeView.prototype.getAllChecked = function(parentId) {
	return this._chbxGetCheckedBranch(parentId, true);
};
dhtmlXTreeView.prototype.getAllUnchecked = function(parentId) {
	return this._chbxGetCheckedBranch(parentId, false);
};

dhtmlXTreeView.prototype.checkItem = function(id) {
	this._chbxSetChecked(id, true, true);
};
dhtmlXTreeView.prototype.uncheckItem = function(id) {
	this._chbxSetChecked(id, false, true);
};
dhtmlXTreeView.prototype.isItemChecked = function(id) {
	if (this.items[id] == null) return null;
	return (this.items[id].checked == true);
};

dhtmlXTreeView.prototype.enableCheckbox = function(id) {
	this._chbxSetEnabled(id, true);
};
dhtmlXTreeView.prototype.disableCheckbox = function(id) {
	this._chbxSetEnabled(id, false);
};
dhtmlXTreeView.prototype.isCheckboxEnabled = function(id) {
	return (this.items[id].chbx_enabled == true);
};

dhtmlXTreeView.prototype.showCheckbox = function(id) {
	this._chbxSetVisible(id, true);
};
dhtmlXTreeView.prototype.hideCheckbox = function(id) {
	this._chbxSetVisible(id, false);
};
dhtmlXTreeView.prototype.isCheckboxVisible = function(id) {
	return (this.items[id].chbx_visible == true);
};

// private
dhtmlXTreeView.prototype._chbxInit = function(conf) { // init
	
	this.enableCheckboxes(conf.checkboxes);
	
	this.attachEvent("_onItemRendered", function(id, data){
		
		this.items[id].checked = window.dhx4.s2b(data.checked);
		
		var conf = (data.checkbox||"enabled,visible");
		this.items[id].chbx_enabled = (conf.match(/disabled/)==null);
		this.items[id].chbx_visible = (conf.match(/hidden/)==null);
		
	});
	
	this.attachEvent("_onTreeClick", function(e, flow){
			
		if (this.conf.enable_chbx != true) return;
		
		var t = (e.target||e.srcElement);
		if (t.tagName.toLowerCase() == "i") t = t.parentNode; // check if icon
		
		if ((t.parentNode.className||"").match(/dhxtreeview_item_text/) != null && t == t.parentNode.childNodes[this.conf.idx.chbx]) { // check if checkbox
			var id = t.parentNode.parentNode._itemId;
			if (this.items[id].chbx_enabled == true) this._chbxSetChecked(id, !this.items[id].checked, true);
			flow.stop = true;
		}
	});
	
	conf = null;
	
};

dhtmlXTreeView.prototype._itemHtml_chbx = function(id, nodeIndex) {
	var r = {nodeIndex: 0, nodeText: false};
	if (this.conf.enable_chbx == true) {
		if (this.items[id].chbx_visible == true) r.nodeIndex = 1;
		r.nodeText = "<div class='dhxtreeview_item_icon' style='left:"+this._getIconOfs(id, nodeIndex)+"px;"+(r.nodeIndex>0?"":"display:none;")+"'>"+this._chbxGenIcon(id)+"</div>";
	}
	return r;
};

dhtmlXTreeView.prototype._chbxSetChecked = function(id, state) {
	if (this.conf.enable_chbx != true) return;
	state = (state==true);
	if (this.items[id].checked != state) {
		if (this._callPublicEvent("onBeforeCheck", [id, (this.items[id].checked==true)]) !== true) return;
		this.items[id].checked = state;
		this.items[id].item.childNodes[0].childNodes[this.conf.idx.chbx].innerHTML = this._chbxGenIcon(id);
		this._callPublicEvent("onCheck", [id, state]);
	}
};

dhtmlXTreeView.prototype._chbxSetEnabled = function(id, mode) {
	if (this.items[id].chbx_enabled != mode) {
		this.items[id].chbx_enabled = mode;
		this.items[id].item.firstChild.childNodes[this.conf.idx.chbx].innerHTML = this._chbxGenIcon(id);
	}
};

dhtmlXTreeView.prototype._chbxSetVisible = function(id, mode) {
	if (this.items[id].chbx_visible != mode) {
		this.items[id].chbx_visible = mode;
		this._refreshItemHtml(id, true, true);
	}
};

dhtmlXTreeView.prototype._chbxGenIcon = function(id) {
	var icon = this.conf.icons["chbx_"+(this.items[id].chbx_enabled?"":"dis_")+(this.items[id].checked?"1":"0")];
	return '<i class="'+this.conf.icons.prefix+' '+icon+'"></i>';
};

dhtmlXTreeView.prototype._chbxUpdIndex = function() {
	if (this.conf.enable_chbx == true) {
		this.conf.idx = {sign: 0, chbx: 1, icon: 2, text: 3};
	} else {
		this.conf.idx = {sign: 0, icon: 1, text: 2};
	}
};

dhtmlXTreeView.prototype._chbxGetCheckedBranch = function(pId, mode) {
	var k = [];
	for (var a in this.items) {
		if (this.items[a].pId == pId) {
			if (this.items[a].checked == mode) k.push(a);
			if (this.items[a].kids == true) k = k.concat(this._chbxGetCheckedBranch(a, mode));
		}
	}
	return k;
};
// register selection module
dhtmlXTreeView.prototype.modules.sign = {
	init: "_signInit"
};

// private
dhtmlXTreeView.prototype._signInit = function() {
	this.attachEvent("_onTreeClick", function(e, flow){
		if (flow.stop == true) return; // check if cancelled by prev attached function
		var t = (e.target||e.srcElement);
		if (t.tagName.toLowerCase() == "i") t = t.parentNode; // check if icon
		if ((t.parentNode.className||"").match(/dhxtreeview_item_text/) != null && t == t.parentNode.childNodes[this.conf.idx.sign]) {
			this._openCloseItem(t.parentNode.parentNode._itemId, true);
			flow.stop = true;
		}
	});
};

dhtmlXTreeView.prototype._signUpdate = function(id) {
	var t = this.items[id];
	var img = t.item.childNodes[0].childNodes[this.conf.idx.sign];
	if (t.kids == true || t.kids_request == true) {
		img.innerHTML = '<i class="'+this.conf.icons.prefix+" "+this.conf.icons[(t.opened||t.half_opened?"minus":"plus")]+'"></i>';
	} else {
		img.innerHTML = "";
	}
	t = img = null;
}

dhtmlXTreeView.prototype._itemHtml_sign = function(id, nodeIndex) { // item html renderer
	return {
		nodeIndex: 1,
		nodeText: "<div class='dhxtreeview_item_icon' style='left:"+this._getIconOfs(id, nodeIndex)+"px;'></div>"
	};
};
// register selection module
dhtmlXTreeView.prototype.modules.selection = {
	init: "_selectionInit"
};

// public
dhtmlXTreeView.prototype.selectItem = function(id) {
	if (this.conf.msel == true) {
		var t = {};
		if (!(id instanceof Array)) id = [id];
		for (var q=0; q<id.length; q++) t[id[q]] = true;
		for (var a in this.conf.selected) {
			if (t[a] == true) {
				delete t[a]; // already selected
			} else {
				this._setSelected(a, false); // clear selection if not preserve
			}
		}
		for (var a in t) this._setSelected(a, true); // select the rest
	} else if (id != null && this.conf.selected[id] != true && !(id instanceof Array)) {
		if (this._clearSelection(id) == false) this._setSelected(id, true);
	}
};

dhtmlXTreeView.prototype.unselectItem = function(id) {
	if (this.conf.msel == true) {
		if (!(id instanceof Array)) id = [id];
		for (var q=0; q<id.length; q++) {
			if (this.conf.selected[id[q]] == true) this._setSelected(id[q], false);
		}
	} else if (id != null) {
		this._setSelected(id, false);
	}
};

dhtmlXTreeView.prototype.getSelectedId = function() {
	var ids = [];
	for (var a in this.conf.selected) ids.push(a);
	return (this.conf.msel?ids:(ids[0]||null));
};

dhtmlXTreeView.prototype.enableMultiselect = function(mode) {
	mode = (mode==true);
	if (this.conf.msel != mode) {
		this._clearSelection();
		this.conf.msel = mode;
	}
};

// private
dhtmlXTreeView.prototype._selectionInit = function(conf) { // init
	
	this.conf.msel = window.dhx4.s2b(conf.multiselect);
	
	this.attachEvent("_onTreeClick", function(e, flow){
		
		if (flow.stop == true) return; // check if cancelled by prev attached function
		
		var t = (e.target||e.srcElement);
		if (t.tagName.toLowerCase() == "i") t = t.parentNode; // check if icon
		
		var selectId = null;
		
		if (t.className.match(/dhxtreeview_item_label/) != null) {
			selectId = t.parentNode.parentNode._itemId;
		} else if (t.className.match(/^dhxtreeview_item_text/) != null) {
			selectId = t.parentNode._itemId;
		} else if (t.className.match(/^dhxtreeview_item_icon/) != null) {
			selectId = t.parentNode.parentNode._itemId;
		}
		
		if (selectId != null)  {
			if (this.conf.msel == true) {
				if ((e.ctrlKey == true || this.conf.mac_cmd_key == true) && e.shiftKey == false && e.altKey == false) { // ctrl pressed
					this._setSelected(selectId, !this._isSelected(selectId));
				} else if (e.ctrlKey == false && e.shiftKey == false && e.altKey == false && this.conf.mac_cmd_key == false) { // nothing pressed
					if (this._clearSelection(selectId) == false) this._setSelected(selectId, true);
				}
			} else {
				if (this._clearSelection(selectId) == false) this._setSelected(selectId, true);
			}
		}
	});
};

dhtmlXTreeView.prototype._setSelected = function(id, mode) {
	if (mode == true) {
		if (this.conf.selected[id] != true) {
			this.items[id].item.childNodes[0].className += " dhxtreeview_item_text_selected";
			this.conf.selected[id] = true;
			this._callPublicEvent("onSelect", [id, true]);
		}
	} else {
		if (this.conf.selected[id] == true) {
			this.items[id].item.childNodes[0].className = String(this.items[id].item.childNodes[0].className).replace(/\s*dhxtreeview_item_text_selected/gi, "");
			delete this.conf.selected[id];
			this._callPublicEvent("onSelect", [id, false]);
		}
	}
};

dhtmlXTreeView.prototype._clearSelection = function(exceptId) {
	var r = false;
	for (var a in this.conf.selected) {
		if (exceptId != null && a == exceptId) r = true; else this._setSelected(a, false);
	}
	return r; // true if item stay selected
};

dhtmlXTreeView.prototype._isSelected = function(id) {
	return (this.conf.selected[id]==true);
};

// register icons module
dhtmlXTreeView.prototype.modules.icons = {
	init: "_iconModuleInit"
};

// public
dhtmlXTreeView.prototype.setItemIcons = function(id, icons) {
	if (icons == null && this.items[id].icons != null) {
		delete this.items[id].icons; // clear all custom for certain item
	} else if (icons != null) {
		if (this.items[id].icons == null) this.items[id].icons = {};
		for (var a in icons) {
			if (icons[a] != null) {
				this.items[id].icons[a] = icons[a];
			} else if (icons[a] == null && this.items[id].icons[a] != null) {
				delete this.items[id].icons[a]; // clear only specified icon
			}
		}
	}
	this._iconUpdate(id);
};

dhtmlXTreeView.prototype.setIconColor = function(id, color) {
	var icon = this.items[id].item.firstChild.childNodes[this.conf.idx.icon].firstChild;
	if (color == null) {
		if (this.items[id].icon_color != null) {
			delete this.items[id].icon_color;
			icon.style.color = "inherit";
		}
	} else {
		if (this.items[id].icon_color != color) {
			this.items[id].icon_color = color;
			icon.style.color = color;
		}
	}
	icon = null;
};

dhtmlXTreeView.prototype.setIconset = function(name) {
	if (this.icons[name] != null && this.icons[name].r == true) {
		this.conf.icons = this.icons[name];
	}
};

// private
dhtmlXTreeView.prototype._iconModuleInit = function() { // init
	this.attachEvent("_onItemRendered", function(id, data){
		if (data.icons != null) this.items[id].icons = data.icons;
		if (data.icon_color != null) this.items[id].icon_color = data.icon_color;
	});
};

dhtmlXTreeView.prototype._iconConf = function(id) { // return array with icons
	var icons = this.items[id].icons||{};
	for (var a in {folder_opened:1, folder_closed:1, file:1}) {
		if (typeof(icons[a]) == "undefined") icons[a] = this.conf.icons[a]; // if item has own icons missing will updated here
	}
	return icons;
};

dhtmlXTreeView.prototype._iconHtml = function(id, css) { // generate <i> for icon
	var attrs = ['class="'+this.conf.icons.prefix+" "+css+'"'];
	if (this.items[id].icon_color != null) attrs.push('style="color:'+this.items[id].icon_color+';"');
	return "<i "+attrs.join(" ")+"></i>";
};

dhtmlXTreeView.prototype._itemHtml_icon = function(id, nodeIndex) { // item html renderer
	return {
		nodeIndex: 1,
		nodeText: "<div class='dhxtreeview_item_icon' style='left:"+this._getIconOfs(id, nodeIndex)+"px;'>"+this._iconHtml(id, this._iconConf(id).file)+"</div>"
	};
};

dhtmlXTreeView.prototype._iconUpdate = function(id) { // update icon inner call
	var t = this.items[id];
	var icons = this._iconConf(id);
	var css = (t.kids == true || t.kids_request == true ? icons[t.opened?"folder_opened":"folder_closed"] : icons.file);
	t.item.childNodes[0].childNodes[this.conf.idx.icon].innerHTML = this._iconHtml(id, css);
	t = null;
};

// config
dhtmlXTreeView.prototype.icons = {
	tree_native: {
		r: true, // allow rendering depending on browser
		prefix: "dhxtreeview_icon", // common prefix for all icons/arrows/checkboxes/etc
		plus: "dhxtreeview_icon_plus",
		minus: "dhxtreeview_icon_minus",
		file: "dhxtreeview_icon_file",
		folder_opened: "dhxtreeview_icon_folder_opened",
		folder_closed: "dhxtreeview_icon_folder_closed",
		loading: "dhxtreeview_icon_loading",
		chbx_0: "dhxtreeview_icon_chbx_0",
		chbx_1: "dhxtreeview_icon_chbx_1",
		chbx_dis_0: "dhxtreeview_icon_chbx_dis_0",
		chbx_dis_1: "dhxtreeview_icon_chbx_dis_1"
	},
	font_awesome: {
		r: (!(window.dhx4.isIE6 == true || window.dhx4.isIE7 == true)),
		prefix: "fa",
		plus: "fa-caret-right",
		minus: "fa-caret-down",
		file: "fa-file-o",
		folder_opened: "fa-folder-open-o",
		folder_closed: "fa-folder-o",
		loading: "fa-refresh fa-spin",
		chbx_0: "fa-square-o",
		chbx_1: "fa-check-square-o",
		chbx_dis_0: "fa-square-o dhx-disabled",
		chbx_dis_1: "fa-check-square-o dhx-disabled"
	}
};
// register loading module
dhtmlXTreeView.prototype.modules.loading = {
	init: "_loadingInit",
	unload: "_loadingUnload"
};

dhtmlXTreeView.prototype._loadingInit = function(conf) {
	window.dhx4._enableDataLoading(this, "_initObj", "_xmlToObj", "tree", {struct:true});
	this.conf.root_id = (typeof(conf.root_id)=="undefined" || conf.root_id==null ? "0" : conf.root_id); // top-level item
	this._dhxdataload.onBeforeXLS = function(url) { // add tree_id for 1st load if any
		if (this.conf.autoload.url == null) this.conf.autoload.url = url;
		return {url:url.replace(/\{id\}/gi, this.conf.root_id)};
	}
};

dhtmlXTreeView.prototype._loadingUnload = function() {
	window.dhx4._enableDataLoading(this, null, null, null, "clear");
};

dhtmlXTreeView.prototype._initObj = function(data, url, pId, fixArea) {
	
	for (var q=0; q<data.length; q++) {
		
		var id = data[q].id;
		if (id == null) id = "dhxtreeview_id_"+window.dhx4.newId();
		
		// add item if not exists, if already exists - refresh?
		if (this.items[id] == null) this._addItem(id, pId, data[q]);
		
		// nested
		if (data[q].items != null) this._initObj(data[q].items, null, id, true);
	}
	
	// done
	if (fixArea != true) {
		this._fixAreaWidth();
	}
};

dhtmlXTreeView.prototype._xmlToObj = function(root, nested) {
	
	if (nested != true) root = root.getElementsByTagName("tree")[0];
	var data = [];
	
	for (var q=0; q<root.childNodes.length; q++) {
		var node = root.childNodes[q];
		
		if ((node.tagName||"").toLowerCase() == "item") {
			
			// main item attrs
			var item = {};
			for (var w=0; w<node.attributes.length; w++) {
				item[node.attributes[w].name] = node.attributes[w].value;
			}
			
			if (node.childNodes.length > 0) {
				
				// nested items
				var nested = this._xmlToObj(node, true);
				if (nested.length > 0) item.items = nested;
				
				// icons and userdata
				for (var w=0; w<node.childNodes.length; w++) {
					var tag = (node.childNodes[w].tagName||"").toLowerCase();
					if ({icons:1, userdata:1}[tag] == 1) {
						if (item[tag] == null) item[tag] = {};
						for (var e=0; e<node.childNodes[w].attributes.length; e++) {
							var name = node.childNodes[w].attributes[e].name;
							if (item[tag][name] == null) item[tag][name] = node.childNodes[w].attributes[e].value;
						}
					}
					n2 = null;
				}
				
			}
			
			data.push(item);
		}
		
		node = null;
	}
	
	return data;
};

// register dnd module
dhtmlXTreeView.prototype.modules.dnd = {
	init: "_dndInit",
	unload: "_dndUnload"
};

dhtmlXTreeView.prototype.enableDragAndDrop = function(mode) {
	this.conf.enable_dnd = window.dhx4.s2b(mode);
};

dhtmlXTreeView.prototype._dndInit = function(conf) { // init
	
	var that = this;
	
	this.enableDragAndDrop(conf.dnd);
	this.conf.dnd = null;
	
	this._dndOnMouseDown = function(e) {
		
		if (that.conf.enable_dnd != true) return;
		
		e = e||event;
		
		if (typeof(e.button) != "undefined" && e.button >= 2) return false;
		
		var id = null;
		var treeId = null;
		
		var t = e.target||e.srcElement;
		
		var ofs_x = window.dhx4.absLeft(t)+(typeof(e.offsetX)=="undefined"?e.layerX:e.offsetX) - e.clientX;
		var ofs_y = window.dhx4.absTop(t)+(typeof(e.offsetY)=="undefined"?e.layerY:e.offsetY) - e.clientY;
		
		while (t != null && t != that.cont) {
			if ((t.className||"").match(/dhxtreeview_item/) != null && t._itemId != null) {
				id = t._itemId;
				treeId = t._treeId;
				t = null;
			} else {
				t = t.parentNode;
			}
		}
		t = null;
		
		if (id == null) return; // check if empty click and abort
		
		that.conf.dnd = {
			inited: false,
			id: id,
			treeId: treeId,
			selected: (that.conf.selected[id]==true),
			tid: null,
			drop: {},
			x: e.clientX,
			y: e.clientY,
			ofs_x: ofs_x,
			ofs_y: ofs_y,
			zi: window.dhx4.newId(),
			scroll: false,
			scroll_ofs: 5, // offset for single loop
			scroll_time: 30, // timeout
			scroll_tm: null,
			kids: {}, // all kids of dragged to prevent dnd in advance
			idx: {}
		};
		
		
		
		that._dndInitEvents();
		
	}
	
	this._dndOnMouseMove = function(e) {
		
		e = e||event;
		
		if (that.conf.dnd.inited != true) {
			
			if (Math.abs(that.conf.dnd.x - e.clientX) >= 15 || Math.abs(that.conf.dnd.y - e.clientY) >= 15) {
				
				if (that._callPublicEvent("onBeforeDrag", [that.conf.dnd.id]) !== true) return;
				
				that.conf.dnd.inited = true;
				that.cont.className += " dhxtreeview_dnd_mode";
				that._dndInitDraggedObj();
				that._dndCollectKids(that.conf.dnd.id);
				that._dndCollectIndexes(that.area);
				
				// rearrange selection
				if (that._clearSelection(that.conf.dnd.id) == false) that._setSelected(that.conf.dnd.id, true);
				
				// update item css
				that.items[that.conf.dnd.id].item.className += " dhxtreeview_item_dragged";
				document.body.className += " dhxtreeview_dnd_mode";
				
				// tree area to check if scroll should be performed
				that.conf.dnd.cont = {
					x1: window.dhx4.absLeft(that.base),
					y1: window.dhx4.absTop(that.base)
				};
				that.conf.dnd.cont.x2 = that.conf.dnd.cont.x1 + that.base.offsetWidth;
				that.conf.dnd.cont.y2 = that.conf.dnd.cont.y1 + that.base.offsetHeight;
				
			} else {
				return;
			}
			
		}
		
		that.conf.dnd.x = e.clientX;
		that.conf.dnd.y = e.clientY;
		
		that._dndAdjustDraggedObj();
		
		// check tree area edges and scroll content if any
		var stopScroll = true;
		
		if (that.cont.scrollHeight > that.cont.clientHeight) {
			if (that.conf.dnd.x >= that.conf.dnd.cont.x1 && that.conf.dnd.x <= that.conf.dnd.cont.x2) {
				if (that.cont.scrollTop > 0 && that.conf.dnd.y >= that.conf.dnd.cont.y1 && that.conf.dnd.y <= that.conf.dnd.cont.y1 + 10) { // top edge
					that._dndScroll("up");
					stopScroll = false;
				} else if (that.cont.scrollTop+that.cont.clientHeight < that.cont.scrollHeight && that.conf.dnd.y <= that.conf.dnd.cont.y2 && that.conf.dnd.y >= that.conf.dnd.cont.y2 - 10) { // bottom edge
					that._dndScroll("down");
					stopScroll = false;
				}
			}
		}
		
		if (stopScroll == true && that.conf.dnd.scroll == true) {
			that._dndScroll("stop");
		}
		
		// detect node by target
		var t = (e.target||e.srcElement);
		
		// remove blink artefact if any
		if (t.parentNode != null && (t.parentNode.className||"").match(/dhxtreeview_kids_cont/) != null) {
			t = null;
			return;
		}
		
		var upd = false;
		var tid = null;
		var treeId = null;
		
		if (t.className != null) {
			if (t.className.match(/dhxtreeview_item_[li]/) != null) { // label/icon
				tid = t.parentNode.parentNode._itemId;
				treeId = t.parentNode.parentNode._treeId;
			} else if (t.className.match(/dhxtreeview_item_[t]/) != null) { // text
				tid = t.parentNode._itemId;
				treeId = t.parentNode._treeId;
			}
		}
		
		// check if the same tree
		if (tid != null && treeId != that.conf.dnd.treeId) {
			return;
		}
		
		// check if target is the same or if target is child
		if (that.conf.dnd.id == tid || that.conf.dnd.kids[tid] == true) {
			tid = null;
		}
		
		if (tid != null) {
			
			var h = that.items[tid].item.firstChild.offsetHeight;
			var ofs = Math.max(Math.floor(Math.min(e.layerY||e.offsetY, h) * 3 / h), 0);
			
			// depending on item type and offset - allow/block some offsets
			
			if (ofs == 0) { // drop as sibling above target
				
				if (that.items[tid].item.previousSibling == that.items[that.conf.dnd.id].item) { // do not allow if prev sibling is dragged
					ofs = null;
				}
				
			} else if (ofs == 1) { // drop as child of target
				
				if (that.items[that.conf.dnd.id].pId == tid) { // if already child of selected parent
					ofs = null;
				} else if (that.items[tid].kids == true && that.items[tid].item.lastChild.firstChild.firstChild == that.items[that.conf.dnd.id].item) { // do not allo if dragged already 1st child
					ofs = null;
				} else if (that.items[tid].opened == false) { // open node
					//that._openCloseItem(tid, true);
				}
				
			} else if (ofs == 2) { // drop as sibling below target
				
				if (that.items[tid].opened == true) { // do not allow for opened item
					ofs = null;
				} else if (that.items[tid].item.nextSibling == that.items[that.conf.dnd.id].item) { // do not allow if next sibling is dragged
					ofs = null;
				}
			}
			//
			if (ofs != that.conf.dnd.ofs) {
				that.conf.dnd.ofs = ofs;
				upd = true;
			}
		}
		
		if (tid != that.conf.dnd.tid) {
			
			// clear old one
			if (that.conf.dnd.tid != null) {
				that._dndUpdateTargetCss(that.conf.dnd.tid, false);
			}
			// update new
			if (tid != null) {
				upd = true;
			}
			that.conf.dnd.tid = tid;
		}
		
		if (upd == true) {
			
			var mode = false;
			
			if (ofs != null) {
				
				var drop = {
					id: that.conf.dnd.id,
					pId: that.items[tid].pId||null,
					index: null,
					idxOfs: (that.items[that.conf.dnd.id].pId == that.items[tid].pId && that.conf.dnd.idx[that.conf.dnd.id] < that.conf.dnd.idx[tid] ? -1 : 0)
				};
				
				if (ofs == 0 || ofs == 2) {
					drop.index = that.conf.dnd.idx[tid]+(ofs==2?1:0)+drop.idxOfs;
				} else if (ofs == 1) {
					drop.pId = tid;
					drop.index = (that.items[tid].item.lastChild.className.match(/dhxtreeview_kids_cont/)==null?0:that.items[tid].item.lastChild.firstChild.childNodes.length);
				}
				
				if (that.conf.dnd.drop.id != drop.id || that.conf.dnd.drop.pId != drop.pId || that.conf.dnd.drop.index != drop.index) {
					that.conf.dnd.drop = drop;
					if (that._callPublicEvent("onDragOver", [that.conf.dnd.drop.id, that.conf.dnd.drop.pId, that.conf.dnd.drop.index]) === true) mode = true;
				}
				
			}
			
			if (mode != true) that.conf.dnd.ofs = ofs = null;
			
			that._dndUpdateTargetCss(tid, mode);
			
		}
		
	}
	
	this._dndOnMouseUp = function(e) {
		
		e = e||event;
		
		if (typeof(e.button) != "undefined" && e.button >= 2) return;
		
		that._dndUnloadEvents();
		that._dndUnloadDraggedObj();
		
		if (that.conf.dnd.scroll == true) {
			that._dndScroll("stop");
		}
		
		if (that.cont.className.match(/dhxtreeview_dnd_mode/gi) != null) {
			that.cont.className = String(that.cont.className).replace(/\s*dhxtreeview_dnd_mode/gi, "");
		}
		
		if (that.conf.dnd.tid != null) {
			that._dndUpdateTargetCss(that.conf.dnd.tid, false);
		}
		
		if (that.conf.dnd.inited == true) {
			
			that.items[that.conf.dnd.id].item.className = String(that.items[that.conf.dnd.id].item.className).replace(/\s*dhxtreeview_item_dragged/gi, "");
			document.body.className = String(document.body.className).replace(/\s*dhxtreeview_dnd_mode/, "");
			
			if (that.conf.dnd.tid != null && that.conf.dnd.ofs != null) {
				
				if (that._callPublicEvent("onBeforeDrop", [that.conf.dnd.drop.id, that.conf.dnd.drop.pId, that.conf.dnd.drop.index]) === true) {
					
					var obj = that.items[that.conf.dnd.id];
					var tobj = that.items[that.conf.dnd.tid];
					var pobj = (obj.pId != null ? that.items[obj.pId] : null); // prev_parent id
					
					var levelOfs;
					
					// 1) dom
					if (that.conf.dnd.ofs == 1) {
						
						var open = false;
						if (tobj.kids == false) {
							that._initKidsNode(tobj.id);
							open = true;
						}
						tobj.item.lastChild.firstChild.appendChild(obj.item);
						//
						if (open == true) {
							that._openCloseItem(tobj.id, false);
						}
						
						obj.pId = tobj.id;
						levelOfs = tobj.level+1-obj.level;
						
					} else if (that.conf.dnd.ofs == 0 || that.conf.dnd.ofs == 2) { // sibling before/after
						
						if (that.conf.dnd.ofs == 0) { // before
							tobj.item.parentNode.insertBefore(obj.item, tobj.item);
						} else if (tobj.item.nextSibling != null) { // after
							tobj.item.parentNode.insertBefore(obj.item, tobj.item.nextSibling);
						} else { // after
							tobj.item.parentNode.appendChild(obj.item);
						}
						
						obj.pId = tobj.pId;
						levelOfs = tobj.level-obj.level;
					}
					
					// update nested if level changed
					if (levelOfs != 0) {
						that.conf.dnd.kids[obj.id] = true;
						for (var a in that.conf.dnd.kids) {
							that.items[a].level += levelOfs;
							that._refreshItemHtml(a, (that.items[a].kids == true), true);
						}
					}
					
					// 4) check parent's kids area and remove if empty
					if (pobj != null && pobj.kids == true && pobj.item.lastChild.firstChild.childNodes.length == 0) {
						that._clearKidsNode(pobj.id)
						pobj.opened = false;
					}
					
					obj = tobj = pobj = null;
					
					that._fixAreaWidth();
					
					that._callPublicEvent("onDrop", [that.conf.dnd.drop.id, that.conf.dnd.drop.pId, that.conf.dnd.drop.index]);
					
				}
				
			}
			
		}
		
		window.dhx4.zim.clear(that.conf.dnd.zi);
		
		that.conf.dnd = null;
		
	}
	
	this._dndOnContextMenu = function(e) {
		if (that.conf.dnd.inited == true) {
			e = e||event;
			e.cancelBubble = true;
			if (e.preventDefault) e.preventDefault();
			e.returnValue = false;
			return false;
		}
	}
	
	// events
	this._dndInitEvents = function() {
		
		if (typeof(window.addEventListener) == "function") {
			window.addEventListener("mousemove", this._dndOnMouseMove, false);
			window.addEventListener("mouseup", this._dndOnMouseUp, false);
			window.addEventListener("contextmenu", this._dndOnContextMenu, false);
		} else {
			document.body.attachEvent("onmousemove", this._dndOnMouseMove);
			document.body.attachEvent("onmouseup", this._dndOnMouseUp);
			document.body.attachEvent("oncontextmenu", this._dndOnContextMenu);
		}
		
	}
	
	this._dndUnloadEvents = function() {
		if (typeof(window.addEventListener) == "function") {
			window.removeEventListener("mousemove", this._dndOnMouseMove, false);
			window.removeEventListener("mouseup", this._dndOnMouseUp, false);
			window.removeEventListener("contextmenu", this._dndOnContextMenu, false);
		} else {
			document.body.detachEvent("onmousemove", this._dndOnMouseMove);
			document.body.detachEvent("onmouseup", this._dndOnMouseUp);
			document.body.detachEvent("oncontextmenu", this._dndOnContextMenu);
		}
	}
	
	// dragged object
	this._dndInitDraggedObj = function() {
		this.conf.dnd.dragged = document.createElement("DIV");
		this.conf.dnd.dragged.className = "dhxtreeview_dragged_obj_"+this.conf.skin;
		this.conf.dnd.dragged.style.zIndex = window.dhx4.zim.reserve(this.conf.dnd.zi);
		document.body.appendChild(this.conf.dnd.dragged);
		//
		this.conf.dnd.dragged.innerHTML = this.getItemText(this.conf.dnd.id);
	}
	
	this._dndAdjustDraggedObj = function() {
		this.conf.dnd.dragged.style.left = this.conf.dnd.x + this.conf.dnd.ofs_x + 12 + "px";
		this.conf.dnd.dragged.style.top = this.conf.dnd.y + this.conf.dnd.ofs_y + 18 + "px";
	}
	
	this._dndUnloadDraggedObj = function() {
		if (this.conf.dnd.dragged != null) {
			document.body.removeChild(this.conf.dnd.dragged);
			this.conf.dnd.dragged = null;
		}
	}
	
	// target node ui
	this._dndUpdateTargetCss = function(id, mode) {
		
		var t = this.items[id].item.childNodes[0];
		
		if (this.conf.dnd.ofs == null) {
			mode = false;
		}
		
		if (mode == true) {
			
			t.className = String(t.className).replace(/(\s*dhxtreeview_drop_\d)?$/i, " dhxtreeview_drop_"+this.conf.dnd.ofs);
			//
			if (t.nextSibling == null || t.nextSibling.className.match(/dhxtreeview_drop_preview/) == null) {
				var k = document.createElement("DIV");
				k.className = "dhxtreeview_drop_preview";
				k.style.left = t.lastChild.previousSibling.style.left;
				if (t.nextSibling == null) {
					t.parentNode.appendChild(k);
				} else {
					t.parentNode.insertBefore(k, t.nextSibling);
				}
				k = null;
			}
			
			t.nextSibling.className = String(t.nextSibling.className).replace(/(\s*dhxtreeview_drop_\d)?$/i, " dhxtreeview_drop_"+this.conf.dnd.ofs);
			
		} else if (t.className.match(/dhxtreeview_drop_\d/) != null) {
			t.className = String(t.className).replace(/\s*dhxtreeview_drop_\d/gi, "");
			//
			if (t.nextSibling != null && t.nextSibling.className.match(/dhxtreeview_drop_preview/) != null) {
				t.parentNode.removeChild(t.nextSibling);
			}
		}
		
		t = null;
		
	}
	
	// cache for kids items, dnd can't be performed
	this._dndCollectKids = function(pId) {
		for (var a in this.items) {
			if (this.items[a].pId == pId) {
				this.conf.dnd.kids[a] = true;
				if (this.items[a].kids == true) this._dndCollectKids(a);
			}
		}
	}
	
	this._dndCollectIndexes = function(node) {
		for (var q=0; q<node.childNodes.length; q++) {
			this.conf.dnd.idx[node.childNodes[q]._itemId] = q;
			if (node.childNodes[q].lastChild.className.match(/dhxtreeview_kids_cont/) != null) {
				this._dndCollectIndexes(node.childNodes[q].lastChild.firstChild);
			}
		}
	}
	
	// scroll content area
	this._dndScroll = function(mode, force) {
		
		if (mode == "stop") {
			
			if (that.conf.dnd.scroll == true) {
				if (that.conf.dnd.scroll_tm) window.clearTimeout(that.conf.dnd.scroll_tm);
				that.conf.dnd.scroll = false;
			}
			
			return;
			
		} else {
			
			if (that.conf.dnd.scroll == true) {
				if (force != true) return; // call from script, already performed, aborting
			} else {
				that.conf.dnd.scroll = true;
			}
			
			var stopScroll = false;
			if (mode == "up") {
				that.cont.scrollTop = Math.max(0, that.cont.scrollTop-that.conf.dnd.scroll_ofs);
				if (that.cont.scrollTop == 0) stopScroll = true;
			} else {
				that.cont.scrollTop = Math.min(that.cont.scrollHeight-that.cont.clientHeight, that.cont.scrollTop+that.conf.dnd.scroll_ofs);
				if (that.cont.scrollTop+that.cont.clientHeight == that.cont.scrollHeight) stopScroll = true;
			}
			
			if (stopScroll != true) {
				that.conf.dnd.scroll_tm = window.setTimeout(function(){
					that._dndScroll(mode, true);
				}, that.conf.dnd.scroll_time);
			}
			
		}
		
	}
	
	
	if (typeof(window.addEventListener) == "function") {
		this.cont.addEventListener("mousedown", this._dndOnMouseDown, false);
	} else {
		this.cont.attachEvent("onmousedown", this._dndOnMouseDown);
	}
	
	
	// unload
	this._dndUnload = function() {
		
		if (typeof(window.addEventListener) == "function") {
			this.cont.removeEventListener("mousedown", this._dndOnMouseDown, false);
		} else {
			this.cont.detachEvent("onmousedown", this._dndOnMouseDown);
		}
		
		that = null;
	}
	
	conf = null;
	
};
// register context menu module
dhtmlXTreeView.prototype.modules.ctx = {
	init: "_ctxInit",
	unload: "_ctxUnload"
};

// public
dhtmlXTreeView.prototype.enableContextMenu = function(mode) {
	this.conf.ctx = window.dhx4.s2b(mode);
};

// private
dhtmlXTreeView.prototype._ctxInit = function(conf) { // init
	
	var that = this;
	
	this._ctxCall = function(e) {
		
		if (that.conf.ctx != true) return;
		
		e = e||event;
		var t = (e.target||e.srcElement);
		if (t.tagName.toLowerCase() == "i") t = t.parentNode; // check if icon
		var id = (t.parentNode._itemId||t.parentNode.parentNode._itemId);
		
		var cx = window.dhx4.absLeft(t)+(typeof(e.offsetX)=="undefined"?e.layerX:e.offsetX);
		var cy = window.dhx4.absTop(t)+(typeof(e.offsetY)=="undefined"?e.layerY:e.offsetY);
		
		if (id != null && that._callPublicEvent("onContextMenu", [id, cx, cy, e]) !== true) {
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			e.returnValue = false;
			return false;
		}
		
	}
	
	if (typeof(window.addEventListener) == "function") {
		this.cont.addEventListener("contextmenu", this._ctxCall, false);
	} else {
		this.cont.attachEvent("oncontextmenu", this._ctxCall);
	}
	
	// unload
	this._ctxUnload = function() {
		if (typeof(window.addEventListener) == "function") {
			this.cont.removeEventListener("contextmenu", this._ctxCall, false);
		} else {
			this.cont.detachEvent("oncontextmenu", this._ctxCall);
		}
		that = null;
	};
	
	// autoload if any
	this.enableContextMenu(conf.context_menu);
	
};
// reguster dynload module
dhtmlXTreeView.prototype.modules.dynload = {
	init: "_dynLoadInit"
};

dhtmlXTreeView.prototype._dynLoadInit = function() {
	
	this.attachEvent("_onItemInited", function(id, data){
		
		// true/false to send extra request to server
		this.items[id].kids_request = window.dhx4.s2b(data.kids);
		
		// kids dyn load if any
		if (this.items[id].kids_request == true) {
			this._initKidsNode(id);
		}
		
		// dynload + open, load more data right after item added
		if (this.items[id].opened == true && this.items[id].kids_request == true) {
			var t = this;
			window.setTimeout(function(){
				t._dynLoadRequest(id);
				t = null;
			}, 100);
		}
		
	});
	
	this.attachEvent("_onBeforeOpen", function(id){
		
		// load more kids if any
		if (this.items[id].opened != true && this.items[id].kids_request == true) {
			if (this._dynLoadRequest(id) != true) {
				// change only plus-minus, will opened after data loaded
				this.items[id].half_opened = true;
				this._signUpdate(id);
				return false;
			}
		}
		
		return true;
	});
};

dhtmlXTreeView.prototype._dynLoadRequest = function(id) {
	
	// return true/false for node auto-open
	// if false - open after data will loaded
	if (typeof(this.conf.autoload.mode) == "function") {
		this.conf.autoload.mode.apply(window,[id]);
		return true;
	}
	
	if (this.conf.autoload.url == null) return; // data was loaded in different way
	
	this._dhxdataload.onBeforeXLS = function(url){
		return {url:url.replace(/\{id\}/gi,id)};
	}
	
	// loading icon
	var t = this;
	this.items[id].kids_loading_tm = window.setTimeout(function(){
		t._dynLoadUpdateIcon(id, true);
		t = null;
	}, 100);
	
	this.loadStruct(this.conf.autoload.url, function(){
		window.clearTimeout(this.items[id].kids_loading_tm);
		this._dynLoadUpdateIcon(id, false);
		if (this.items[id].half_opened) {
			this.items[id].half_opened = false;
			this._openCloseItem(id, true);
		}
	});
	
	this.items[id].kids_request = false;
	
	return false;
};

dhtmlXTreeView.prototype._dynLoadUpdateIcon = function(id, mode) {
	this.items[id].loading = (mode == true);
	if (this.items[id].loading == true) {
		this.items[id].item.childNodes[0].childNodes[this.conf.idx.icon].innerHTML = "<i class='"+this.conf.icons.prefix+" "+this.conf.icons.loading+"'></i>";
	} else {
		this._iconUpdate(id);
	}
};
;
///<jscompress sourcefile="dhtmlxgrid.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

//latest dev. version

/*_TOPICS_
@0:initialization
@1:selection control
@2:rows control
@3:colums control
@4:cells controll
@5:data manipulation
@6:appearence control
@7:overal control
@8:tools
@9:treegrid
@10: event handlers
@11: paginal output
*/

var globalActiveDHTMLGridObject;
String.prototype._dhx_trim=function(){
	return this.replace(/&nbsp;/g, " ").replace(/(^[ \t]*)|([ \t]*$)/g, "");
}

function dhtmlxArray(ar){
	return dhtmlx.extend((ar||new Array()), dhtmlxArray._master);
};
dhtmlxArray._master={
	_dhx_find:function(pattern){
		for (var i = 0; i < this.length; i++){
			if (pattern == this[i])
				return i;
		}
		return -1;
	},
	_dhx_insertAt:function(ind, value){
		this[this.length]=null;
		for (var i = this.length-1; i >= ind; i--)
			this[i]=this[i-1]
		this[ind]=value
	},
	_dhx_removeAt:function(ind){
		this.splice(ind,1)
	},
	_dhx_swapItems:function(ind1, ind2){
		var tmp = this[ind1];
		this[ind1]=this[ind2]
		this[ind2]=tmp;
	}
}

/**
*   @desc: dhtmlxGrid constructor
*   @param: id - (optional) id of div element to base grid on
*   @returns: dhtmlxGrid object
*   @type: public
*/
function dhtmlXGridObject(id){
	if (dhtmlxEvent.initTouch)
		dhtmlxEvent.initTouch();
	
	if (_isIE)
	try{
		document.execCommand("BackgroundImageCache", false, true);
	}
	catch (e){}
	
	if (id){
		if (typeof (id) == 'object'){
			this.entBox=id
			if (!this.entBox.id) this.entBox.id="cgrid2_"+this.uid();
		} else
		this.entBox=document.getElementById(id);
	} else {
		this.entBox=document.createElement("DIV");
		this.entBox.id="cgrid2_"+this.uid();
	}
	this.entBox.innerHTML="";
	dhx4._eventable(this);
	
	var self = this;
	
	this._RaSeCol=[];
	this._wcorr=0;
	this.fontWidth = 7;
	this.cell=null;
	this.row=null;
	this.iconURL="";
	this.editor=null;
	this._f2kE=true;
	this._dclE=true;
	this.combos=new Array(0);
	this.defVal=new Array(0);
	this.rowsAr={
	};
	
	this.rowsBuffer=dhtmlxArray();
	this.rowsCol=dhtmlxArray(); //array of rows by index
	
	this._data_cache={
	};
	
	this._ecache={
	}
	
	this._ud_enabled=true;
	this.xmlLoader=this.doLoadDetails;
	
	this._maskArr=[];
	this.selectedRows=dhtmlxArray(); //selected rows array
	
	this.UserData={};//hash of row related userdata (and for grid - "gridglobaluserdata")
	this._sizeFix=this._borderFix=0;
	/*MAIN OBJECTS*/
	
	this.entBox.className+=" gridbox";
	
	this.entBox.style.width=this.entBox.getAttribute("width")
	||(window.getComputedStyle
		? (this.entBox.style.width||window.getComputedStyle(this.entBox, null)["width"])
		: (this.entBox.currentStyle
			? this.entBox.currentStyle["width"]
			: this.entBox.style.width||0))
	||"100%";
	
	this.entBox.style.height=this.entBox.getAttribute("height")
	||(window.getComputedStyle
		? (this.entBox.style.height||window.getComputedStyle(this.entBox, null)["height"])
		: (this.entBox.currentStyle
			? this.entBox.currentStyle["height"]
			: this.entBox.style.height||0))
	||"100%";
	//cursor and text selection
	this.entBox.style.cursor='default';
	
	this.entBox.onselectstart=function(){
		return false
	}; //avoid text select
	var t_creator=function(name){
		var t=document.createElement("TABLE");
		t.cellSpacing=t.cellPadding=0;
		t.style.cssText='width:100%;table-layout:fixed;';
		t.className=name.substr(2);
		return t;
	}
	this.obj=t_creator("c_obj");
	this.hdr=t_creator("c_hdr");
	this.hdr.style.marginRight="20px";
	this.hdr.style.paddingRight="20px";
	
	this.objBox=document.createElement("DIV");
	this.objBox.style.width="100%";
	this.objBox.style.overflow="auto";
	this.objBox.appendChild(this.obj);
	this.objBox.className="objbox";
	
	if (dhtmlx.$customScroll)
		dhtmlx.CustomScroll.enable(this);
	
	this.hdrBox=document.createElement("DIV");
	this.hdrBox.style.width="100%"
	this.hdrBox.style.height="25px";
	this.hdrBox.style.overflow="hidden";
	this.hdrBox.className="xhdr";
	
	
	this.preloadImagesAr=new Array(0)
	
	this.sortImg=document.createElement("DIV")
	this.sortImg.style.display="none";
	
	this.hdrBox.appendChild(this.sortImg)
	this.hdrBox.appendChild(this.hdr);
	this.hdrBox.style.position="relative";
	
	this.entBox.appendChild(this.hdrBox);
	this.entBox.appendChild(this.objBox);
	
	//add links to current object
	this.entBox.grid=this;
	this.objBox.grid=this;
	this.hdrBox.grid=this;
	this.obj.grid=this;
	this.hdr.grid=this;
	
	/*PROPERTIES*/
	this.cellWidthPX=[];                      //current width in pixels
	this.cellWidthPC=[];                      //width in % if cellWidthType set in pc
	this.cellWidthType=this.entBox.cellwidthtype||"px"; //px or %
	
	this.delim=this.entBox.delimiter||",";
	this._csvDelim=",";
	
	this.hdrLabels=[];
	this.columnIds=[];
	this.columnColor=[];
	this._hrrar=[];
	this.cellType=dhtmlxArray();
	this.cellAlign=[];
	this.initCellWidth=[];
	this.fldSort=[];
	this._srdh=(_isIE && (document.compatMode != "BackCompat") ? 22 : 20);
	this.imgURL=window.dhx_globalImgPath||""; 
	this.isActive=false; //fl to indicate if grid is in work now
	this.isEditable=true;
	this.useImagesInHeader=false; //use images in header or not
	this.pagingOn=false;          //paging on/off
	this.rowsBufferOutSize=0;     //number of rows rendered at a moment
	/*EVENTS*/
	dhtmlxEvent(window, "unload", function(){
			try{
				if (self.destructor) self.destructor();
			}
			catch (e){}
	});
	
	/*XML LOADER(S)*/
	/**
	*   @desc: set one of predefined css styles (xp, mt, gray, light, clear, modern)
	*   @param: name - style name
	*   @type: public
	*   @topic: 0,6
	*/
	this.setSkin=function(name){
		this._srdh=window.dhx4.readFromCss("dhxgrid_rh_"+name)+4;
		this.skin_name=name;
		if (this._imgURL)
			this.setImagePath(this._imgURL);
		
		var classname = this.entBox.className.split(" gridbox")[0];
		this.entBox.className=classname + " gridbox gridbox_"+name+(_isIE?" isIE":" isModern");
		this.skin_h_correction=0;
		
		//#alter_css:06042008{		
		this.enableAlterCss("ev_"+name, "odd_"+name, this.isTreeGrid())
		this._fixAlterCss()
		//#}
		switch (name){
		case "dhx_terrace":
		case "material":
			this._srdh=33;
			this.forceDivInHeader=true;
			break;
			
		case "dhx_web":
		case "material":
			this.forceDivInHeader=true;
			this._srdh = 31;
			break;
			
		case "dhx_skyblue":
			this.forceDivInHeader=true;
			break;
		}
		
		if (_isIE&&this.hdr){
			var d = this.hdr.parentNode;
			d.removeChild(this.hdr);
			d.appendChild(this.hdr);
		}
		this.setSizes();
	}
	
	if (_isIE)
		this.preventIECaching(true);
	if (window.dhtmlDragAndDropObject)
		this.dragger=new dhtmlDragAndDropObject();
	
	/*METHODS. SERVICE*/
	/**
	*   @desc: on scroll grid inner actions
	*   @type: private
	*   @topic: 7
	*/
	this._doOnScroll=function(e, mode){
		this.callEvent("onScroll", [
				this.objBox.scrollLeft,
				this.objBox.scrollTop
		]);
		
		this.doOnScroll(e, mode);
	}
	/**
	*   @desc: on scroll grid more inner action
	*   @type: private
	*   @topic: 7
	*/
	this.doOnScroll=function(e, mode){
		var box = this.hdrBox;
		box._try_header_sync = true;
		setTimeout(function(){
			box._try_header_sync = false;
		},2000);

		this.hdrBox.scrollLeft=this.objBox.scrollLeft;
		if (this.ftr)
			this.ftr.parentNode.scrollLeft=this.objBox.scrollLeft;
		
		if (mode)
			return;
		
		if (this._srnd){
			if (this._dLoadTimer)
				window.clearTimeout(this._dLoadTimer);
			this._dLoadTimer=window.setTimeout(function(){
					if (self._update_srnd_view)
						self._update_srnd_view();
			}, 100);
		}
	}
	/**
	*   @desc: attach grid to some object in DOM
	*   @param: obj - object to attach to
	*   @type: public
	*   @topic: 0,7
	*/
	this.attachToObject=function(obj){
		obj.appendChild(this.globalBox?this.globalBox:this.entBox);
		//this.objBox.style.height=this.entBox.style.height;
		this.setSizes();
	}
	/**
	*   @desc: initialize grid
	*   @param: fl - if to parse on page xml data island 
	*   @type: public
	*   @topic: 0,7
	*/
	this.init=function(fl){
		if ((this.isTreeGrid())&&(!this._h2)){
			this._h2=this._createHierarchy();
			
			if ((this._fake)&&(!this._realfake))
				this._fake._h2=this._h2;
			this._tgc={
				imgURL: null
			};
		}
		
		if (!this._hstyles)
			return;
		
		if (!this.skin_name)
			this.setSkin(window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhxgrid")||"material");
		
		this.editStop()
		/*TEMPORARY STATES*/
		this.lastClicked=null;                //row clicked without shift key. used in multiselect only
		this.resized=null;                    //hdr cell that is resized now
		this.fldSorted=this.r_fldSorted=null; //hdr cell last sorted
		//empty grid if it already was initialized
		this.cellWidthPX=[];
		this.cellWidthPC=[];
		
		if (this.hdr.rows.length > 0){
			var temp = this.xmlFileUrl;
			this.clearAll(true);
			this.xmlFileUrl = temp;
		}
		
		var hdrRow = this.hdr.insertRow(0);
		
		for (var i = 0; i < this.hdrLabels.length; i++){
			hdrRow.appendChild(document.createElement("TH"));
			hdrRow.childNodes[i]._cellIndex=i;
			hdrRow.childNodes[i].style.height="0px";
		}
		
		if (_isIE && _isIE<8 && document.body.style.msTouchAction == this.undefined)
			hdrRow.style.position="absolute";
		else
			hdrRow.style.height='auto';
		
		var hdrRow = this.hdr.insertRow(_isKHTML ? 2 : 1);
		
		hdrRow._childIndexes=new Array();
		var col_ex = 0;
		
		for (var i = 0; i < this.hdrLabels.length; i++){
			hdrRow._childIndexes[i]=i-col_ex;
			
			if ((this.hdrLabels[i] == this.splitSign)&&(i != 0)){
				if (_isKHTML)
					hdrRow.insertCell(i-col_ex);
				hdrRow.cells[i-col_ex-1].colSpan=(hdrRow.cells[i-col_ex-1].colSpan||1)+1;
				hdrRow.childNodes[i-col_ex-1]._cellIndex++;
				col_ex++;
				hdrRow._childIndexes[i]=i-col_ex;
				continue;
			}
			
			hdrRow.insertCell(i-col_ex);
			
			hdrRow.childNodes[i-col_ex]._cellIndex=i;
			hdrRow.childNodes[i-col_ex]._cellIndexS=i;
			this.setColumnLabel(i, this.hdrLabels[i]);
		}
		
		if (col_ex == 0)
			hdrRow._childIndexes=null;
		this._cCount=this.hdrLabels.length;
		
		if (_isIE)
		window.setTimeout(function(){
				if (self.setSizes)
					self.setSizes();
		}, 1);
		
		//create virtual top row
		if (!this.obj.firstChild)
			this.obj.appendChild(document.createElement("TBODY"));
		
		var tar = this.obj.firstChild;
		
		if (!tar.firstChild){
			tar.appendChild(document.createElement("TR"));
			tar=tar.firstChild;
			
			if (_isIE && _isIE<8 && document.body.style.msTouchAction == this.undefined)
				tar.style.position="absolute";
			else
				tar.style.height='auto';
			
			for (var i = 0; i < this.hdrLabels.length; i++){
				tar.appendChild(document.createElement("TH"));
				tar.childNodes[i].style.height="0px";
			}
		}
		
		this._c_order=null;
		
		if (this.multiLine != true)
			this.obj.className+=" row20px";
		
		//
		//this.combos = new Array(this.hdrLabels.length);
		//set sort image to initial state
		this.sortImg.style.position="absolute";
		this.sortImg.style.display="none";
		this.sortImg.className = "dhxgrid_sort_desc";
		this.sortImg.defLeft=0;
		
		if (this.noHeader){
			this.hdrBox.style.display='none';
		}
		else {
			this.noHeader=false
		}
		//#__pro_feature:21092006{
		//#column_hidden:21092006{
		if (this._ivizcol)
			this.setColHidden();
		//#}
		//#}
		//#header_footer:06042008{		
		this.attachHeader();
		this.attachHeader(0, 0, "_aFoot");
		//#}
		this.setSizes();
		
		if (fl)
			this.parseXML()
		this.obj.scrollTop=0
		
		if (this.dragAndDropOff)
			this.dragger.addDragLanding(this.entBox, this);
		
		if (this._initDrF)
			this._initD();
		
		dhx4.callEvent("onGridCreated", [this]);
	};
	
	this.setColumnSizes=function(gridWidth){
		var summ = 0;
		var fcols = []; //auto-size columns
		
		var fix = 0;
		for (var i = 0; i < this._cCount; i++){
			if ((this.initCellWidth[i] == "*") && !this._hrrar[i]){
				this._awdth=false; //disable auto-width
				fcols.push(i);
				continue;
			}
			
			if (this.cellWidthType == '%'){
				if (typeof this.cellWidthPC[i]=="undefined")
					this.cellWidthPC[i]=this.initCellWidth[i];
				var cwidth = (gridWidth*this.cellWidthPC[i]/100)||0;
				if (fix>0.5){
					cwidth++;
					fix--;
				}
				var rwidth = this.cellWidthPX[i]=Math.floor(cwidth);
				var fix =fix + cwidth - rwidth;
			} else{
				if (typeof this.cellWidthPX[i]=="undefined")
					this.cellWidthPX[i]=this.initCellWidth[i];
			}
			if (!this._hrrar[i])
				summ+=this.cellWidthPX[i]*1;
		}
		
		//auto-size columns
		if (fcols.length){
			var ms = Math.floor((gridWidth-summ)/fcols.length);
			if (ms < 0) ms=1;
			
			for (var i = 0; i < fcols.length; i++){
				var next=Math.max((this._drsclmW ? (this._drsclmW[fcols[i]]||0) : 0),ms)
				this.cellWidthPX[fcols[i]]=next;
				summ+=next;
			}
			
			if(gridWidth > summ){
				var last=fcols[fcols.length-1];
				this.cellWidthPX[last]=this.cellWidthPX[last] + (gridWidth-summ);
				summ = gridWidth;
			}
			
			this._setAutoResize();
		}
		
		
		this.obj.style.width=summ+"px";
		this.hdr.style.width=summ+"px";
		if (this.ftr) this.ftr.style.width=summ+"px";
		
		this.chngCellWidth();
		return summ;
	}
	
	/**shz)_
	*   @desc: sets sizes of grid elements
	*   @type: private
	*   @topic: 0,7
	*/
	this.setSizes=function(){
		//drop processing if grid still not initialized 
		if ((!this.hdr.rows[0])) return;
		
		var quirks=this.quirks = (_isIE && document.compatMode=="BackCompat");
		var outerBorder=(this.entBox.offsetWidth-this.entBox.clientWidth)/2;		

		if (!this.dontSetSizes){
			if (this.globalBox){
				if (!this.globalBox.clientWidth) return;
				var ow = this.globalBox.clientWidth;
				var splitOuterBorder=(this.globalBox.offsetWidth-ow)/2;		
				if (this._delta_x && !this._realfake){
					this.globalBox.style.width=this._delta_x;
					var owu = this.globalBox.clientWidth;
					this.entBox.style.width=Math.max(0,(owu+(quirks?splitOuterBorder*2:0))-this._fake.entBox.clientWidth)+"px";
					if (owu != this._lastTimeSplitWidth){
						this._fake._correctSplit(this._fake.entBox.clientWidth);
						this._lastTimeSplitWidth = owu;
					}
				}
				if (this._delta_y && !this._realfake){
					this.globalBox.style.height = this._delta_y;
					this.entBox.style.overflow = this._fake.entBox.style.overflow="hidden";
					this.entBox.style.height = this._fake.entBox.style.height=this.globalBox.clientHeight+(quirks?splitOuterBorder*2:0)+"px";
				}
			} else {
				if (this._delta_x){
					/*when placed directly in TD tag, container can't use native percent based sizes, 
					because table auto-adjust to show all content - too clever*/
					if (this.entBox.parentNode && this.entBox.parentNode.tagName=="TD"){
						this.entBox.style.width="1px";
						this.entBox.style.width=parseInt(this._delta_x)*this.entBox.parentNode.clientWidth/100-outerBorder*2+"px";
					}else
					this.entBox.style.width=this._delta_x;
				}
				if (this._delta_y)
					this.entBox.style.height=this._delta_y;
			}
		}
		
		//if we have container without sizes, wait untill sizes defined
		window.clearTimeout(this._sizeTime);		
		if (!this.entBox.offsetWidth && (!this.globalBox || !this.globalBox.offsetWidth)){
			this._sizeTime=window.setTimeout(function(){
					if (self.setSizes)
						self.setSizes();
			}, 250);
			return;
		}		
		
		var border_x = ((!this._wthB) && ((this.entBox.cmp||this._delta_x) && (this.skin_name||"").indexOf("dhx")==0 && !quirks)?2:0);
		var border_y = ((!this._wthB) && ((this.entBox.cmp||this._delta_y) && (this.skin_name||"").indexOf("dhx")==0 && !quirks)?2:0);
		
		if (this._sizeFix){
			border_x -= this._sizeFix;
			border_y -= this._sizeFix;
		}
		
		if(this.type="vmdgrid"){
			isVScroll = this.parentGrid?false:(this.objBox.scrollHeight > this.objBox.parentNode.offsetHeight);
		}else{
			isVScroll = this.parentGrid?false:(this.objBox.scrollHeight > this.objBox.offsetHeight);
		}
		var scrfix = dhtmlx.$customScroll?0:18;
		
		var gridWidth=this.entBox.clientWidth-(this.skin_h_correction||0)*(quirks?0:1)-border_x;
		var gridWidthActive=this.entBox.clientWidth-(this.skin_h_correction||0)-border_x;
		var gridHeight=this.entBox.clientHeight-border_y;
		var summ=this.setColumnSizes(gridWidthActive-(isVScroll?scrfix:0)-(this._correction_x||0));
		
		var isHScroll = this.parentGrid?false:((this.objBox.scrollWidth > this.objBox.offsetWidth)||(this.objBox.style.overflowX=="scroll")); 
		var headerHeight = this.hdr.clientHeight;
		var footerHeight = this.ftr?this.ftr.clientHeight:0;
		var newWidth=gridWidth;
		var newHeight=gridHeight-headerHeight-footerHeight;
		
		//if we have auto-width without limitations - ignore h-scroll
		if (this._awdth && this._awdth[0] && this._awdth[1]==99999) isHScroll=0;
		//auto-height
		if (this._ahgr){
			if (this._ahgrMA)
				newHeight=this.entBox.parentNode.clientHeight-headerHeight-footerHeight;
			else
				newHeight=this.obj.offsetHeight+(isHScroll?scrfix:0)+(this._correction_y||0);
			
			if (this._ahgrM){
				if (this._ahgrF) 
					newHeight=Math.min(this._ahgrM,newHeight+headerHeight+footerHeight)-headerHeight-footerHeight;
				else 
					newHeight=Math.min(this._ahgrM,newHeight);
				
			}
			if (isVScroll && newHeight>=this.obj.scrollHeight+(isHScroll?scrfix:0)){
				isVScroll=false;//scroll will be compensated;
				this.setColumnSizes(gridWidthActive-(this._correction_x||0)); //correct auto-size columns
			}
		}
		
		//auto-width
		if ((this._awdth)&&(this._awdth[0])){ 
			//convert percents to PX, because auto-width with procents has no sense
			if (this.cellWidthType == '%') this.cellWidthType="px";
			
			if (this._fake) summ+=this._fake.entBox.clientWidth;	//include fake grid in math
			var newWidth=Math.min(Math.max(summ+(isVScroll?scrfix:0),this._awdth[2]),this._awdth[1])+(this._correction_x||0);
			this.objBox.style.overflowX = (!isVScroll && this.objBox.scrollWidth <= newWidth)?"hidden":"auto";
			if (this._fake) newWidth-=this._fake.entBox.clientWidth;
		}
		
		newHeight=Math.max(0,newHeight);//validate value for IE
		
		//FF3.1, bug in table rendering engine
		this._ff_size_delta=(this._ff_size_delta==0.1)?0.2:0.1;
		if (!_isFF) this._ff_size_delta=0;
		
		if (!this.dontSetSizes){
			this.entBox.style.width=Math.max(0,newWidth+(quirks?2:0)*outerBorder+this._ff_size_delta)+"px";
			this.entBox.style.height=newHeight+(quirks?2:0)*outerBorder+headerHeight+footerHeight+"px";
		}
		this.objBox.style.height=newHeight+((quirks&&!isVScroll)?2:0)*outerBorder+"px";//):this.entBox.style.height);
		this.hdrBox.style.height=headerHeight+"px";		
		
		
		if (newHeight != gridHeight)
			this.doOnScroll(0, !this._srnd);
		var ext=this["setSizes_"+this.skin_name];
		if (ext) ext.call(this);
		
		this.setSortImgPos();	
		
		//it possible that changes of size, has changed header height 
		if (headerHeight != this.hdr.clientHeight && this._ahgr) 	
			this.setSizes();
		this.callEvent("onSetSizes",[]);
	};
	/**
	*   @desc: changes cell width
	*   @param: [ind] - index of row in grid
	*   @type: private
	*   @topic: 4,7
	*/
	this.chngCellWidth=function(){
		if ((_isOpera)&&(this.ftr))
			this.ftr.width=this.objBox.scrollWidth+"px";
		var l = this._cCount;
		
		for (var i = 0; i < l; i++){
			this.hdr.rows[0].cells[i].style.width=this.cellWidthPX[i]+"px";
			this.obj.rows[0].childNodes[i].style.width=this.cellWidthPX[i]+"px";
			
			if (this.ftr)
				this.ftr.rows[0].cells[i].style.width=this.cellWidthPX[i]+"px";
		}
	}
	/**
	*   @desc: set delimiter character used in list values (default is ",")
	*   @param: delim - delimiter as string
	*   @before_init: 1
	*   @type: public
	*   @topic: 0
	*/
	this.setDelimiter=function(delim){
		this.delim=delim;
	}
	/**
	*   @desc: set width of columns in percents
	*   @type: public
	*   @before_init: 1
	*   @param: wp - list of column width in percents
	*   @topic: 0,7
	*/
	this.setInitWidthsP=function(wp){
		this.cellWidthType="%";
		this.initCellWidth=wp.split(this.delim.replace(/px/gi, ""));
		if (!arguments[1]) this._setAutoResize();
	}
	/**
	*	@desc:
	*	@type: private
	*	@topic: 0
	*/
	this._setAutoResize=function(){
		if (this._realfake) return;
		var el = window;
		var self = this;
		
		dhtmlxEvent(window,"resize",function(){
				window.clearTimeout(self._resize_timer);
				if (self._setAutoResize)
				self._resize_timer=window.setTimeout(function(){
						if (self.setSizes)
							self.setSizes();
						if (self._fake)
							self._fake._correctSplit();
				}, 100);
		});

		//prevent multiple initializations
		this._setAutoResize = function(){};
	}
	
	
	/**
	*   @desc: set width of columns in pixels
	*   @type: public
	*   @before_init: 1
	*   @param: wp - list of column width in pixels
	*   @topic: 0,7
	*/
	this.setInitWidths=function(wp){
		this.cellWidthType="px";
		this.initCellWidth=wp.split(this.delim);
		
		if (_isFF){
			for (var i = 0; i < this.initCellWidth.length; i++)
				if (this.initCellWidth[i] != "*")
				this.initCellWidth[i]=parseInt(this.initCellWidth[i]);
		}
	}
	
	/**
	*   @desc: set multiline rows support to enabled or disabled state
	*   @type: public
	*   @before_init: 1
	*   @param: state - true or false
	*   @topic: 0,7
	*/
	this.enableMultiline=function(state){
		this.multiLine=dhx4.s2b(state);
	}
	
	/**
	*   @desc: set multiselect mode to enabled or disabled state
	*   @type: public
	*   @param: state - true or false
	*   @topic: 0,7
	*/
	this.enableMultiselect=function(state){
		this.selMultiRows=dhx4.s2b(state);
	}
	
	/**
	*   @desc: set path to grid internal images (sort direction, any images used in editors, checkbox, radiobutton)
	*   @type: public
	*   @param: path - url (or relative path) of images folder with closing "/"
	*   @topic: 0,7
	*/
	this.setImagePath=function(path){
		path = path.replace(/imgs\/dhxgrid_[a-z]*\/$/,"imgs/");
		this._imgURL= path;
		this.imgURL = path + "dhxgrid_"+(this.skin_name || "dhx_skyblue").replace("dhx_", "") + "/";
		this.iconTree = this.imgURL + "tree/";
	}
	this.setImagesPath=this.setImagePath;
	/**
	*   @desc: set path to external images used in grid ( tree and img column types )
	*   @type: public
	*   @param: path - url (or relative path) of images folder with closing "/"
	*   @topic: 0,7
	*/
	this.setIconPath=function(path){
		this.iconURL=path;
	}	
	this.setIconsPath=this.setIconPath;
	//#column_resize:06042008{
	/**
	*   @desc: part of column resize routine
	*   @type: private
	*   @param: ev - event
	*   @topic: 3
	*/
	this.changeCursorState=function(ev){
		var el = ev.target||ev.srcElement;
		
		if (el.tagName != "TD")
			el=this.getFirstParentOfType(el, "TD")
		if (!el) return;
		if ((el.tagName == "TD")&&(this._drsclmn)&&(!this._drsclmn[el._cellIndex]))
			return el.style.cursor="default";
		var check = (ev.layerX||0)+(((!_isIE)&&(ev.target.tagName == "DIV")) ? el.offsetLeft : 0);
		if ((el.offsetWidth-(ev.offsetX||(parseInt(this.getPosition(el, this.hdrBox))-check)*-1)) < (_isOpera?20:10)){
			el.style.cursor="E-resize";
		}
		else{
			el.style.cursor="default";
		}
		
		if (_isOpera)
			this.hdrBox.scrollLeft=this.objBox.scrollLeft;
	}
	/**
	*   @desc: part of column resize routine
	*   @type: private
	*   @param: ev - event
	*   @topic: 3
	*/
	this.startColResize=function(ev){
		if (this.resized) this.stopColResize();
		this.resized=null;
		var el = ev.target||ev.srcElement;
		if (el.tagName != "TD")
			el=this.getFirstParentOfType(el, "TD")
		var x = ev.clientX;
		var tabW = this.hdr.offsetWidth;
		var startW = parseInt(el.offsetWidth)
		
		if (el.tagName == "TD"&&el.style.cursor != "default"){
			if ((this._drsclmn)&&(!this._drsclmn[el._cellIndex]))
				return;
			
			self._old_d_mm=document.body.onmousemove;
			self._old_d_mu=document.body.onmouseup;
			document.body.onmousemove=function(e){
				if (self)
					self.doColResize(e||window.event, el, startW, x, tabW)
			}
			document.body.onmouseup=function(){
				if (self)
					self.stopColResize();
			}
		}
	}
	/**
	*   @desc: part of column resize routine
	*   @type: private
	*   @param: ev - event
	*   @topic: 3
	*/
	this.stopColResize=function(){ 
		document.body.onmousemove=self._old_d_mm||"";
		document.body.onmouseup=self._old_d_mu||"";
		this.setSizes();
		this.doOnScroll(0, 1)
		this.callEvent("onResizeEnd", [this]);
	}
	/**
	*   @desc: part of column resize routine
	*   @param: el - element (column resizing)
	*   @param: startW - started width
	*   @param: x - x coordinate to resize from
	*   @param: tabW - started width of header table
	*   @type: private
	*   @topic: 3
	*/
	this.doColResize=function(ev, el, startW, x, tabW){
		el.style.cursor="E-resize";
		this.resized=el;
		var fcolW = startW+(ev.clientX-x);
		var wtabW = tabW+(ev.clientX-x)
		
		if (!(this.callEvent("onResize", [
				el._cellIndex,
			fcolW,
			this
		])))
		return;
		
		if (_isIE)
			this.objBox.scrollLeft=this.hdrBox.scrollLeft;
		
		var result = false;
		if (el.colSpan > 1){
			var a_sizes = new Array();
			
			for (var i = 0;
				i < el.colSpan;
				i++)a_sizes[i]=Math.round(fcolW*this.hdr.rows[0].childNodes[el._cellIndexS+i].offsetWidth/el.offsetWidth);
				
				for (var i = 0; i < el.colSpan; i++)
					result = this._setColumnSizeR(el._cellIndexS+i*1, a_sizes[i]);
		} else
		result = this._setColumnSizeR(el._cellIndex, fcolW);
		this.doOnScroll(0, 1);
		
		this.setSizes();
		if (this._fake && this._awdth) this._fake._correctSplit();
		
		return result;
	}
	
	/**
	*   @desc: set width of grid columns ( zero row of header and body )
	*   @type: private
	*   @topic: 7
	*/
	this._setColumnSizeR=function(ind, fcolW){
		if (fcolW > ((this._drsclmW&&!this._notresize) ? (this._drsclmW[ind]||10) : 10)){
			this.obj.rows[0].childNodes[ind].style.width=fcolW+"px";
			this.hdr.rows[0].childNodes[ind].style.width=fcolW+"px";
			
			if (this.ftr)
				this.ftr.rows[0].childNodes[ind].style.width=fcolW+"px";
			
			if (this.cellWidthType == 'px'){
				this.cellWidthPX[ind]=fcolW;
			}
			else {
				var gridWidth = parseInt(this.entBox.offsetWidth);
				
				if (this.objBox.scrollHeight > this.objBox.offsetHeight)
					gridWidth-=17;
				var pcWidth = Math.round(fcolW / gridWidth*100)
				this.cellWidthPC[ind]=pcWidth;
			}
			if (this.sortImg.style.display!="none")
				this.setSortImgPos();
		} else return false;
	}
	//#}
	//#sorting:06042008{
	/**
	*    @desc: sets position and visibility of sort arrow
	*    @param: state - true/false - show/hide image
	*    @param: ind - index of field
	*    @param: order - asc/desc - type of image
	*    @param: row - one based index of header row ( used in multirow headers, top row by default )
	*   @type: public
	*   @topic: 7
	*/
	this.setSortImgState=function(state, ind, order, row){
		order=(order||"asc").toLowerCase();
		
		if (!dhx4.s2b(state)){
			this.sortImg.style.display="none";
			if (this.r_fldSorted)
				this.r_fldSorted.className = "";
			this.fldSorted=this.r_fldSorted = null;
			return;
		}
		
		if (order == "asc")
			this.sortImg.className = "dhxgrid_sort_asc";
		else
			this.sortImg.className = "dhxgrid_sort_desc";
		
		this.sortImg.style.display="";
		this.fldSorted=this.hdr.rows[0].childNodes[ind];
		var r = this.hdr.rows[row||1];
		if (!r) return;
		
		for (var i = 0; i < r.childNodes.length; i++){
			if (r.childNodes[i]._cellIndexS == ind){
				this.r_fldSorted=r.childNodes[i];
				return  this.setSortImgPos();
			}
		}
		return this.setSortImgState(state,ind,order,(row||1)+1);
	}
	
	/**
	*    @desc: sets position and visibility of sort arrow
	*    @param: ind - index of field
	*    @param: ind - index of field
	*    @param: hRowInd - index of row in case of complex header, one-based, optional
	
	*   @type: private
	*   @topic: 7
	*/
	this.setSortImgPos=function(ind, mode, hRowInd, el){
		if (this._hrrar && this._hrrar[this.r_fldSorted?this.r_fldSorted._cellIndex:ind]) return;
		if (this.ar_fldSorted)
			this.ar_fldSorted.className = "";

		if (!el){
			if (!ind)
				var el = this.r_fldSorted;
			else
				var el = this.hdr.rows[hRowInd||0].cells[ind];
		}
		
		if (el != null){
			var pos = this.getPosition(el, this.hdrBox)
			var wdth = el.offsetWidth;
			this.ar_fldSorted = el;
			el.className = this.sortImg.className+"_col";

			this.sortImg.style.left=Number(pos[0]+wdth-13)+"px"; //Number(pos[0]+5)+"px";
			this.sortImg.defLeft=parseInt(this.sortImg.style.left)
			this.sortImg.style.top=Number(pos[1]+5)+"px";
			
			if ((!this.useImagesInHeader)&&(!mode))
				this.sortImg.style.display="inline";
			this.sortImg.style.left=this.sortImg.defLeft+"px"; //-parseInt(this.hdrBox.scrollLeft)
		}
	}
	//#}
	/**
	*   @desc: manage activity of the grid.
	*   @param: fl - true to activate,false to deactivate
	*   @type: private
	*   @topic: 1,7
	*/
	this.setActive=function(fl){
		if (arguments.length == 0)
			var fl = true;
		
		if (fl == true){
			//document.body.onkeydown = new Function("","document.getElementById('"+this.entBox.id+"').grid.doKey()")//
			if (globalActiveDHTMLGridObject&&(globalActiveDHTMLGridObject != this)){
				globalActiveDHTMLGridObject.editStop();
				globalActiveDHTMLGridObject.callEvent("onBlur",[globalActiveDHTMLGridObject]);
			}
			
			globalActiveDHTMLGridObject=this;
			this.isActive=true;
		} else {
			this.isActive=false;
			this.callEvent("onBlur",[this]);
		}
	};
	/**
	*     @desc: called on click occured
	*     @type: private
	*/
	this._doClick=function(ev){
		var selMethod = 0;
		var el = this.getFirstParentOfType(_isIE ? ev.srcElement : ev.target, "TD");
		if (!el || !el.parentNode || !el.parentNode.idd) return;
		var fl = true;
		
		//mm
		//markers start
		if (this.markedCells){
			var markMethod = 0;
			
			if (ev.shiftKey||ev.metaKey){
				markMethod=1;
			}
			
			if (ev.ctrlKey){
				markMethod=2;
			}
			this.doMark(el, markMethod);
			return true;
		}
		//markers end
		//mm
		
		if (this.selMultiRows != false){
			if (ev.shiftKey && this.row != null && this.selectedRows.length){
				selMethod=1;
			}
			
			if (ev.ctrlKey||ev.metaKey){
				selMethod=2;
			}
		}
		return this.doClick(el, fl, selMethod, false)
	};
	
	//#context_menu:06042008{
	/**
	*   @desc: called onmousedown inside grid area
	*   @type: private
	*/
	this._doContClick=function(ev){ 
		var el = this.getFirstParentOfType(_isIE ? ev.srcElement : ev.target, "TD");
		
		if ((!el)||( typeof (el.parentNode.idd) == "undefined")){
			this.callEvent("onEmptyClick", [ev]);
			return true;
		}
		
		if (ev.button == 2||(_isMacOS&&ev.ctrlKey)){
			if (!this.callEvent("onRightClick", [
					el.parentNode.idd,
				el._cellIndex,
				ev
			])){
			var z = function(e){
				(e||event).cancelBubble=true;
				return false;
			};
			
			(ev.srcElement||ev.target).oncontextmenu=z;
			return z(ev);
			}
			
			if (this._ctmndx){
				if (!(this.callEvent("onBeforeContextMenu", [
						el.parentNode.idd,
					el._cellIndex,
					this
				])))
				return true;
				
				if (_isIE)
				ev.srcElement.oncontextmenu=function(){
					event.cancelBubble=true;
					return false;
				};
				
				if (this._ctmndx.showContextMenu){
					
					var dEl0=window.document.documentElement;
					var dEl1=window.document.body;
					var corrector = new Array((dEl0.scrollLeft||dEl1.scrollLeft),(dEl0.scrollTop||dEl1.scrollTop));
					if (_isIE){
						var x= ev.clientX+corrector[0];
						var y = ev.clientY+corrector[1];
					} else {
						var x= ev.pageX;
						var y = ev.pageY;
					}
					this._ctmndx.showContextMenu(x-1,y-1)
					this.contextID=this._ctmndx.contextMenuZoneId=el.parentNode.idd+"_"+el._cellIndex;
					this._ctmndx._skip_hide=true;
				} else {
					el.contextMenuId=el.parentNode.idd+"_"+el._cellIndex;
					el.contextMenu=this._ctmndx;
					el.a=this._ctmndx._contextStart;
					el.a(el, ev);
					el.a=null;
				}
				ev.cancelBubble=true;
				return false;
			}
		}
		
		else if (this._ctmndx){
			if (this._ctmndx.hideContextMenu)
				this._ctmndx.hideContextMenu()
			else
				this._ctmndx._contextEnd();
		}
		return true;
	}
	//#}
	/**
	*    @desc: occures on cell click (supports treegrid)
	*   @param: [el] - cell to click on
	*   @param:   [fl] - true if to call onRowSelect function
	*   @param: [selMethod] - 0 - simple click, 1 - shift, 2 - ctrl
	*   @param: show - true/false - scroll row to view, true by defaul    
	*   @type: private
	*   @topic: 1,2,4,9
	*/
	this.doClick=function(el, fl, selMethod, show){
		if (!this.selMultiRows) selMethod=0; //block programmatical multiselecton if mode not enabled explitly
		var psid = this.row ? this.row.idd : 0;
		
		this.setActive(true);
		
		if (!selMethod)
			selMethod=0;
		
		if (this.cell != null)
			this.cell.className=this.cell.className.replace(/cellselected/g, "");
		
		if (el.tagName == "TD"){
			if (this.checkEvent("onSelectStateChanged"))
				var initial = this.getSelectedId();
			var prow = this.row;
			if (selMethod == 1){
				var elRowIndex = this.rowsCol._dhx_find(el.parentNode)
				var lcRowIndex = this.rowsCol._dhx_find(this.lastClicked)
				
				if (elRowIndex > lcRowIndex){
					var strt = lcRowIndex;
					var end = elRowIndex;
				} else {
					var strt = elRowIndex;
					var end = lcRowIndex;
				}
				
				for (var i = 0; i < this.rowsCol.length; i++)
				if ((i >= strt&&i <= end)){
					if (this.rowsCol[i]&&(!this.rowsCol[i]._sRow)){
						if (!this.rowsCol[i].idd) continue;
						if (this.rowsCol[i].className.indexOf("rowselected")
							== -1&& (this.callEvent("onBeforeSelect", [
									this.rowsCol[i].idd,
									psid,
									el._cellIndex
							]))){
						this.rowsCol[i].className+=" rowselected";
						this.selectedRows[this.selectedRows.length]=this.rowsCol[i]
							}
					} else {
						this.clearSelection();
						return this.doClick(el, fl, 0, show);
					}
				}
			} else if (selMethod == 2){
				if (el.parentNode.className.indexOf("rowselected") != -1){
					el.parentNode.className=el.parentNode.className.replace(/rowselected/g, "");
					this.selectedRows._dhx_removeAt(this.selectedRows._dhx_find(el.parentNode))
					var skipRowSelection = true;
					show = false;
				}
			}
			this.editStop()
			if (typeof (el.parentNode.idd) == "undefined")
				return true;
			
			if ((!skipRowSelection)&&(!el.parentNode._sRow)){
				if (this.callEvent("onBeforeSelect", [
						el.parentNode.idd,
					psid,
					el._cellIndex
				])){
				if (this.getSelectedRowId() != el.parentNode.idd){
					if (selMethod == 0)
						this.clearSelection();
					this.cell=el;
					if ((prow == el.parentNode)&&(this._chRRS))
						fl=false;
					this.row = el.parentNode;
					if (this.rowSelecteStates !== false) {
					    this.row.className += " rowselected";
					}
					
					if (this.selectedRows._dhx_find(this.row) == -1)
						this.selectedRows[this.selectedRows.length]=this.row;
				} else {
					this.cell=el;
					this.row = el.parentNode;
				}
				} else fl = false;
			}
			
			if (this.cell && this.cell.parentNode.className.indexOf("rowselected") != -1)
				this.cell.className=this.cell.className.replace(/cellselected/g, "")+" cellselected";
			
			if (selMethod != 1)
				if (!this.row)
				return;
			this.lastClicked=el.parentNode;
			
			var rid = this.row.idd;
			var cid = this.cell;
			
			if (fl&& typeof (rid) != "undefined" && cid && !skipRowSelection) {
				self.onRowSelectTime=setTimeout(function(){
						if (self.callEvent)
						self.callEvent("onRowSelect", [
								rid,
								cid._cellIndex
						]);
				}, 100);
			} else this.callEvent("onRowSelectRSOnly",[rid]);
			
			if (this.checkEvent("onSelectStateChanged")){
				var afinal = this.getSelectedId();
				
				if (initial != afinal)
					this.callEvent("onSelectStateChanged", [afinal,initial]);
			}
			
			if (skipRowSelection) return false;
		}
		this.isActive=true;
		if (show !== false && this.cell && this.cell.parentNode.idd)
			this.moveToVisible(this.cell)
	}
	
	/**
	*   @desc: select all rows in grid, it doesn't fire any events
	*   @param: edit - switch selected cell to edit mode
	*   @type: public
	*   @topic: 1,4
	*/
	this.selectAll=function(){
		this.clearSelection();
		
		var coll = this.rowsBuffer;
		//in paging mode, we select only current page
		if (this.pagingOn) coll = this.rowsCol;
		for (var i = 0; i<coll.length; i ++){
			this.render_row(i).className+=" rowselected";
		}
		
		this.selectedRows=dhtmlxArray([].concat(coll));
		
		if (this.selectedRows.length){
			this.row  = this.selectedRows[0];
			this.cell = this.row.cells[0];
		}
		
		if ((this._fake)&&(!this._realfake))
			this._fake.selectAll();
	}
	/**
	*   @desc: set selection to specified row-cell
	*   @param: r - row object or row index
	*   @param: cInd - cell index
	*   @param: [fl] - true if to call onRowSelect function
	*   @param: preserve - preserve previously selected rows true/false (false by default)
	*   @param: edit - switch selected cell to edit mode
	*   @param: show - true/false - scroll row to view, true by defaul         
	*   @type: public
	*   @topic: 1,4
	*/
	this.selectCell=function(r, cInd, fl, preserve, edit, show){
		if (!fl)
			fl=false;
		
		if (typeof (r) != "object")
			r=this.render_row(r)
		if (!r || r==-1) return null;
		//#__pro_feature:21092006{
		//#colspan:20092006{
		if (r._childIndexes)
			var c = r.childNodes[r._childIndexes[cInd]];
		else
			//#}
		//#}
		var c = r.childNodes[cInd];
		
		if (!c)
			c=r.childNodes[0];
		if(!this.markedCells){
			if (preserve)
				this.doClick(c, fl, 3, show)
			else
				this.doClick(c, fl, 0, show)
		}
		else 
			this.doMark(c,preserve?2:0);
		
		if (edit)
			this.editCell();
	}
	/**
	*   @desc: moves specified cell to visible area (scrolls)
	*   @param: cell_obj - object of the cell to work with
	*   @param: onlyVScroll - allow only vertical positioning
	
	*   @type: private
	*   @topic: 2,4,7
	*/
	this.moveToVisible=function(cell_obj, onlyVScroll){
		if (this.pagingOn){
			var newPage=Math.floor(this.getRowIndex(cell_obj.parentNode.idd) / this.rowsBufferOutSize)+1;
			if (newPage!=this.currentPage)
				this.changePage(newPage);
		}
		
		try{
			if (cell_obj.offsetHeight){
				var distance = cell_obj.offsetLeft+cell_obj.offsetWidth+20;
				
				var scrollLeft = 0;
				
				if (distance > (this.objBox.offsetWidth+this.objBox.scrollLeft)){
					if (cell_obj.offsetLeft > this.objBox.scrollLeft)
						scrollLeft= cell_obj.offsetLeft - (this.objBox.offsetWidth - cell_obj.offsetWidth) +5
				} else if (cell_obj.offsetLeft < this.objBox.scrollLeft){
					distance-=cell_obj.offsetWidth*2/3;
					if (distance < this.objBox.scrollLeft)
						scrollLeft=cell_obj.offsetLeft-5
				}
				
				if ((scrollLeft)&&(!onlyVScroll))
					this.objBox.scrollLeft=scrollLeft;
			}
			
			
			if (!cell_obj.offsetHeight){
				var mask=this._realfake?this._fake.rowsAr[cell_obj.parentNode.idd]:cell_obj.parentNode;
				distance = this.rowsBuffer._dhx_find(mask)*this._srdh;
			}
			else
				distance = cell_obj.offsetTop;
			var distancemax = distance + cell_obj.offsetHeight+38;
			
			if (distancemax > (this.objBox.offsetHeight+this.objBox.scrollTop)){
				var scrollTop = distance;
			} else if (distance < this.objBox.scrollTop){
				var scrollTop = distance-5
			}
			
			if (scrollTop)
				this.objBox.scrollTop=scrollTop;
		}
		catch (er){}
	}
	/**
	*   @desc: creates Editor object and switch cell to edit mode if allowed
	*   @type: public
	*   @topic: 4
	*/
	this.editCell = function(){
		if (this.editor&&this.cell == this.editor.cell)
			return; //prevent reinit for same cell
		
		this.editStop();
		
		if ((this.isEditable != true)||(!this.cell))
			return false;
		var c = this.cell;
		
		//#locked_row:11052006{
		if (c.parentNode._locked)
			return false;
		//#}
		
		this.editor=this.cells4(c);
		
		//initialize editor
		if (this.editor != null){
			if (this.editor.isDisabled()){
				this.editor=null;
				return false;
			}
			
			if (this.callEvent("onEditCell", [
					0,
				this.row.idd,
				this.cell._cellIndex
			]) != false&&this.editor.edit){
			this._Opera_stop=(new Date).valueOf();
			c.className += " editable";
			this.editor.edit();
			this.callEvent("onEditCell", [
					1,
					this.row.idd,
					this.cell._cellIndex
			])
			} else { //preserve editing
				this.editor=null;
			}
		}
	}
	/**
	*   @desc: retuns value from editor(if presents) to cell and closes editor
	*   @mode: if true - current edit value will be reverted to previous one
	*   @type: public
	*   @topic: 4
	*/
	this.editStop=function(mode){
		if (_isOpera)
		if (this._Opera_stop){
			if ((this._Opera_stop*1+50) > (new Date).valueOf())
				return;
			
			this._Opera_stop=null;
		}
		
		if (this.editor&&this.editor != null){
			this.editor.cell.className=this.editor.cell.className.replace("editable", "");
			
			if (mode){
				var t = this.editor.val;
				this.editor.detach();
				this.editor.setValue(t);
				this.editor=null;
				
				this.callEvent("onEditCancel", [
						this.row.idd,
						this.cell._cellIndex,
						t
				]);
				return;
			}
			
			if (this.editor.detach())
				this.cell.wasChanged=true;
			
			var g = this.editor;
			if (g == null) return;
			
			this.editor=null;
			var z = this.callEvent("onEditCell", [
					2,
					this.row.idd,
					this.cell._cellIndex,
					g.getValue(),
					g.val
			]);
			
			if (( typeof (z) == "string")||( typeof (z) == "number"))
				g[g.setImage ? "setLabel" : "setValue"](z);
			
			else if (!z)
				g[g.setImage ? "setLabel" : "setValue"](g.val);
			
			if (this._ahgr && this.multiLine) this.setSizes();
		}
	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this._nextRowCell=function(row, dir, pos){
		row=this._nextRow((this._groups?this.rowsCol:this.rowsBuffer)._dhx_find(row), dir);
		
		if (!row)
			return null;
		
		return row.childNodes[row._childIndexes ? row._childIndexes[pos] : pos];
	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this._getNextCell=function(acell, dir, i){
		
		acell=acell||this.cell;
		
		var arow = acell.parentNode;
		
		if (this._tabOrder){
			i=this._tabOrder[acell._cellIndex];
			
			if (typeof i != "undefined")
				if (i < 0)
				acell=this._nextRowCell(arow, dir, Math.abs(i)-1);
			else
				acell=arow.childNodes[i];
		} else {
			var i = acell._cellIndex+dir;
			
			if (i >= 0&&i < this._cCount){
				if (arow._childIndexes)
					i=arow._childIndexes[acell._cellIndex]+dir;
				acell=arow.childNodes[i];
			} else {
				
				acell=this._nextRowCell(arow, dir, (dir == 1 ? 0 : (this._cCount-1)));
			}
		}
		
		if (!acell){
			if ((dir == 1)&&this.tabEnd){
				this.tabEnd.focus();
				this.tabEnd.focus();
				this.setActive(false);
			}
			
			if ((dir == -1)&&this.tabStart){
				this.tabStart.focus();
				this.tabStart.focus();
				this.setActive(false);
			}
			return null;
		}
		
		//tab out
		
		// tab readonly
		if (acell.style.display != "none"
			&&(!this.smartTabOrder||!this.cells(acell.parentNode.idd, acell._cellIndex).isDisabled()))
		return acell;
		return this._getNextCell(acell, dir);
		// tab readonly
		
	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this._nextRow=function(ind, dir){
		var r = this.render_row(ind+dir);
		if (!r || r==-1) return null;
		if (r&&r.style.display == "none")
			return this._nextRow(ind+dir, dir);
		
		return r;
	}
	/**
	*	@desc: 
	*	@type: private
	*/
	this.scrollPage=function(dir){ 
		if (!this.rowsBuffer.length) return;
		var master = this._realfake?this._fake:this;
		var new_ind = Math.floor((master._r_select||this.getRowIndex(this.row.idd)||0)+(dir)*this.objBox.offsetHeight / (this._srdh||20));
		
		if (new_ind < 0)
			new_ind=0;
		if (new_ind >= this.rowsBuffer.length)
			new_ind=this.rowsBuffer.length-1;
		
		if (this._srnd && !this.rowsBuffer[new_ind]){			
			this.objBox.scrollTop+=Math.floor((dir)*this.objBox.offsetHeight / (this._srdh||20))*(this._srdh||20);
			if (this._fake) this._fake.objBox.scrollTop = this.objBox.scrollTop;
			master._r_select=new_ind;
		} else {
			this.selectCell(new_ind, this.cell._cellIndex, true, false,false,(this.multiLine || this._srnd));
			if (!this.multiLine && !this._srnd && !this._realfake){
				this.objBox.scrollTop=this.getRowById(this.getRowId(new_ind)).offsetTop;
				if (this._fake) this._fake.objBox.scrollTop = this.objBox.scrollTop;
			}
			master._r_select=null;
		}
	}
	
	/**
	*   @desc: manages keybord activity in grid
	*   @type: private
	*   @topic: 7
	*/
	this.doKey=function(ev){
		if (!ev)
			return true;
		
		if ((ev.target||ev.srcElement).value !== window.undefined){
			var zx = (ev.target||ev.srcElement);
			
			if (zx.className!="dhxcombo_input"&&((!zx.parentNode)||(zx.parentNode.className.indexOf("editable") == -1)))
				return true;
		}
		
		if ((globalActiveDHTMLGridObject)&&(this != globalActiveDHTMLGridObject))
			return globalActiveDHTMLGridObject.doKey(ev);
		
		if (this.isActive == false){
			//document.body.onkeydown = "";
			return true;
		}
		
		if (this._htkebl)
			return true;
		
		if (!this.callEvent("onKeyPress", [
				ev.keyCode,
			ev.ctrlKey,
			ev.shiftKey,
			ev
		]))
		return false;
		
		var code = "k"+ev.keyCode+"_"+(ev.ctrlKey ? 1 : 0)+"_"+(ev.shiftKey ? 1 : 0);
		
		if (this.cell){ //if selection exists in grid only
			if (this._key_events[code]){
				if (false === this._key_events[code].call(this))
					return true;
				
				if (ev.preventDefault)
					ev.preventDefault();
				ev.cancelBubble=true;
				return false;
			}
			
			if (this._key_events["k_other"])
				this._key_events.k_other.call(this, ev);
		}
		
		return true;
	}
	
	/**
	*   @desc: selects row (and first cell of it)
	*   @param: r - row index or row object
	*   @param: fl - if true, then call function on select
	*   @param: preserve - preserve previously selected rows true/false (false by default)
	*   @param: show - true/false - scroll row to view, true by defaul    
	*   @type: public
	*   @topic: 1,2
	*/
	this.selectRow=function(r, fl, preserve, show){
		if (typeof (r) != 'object')
			r=this.render_row(r);
		this.selectCell(r, 0, fl, preserve, false, show)
	};
	
	/**
	*   @desc: called when row was double clicked
	*   @type: private
	*   @topic: 1,2
	*/
	this.wasDblClicked=function(ev){
		var el = this.getFirstParentOfType(_isIE ? ev.srcElement : ev.target, "TD");
		
		if (el){
			var rowId = el.parentNode.idd;
			return this.callEvent("onRowDblClicked", [
					rowId,
					el._cellIndex,
					ev
			]);
		}
	}
	
	/**
	*   @desc: called when header was clicked
	*   @type: private
	*   @topic: 1,2
	*/
	this._onHeaderClick=function(e, el){
		var that = this.grid;
		el=el||that.getFirstParentOfType(_isIE ? event.srcElement : e.target, "TD");
		
		if (this.grid.resized == null){
			if (!(this.grid.callEvent("onHeaderClick", [
					el._cellIndexS,
				(e||window.event)
			])))
			return false;
			//#sorting:06042008{				
			that.sortField(el._cellIndexS, false, el)
			//#}
		}
		this.grid.resized = null;
	}
	
	/**
	*   @desc: deletes selected row(s)
	*   @type: public
	*   @topic: 2
	*/
	this.deleteSelectedRows=function(){
		var num = this.selectedRows.length //this.obj.rows.length
		
		if (num == 0)
			return;
		
		var tmpAr = this.selectedRows;
		this.selectedRows=dhtmlxArray()
		for (var i = num-1; i >= 0; i--){
			var node = tmpAr[i]
			
			if (!this.deleteRow(node.idd, node)){
				this.selectedRows[this.selectedRows.length]=node;
			}
			else {
				if (node == this.row){
					var ind = i;
				}
			}
			/*
			this.rowsAr[node.idd] = null;
			var posInCol = this.rowsCol._dhx_find(node)
			this.rowsCol[posInCol].parentNode.removeChild(this.rowsCol[posInCol]);//nb:this.rowsCol[posInCol].removeNode(true);
			this.rowsCol._dhx_removeAt(posInCol)*/
		}
		
		if (ind){
			try{
				if (ind+1 > this.rowsCol.length) //this.obj.rows.length)
					ind--;
				this.selectCell(ind, 0, true)
			}
			catch (er){
				this.row=null
				this.cell=null
			}
		}
	}
	
	/**
	*   @desc: gets selected row id
	*   @returns: id of selected row (list of ids with default delimiter) or null if non row selected
	*   @type: public
	*   @topic: 1,2,9
	*/
	this.getSelectedRowId=function(){
		var selAr = new Array(0);
		var uni = {
		};
		
		for (var i = 0; i < this.selectedRows.length; i++){
			var id = this.selectedRows[i].idd;
			
			if (uni[id])
				continue;
			
			selAr[selAr.length]=id;
			uni[id]=true;
		}
		
		//..
		if (selAr.length == 0)
			return null;
		else
			return selAr.join(this.delim);
	}
	
	/**
	*   @desc: gets index of selected cell
	*   @returns: index of selected cell or -1 if there is no selected sell
	*   @type: public
	*   @topic: 1,4
	*/
	this.getSelectedCellIndex=function(){
		if (this.cell != null)
			return this.cell._cellIndex;
		else
			return -1;
	}
	/**
	*   @desc: gets width of specified column in pixels
	*   @param: ind - column index
	*   @returns: column width in pixels
	*   @type: public
	*   @topic: 3,7
	*/
	this.getColWidth=function(ind){
		return parseInt(this.cellWidthPX[ind]);
	}
	
	/**
	*   @desc: sets width of specified column in pixels (soen't works with procent based grid)
	*   @param: ind - column index
	*   @param: value - new width value
	*   @type: public
	*   @topic: 3,7
	*/
	this.setColWidth=function(ind, value){
		if (value == "*")
			this.initCellWidth[ind] = "*";
		else {
			if (this._hrrar[ind]) return; //hidden
			if (this.cellWidthType == 'px')
				this.cellWidthPX[ind]=parseInt(value);
			else
				this.cellWidthPC[ind]=parseInt(value);
		}
		this.setSizes();
	}
	/**
	*   @desc: gets row index by id (grid only)
	*   @param: row_id - row id
	*   @returns: row index or -1 if there is no row with specified id
	*   @type: public
	*   @topic: 2
	*/
	this.getRowIndex=function(row_id){
		for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i]&&this.rowsBuffer[i].idd == row_id)
			return i;
		return -1;
	}
	/**
	*   @desc: gets row id by index
	*   @param: ind - row index
	*   @returns: row id or null if there is no row with specified index
	*   @type: public
	*   @topic: 2
	*/
	this.getRowId=function(ind){
		return this.rowsBuffer[ind] ? this.rowsBuffer[ind].idd : this.undefined;
	}
	/**
	*   @desc: sets new id for row by its index
	*   @param: ind - row index
	*   @param: row_id - new row id
	*   @type: public
	*   @topic: 2
	*/
	this.setRowId=function(ind, row_id){
		this.changeRowId(this.getRowId(ind), row_id)
	}
	/**
	*   @desc: changes id of the row to the new one
	*   @param: oldRowId - row id to change
	*   @param: newRowId - row id to set
	*   @type:public
	*   @topic: 2
	*/
	this.changeRowId=function(oldRowId, newRowId){
		if (oldRowId == newRowId)
			return;
		/*
		for (var i=0; i<row.childNodes.length; i++)
		if (row.childNodes[i]._code)
		this._compileSCL("-",row.childNodes[i]);      */
		var row = this.rowsAr[oldRowId]
		row.idd=newRowId;
		
		if (this.UserData[oldRowId]){
			this.UserData[newRowId]=this.UserData[oldRowId]
			this.UserData[oldRowId]=null;
		}
		
		if (this._h2&&this._h2.get[oldRowId]){
			this._h2.get[newRowId]=this._h2.get[oldRowId];
			this._h2.get[newRowId].id=newRowId;
			delete this._h2.get[oldRowId];
		}
		
		this.rowsAr[oldRowId]=null;
		this.rowsAr[newRowId]=row;
		
		for (var i = 0; i < row.childNodes.length; i++)
			if (row.childNodes[i]._code)
			row.childNodes[i]._code=this._compileSCL(row.childNodes[i]._val, row.childNodes[i]);
		
		if (this._mat_links && this._mat_links[oldRowId]){
			var a=this._mat_links[oldRowId];
			delete this._mat_links[oldRowId];
			for (var c in a)
				for (var i=0; i < a[c].length; i++)
				this._compileSCL(a[c][i].original,a[c][i]);
		}
		
		this.callEvent("onRowIdChange",[oldRowId,newRowId]);
	}
	/**
	*   @desc: sets ids to every column. Can be used then to retreive the index of the desired colum
	*   @param: [ids] - delimitered list of ids (default delimiter is ","), or empty if to use values set earlier
	*   @type: public
	*   @topic: 3
	*/
	this.setColumnIds=function(ids){
		this.columnIds=ids.split(this.delim)
	}
	/**
	*   @desc: sets ids to specified column.
	*   @param: ind- index of column
	*   @param: id- id of column
	*   @type: public
	*   @topic: 3
	*/
	this.setColumnId=function(ind, id){
		this.columnIds[ind]=id;
	}
	/**
	*   @desc: gets column index by column id
	*   @param: id - column id
	*   @returns: index of the column
	*   @type: public
	*   @topic: 3
	*/
	this.getColIndexById=function(id){
		for (var i = 0; i < this.columnIds.length; i++)
			if (this.columnIds[i] == id)
			return i;
	}
	/**
	*   @desc: gets column id of column specified by index
	*   @param: cin - column index
	*   @returns: column id
	*   @type: public
	*   @topic: 3
	*/
	this.getColumnId=function(cin){
		return this.columnIds[cin];
	}
	
	/**
	*   @desc: gets label of column specified by index
	*   @param: cin - column index
	*   @returns: column label
	*   @type: public
	*   @topic: 3
	*/
	this.getColumnLabel=function(cin, ind, hdr, raw){
		var z = (hdr||this.hdr).rows[(ind||0)+1];
		for (var i=0; i<z.cells.length; i++)
			if (z.cells[i]._cellIndexS==cin) return raw ? z.cells[i].firstChild.innerHTML : (_isIE ? z.cells[i].innerText : z.cells[i].textContent);
		return "";
	};
	this.getColLabel = this.getColumnLabel;
	/**
	*   @desc: gets label of footer specified by index
	*   @param: cin - column index
	*   @returns: column label
	*   @type: public
	*   @topic: 3
	*/
	this.getFooterLabel=function(cin, ind, raw){
		return this.getColumnLabel(cin,ind,this.ftr, raw);
	}
	
	
	/**
	*   @desc: sets row text BOLD
	*   @param: row_id - row id
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowTextBold=function(row_id){
		var r=this.getRowById(row_id)
		if (r) r.style.fontWeight="bold";
	}
	/**
	*   @desc: sets style to row
	*   @param: row_id - row id
	*   @param: styleString - style string in common format (exmpl: "color:red;border:1px solid gray;")
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowTextStyle=function(row_id, styleString){
		var r = this.getRowById(row_id)
		if (!r) return;
		for (var i = 0; i < r.childNodes.length; i++){
			var pfix = r.childNodes[i]._attrs["style"]||"";
			//#__pro_feature:21092006{
			//#column_hidden:21092006{
			if ((this._hrrar)&&(this._hrrar[i]))
				pfix="display:none;";
			//#}
			//#}
			if (_isIE)
				r.childNodes[i].style.cssText=pfix+"width:"+r.childNodes[i].style.width+";"+styleString;
			else
				r.childNodes[i].style.cssText=pfix+"width:"+r.childNodes[i].style.width+";"+styleString;
		}
	}
	/**
	*   @desc: sets background color of row (via bgcolor attribute)
	*   @param: row_id - row id
	*   @param: color - color value
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowColor=function(row_id, color){
		var r = this.getRowById(row_id)
		
		for (var i = 0; i < r.childNodes.length; i++)r.childNodes[i].bgColor=color;
	}
	/**
	*   @desc: sets style to cell
	*   @param: row_id - row id
	*   @param: ind - cell index
	*   @param: styleString - style string in common format (exmpl: "color:red;border:1px solid gray;")
	*   @type: public
	*   @topic: 2,6
	*/
	this.setCellTextStyle=function(row_id, ind, styleString){
		var r = this.getRowById(row_id)
		
		if (!r)
			return;
		
		var cell = r.childNodes[r._childIndexes ? r._childIndexes[ind] : ind];
		
		if (!cell)
			return;
		var pfix = "";
		//#__pro_feature:21092006{
		//#column_hidden:21092006{
		if ((this._hrrar)&&(this._hrrar[ind]))
			pfix="display:none;";
		//#}
		//#}
		if (_isIE)
			cell.style.cssText=pfix+"width:"+cell.style.width+";"+styleString;
		else
			cell.style.cssText=pfix+"width:"+cell.style.width+";"+styleString;
	}
	
	/**
	*   @desc: sets row text weight to normal
	*   @param: row_id - row id
	*   @type: public
	*   @topic: 2,6
	*/
	this.setRowTextNormal=function(row_id){
		var r=this.getRowById(row_id);
		if (r) r.style.fontWeight="normal";
	}
	/**
	*   @desc: determines if row with specified id exists
	*   @param: row_id - row id
	*   @returns: true if exists, false otherwise
	*   @type: public
	*   @topic: 2,7
	*/
	this.doesRowExist=function(row_id){
		if (this.getRowById(row_id) != null)
			return true
		else
			return false
	}
	
	
	
	/**
	*   @desc: gets number of columns in grid
	*   @returns: number of columns in grid
	*   @type: public
	*   @topic: 3,7
	*/
	this.getColumnsNum=function(){
		return this._cCount;
	}
	
	
	//#moving_rows:06042008{
	/**
	*   @desc: moves row one position up if possible
	*   @param: row_id -  row id
	*   @type: public
	*   @topic: 2
	*/
	this.moveRowUp=function(row_id){
		var r = this.getRowById(row_id)
		
		if (this.isTreeGrid())
			return this.moveRowUDTG(row_id, -1);
		
		var rInd = this.rowsCol._dhx_find(r)
		if ((r.previousSibling)&&(rInd != 0)){
			r.parentNode.insertBefore(r, r.previousSibling)
			this.rowsCol._dhx_swapItems(rInd, rInd-1)
			this.setSizes();
			var bInd=this.rowsBuffer._dhx_find(r);
			this.rowsBuffer._dhx_swapItems(bInd,bInd-1);
			
			if (this._cssEven)
				this._fixAlterCss(rInd-1);
		}
	}
	/**
	*   @desc: moves row one position down if possible
	*   @param: row_id -  row id
	*   @type: public
	*   @topic: 2
	*/
	this.moveRowDown=function(row_id){
		var r = this.getRowById(row_id)
		
		if (this.isTreeGrid())
			return this.moveRowUDTG(row_id, 1);
		
		var rInd = this.rowsCol._dhx_find(r);
		if (r.nextSibling){ 
			this.rowsCol._dhx_swapItems(rInd, rInd+1)
			
			if (r.nextSibling.nextSibling)
				r.parentNode.insertBefore(r, r.nextSibling.nextSibling)
			else
				r.parentNode.appendChild(r)
			this.setSizes();
			
			var bInd=this.rowsBuffer._dhx_find(r);
			this.rowsBuffer._dhx_swapItems(bInd,bInd+1);
			
			if (this._cssEven)
				this._fixAlterCss(rInd);
		}
	}
	//#}
	//#co_excell:06042008{
	/**
	* @desc: gets Combo object of specified column. Use it to change select box value for cell before editor opened
	*   @type: public
	*   @topic: 3,4
	*   @param: col_ind - index of the column to get combo object for
	*/
	this.getCombo=function(col_ind){
		if (!this.combos[col_ind]){
			this.combos[col_ind]=new dhtmlXGridComboObject();
		}
		return this.combos[col_ind];
	}
	//#}
	/**
	*   @desc: sets user data to row
	*   @param: row_id -  row id. if empty then user data is set for grid (not row)
	*   @param: name -  name of user data block
	*   @param: value -  value of user data block
	*   @type: public
	*   @topic: 2,5
	*/
	this.setUserData=function(row_id, name, value){
		if (!row_id)
			row_id="gridglobaluserdata";
		
		if (!this.UserData[row_id])
			this.UserData[row_id]=new Hashtable()
		this.UserData[row_id].put(name, value)
	}
	/**
	*   @desc: gets user Data
	*   @param: row_id -  row id. if empty then user data is for grid (not row)
	*   @param: name -  name of user data
	*   @returns: value of user data
	*   @type: public
	*   @topic: 2,5
	*/
	this.getUserData=function(row_id, name){
		if (!row_id)
			row_id="gridglobaluserdata";		
		this.getRowById(row_id); //parse row if necessary
		
		var z = this.UserData[row_id];
		return (z ? z.get(name) : "");
	}
	
	/**
	*   @desc: manage editibility of the grid
	*   @param: [fl] - set not editable if FALSE, set editable otherwise
	*   @type: public
	*   @topic: 7
	*/
	this.setEditable=function(fl){
		this.isEditable=dhx4.s2b(fl);
	}
	/**
	*   @desc: selects row by ID
	*   @param: row_id - row id
	*   @param: multiFL - VOID. select multiple rows
	*   @param: show - true/false - scroll row to view, true by defaul    
	*   @param: call - true to call function on select
	*   @type: public
	*   @topic: 1,2
	*/
	this.selectRowById=function(row_id, multiFL, show, call){
		if (!call)
			call=false;
		this.selectCell(this.getRowById(row_id), 0, call, multiFL, false, show);
	}
	
	/**
	*   @desc: removes selection from the grid
	*   @type: public
	*   @topic: 1,9
	*/
	this.clearSelection=function(){
		this.editStop()
		
		for (var i = 0; i < this.selectedRows.length; i++){
			var r = this.rowsAr[this.selectedRows[i].idd];
			
			if (r)
				r.className=r.className.replace(/rowselected/g, "");
		}
		
		//..
		this.selectedRows=dhtmlxArray()
		this.row=null;
		
		if (this.cell != null){
			this.cell.className=this.cell.className.replace(/cellselected/g, "");
			this.cell=null;
		}
		
		this.callEvent("onSelectionCleared",[]);
	}
	/**
	*   @desc: copies row content to another existing row
	*   @param: from_row_id - id of the row to copy content from
	*   @param: to_row_id - id of the row to copy content to
	*   @type: public
	*   @topic: 2,5
	*/
	this.copyRowContent=function(from_row_id, to_row_id){
		var frRow = this.getRowById(from_row_id)
		
		if (!this.isTreeGrid())
		for (var i = 0; i < frRow.cells.length; i++){
			this.cells(to_row_id, i).setValue(this.cells(from_row_id, i).getValue())
		}
		else
			this._copyTreeGridRowContent(frRow, from_row_id, to_row_id);
		
		//for Mozilla (to avaoid visual glitches)
		if (!_isIE)
			this.getRowById(from_row_id).cells[0].height=frRow.cells[0].offsetHeight
	}
	/**
	*   @desc: sets new label for cell in footer
	*   @param: col - header column index
	*   @param: label - new label for the cpecified footer's column. Can contai img:[imageUrl]Text Label
	*	@param: ind - header row index 
	*   @type: public
	*   @topic: 3,6
	*/
	this.setFooterLabel=function(c, label, ind){
		return this.setColumnLabel(c,label,ind,this.ftr);
	};
	/**
	*   @desc: sets new column header label
	*   @param: col - header column index
	*   @param: label - new label for the cpecified header's column. Can contai img:[imageUrl]Text Label
	*	@param: ind - header row index 
	*   @type: public
	*   @topic: 3,6
	*/
	this.setColumnLabel=function(c, label, ind, hdr){
		var z = (hdr||this.hdr).rows[ind||1];
		var col = (z._childIndexes ? z._childIndexes[c] : c);
		if (!z.cells[col]) return;
		if (!this.useImagesInHeader){
			var hdrHTML = "<div class='hdrcell'>"
			
			if (label.indexOf('img:[') != -1){
				var imUrl = label.replace(/.*\[([^>]+)\].*/, "$1");
				label=label.substr(label.indexOf("]")+1, label.length)
				hdrHTML+="<img width='18px' height='18px' align='absmiddle' src='"+imUrl+"' hspace='2'>"
			}
			hdrHTML+=label;
			hdrHTML+="</div>";
			z.cells[col].innerHTML=hdrHTML;
			
			if (this._hstyles[c])
				z.cells[col].style.cssText=this._hstyles[c];
		} else { //if images in header header
			z.cells[col].style.textAlign="left";
			z.cells[col].innerHTML="<img src='"+label+"'>";
			//preload sorting headers (asc/desc)
			var a = new Image();
			a.src=""+label.replace(/(\.[a-z]+)/, ".des$1");
			this.preloadImagesAr[this.preloadImagesAr.length]=a;
			var b = new Image();
			b.src=""+label.replace(/(\.[a-z]+)/, ".asc$1");
			this.preloadImagesAr[this.preloadImagesAr.length]=b;
		}
		
		if ((label||"").indexOf("#") != -1){
			var t = label.match(/(^|{)#([^}]+)(}|$)/);
			
			if (t){
				var tn = "_in_header_"+t[2];
				
				if (this[tn])
					this[tn]((this.forceDivInHeader ? z.cells[col].firstChild : z.cells[col]), col, label.split(t[0]));
			}
		}
	};
	this.setColLabel = function(a,b,ind,c){
		return this.setColumnLabel(a,b,(ind||0)+1,c);
	};
	/**
	*   @desc: deletes all rows in grid
	*   @param: header - (boolean) enable/disable cleaning header
	*   @type: public
	*   @topic: 5,7,9
	*/
	this.clearAll=function(header){
		if (!this.obj.rows[0]) return; //call before initilization
		if (this._h2){
			this._h2=this._createHierarchy();
			
			if (this._fake){
				if (this._realfake)
					this._h2=this._fake._h2;
				else
					this._fake._h2=this._h2;
			}
		}
		
		this.limit=this._limitC=0;
		this.editStop(true);
		
		if (this._dLoadTimer)
			window.clearTimeout(this._dLoadTimer);
		
		if (this._dload){
			this.objBox.scrollTop=0;
			this.limit=this._limitC||0;
			this._initDrF=true;
		}
		
		var len = this.rowsCol.length;
		
		//for some case
		len=this.obj.rows.length;
		
		for (var i = len-1; i > 0; i--){
			var t_r = this.obj.rows[i];
			t_r.parentNode.removeChild(t_r);
		}
		
		if (header){
			this._master_row=null;
			this.obj.rows[0].parentNode.removeChild(this.obj.rows[0]);
			
			for (var i = this.hdr.rows.length-1; i >= 0; i--){
				var t_r = this.hdr.rows[i];
				t_r.parentNode.removeChild(t_r);
			}
			
			if (this.ftr){
				this.ftr.parentNode.removeChild(this.ftr);
				this.ftr=null;
			}
			this._aHead=this.ftr=this.cellWidth=this._aFoot=null;
			this.cellType=dhtmlxArray();
			this._hrrar=[];
			this.columnIds=[];
			this.combos=[];
			this._strangeParams=[];
			this.defVal = [];
			this._ivizcol = null;
		}
		
		//..
		this.row=null;
		this.cell=null;
		
		this.rowsCol=dhtmlxArray()
		this.rowsAr={}; //array of rows by idd
		this._RaSeCol=[];
		this.rowsBuffer=dhtmlxArray()
		this.UserData=[]
		this.selectedRows=dhtmlxArray();
		
		if (this.pagingOn || this._srnd)
			this.xmlFileUrl="";
		if (this.pagingOn)
			this.changePage(1);
		
		//  if (!this._fake){
		/*
		if ((this._hideShowColumn)&&(this.hdr.rows[0]))
		for (var i=0; i<this.hdr.rows[0].cells.length; i++)
		this._hideShowColumn(i,"");
		this._hrrar=new Array();*/
		//}
		if (this._contextCallTimer)
			window.clearTimeout(this._contextCallTimer);
		
		if (this._sst)
			this.enableStableSorting(true);
		this._fillers=this.undefined;
		this.setSortImgState(false);
		this.setSizes();
		//this.obj.scrollTop = 0;
		
		this.callEvent("onClearAll", []);
	}
	
	//#sorting:06042008{
	/**
	*   @desc: sorts grid by specified field
	*    @invoke: header click
	*   @param: [ind] - index of the field
	*   @param: [repeatFl] - if to repeat last sorting
	*   @type: private
	*   @topic: 3
	*/
	this.sortField=function(ind, repeatFl, r_el){
		if (this.getRowsNum() == 0)
			return false;
		
		var el = this.hdr.rows[0].cells[ind];
		
		if (!el)
			return; //somehow
		// if (this._dload  && !this.callEvent("onBeforeSorting",[ind,this]) ) return true;
		
		if (el.tagName == "TH"&&(this.fldSort.length-1) >= el._cellIndex
			&&this.fldSort[el._cellIndex] != 'na'){ //this.entBox.fieldstosort!="" &&
		var data=this.getSortingState();
		var sortType= ( data[0]==ind && data[1]=="asc" ) ? "des" : "asc";
		
		if (!this.callEvent("onBeforeSorting", [
				ind,
			this.fldSort[ind],
			sortType
		]))
		return;
		this.sortImg.className="dhxgrid_sort_"+(sortType == "asc" ? "asc" : "desc");
		
		//for header images
		if (this.useImagesInHeader){
			var cel = this.hdr.rows[1].cells[el._cellIndex].firstChild;
			
			if (this.fldSorted != null){
				var celT = this.hdr.rows[1].cells[this.fldSorted._cellIndex].firstChild;
				celT.src=celT.src.replace(/(\.asc\.)|(\.des\.)/, ".");
			}
			cel.src=cel.src.replace(/(\.[a-z]+)$/, "."+sortType+"$1")
		}
		//.
		this.sortRows(el._cellIndex, this.fldSort[el._cellIndex], sortType)
		this.fldSorted=el;
		if (r_el && r_el.tagName.toLowerCase() != "th")
			this.r_fldSorted=r_el;

		var c = this.hdr.rows[1];
		var c = r_el.parentNode;
		var real_el = c._childIndexes ? c._childIndexes[el._cellIndex] : el._cellIndex;
		this.setSortImgPos(false, false, false, r_el);
			}
	}
	//#__pro_feature:21092006{
	//#custom_sort:21092006{
	/**
	*   @desc: set custom sorting (custom sort has three params - valueA,valueB,order; where order can be asc or des)
	*   @param: func - function to use for comparison
	*   @param:   col - index of column to apply custom sorting to
	*   @type: public
	*   @edition: Professional
	*   @topic: 3
	*/
	this.setCustomSorting=function(func, col){
		if (!this._customSorts)
			this._customSorts=new Array();
		this._customSorts[col]=( typeof (func) == "string") ? eval(func) : func;
		this.fldSort[col]="cus";
	}
	//#}
	//#}
	//#}
	/**
	*   @desc: specify if values passed to Header are images file names
	*   @param: fl - true to treat column header values as image names
	*   @type: public
	*   @before_init: 1
	*   @topic: 0,3
	*/
	this.enableHeaderImages=function(fl){
		this.useImagesInHeader=fl;
	}
	
	/**
	*   @desc: set header label and default params for new headers
	*   @param: hdrStr - header string with delimiters
	*   @param: splitSign - string used as a split marker, optional. Default is "#cspan"
	*   @param: styles - array of header styles
	*   @type: public
	*   @before_init: 1
	*   @topic: 0,3
	*/
	this.setHeader=function(hdrStr, splitSign, styles){
		if (typeof (hdrStr) != "object")
			var arLab = this._eSplit(hdrStr);
		else
			arLab=[].concat(hdrStr);
		
		var arWdth = new Array(0);
		var arTyp = new dhtmlxArray(0);
		var arAlg = new Array(0);
		var arVAlg = new Array(0);
		var arSrt = new Array(0);
		
		for (var i = 0; i < arLab.length; i++){
			arWdth[arWdth.length]=Math.round(100 / arLab.length);
			arTyp[arTyp.length]="ed";
			arAlg[arAlg.length]="left";
			arVAlg[arVAlg.length]="middle"; //top
			arSrt[arSrt.length]="na";
		}
		
		this.splitSign=splitSign||"#cspan";
		this.hdrLabels=arLab;
		this.cellWidth=arWdth;
		if (!this.initCellWidth.length) this.setInitWidthsP(arWdth.join(this.delim),true);
		this.cellType=arTyp;
		this.cellAlign=arAlg;
		this.cellVAlign=arVAlg;
		this.fldSort=arSrt;
		this._hstyles=styles||[];
	}
	/**
	*   @desc: 
	*   @param: str - ...
	*   @type: private
	*/
	this._eSplit=function(str){
		if (![].push)
			return str.split(this.delim);
		
		var a = "r"+(new Date()).valueOf();
		var z = this.delim.replace(/([\|\+\*\^])/g, "\\$1")
		return (str||"").replace(RegExp(z, "g"), a).replace(RegExp("\\\\"+a, "g"), this.delim).split(a);
	}
	
	/**
	*   @desc: get column type by column index
	*   @param: cInd - column index
	*   @returns:  type code
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.getColType=function(cInd){
		return this.cellType[cInd];
	}
	
	/**
	*   @desc: get column type by column ID
	*   @param: cID - column id
	*   @returns:  type code
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.getColTypeById=function(cID){
		return this.cellType[this.getColIndexById(cID)];
	}
	
	/**
	*   @desc: set column types
	*   @param: typeStr - type codes list (default delimiter is ",")
	*   @before_init: 2
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.setColTypes=function(typeStr){
		this.cellType=dhtmlxArray(typeStr.split(this.delim));
		this._strangeParams=new Array();
		
		for (var i = 0; i < this.cellType.length; i++){
			if ((this.cellType[i].indexOf("[") != -1)){
				var z = this.cellType[i].split(/[\[\]]+/g);
				this.cellType[i]=z[0];
				this.defVal[i]=z[1];
				
				if (z[1].indexOf("=") == 0){
					this.cellType[i]="math";
					this._strangeParams[i]=z[0];
				}
			}
			if (!window["eXcell_"+this.cellType[i]]) dhx4.callEvent("onConfigurationError",["Incorrect cell type: "+this.cellType[i],this,this.cellType[i]]);
		}
	}
	/**
	*   @desc: set column sort types (avaialble: str, int, date, na or function object for custom sorting)
	*   @param: sortStr - sort codes list with default delimiter
	*   @before_init: 1
	*   @type: public
	*   @topic: 0,3,4
	*/
	this.setColSorting=function(sortStr){
		this.fldSort=sortStr.split(this.delim)
		//#__pro_feature:21092006{
		//#custom_sort:21092006{
		//str, int, date
		var check = {str:1, "int":1, date:1};
		for (var i = 0; i < this.fldSort.length; i++)
		if ((!check[this.fldSort[i]])&&( typeof (window[this.fldSort[i]]) == "function")){
			if (!this._customSorts)
				this._customSorts=new Array();
			this._customSorts[i]=window[this.fldSort[i]];
			this.fldSort[i]="cus";
		}
		//#}
		//#}
	}
	/**
	*   @desc: set align of values in columns
	*   @param: alStr - list of align values (possible values are: right,left,center,justify). Default delimiter is ","
	*   @before_init: 1
	*   @type: public
	*   @topic: 0,3
	*/
	this.setColAlign=function(alStr){
		this.cellAlign=alStr.split(this.delim)
		for (var i=0; i < this.cellAlign.length; i++)
			this.cellAlign[i]=this.cellAlign[i]._dhx_trim();
	}
	/**
	*   @desc: set vertical align of columns
	*   @param: valStr - vertical align values list for columns (possible values are: baseline,sub,super,top,text-top,middle,bottom,text-bottom)
	*   @before_init: 1
	*   @type: public
	*   @topic: 0,3
	*/
	this.setColVAlign=function(valStr){
		this.cellVAlign=valStr.split(this.delim)
	}
	
	/**
	* 	@desc: create grid with no header. Call before initialization, but after setHeader. setHeader have to be called in any way as it defines number of columns
	*   @param: fl - true to use no header in the grid
	*   @type: public
	*   @before_init: 1
	*   @topic: 0,7
	*/
	this.setNoHeader=function(fl){
		this.noHeader=dhx4.s2b(fl);
	}
	/**
	*   @desc: scrolls row to the visible area
	*   @param: rowID - row id
	*   @type: public
	*   @topic: 2,7
	*/
	this.showRow=function(rowID){
		this.getRowById(rowID)
		
		if (this._h2) this.openItem(this._h2.get[rowID].parent.id);
		var c = this.getRowById(rowID).childNodes[0];
		
		while (c&&c.style.display == "none")
			c=c.nextSibling;
		
		if (c)
			this.moveToVisible(c, true)
	}
	
	/**
	*   @desc: modify default style of grid and its elements. Call before or after Init
	*   @param: ss_header - style def. expression for header
	*   @param: ss_grid - style def. expression for grid cells
	*   @param: ss_selCell - style def. expression for selected cell
	*   @param: ss_selRow - style def. expression for selected Row
	*   @type: public
	*   @before_init: 2
	*   @topic: 0,6
	*/
	this.setStyle=function(ss_header, ss_grid, ss_selCell, ss_selRow){
		this.ssModifier=[
			ss_header,
			ss_grid,
			ss_selCell,
			ss_selCell,
			ss_selRow
		];
		
		var prefs = ["#"+this.entBox.id+" table.hdr td", "#"+this.entBox.id+" table.obj td",
			"#"+this.entBox.id+" table.obj tr.rowselected td.cellselected",
		"#"+this.entBox.id+" table.obj td.cellselected", "#"+this.entBox.id+" table.obj tr.rowselected td"];
		
		var index = 0;
		while (!_isIE){
			try{
				var temp = document.styleSheets[index].cssRules.length;
			} catch(e) { index++; continue; }
			break;
		}
		
		for (var i = 0; i < prefs.length; i++)
		if (this.ssModifier[i]){
			if (_isIE)
				document.styleSheets[0].addRule(prefs[i], this.ssModifier[i]);
			else
				document.styleSheets[index].insertRule(prefs[i]+(" { "+this.ssModifier[i]+" }"), document.styleSheets[index].cssRules.length);
		}
	}
	/**
	*   @desc: colorize columns  background.
	*   @param: clr - colors list
	*   @type: public
	*   @before_init: 1
	*   @topic: 3,6
	*/
	this.setColumnColor=function(clr){
		this.columnColor=clr.split(this.delim)
	}
	//#alter_css:06042008{
	/**
	*   @desc: set even/odd css styles
	*   @param: cssE - name of css class for even rows
	*   @param: cssU - name of css class for odd rows
	*   @param: perLevel - true/false - mark rows not by order, but by level in treegrid
	*   @param: levelUnique - true/false - creates additional unique css class based on row level
	*   @type: public
	*   @before_init: 1
	*   @topic: 3,6
	*/
	this.enableAlterCss=function(cssE, cssU, perLevel, levelUnique){
		if (cssE||cssU)
		this.attachEvent("onGridReconstructed",function(){
				this._fixAlterCss();
				if (this._fake)
					this._fake._fixAlterCss();
		});
		
		this._cssSP=perLevel;
		this._cssSU=levelUnique;
		this._cssEven=cssE;
		this._cssUnEven=cssU;
	}
	//#}
	/**
	*   @desc: recolor grid from defined point
	*   @type: private
	*   @before_init: 1
	*   @topic: 3,6
	*/
	this._fixAlterCss=function(ind){
		//#alter_css:06042008{		
		if (this._h2 && (this._cssSP || this._cssSU))
			return this._fixAlterCssTGR(ind);
		if (!this._cssEven && !this._cssUnEven) return;
		ind=ind||0;
		var j = ind;
		
		for (var i = ind; i < this.rowsCol.length; i++){
			if (!this.rowsCol[i])
				continue;
			
			if (this.rowsCol[i].style.display != "none"){
				if (this.rowsCol[i]._cntr) { j=1; continue; }
				if (this.rowsCol[i].className.indexOf("rowselected") != -1){
					if (j%2 == 1)
						this.rowsCol[i].className=this._cssUnEven+" rowselected "+(this.rowsCol[i]._css||"");
					else
						this.rowsCol[i].className=this._cssEven+" rowselected "+(this.rowsCol[i]._css||"");
				} else {
					if (j%2 == 1)
						this.rowsCol[i].className=this._cssUnEven+" "+(this.rowsCol[i]._css||"");
					else
						this.rowsCol[i].className=this._cssEven+" "+(this.rowsCol[i]._css||"");
				}
				j++;
			}
		}
		//#}		
	}
	//#__pro_feature:21092006{
	/**
	*     @desc: clear wasChanged state for all cells in grid
	*     @type: public
	*     @edition: Professional
	*     @topic: 7
	*/
	this.clearChangedState=function(){
		for (var i = 0; i < this.rowsCol.length; i++){
			var row = this.rowsCol[i];
			if (row && row.childNodes){
				var cols = row.childNodes.length;
				for (var j = 0; j < cols; j++)row.childNodes[j].wasChanged=false;
			}
		}
	};
	
	/**
	*     @desc: get list of IDs of changed rows
	*     @type: public
	*     @edition: Professional
	*     @return: list of ID of changed rows
	*     @topic: 7
	*/
	this.getChangedRows=function(and_added){
		var res = new Array();
		this.forEachRow(function(id){
				var row = this.rowsAr[id];
				if (row.tagName!="TR") return; 
				var cols = row.childNodes.length;
				if (and_added && row._added)
					res[res.length]=row.idd;
				else
					for (var j = 0; j < cols; j++)
					if (row.childNodes[j].wasChanged){
						res[res.length]=row.idd;
						break;
					}
		})
		return res.join(this.delim);
	};
	
	
	//#serialization:21092006{
	
	this._sUDa=false;
	this._sAll=false;
	
	/**
	*     @desc: configure XML serialization
	*     @type: public
	*     @edition: Professional
	*     @param: userData - enable/disable user data serialization
	*     @param: fullXML - enable/disable full XML serialization (selection state)
	*     @param: config - serialize grid configuration
	*     @param: changedAttr - include changed attribute
	*     @param: onlyChanged - include only Changed  rows in result XML
	*     @param: asCDATA - output cell values as CDATA sections (prevent invalid XML)
	*     @topic: 0,5,7
	*/
	this.setSerializationLevel=function(userData, fullXML, config, changedAttr, onlyChanged, asCDATA){
		this._sUDa=userData;
		this._sAll=fullXML;
		this._sConfig=config;
		this._chAttr=changedAttr;
		this._onlChAttr=onlyChanged;
		this._asCDATA=asCDATA;
	}
	
	
	/**
	*     @desc: configure which column must be serialized (if you do not use this method, then all columns will be serialized)
	*     @type: public
	*     @edition: Professional
	*     @param: list - list of true/false values separated by comma, if list empty then all fields will be serialized
	*     @topic: 0,5,7
	*/
	this.setSerializableColumns=function(list){
		if (!list){
			this._srClmn=null;
			return;
		}
		this._srClmn=(list||"").split(",");
		
		for (var i = 0; i < this._srClmn.length; i++)this._srClmn[i]=dhx4.s2b(this._srClmn[i]);
	}
	
	/**
	*     @desc: serialize a collection of rows
	*     @type: private
	*     @topic: 0,5,7
	*/
	this._serialise=function(rCol, inner, closed){
		this.editStop()
		var out = [];
		//rows collection
		var close = "</"+this.xml.s_row+">"
		
		if (this.isTreeGrid()){
			this._h2.forEachChildF(0, function(el){
					var temp = this._serializeRow(this.render_row_tree(-1, el.id));
					out.push(temp);
					
					if (temp)
						return true;
					else
						return false;
			}, this, function(){
				out.push(close);
			});
		}
		else
			for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i]){
				if (this._chAttr && this.rowsBuffer[i]._locator)
					continue;
				
				var temp = this._serializeRow(this.render_row(i));
				out.push(temp);
				
				if (temp)
					out.push(close);
			}
			
			return [out.join("")];
	}
	
	/**
	*   @desc: serialize TR or xml node to grid formated xml (row tag)
	*   @param: r - TR or xml node (row)
	*   @retruns: string - xml representation of passed row
	*   @type: private
	*/
	this._serializeRow=function(r, i){
		var out = [];
		var ra = this.xml.row_attrs;
		var ca = this.xml.cell_attrs;
		
		out.push("<"+this.xml.s_row);
		out.push(" id='"+r.idd+"'");
		
		if ((this._sAll)&&this.selectedRows._dhx_find(r) != -1)
			out.push(" selected='1'");
		
		if (this._h2&&this._h2.get[r.idd].state == "minus")
			out.push(" open='1'");
		
		if (ra.length)
			for (var i = 0; i < ra.length; i++)out.push(" "+ra[i]+"='"+r._attrs[ra[i]]+"'");
		out.push(">");
		
		//userdata
		if (this._sUDa&&this.UserData[r.idd]){
			keysAr=this.UserData[r.idd].getKeys()
			
			for (var ii = 0; ii < keysAr.length; ii++){
				var subkey = keysAr[ii];
				if (subkey.indexOf("__") !== 0)
					out.push("<userdata name='"+subkey+"'>"+(this._asCDATA?"<![CDATA[":"")+this.UserData[r.idd].get(subkey)+(this._asCDATA?"]]>":"")+"</userdata>");
			}
		}
		
		
		//cells
		var changeFl = false;
		
		for (var jj = 0; jj < this._cCount; jj++){
			if ((!this._srClmn)||(this._srClmn[jj])){
				var zx = this.cells3(r, jj);
				out.push("<cell");
				
				if (ca.length)
					for (var i = 0; i < ca.length; i++)out.push(" "+ca[i]+"='"+zx.cell._attrs[ca[i]]+"'");
				zxVal=zx[this._agetm]();
				
				if (this._asCDATA)
					zxVal="<![CDATA["+zxVal+"]]>";
				
				//#colspan:20092006{
				if ((this._ecspn)&&(zx.cell.colSpan)&&zx.cell.colSpan > 1)
					out.push(" colspan=\""+zx.cell.colSpan+"\" ");
				//#}
				
				if (this._chAttr){
					if (zx.wasChanged()){
						out.push(" changed=\"1\"");
						changeFl=true;
					}
				}
				
				else if ((this._onlChAttr)&&(zx.wasChanged()))
					changeFl=true;
				
				if (this._sAll && this.cellType[jj]=="tree")
					out.push((this._h2 ? (" image='"+this._h2.get[r.idd].image+"'") : "")+">"+zxVal+"</cell>");
				else
					out.push(">"+zxVal+"</cell>");
				
				//#colspan:20092006{
				if ((this._ecspn)&&(zx.cell.colSpan))
				for (var u = 0; u < zx.cell.colSpan-1; u++){
					out.push("<cell/>");
					jj++;
				}
				//#}
			}
		}
		
		if ((this._onlChAttr)&&(!changeFl)&&(!r._added))
			return "";
		
		return out.join("");
	}
	
	/**
	*     @desc: serialize grid configuration
	*     @type: private
	*     @topic: 0,5,7
	*/
	this._serialiseConfig=function(){
		var out = "<head>";
		
		for (var i = 0; i < this.hdr.rows[0].cells.length; i++){
			if (this._srClmn && !this._srClmn[i]) continue;
			var sort = this.fldSort[i];
			if (sort == "cus"){
				sort = this._customSorts[i].toString();
				sort=sort.replace(/function[\ ]*/,"").replace(/\([^\f]*/,"");
			}
			out+="<column width='"+this.getColWidth(i)+"' align='"+this.cellAlign[i]+"' type='"+this.cellType[i]
			+"' sort='"+(sort||"na")+"' color='"+(this.columnColor[i]||"")+"'"
			+(this.columnIds[i]
				? (" id='"+this.columnIds[i]+"'")
				: "")+">";
			if (this._asCDATA)
				out+="<![CDATA["+this.getColumnLabel(i)+"]]>";
			else
				out+=this.getColumnLabel(i);
			var z = this.getCombo(i);
			
			if (z)
				for (var j = 0; j < z.keys.length; j++)out+="<option value='"+z.keys[j]+"'>"+z.values[j]+"</option>";
			out+="</column>"
		}
		return out+="</head>";
	}
	/**
	*     @desc: get actual xml of grid. The depth of serialization can be set with setSerializationLevel method
	*     @type: public
	*     @edition: Professional
	*     @topic: 5,7
	*/
	this.serialize=function(){
		var out = '<?xml version="1.0"?><rows>';
		
		if (this._mathSerialization)
			this._agetm="getMathValue";
		else
			this._agetm="getValue";
		
		if (this._sUDa&&this.UserData["gridglobaluserdata"]){
			var keysAr = this.UserData["gridglobaluserdata"].getKeys()
			
			for (var i = 0;
				i < keysAr.length;
				i++)out+="<userdata name='"+keysAr[i]+"'>"+this.UserData["gridglobaluserdata"].get(keysAr[i])
				+"</userdata>";
		}
		
		if (this._sConfig)
			out+=this._serialiseConfig();
		out+=this._serialise();
		
		out+='</rows>';
		return out;
	}
	//#}
	//#}
	
	/**
	*    @desc: returns absolute left and top position of specified element
	*    @returns: array of two values: absolute Left and absolute Top positions
	*    @param: oNode - element to get position of
	*   @type: private
	*   @topic: 8
	*/
	this.getPosition=function(oNode, pNode){
		if (!pNode){
			var pos = dhx4.getOffset(oNode);
			return [pos.left, pos.top];
		}
		pNode = pNode||document.body;
		
		var oCurrentNode = oNode;
		var iLeft = 0;
		var iTop = 0;
		
		while ((oCurrentNode)&&(oCurrentNode != pNode)){ //.tagName!="BODY"){
			iLeft+=oCurrentNode.offsetLeft-oCurrentNode.scrollLeft;
			iTop+=oCurrentNode.offsetTop-oCurrentNode.scrollTop;
			oCurrentNode=oCurrentNode.offsetParent;
		}
		
		if (pNode == document.body){
			if (_isIE){
				iTop+=document.body.offsetTop||document.documentElement.offsetTop;
				iLeft+=document.body.offsetLeft||document.documentElement.offsetLeft;
			} else if (!_isFF){
				iLeft+=document.body.offsetLeft;
				iTop+=document.body.offsetTop;
			}
		}
		return [iLeft, iTop];
	}
	/**
	*   @desc: gets nearest parent of specified type
	*   @param: obj - input object
	*   @param: tag - string. tag to find as parent
	*   @returns: object. nearest paraent object (including spec. obj) of specified type.
	*   @type: private
	*   @topic: 8
	*/
	this.getFirstParentOfType=function(obj, tag){
		while (obj&&obj.tagName != tag&&obj.tagName != "BODY"){
			obj=obj.parentNode;
		}
		return obj;
	}
	
	
	
	/*INTERNAL EVENT HANDLERS*/
	this.objBox.onscroll=function(){
		this.grid._doOnScroll();
	};
	this.hdrBox.onscroll=function(){
		if (this._try_header_sync) return;
		this._try_header_sync = true;
		if (Math.abs(this.grid.objBox.scrollLeft - this.scrollLeft)>1){
			this.grid.objBox.scrollLeft = this.scrollLeft;
		}
		this._try_header_sync = false;
	}
	//#column_resize:06042008{
	if ((!_isOpera)||(_OperaRv > 8.5)){
		this.hdr.onmousemove=function(e){
			this.grid.changeCursorState(e||window.event);
		};
		this.hdr.onmousedown=function(e){
			return this.grid.startColResize(e||window.event);
		};		
	}
	//#}
	//#tooltips:06042008{
	this.obj.onmousemove=this._drawTooltip;
	//#}
	this.objBox.onclick=function(e){
		e = e||event;
		e.cancelBubble=true;
		this.firstChild.grid.setActive(true);
		window.dhx4.callEvent("_onGridClick", [e, this.firstChild.grid]);
	};
	this.obj.onclick=function(e){
		if (this.grid._doClick(e||window.event) !== false){
			if (this.grid._sclE) 
				this.grid.editCell(e||window.event); 
			else
				this.grid.editStop();
		}
		
		e = e||event;
		e.cancelBubble=true;
		window.dhx4.callEvent("_onGridClick", [e, this.grid]);
	};
	//#context_menu:06042008{
	if (_isMacOS){
		this.entBox.oncontextmenu=function(e){
			e.cancelBubble=true;
			if (e.preventDefault) e.preventDefault(); else e.returnValue=false;
			var that = this.grid; if (that._realfake) that = that._fake;
			return that._doContClick(e||window.event);
		};
	} else {
		this.entBox.onmousedown=function(e){
			return this.grid._doContClick(e||window.event);
		};
		this.entBox.oncontextmenu=function(e){
			if (this.grid._ctmndx)
				(e||event).cancelBubble=true;
			return !this.grid._ctmndx;
		};
	}
		
	//#}		
	this.obj.ondblclick=function(e){
		if (!this.grid.wasDblClicked(e||window.event)) 
			return false; 
		if (this.grid._dclE) {
			var row = this.grid.getFirstParentOfType((_isIE?event.srcElement:e.target),"TR");
			if (row == this.grid.row)
				this.grid.editCell(e||window.event);  
		}
		(e||event).cancelBubble=true;
		if (_isOpera) return false; //block context menu for Opera 9+
	};
	this.hdr.onclick=this._onHeaderClick;
	this.sortImg.onclick=function(){
		self._onHeaderClick.apply({
				grid: self
		}, [
			null,
			self.r_fldSorted
		]);
	};
	
	this.hdr.ondblclick=this._onHeaderDblClick;
	
	
	if (!document.body._dhtmlxgrid_onkeydown){
		dhtmlxEvent(document, "keydown",function(e){
				if (globalActiveDHTMLGridObject) 
					return globalActiveDHTMLGridObject.doKey(e||window.event);
		});
		document.body._dhtmlxgrid_onkeydown=true;
	}
	
	dhtmlxEvent(document.body, "click", function(){
			if (self.editStop) self.editStop();
			if (self.isActive) self.setActive(false);
	});
	
	
	if (this.entBox.style.height.toString().indexOf("%") != -1)
		this._delta_y = this.entBox.style.height;
	if (this.entBox.style.width.toString().indexOf("%") != -1)
		this._delta_x = this.entBox.style.width;
	
	if (this._delta_x||this._delta_y)
		this._setAutoResize();
	
	
	/* deprecated names */
	this.setColHidden=this.setColumnsVisibility
	this.enableCollSpan = this.enableColSpan
	this.setMultiselect=this.enableMultiselect;
	this.setMultiLine=this.enableMultiline;
	this.deleteSelectedItem=this.deleteSelectedRows;
	this.getSelectedId=this.getSelectedRowId;
	this.getHeaderCol=this.getColumnLabel;
	this.isItemExists=this.doesRowExist;
	this.getColumnCount=this.getColumnsNum;
	this.setSelectedRow=this.selectRowById;
	this.setHeaderCol=this.setColumnLabel;
	this.preventIECashing=this.preventIECaching;
	this.enableAutoHeigth=this.enableAutoHeight;
	this.getUID=this.uid;
	
	if (dhtmlx.image_path) this.setImagePath(dhtmlx.image_path);
	if (dhtmlx.skin) this.setSkin(dhtmlx.skin);
	
	return this;
}

dhtmlXGridObject.prototype={
	getRowAttribute: function(id, name){
		return this.getRowById(id)._attrs[name];
	},
	setRowAttribute: function(id, name, value){
		this.getRowById(id)._attrs[name]=value;
	},
	/**
	*   @desc: detect is current grid is a treeGrid
	*   @type: private
	*   @topic: 2
	*/
	isTreeGrid:function(){
		return (this.cellType._dhx_find("tree") != -1);
	},
	
	//#column_hidden:21092006{	
	/**
	*   @desc: hide/show row (warning! - this command doesn't affect row indexes, only visual appearance)
	*   @param: ind - column index
	*   @param: state - true/false - hide/show row
	*   @type:  public
	*/
	setRowHidden:function(id, state){
		var f = dhx4.s2b(state);
		//var ind=this.getRowIndex(id);
		//if (id<0)
		//   return;
		var row = this.getRowById(id) //this.rowsCol[ind];
		
		if (!row)
			return;
		
		if (row.expand === "")
			this.collapseKids(row);
		
		if ((state)&&(row.style.display != "none")){
			row.style.display="none";
			var z = this.selectedRows._dhx_find(row);
			
			if (z != -1){
				row.className=row.className.replace("rowselected", "");
				
				for (var i = 0;
					i < row.childNodes.length;
					i++)row.childNodes[i].className=row.childNodes[i].className.replace(/cellselected/g, "");
					this.selectedRows._dhx_removeAt(z);
			}
			this.callEvent("onGridReconstructed", []);
		}
		
		if ((!state)&&(row.style.display == "none")){
			row.style.display="";
			this.callEvent("onGridReconstructed", []);
		}
		this.callEvent("onRowHide",[id, state]);
		this.setSizes();
	},
	
	//#__pro_feature:21092006{
	/**
	*   @desc: hide/show column
	*   @param: ind - column index
	*   @param: state - true/false - hide/show column
	*   @type:  public
	*   @edition: Professional
	*/
	setColumnHidden:function(ind, state){
		if (!this.hdr.rows.length){
			if (!this._ivizcol)
				this._ivizcol=[];
			return this._ivizcol[ind]=state;
		}
		
		if ((this.fldSorted)&&(this.fldSorted.cellIndex == ind)&&(state))
			this.sortImg.style.display="none";
		
		var f = dhx4.s2b(state);
		
		if (f){
			if (!this._hrrar)
				this._hrrar=new Array();
			
			else if (this._hrrar[ind])
				return;
			this._hrrar[ind]="display:none;";
			this._hideShowColumn(ind, "none");
		} else {
			if ((!this._hrrar)||(!this._hrrar[ind]))
				return;
			this._hrrar[ind]="";
			this._hideShowColumn(ind, "");
		}
		
		if ((this.fldSorted)&&(this.fldSorted.cellIndex == ind)&&(!state))
			this.sortImg.style.display="inline";
		
		this.setSortImgPos();
		this.callEvent("onColumnHidden",[ind,state])
	},
	
	
	/**
	*   @desc: get show/hidden status of column
	*   @param: ind - column index
	*   @type:  public
	*   @edition: Professional
	*   @returns:  if column hidden then true else false
	*/
	isColumnHidden:function(ind){
		if ((this._hrrar)&&(this._hrrar[ind]))
			return true;
		
		return false;
	},
	/**
	*   @desc: set list of visible/hidden columns
	*   @param: list - list of true/false separated by comma
	*   @type:  public
	*	@newmethod: setColumnsVisibility
	*   @edition: Professional
	*   @topic:0
	*/
	setColumnsVisibility:function(list){
		if (list)
			this._ivizcol=list.split(this.delim);
		
		if (this.hdr.rows.length&&this._ivizcol)
			for (var i = 0; i < this._ivizcol.length; i++)this.setColumnHidden(i, this._ivizcol[i]);
	},
	/**
	*   @desc: fix hidden state for column in all rows
	*   @type: private
	*/
	_fixHiddenRowsAll:function(pb, ind, prop, state, index){
		index=index||"_cellIndex";
		var z = pb.rows.length;
		
		for (var i = 0; i < z; i++){
			var x = pb.rows[i].childNodes;
			
			if (x.length != this._cCount){
				for (var j = 0; j < x.length; j++)
				if (x[j][index] == ind){
					x[j].style[prop]=state;
					break;
				}
			} else
			x[ind].style[prop]=state;
		}
	},
	/**
	*   @desc: hide column
	*   @param: ind - column index
	*   @param: state - hide/show
	*   @edition: Professional
	*   @type:  private
	*/
	_hideShowColumn:function(ind, state){
		var hind = ind;
		
		if (this.hdr.rows[1] && (this.hdr.rows[1]._childIndexes)&&(this.hdr.rows[1]._childIndexes[ind] != ind))
			hind=this.hdr.rows[1]._childIndexes[ind];
		
		if (state == "none"){
			this.hdr.rows[0].cells[ind]._oldWidth=this.hdr.rows[0].cells[ind].style.width||(this.initCellWidth[ind]+"px");
			this.hdr.rows[0].cells[ind]._oldWidthP=this.cellWidthPC[ind];
			this.obj.rows[0].cells[ind].style.width="0px";
			
			
			var t={rows:[this.obj.rows[0]]}
			this.forEachRow(function(id){
					if (this.rowsAr[id].tagName=="TR")
						t.rows.push(this.rowsAr[id])
			})
			this._fixHiddenRowsAll(t, ind, "display", "none");
			
			if (this.isTreeGrid())
				this._fixHiddenRowsAllTG(ind, "none");
			
			if ((_isOpera&&_OperaRv < 9)||_isKHTML||(_isFF)){ 
				this._fixHiddenRowsAll(this.hdr, ind, "display", "none","_cellIndexS");
				
			}
			if (this.ftr)
				this._fixHiddenRowsAll(this.ftr.childNodes[0], ind, "display", "none");			
			this._fixHiddenRowsAll(this.hdr, ind, "whiteSpace", "nowrap","_cellIndexS");
			
			if (!this.cellWidthPX.length&&!this.cellWidthPC.length)
				this.cellWidthPX=[].concat(this.initCellWidth);
			
			if (this.cellWidthPX[ind])
				this.cellWidthPX[ind]=0;
			
			if (this.cellWidthPC[ind])
				this.cellWidthPC[ind]=0;
		} else {
			if (this.hdr.rows[0].cells[ind]._oldWidth){
				var zrow = this.hdr.rows[0].cells[ind];
				
				if (_isOpera||_isKHTML||(_isFF))
					this._fixHiddenRowsAll(this.hdr, ind, "display", "","_cellIndexS");
				
				if (this.ftr)
					this._fixHiddenRowsAll(this.ftr.childNodes[0], ind, "display", "");
				
				
				var t={rows:[this.obj.rows[0]]}
				this.forEachRow(function(id){
						if (this.rowsAr[id].tagName=="TR")
							t.rows.push(this.rowsAr[id])
				})
				this._fixHiddenRowsAll(t, ind, "display", "");
				
				if (this.isTreeGrid())
					this._fixHiddenRowsAllTG(ind, "");
				
				this._fixHiddenRowsAll(this.hdr, ind, "whiteSpace", "normal","_cellIndexS");
				
				if (zrow._oldWidthP)
					this.cellWidthPC[ind]=zrow._oldWidthP;
				
				if (zrow._oldWidth)
					this.cellWidthPX[ind]=parseInt(zrow._oldWidth);
			}
		}

		if (!state && this._realfake)
			this.setColumnSizes(this.entBox.clientWidth);

		this.setSizes();
		
		if ((!_isIE)&&(!_isFF)){
			//dummy Opera/Safari fix
			this.obj.border=1;
			this.obj.border=0;
		}
	},
	//#}	
	//#}
	//#__pro_feature:21092006{	
	//#colspan:20092006{
	/**
	*   @desc: enable/disable colspan support
	*   @param: mode - true/false
	*   @type:  public
	*   @edition: Professional
	*/
	enableColSpan:function(mode){
		this._ecspn=dhx4.s2b(mode);
	},
	//#}
	//#}
	//#hovering:060402008{	
	/**
	*   @desc: enable/disable hovering row on mouse over
	*   @param: mode - true/false
	*   @param: cssClass - css class for hovering row
	*   @type:  public
	*/
	enableRowsHover:function(mode, cssClass){
		this._unsetRowHover(false,true);
		this._hvrCss=cssClass;
		
		if (dhx4.s2b(mode)){
			if (!this._elmnh){
				this.obj._honmousemove=this.obj.onmousemove;
				this.obj.onmousemove=this._setRowHover;
				
				if (_isIE)
					this.obj.onmouseleave=this._unsetRowHover;
				else
					this.obj.onmouseout=this._unsetRowHover;
				
				this._elmnh=true;
			}
		} else {
			if (this._elmnh){
				this.obj.onmousemove=this.obj._honmousemove;
				
				if (_isIE)
					this.obj.onmouseleave=null;
				else
					this.obj.onmouseout=null;
				
				this._elmnh=false;
			}
		}
	},
	//#}	
	/**
	*   @desc: enable/disable events which fire excell editing, mutual exclusive with enableLightMouseNavigation
	*   @param: click - true/false - enable/disable editing by single click
	*   @param: dblclick - true/false - enable/disable editing by double click
	*   @param: f2Key - enable/disable editing by pressing F2 key
	*   @type:  public
	*/
	enableEditEvents:function(click, dblclick, f2Key){
		this._sclE=dhx4.s2b(click);
		this._dclE=dhx4.s2b(dblclick);
		this._f2kE=dhx4.s2b(f2Key);
	},
	
	//#hovering:060402008{	
	/**
	*   @desc: enable/disable light mouse navigation mode (row selection with mouse over, editing with single click), mutual exclusive with enableEditEvents
	*   @param: mode - true/false
	*   @type:  public
	*/
	enableLightMouseNavigation:function(mode){
		if (dhx4.s2b(mode)){
			if (!this._elmn){
				this.entBox._onclick=this.entBox.onclick;
				this.entBox.onclick=function(){
					return true;
				};
				
				this.obj._onclick=this.obj.onclick;
				this.obj.onclick=function(e){
					var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
					if (!c) return;
					this.grid.editStop();
					this.grid.doClick(c);
					this.grid.editCell();
					(e||event).cancelBubble=true;
				}
				
				this.obj._onmousemove=this.obj.onmousemove;
				this.obj.onmousemove=this._autoMoveSelect;
				this._elmn=true;
			}
		} else {
			if (this._elmn){
				this.entBox.onclick=this.entBox._onclick;
				this.obj.onclick=this.obj._onclick;
				this.obj.onmousemove=this.obj._onmousemove;
				this._elmn=false;
			}
		}
	},
	
	
	/**
	*   @desc: remove hover state on row
	*   @type:  private
	*/
	_unsetRowHover:function(e, c){
		if (c)
			that=this;
		else
			that=this.grid;
		
		if ((that._lahRw)&&(that._lahRw != c)){
			for (var i = 0;
				i < that._lahRw.childNodes.length;
				i++)that._lahRw.childNodes[i].className=that._lahRw.childNodes[i].className.replace(that._hvrCss, "");
				that._lahRw=null;
		}
	},
	
	/**
	*   @desc: set hover state on row
	*   @type:  private
	*/
	_setRowHover:function(e){
		var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
		
		if (c && c.parentNode!=this.grid._lahRw) {
			this.grid._unsetRowHover(0, c);
			c=c.parentNode;
			if (!c.idd || c.idd=="__filler__") return;
			for (var i = 0; i < c.childNodes.length; i++)c.childNodes[i].className+=" "+this.grid._hvrCss;
			this.grid._lahRw=c;
		}
		this._honmousemove(e);
	},
	
	/**
	*   @desc: onmousemove, used in light mouse navigaion mode
	*   @type:  private
	*/
	_autoMoveSelect:function(e){
		//this - grid.obj
		if (!this.grid.editor){
			var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
			
			if (c.parentNode.idd)
				this.grid.doClick(c, true, 0);
		}
		this._onmousemove(e);
	},
	//#}	
	//#__pro_feature:21092006{
	//#distrb_parsing:21092006{
	/**
	*   @desc: enable/disable distributed parsing (rows paresed portion by portion with some timeout)
	*   @param: mode - true/false
	*   @param: count - count of nodes parsed by one step (the 10 by default)
	*   @param: time - time between parsing counts in milli seconds (the 250 by default)
	*   @type:  public
	*   @edition: Professional
	*/
	enableDistributedParsing:function(mode, count, time){
		if (dhx4.s2b(mode)){
			this._ads_count=count||10;
			this._ads_time=time||250;
		} else
		this._ads_count=0;
	},
	//#}
	//#}
	/**
	*     @desc: destructor, removes grid and cleans used memory
	*     @type: public
	*     @topic: 0
	*/
	destructor:function(){
		this.editStop(true);
		//add links to current object
		if (this._sizeTime)
			this._sizeTime=window.clearTimeout(this._sizeTime);
		this.entBox.className=(this.entBox.className||"").replace(/gridbox.*/,"");
		if (this.formInputs)
			for (var i = 0; i < this.formInputs.length; i++)this.parentForm.removeChild(this.formInputs[i]);
		
		var a;
		
		for (var i = 0; i < this.rowsCol.length; i++)
			if (this.rowsCol[i])
			this.rowsCol[i].grid=null;
		
		for (i in this.rowsAr)
			if (this.rowsAr[i])
			this.rowsAr[i]=null;
		
		this.rowsCol=new dhtmlxArray();
		this.rowsAr={};
		this.entBox.innerHTML="";
		
		var dummy=function(){};
		this.entBox.onclick = this.entBox.onmousedown = this.entBox.onbeforeactivate = this.entBox.onbeforedeactivate = this.entBox.onbeforedeactivate = this.entBox.onselectstart = dummy;
		this.setSizes = this._update_srnd_view = this.callEvent = dummy;
		this.entBox.grid=this.objBox.grid=this.hdrBox.grid=this.obj.grid=this.hdr.grid=null;
		if (this._fake){
			this.globalBox.innerHTML = "";
			this._fake.setSizes = this._fake._update_srnd_view = this._fake.callEvent = dummy;
			this.globalBox.onclick = this.globalBox.onmousedown = this.globalBox.onbeforeactivate = this.globalBox.onbeforedeactivate = this.globalBox.onbeforedeactivate = this.globalBox.onselectstart = dummy;
		}
		
		for (a in this){
			if ((this[a])&&(this[a].m_obj))
				this[a].m_obj=null;
			this[a]=null;
		}
		
		if (this == globalActiveDHTMLGridObject)
			globalActiveDHTMLGridObject=null;
		//   self=null;
		return null;
	},
	
	//#sorting:06042008{	
	/**
	*     @desc: get sorting state of grid
	*     @type: public
	*     @returns: array, first element is index of sortef column, second - direction of sorting ("asc" or "des").
	*     @topic: 0
	*/
	getSortingState:function(){
		var z = new Array();
		
		if (this.fldSorted){
			z[0]=this.fldSorted._cellIndex;
			z[1]=(this.sortImg.className == "dhxgrid_sort_desc" ? "des" : "asc");
		}
		return z;
	},
	//#}
	
	/**
	*     @desc: enable autoheight of grid
	*     @param: mode - true/false
	*     @param: maxHeight - maximum height before scrolling appears (no limit by default)
	*     @param: countFullHeight - control the usage of maxHeight parameter - when set to true all grid height included in max height calculation, if false then only data part (no header) of grid included in calcualation (false by default)
	*     @type: public
	*     @topic: 0
	*/
	enableAutoHeight:function(mode, maxHeight, countFullHeight){
		this._ahgr=dhx4.s2b(mode);
		this._ahgrF=dhx4.s2b(countFullHeight);
		this._ahgrM=maxHeight||null;
		if (arguments.length == 1){
			this.objBox.style.overflowY=mode?"hidden":"auto";
		}
		if (maxHeight == "auto"){
			this._ahgrM=null;
			this._ahgrMA=true;
			this._setAutoResize();
			//   this._activeResize();
		}
	},
	//#sorting:06042008{	
	enableStableSorting:function(mode){
		this._sst=dhx4.s2b(mode);
		this.rowsCol.stablesort=function(cmp){
			var size = this.length-1;
			
			for (var i = 0; i < this.length-1; i++){
				for (var j = 0; j < size; j++)
				if (cmp(this[j], this[j+1]) > 0){
					var temp = this[j];
					this[j]=this[j+1];
					this[j+1]=temp;
				}
				size--;
			}
		}
	},
	//#}
	
	/**
	*     @desc: enable/disable hot keys in grid
	*     @param: mode - true/false
	*     @type: public
	*     @topic: 0
	*/
	enableKeyboardSupport:function(mode){
		this._htkebl=!dhx4.s2b(mode);
	},
	
	//#context_menu:06042008{	
	/**
	*     @desc: enable/disable context menu
	*     @param: dhtmlxMenu object, if null - context menu will be disabled
	*     @type: public
	*     @topic: 0
	*/
	enableContextMenu:function(menu){
		this._ctmndx=menu;
	},
	//#}	
	
	/*backward compatibility*/
	setScrollbarWidthCorrection:function(width){
	},
	//#tooltips:06042008{	
	/**
	*     @desc: enable/disable tooltips for specified colums
	*     @param: list - list of true/false values, tooltips enabled for all columns by default
	*     @type: public
	*     @topic: 0
	*/
	enableTooltips:function(list){
		this._enbTts=list.split(",");
		
		for (var i = 0; i < this._enbTts.length; i++)this._enbTts[i]=dhx4.s2b(this._enbTts[i]);
	},
	//#}	
	
	//#column_resize:06042008{
	/**
	*     @desc: enable/disable resizing for specified colums
	*     @param: list - list of true/false values, resizing enabled for all columns by default
	*     @type: public
	*     @topic: 0
	*/
	enableResizing:function(list){
		this._drsclmn=list.split(",");
		
		for (var i = 0; i < this._drsclmn.length; i++)this._drsclmn[i]=dhx4.s2b(this._drsclmn[i]);
	},
	
	/**
	*     @desc: set minimum column width ( works only for manual resizing )
	*     @param: width - minimum column width, can be set for specified column, or as comma separated list for all columns
	*     @param: ind - column index
	*     @type: public
	*     @topic: 0
	*/
	setColumnMinWidth:function(width, ind){
		if (arguments.length == 2){
			if (!this._drsclmW)
				this._drsclmW=new Array();
			this._drsclmW[ind]=width;
		} else
		this._drsclmW=width.split(",");
	},
	//#}	
	
	/**
	*     @desc: enable/disable unique id for cells (id will be automaticaly created using the following template: "c_[RowId]_[colIndex]")
	*     @param: mode - true/false - enable/disable
	*     @type: public
	*     @topic: 0
	*/
	enableCellIds:function(mode){
		this._enbCid=dhx4.s2b(mode);
	},
	
	
	//#locked_row:11052006{
	/**
	*     @desc: lock/unlock row for editing
	*     @param: rowId - id of row
	*     @param: mode - true/false - lock/unlock
	*     @type: public
	*     @topic: 0
	*/
	lockRow:function(rowId, mode){
		var z = this.getRowById(rowId);
		
		if (z){
			z._locked=dhx4.s2b(mode);
			
			if ((this.cell)&&(this.cell.parentNode.idd == rowId))
				this.editStop();
		}
	},
	//#}
	
	/**
	*   @desc:  get values of all cells in row
	*   @type:  private
	*/
	_getRowArray:function(row){
		var text = new Array();
		
		for (var ii = 0; ii < row.childNodes.length; ii++){
			var a = this.cells3(row, ii);
			text[ii]=a.getValue();
		}
		
		return text;
	},
	//#__pro_feature:21092006{	
	//#data_format:12052006{
	/**
	*     @desc: set mask for date formatting in cell
	*     @param: mask - date mask, d,m,y will mean day,month,year; for example "d/m/y" - 22/05/1985
	*     @type: public
	*     @edition: Professional
	*     @topic: 0
	*/
	setDateFormat:function(mask,incoming){
		this._dtmask=mask;
		this._dtmask_inc=incoming;
	},
	
	/**
	*     @desc: set mask for formatting numeric data ( works for [ed/ro]n excell only or oher cell types with suport for this method)
	*     @param: mask - numeric mask; for example 0,000.00 - 1,234.56
	*     @param: cInd - column index
	*     @param: p_sep - char used as decimalseparator ( point by default )
	*     @param: d_sep - char used as groups part separator ( comma by default )
	*     @type: public
	*     @edition: Professional
	*     @topic: 0
	*/
	setNumberFormat:function(mask, cInd, p_sep, d_sep){
		var nmask = mask.replace(/[^0\,\.]*/g, "");
		var pfix = nmask.indexOf(".");
		
		if (pfix > -1)
			pfix=nmask.length-pfix-1;
		var dfix = nmask.indexOf(",");
		
		if (dfix > -1)
			dfix=nmask.length-pfix-2-dfix;
		if (typeof p_sep != "string")
			p_sep=this.i18n.decimal_separator;
		if (typeof d_sep != "string")
			d_sep=this.i18n.group_separator;
		var pref = mask.split(nmask)[0];
		var postf = mask.split(nmask)[1];
		this._maskArr[cInd]=[
			pfix,
			dfix,
			pref,
			postf,
			p_sep,
			d_sep
		];
	},
	/**
	*   @desc:  convert formated value to original
	*   @type:  private
	*/
	_aplNFb:function(data, ind){
		var a = this._maskArr[ind];
		
		if (!a)
			return data;
		
		var ndata = parseFloat(data.toString().replace(/[^0-9]*/g, ""));
		
		if (data.toString().substr(0, 1) == "-")
			ndata=ndata*-1;
		
		if (a[0] > 0)
			ndata=ndata / Math.pow(10, a[0]);
		return ndata;
	},
	
	/**
	*   @desc:  format data with mask
	*   @type:  private
	*/
	_aplNF:function(data, ind){
		var a = this._maskArr[ind];
		
		if (!a)
			return data;
		
		var c = (parseFloat(data) < 0 ? "-" : "")+a[2];
		data=Math.abs(Math.round(parseFloat(data)*Math.pow(10, a[0] > 0 ? a[0] : 0))).toString();
		data=(data.length
			< a[0]
			? Math.pow(10, a[0]+1-data.length).toString().substr(1, a[0]+1)+data.toString()
			: data).split("").reverse();
			data[a[0]]=(data[a[0]]||"0")+a[4];
			
			if (a[1] > 0)
				for (var j = (a[0] > 0 ? 0 : 1)+a[0]+a[1]; j < data.length; j+=a[1])data[j]+=a[5];
			return c+data.reverse().join("")+a[3];
	},
	//#}
	//#}	
	
	//#config_from_xml:20092006{
	
	/**
	*   @desc:  configure grid structure from XML
	*   @type:  private
	*/
	_launchCommands:function(arr){
		for (var i = 0; i < arr.length; i++){
			var args = new Array();
			
			for (var j = 0; j < arr[i].childNodes.length; j++)
				if (arr[i].childNodes[j].nodeType == 1)
				args[args.length]=arr[i].childNodes[j].firstChild.data;
			
			this[arr[i].getAttribute("command")].apply(this, args);
		}
	},
	
	
	/**
	*   @desc:  configure grid structure from XML
	*   @type:  private
	*/
	_parseHead:function(xmlDoc){
		var hheadCol = dhx4.ajax.xpath("./head", xmlDoc);
		
		if (hheadCol.length){
			var headCol = dhx4.ajax.xpath("./column", hheadCol[0]);
			var asettings = dhx4.ajax.xpath("./settings", hheadCol[0]);
			var awidthmet = "setInitWidths";
			var split = false;
			
			if (asettings[0]){
				for (var s = 0; s < asettings[0].childNodes.length; s++)switch (asettings[0].childNodes[s].tagName){
				case "colwidth":
					if (asettings[0].childNodes[s].firstChild&&asettings[0].childNodes[s].firstChild.data == "%")
						awidthmet="setInitWidthsP";
					break;
					
				case "splitat":
					split=(asettings[0].childNodes[s].firstChild ? asettings[0].childNodes[s].firstChild.data : false);
					break;
				}
			}
			this._launchCommands(dhx4.ajax.xpath("./beforeInit/call", hheadCol[0]));
			
			if (headCol.length > 0){
				if (this.hdr.rows.length > 0) this.clearAll(true); //drop existing grid here, to prevent loss of initialization parameters
				var sets = [
					[],
					[],
					[],
					[],
					[],
					[],
					[],
					[],
					[]
				];
				
				var attrs = ["", "width", "type", "align", "sort", "color", "format", "hidden", "id"];
				var calls = ["", awidthmet, "setColTypes", "setColAlign", "setColSorting", "setColumnColor", "",
				"", "setColumnIds"];
				
				for (var i = 0; i < headCol.length; i++){
					for (var j = 1; j < attrs.length; j++)sets[j].push(headCol[i].getAttribute(attrs[j]));
					sets[0].push((headCol[i].firstChild
						? headCol[i].firstChild.data
						: "").replace(/^\s*((\s\S)*.+)\s*$/gi, "$1"));
				};
				
				this.setHeader(sets[0]);
				for (var i = 0; i < calls.length; i++)
					if (calls[i])
					this[calls[i]](sets[i].join(this.delim))
				
				for (var i = 0; i < headCol.length; i++){
					if ((this.cellType[i].indexOf('co') == 0)||(this.cellType[i] == "clist")){
						var optCol = dhx4.ajax.xpath("./option", headCol[i]);
						
						if (optCol.length){
							var resAr = new Array();
							
							if (this.cellType[i] == "clist"){
								for (var j = 0;
									j < optCol.length;
									j++)resAr[resAr.length]=optCol[j].firstChild
								? optCol[j].firstChild.data
								: "";
								
								this.registerCList(i, resAr);
							} else {
								var combo = this.getCombo(i);
								
								for (var j = 0;
									j < optCol.length;
									j++)combo.put(optCol[j].getAttribute("value"),
										optCol[j].firstChild
										? optCol[j].firstChild.data
										: "");
							}
						}
					}
					
					else if (sets[6][i])
						if ((this.cellType[i].toLowerCase().indexOf("calendar")!=-1)||(this.fldSort[i] == "date"))
						this.setDateFormat(sets[6][i]);
					else
						this.setNumberFormat(sets[6][i], i);
				}
				
				this.init();
				
				var param=sets[7].join(this.delim);
				//preserving state of hidden columns, if not specified directly
				if (this.setColHidden && param.replace(/,/g,"")!="")
					this.setColHidden(param);
				
				if ((split)&&(this.splitAt))
					this.splitAt(split);
			}
			this._launchCommands(dhx4.ajax.xpath("./afterInit/call", hheadCol[0]));
		}
		//global(grid) user data
		var gudCol = dhx4.ajax.xpath("//rows/userdata", xmlDoc);
		
		if (gudCol.length > 0){
			
			if (!this.UserData["gridglobaluserdata"])
				this.UserData["gridglobaluserdata"]=new Hashtable();
			
			for (var j = 0; j < gudCol.length; j++){
				var u_record = "";
				for (var xj=0; xj < gudCol[j].childNodes.length; xj++)
					u_record += gudCol[j].childNodes[xj].nodeValue;
				this.UserData["gridglobaluserdata"].put(gudCol[j].getAttribute("name"),u_record);
			}
		}
	},
	
	
	//#}
	
	
	/**
	*   @desc: get list of Ids of all rows with checked exCell in specified column
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/
	getCheckedRows:function(col_ind){
		var d = new Array();
		this.forEachRowA(function(id){
				var cell = this.cells(id, col_ind);
				if (cell.changeState && cell.getValue() != 0)
					d.push(id);
		},true);
		return d.join(",");
	},
	/**
	*   @desc: check all checkboxes in grid
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/	
	checkAll:function(){var mode=arguments.length?arguments[0]:1;
	for (var cInd=0;cInd<this.getColumnsNum();cInd++){if(this.getColType(cInd)=="ch")this.setCheckedRows(cInd,mode)}},
		/**
	*   @desc: uncheck all checkboxes in grid
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/	
	uncheckAll:function(){ this.checkAll(0); },
	/**
	*   @desc: set value for all checkboxes in specified column
	*   @type: public
	*   @param: col_ind - column index
	*   @topic: 5
	*/	
	setCheckedRows:function(cInd,v){this.forEachRowA(function(id){if(this.cells(id,cInd).isCheckbox())this.cells(id,cInd).setValue(v)})},
	//#tooltips:06042008{	
	/**
	*   @desc:  grid body onmouseover function
	*   @type:  private
	*/
	_drawTooltip:function(e){
		var c = this.grid.getFirstParentOfType(e ? e.target : event.srcElement, 'TD');
		
		if (!c || ((this.grid.editor)&&(this.grid.editor.cell == c)))
			return true;
		
		var r = c.parentNode;
		
		if (!r.idd||r.idd == "__filler__")
			return;
		var el = (e ? e.target : event.srcElement);
		
		if (r.idd == window.unknown)
			return true;
		
		if (!this.grid.callEvent("onMouseOver", [
				r.idd,
			c._cellIndex,
			(e||window.event)
		]))
		return true;
		
		if ((this.grid._enbTts)&&(!this.grid._enbTts[c._cellIndex])){
			if (el.title)
				el.title='';
			return true;
		}
		
		if (c._cellIndex >= this.grid._cCount)
			return;
		var ced = this.grid.cells3(r, c._cellIndex);
		if (!ced || !ced.cell || !ced.cell._attrs) return; // fix for public release
		
		if (el._title)
			ced.cell.title="";
		
		if (!ced.cell._attrs['title'])
			el._title=true;
		
		if (ced)
			el.title=ced.cell._attrs['title']
		||(ced.getTitle
			? ced.getTitle()
			: (ced.getValue()||"").toString().replace(/<[^>]*>/gi, ""));
		
		return true;
	},
	//#}	
	/**
	*   @desc:  can be used for setting correction for cell padding, while calculation setSizes
	*   @type:  private
	*/
	enableCellWidthCorrection:function(size){
		if (_isFF)
			this._wcorr=parseInt(size);
	},
	
	
	/**
	*	@desc: gets a list of all row ids in grid
	*	@param: separator - delimiter to use in list
	*	@returns: list of all row ids in grid
	*	@type: public
	*	@topic: 2,7
	*/
	getAllRowIds:function(separator){
		var ar = [];
		
		for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i])
			ar.push(this.rowsBuffer[i].idd);
		
		return ar.join(separator||this.delim)
	},
	getAllItemIds:function(){
		return this.getAllRowIds();
	},
	
	//#__pro_feature:21092006{	
	//#colspan:20092006{
	
	/**
	*   @desc: dynamicaly set colspan in row starting from specified column index
	*   @param: row_id - row id
	*   @param: col_id - index of column
	*   @param: colspan - size of colspan
	*   @type: public
	*   @edition: Professional
	*   @topic: 2,9
	*/
	setColspan:function(row_id, col_ind, colspan){
		if (!this._ecspn)
			return;
		
		var r = this.getRowById(row_id);
		
		if ((r._childIndexes)&&(r.childNodes[r._childIndexes[col_ind]])){
			var j = r._childIndexes[col_ind];
			var n = r.childNodes[j];
			var m = n.colSpan;
			n.colSpan=1;
			
			if ((m)&&(m != 1))
			for (var i = 1; i < m; i++){
				var c = document.createElement("TD");
				
				if (n.nextSibling)
					r.insertBefore(c, n.nextSibling);
				else
					r.appendChild(c);
				r._childIndexes[col_ind+i]=j+i;
				c._cellIndex=col_ind+i;
				c.style.textAlign=this.cellAlign[i];
				c.style.verticalAlign=this.cellVAlign[i];
				n=c;
				this.cells3(r, col_ind+i).setValue("");
			}
			
			for (var z = col_ind*1+1*m; z < r._childIndexes.length; z++){
				r._childIndexes[z]+=(m-1)*1;
			}
		}
		
		if ((colspan)&&(colspan > 1)){
			if (r._childIndexes)
				var j = r._childIndexes[col_ind];
			else {
				var j = col_ind;
				r._childIndexes=new Array();
				
				for (var z = 0; z < r.childNodes.length; z++)r._childIndexes[z]=z;
			}
			
			r.childNodes[j].colSpan=colspan;
			
			for (var z = 1; z < colspan; z++){
				r._childIndexes[r.childNodes[j+1]._cellIndex]=j;
				r.removeChild(r.childNodes[j+1]);
			}
			
			var c1 = r.childNodes[r._childIndexes[col_ind]]._cellIndex;
			
			for (var z = c1*1+1*colspan; z < r._childIndexes.length; z++)r._childIndexes[z]-=(colspan-1);
		}
	},
	
	//#}
	//#}
	
	/**
	*   @desc: prevent caching in IE  by adding random values to URL string
	*   @param: mode - enable/disable random values in URLs ( disabled by default )
	*   @type: public
	*   @topic: 2,9
	*/
	preventIECaching:function(mode){
		dhx4.ajax.cache = !mode;
	},
	enableColumnAutoSize:function(mode){
		this._eCAS=dhx4.s2b(mode);
	},
	/**
	*   @desc: called when header was dbllicked
	*   @type: private
	*   @topic: 1,2
	*/
	_onHeaderDblClick:function(e){
		var that = this.grid;
		var el = that.getFirstParentOfType(_isIE ? event.srcElement : e.target, "TD");
		
		if (!that._eCAS)
			return false;
		that.adjustColumnSize(el._cellIndexS)
	},
	
	/**
	*   @desc: autosize column  to max content size
	*   @param: cInd - index of column
	*   @type:  public
	*/
	adjustColumnSize:function(cInd, complex){
		if (this._hrrar && this._hrrar[cInd]) return;
		this._notresize=true;
		var m = 0;
		this._setColumnSizeR(cInd, 20);
		
		for (var j = 1; j < this.hdr.rows.length; j++){
			var a = this.hdr.rows[j];
			a=a.childNodes[(a._childIndexes) ? a._childIndexes[cInd] : cInd];
			
			if ((a)&&((!a.colSpan)||(a.colSpan < 2)) && a._cellIndex==cInd){
				if ((a.childNodes[0])&&(a.childNodes[0].className == "hdrcell"))
					a=a.childNodes[0];
				m=Math.max(m, a.scrollWidth);
			}
		}
		
		var l = this.obj.rows.length;
		var z = 0;
		var tree = this.cellType._dhx_find("tree");
		
		for (var i = 1; i < l; i++){
			var row = this.obj.rows[i];
			var col = cInd;
			if (!this.rowsAr[row.idd]) continue;
			
			if (row._childIndexes){
				if (row._childIndexes[cInd] == row._childIndexes[cInd+1] )
					continue;
				col = row._childIndexes[cInd];
			}

			if (!row.childNodes[col] || row.childNodes[col]._cellIndex != cInd)
				continue;

			z= ( row.childNodes[col].innerText || row.childNodes[col].textContent || "" ).length*this.fontWidth;
			if (this._h2 && cInd == tree)
				z += this._h2.get[row.idd].level * 22;
			
			
			
			if (z > m)
				m=z;
		}
		m+=20+(complex||0);
		
		this._setColumnSizeR(cInd, m);
		this._notresize=false;
		this.setSizes();
	},
	
	//#header_footer:06042008{
	/**
	*   @desc: remove header line from grid (opposite to attachHeader)
	*   @param: index - index of row to be removed ( zero based )
	*	@param: hdr - header object (optional)
	*   @type:  public
	*/
	detachHeader:function(index, hdr){
		hdr=hdr||this.hdr;
		var row = hdr.rows[index+1];
		
		if (row)
			row.parentNode.removeChild(row);
		this.setSizes();
	},
	
	/**
	*   @desc: remove footer line from grid (opposite to attachFooter)
	*   @param: values - array of header titles
	*   @type:  public
	*/
	detachFooter:function(index){
		this.detachHeader(index, this.ftr);
	},
	
	/**
	*   @desc: attach additional line to header
	*   @param: values - array of header titles
	*   @param: style - array of styles, optional
	*	@param: _type - reserved
	*   @type:  public
	*/
	attachHeader:function(values, style, _type){
		if (typeof (values) == "string")
			values=this._eSplit(values);
		
		if (typeof (style) == "string")
			style=style.split(this.delim);
		_type=_type||"_aHead";
		
		if (this.hdr.rows.length){
			if (values)
			this._createHRow([
					values,
					style
				], this[(_type == "_aHead") ? "hdr" : "ftr"]);
			
			else if (this[_type])
				for (var i = 0; i < this[_type].length; i++)this.attachHeader.apply(this, this[_type][i]);
		} else {
			if (!this[_type])
				this[_type]=new Array();
			this[_type][this[_type].length]=[
				values,
				style,
				_type
			];
		}
	},
	/**
	*	@desc:
	*	@type: private
	*/
	_createHRow:function(data, parent){
		if (!parent){
			if (this.entBox.style.position!="absolute")
				this.entBox.style.position="relative";
			var z = document.createElement("DIV");
			z.className="c_ftr".substr(2);
			this.entBox.appendChild(z);
			var t = document.createElement("TABLE");
			t.cellPadding=t.cellSpacing=0;
			
			if (!_isIE || _isIE == 8){
				t.width="100%";
				t.style.paddingRight="20px";
			}
			t.style.marginRight="20px";
			t.style.tableLayout="fixed";
			
			z.appendChild(t);
			t.appendChild(document.createElement("TBODY"));
			this.ftr=parent=t;
			
			var hdrRow = t.insertRow(0);
			var thl = ((this.hdrLabels.length <= 1) ? data[0].length : this.hdrLabels.length);
			
			for (var i = 0; i < thl; i++){
				hdrRow.appendChild(document.createElement("TH"));
				hdrRow.childNodes[i]._cellIndex=i;
			}
			
			if (_isIE && _isIE<8)
				hdrRow.style.position="absolute";
			else
				hdrRow.style.height='auto';
		}
		var st1 = data[1];
		var z = document.createElement("TR");
		parent.rows[0].parentNode.appendChild(z);
		
		for (var i = 0; i < data[0].length; i++){
			if (data[0][i] == "#cspan"){
				var pz = z.cells[z.cells.length-1];
				pz.colSpan=(pz.colSpan||1)+1;
				continue;
			}
			
			if ((data[0][i] == "#rspan")&&(parent.rows.length > 1)){
				var pind = parent.rows.length-2;
				var found = false;
				var pz = null;
				
				while (!found){
					var pz = parent.rows[pind];
					
					for (var j = 0; j < pz.cells.length; j++)
					if (pz.cells[j]._cellIndex == i){
						found=j+1;
						break;
					}
					pind--;
				}
				
				pz=pz.cells[found-1];
				pz.rowSpan=(pz.rowSpan||1)+1;
				continue;
				//            data[0][i]="";
			}
			
			var w = document.createElement("TD");
			w._cellIndex=w._cellIndexS=i;
			if (this._hrrar && this._hrrar[i] && !_isIE)
				w.style.display='none';
			
			if (typeof data[0][i] == "object")
				w.appendChild(data[0][i]);
			else {
				if (this.forceDivInHeader)
					w.innerHTML="<div class='hdrcell'>"+(data[0][i]||"&nbsp;")+"</div>";
				else
					w.innerHTML=(data[0][i]||"&nbsp;");
				
				if ((data[0][i]||"").indexOf("#") != -1){
					var t = data[0][i].match(/(^|{)#([^}]+)(}|$)/);
					
					if (t){
						var tn = "_in_header_"+t[2];
						
						if (this[tn])
							this[tn]((this.forceDivInHeader ? w.firstChild : w), i, data[0][i].split(t[0]));
					}
				}
			}
			if (st1)
				w.style.cssText=st1[i];
			
			z.appendChild(w);
		}
		var self = parent;
		
		if (_isKHTML){
			if (parent._kTimer)
				window.clearTimeout(parent._kTimer);
			parent._kTimer=window.setTimeout(function(){
					parent.rows[1].style.display='none';
					window.setTimeout(function(){
							parent.rows[1].style.display='';
					}, 1);
			}, 500);
		}
	},
	//#__pro_feature:21092006{	
	/**
	*   @desc: attach additional line to footer
	*   @param: values - array of header titles
	*   @param: style - array of styles, optional
	*   @edition: Professional
	*   @type:  public
	*/
	attachFooter:function(values, style){
		this.attachHeader(values, style, "_aFoot");
	},
	//#}
	//#}
	//#__pro_feature:21092006{
	//#dyn_cell_types:04062008{
	/**
	*   @desc: set excell type for cell in question
	*   @param: rowId - row ID
	*   @param: cellIndex - cell index
	*   @param: type - type of excell (code like "ed", "txt", "ch" etc.)
	*   @edition: Professional
	*   @type:  public
	*/
	setCellExcellType:function(rowId, cellIndex, type){
		this.changeCellType(this.getRowById(rowId), cellIndex, type);
	},
	getCellExcellType:function(rowId, cellIndex) {
	    var row = this.getRowById(rowId);
	    var z = this.cells3(row, cellIndex);
	    return z.cell._cellType || this.cellType[cellIndex];
	},
	/**
	*	@desc: 
	*	@type: private
	*/
	changeCellType:function(r, ind, type){
		type=type||this.cellType[ind];
		var z = this.cells3(r, ind);
		var v = z.getValue();
		z.cell._cellType=type;
		var z = this.cells3(r, ind);
		z.setValue(v);
	},
	/**
	*   @desc: set excell type for all cells in specified row
	*   @param: rowId - row ID
	*   @param: type - type of excell
	*   @edition: Professional
	*   @type:  public
	*/
	setRowExcellType:function(rowId, type){
		var z = this.rowsAr[rowId];
		
		for (var i = 0; i < z.childNodes.length; i++)this.changeCellType(z, i, type);
	},
	/**
	*   @desc: set excell type for all cells in specified column
	*   @param: colIndex - column index
	*   @param: type - type of excell
	*   @edition: Professional
	*   @type:  public
	*/
	setColumnExcellType:function(colIndex, type){
		for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i] && this.rowsBuffer[i].tagName=="TR")
			this.changeCellType(this.rowsBuffer[i], colIndex, type);
		if (this.cellType[colIndex]=="math")
			this._strangeParams[i]=type;
		else
			this.cellType[colIndex]=type;
	},
	
	//#}
	//#}
	
	/**
	*   @desc: execute code for each row in a grid
	*   @param: custom_code - function which get row id as incomming argument
	*   @type:  public
	*/
	forEachRow:function(custom_code){
		for (var a in this.rowsAr)
			if (this.rowsAr[a]&&this.rowsAr[a].idd)
			custom_code.apply(this, [this.rowsAr[a].idd]);
	},
	forEachRowA:function(custom_code){
		for (var a =0; a<this.rowsBuffer.length; a++){
			if (this.rowsBuffer[a])
				custom_code.call(this, this.render_row(a).idd);
		}
	},
	/**
	*   @desc: execute code for each cell in a row
	*   @param: rowId - id of row where cell must be itterated
	*   @param: custom_code - function which get eXcell object as incomming argument
	*   @type:  public
	*/
	forEachCell:function(rowId, custom_code){
		var z = this.getRowById(rowId);
		
		if (!z)
			return;
		
		for (var i = 0; i < this._cCount; i++) custom_code(this.cells3(z, i),i);
	},
	/**
	*   @desc: changes grid's container size on the fly to fit total width of grid columns
	*   @param: mode  - truse/false - enable / disable
	*   @param: max_limit  - max allowed width, not limited by default
	*   @param: min_limit  - min allowed width, not limited by default
	*   @type:  public
	*/
	enableAutoWidth:function(mode, max_limit, min_limit){
		this._awdth=[
			dhx4.s2b(mode),
			parseInt(max_limit||99999),
			parseInt(min_limit||0)
		];
		if (arguments.length == 1)
			this.objBox.style.overflowX=mode?"hidden":"auto";
	},
	//#update_from_xml:06042008{	
	/**
	*   @desc: refresh grid from XML ( doesnt work for buffering, tree grid or rows in smart rendering mode )
	*   @param: insert_new - insert new items
	*   @param: del_missed - delete missed rows
	*   @param: afterCall - function, will be executed after refresh completted
	*   @type:  public
	*/
	
	updateFromXML:function(url, insert_new, del_missed, afterCall){
		if (typeof insert_new == "undefined")
			insert_new=true;
		this._refresh_mode=[
			true,
			insert_new,
			del_missed
		];
		this.load(url,afterCall)
	},
	_refreshFromXML:function(xml){
		if (this._f_rowsBuffer) this.filterBy(0,"");
		reset = false;
		if (window.eXcell_tree){
			eXcell_tree.prototype.setValueX=eXcell_tree.prototype.setValue;
			eXcell_tree.prototype.setValue=function(content){
				var r=this.grid._h2.get[this.cell.parentNode.idd]
				if (r && this.cell.parentNode.valTag){
					this.setLabel(content);
				} else
				this.setValueX(content);
			};
		}
		
		var tree = this.cellType._dhx_find("tree");
		var top = dhx4.ajax.xmltop("rows", xml);
		var pid = top.getAttribute("parent")||0;
		
		var del = {
		};
		
		if (this._refresh_mode[2]){
			if (tree != -1)
			this._h2.forEachChild(pid, function(obj){
					del[obj.id]=true;
			}, this);
			else
			this.forEachRow(function(id){
					del[id]=true;
			});
		}
		
		var rows = dhx4.ajax.xpath("//row", top);
		
		for (var i = 0; i < rows.length; i++){
			var row = rows[i];
			var id = row.getAttribute("id");
			del[id]=false;
			var pid = row.parentNode.getAttribute("id")||pid;
			if (this.rowsAr[id] && this.rowsAr[id].tagName!="TR"){
				if (this._h2)
					this._h2.get[id].buff.data=row;
				else
					this.rowsBuffer[this.getRowIndex(id)].data=row;
				this.rowsAr[id]=row;
			} else if (this.rowsAr[id]){
				this._process_xml_row(this.rowsAr[id], row, -1);
				this._postRowProcessing(this.rowsAr[id],true)
				if (this._fake && this._fake.rowsAr[id])
					this._fake._process_xml_row(this._fake.rowsAr[id], row, -1);
			} else if (this._refresh_mode[1]){
				var dadd={
					idd: id,
					data: row,
					_parser: this._process_xml_row,
					_locator: this._get_xml_data
				};
				
				var render_index = this.rowsBuffer.length;
				if (this._refresh_mode[1]=="top"){
					this.rowsBuffer.unshift(dadd);
					render_index = 0;
				} else
				this.rowsBuffer.push(dadd);
				
				if (this._h2){ 
					reset=true;
					(this._h2.add(id,(row.parentNode.getAttribute("id")||row.parentNode.getAttribute("parent")))).buff=this.rowsBuffer[this.rowsBuffer.length-1];
				} else if (this._srnd)
				reset = true;
				
				this.rowsAr[id]=row;
				row=this.render_row(render_index);
				this._insertRowAt(row,render_index?-1:0)
			}
		}
		
		if (this._refresh_mode[2])
		for (id in del){
			if (del[id]&&this.rowsAr[id])
				this.deleteRow(id);
		}
		
		this._refresh_mode=null;
		if (window.eXcell_tree)
			eXcell_tree.prototype.setValue=eXcell_tree.prototype.setValueX;
		
		if (reset){
			if (this._h2) 
				this._renderSort();
			else
				this.render_dataset();
		}
		
		if (this._f_rowsBuffer) {
			this._f_rowsBuffer = null;
			this.filterByAll();
		}
	},
	//#}	
	//#co_excell:06042008{
	/**
	*   @desc: get combobox specific for cell in question
	*   @param: id - row id
	*   @param: ind  - column index
	*   @type:  public
	*/
	getCustomCombo:function(id, ind){
		var cell = this.cells(id, ind).cell;
		
		if (!cell._combo)
			cell._combo=new dhtmlXGridComboObject();
		return cell._combo;
	},
	//#}
	/**
	*   @desc: set tab order of columns
	*   @param: order - list of tab indexes (default delimiter is ",")
	*   @type:  public
	*/
	setTabOrder:function(order){
		var t = order.split(this.delim);
		this._tabOrder=[];
		var max=this._cCount||order.length;
		
		for (var i = 0; i < max; i++)t[i]={
			c: parseInt(t[i]),
			ind: i
		};
		t.sort(function(a, b){
				return (a.c > b.c ? 1 : -1);
		});
		
		for (var i = 0; i < max; i++)
			if (!t[i+1]||( typeof t[i].c == "undefined"))
			this._tabOrder[t[i].ind]=(t[0].ind+1)*-1;
		else
			this._tabOrder[t[i].ind]=t[i+1].ind;
	},
	
	i18n:{
		loading: "Loading",
		decimal_separator:".",
		group_separator:","
	},
	
	//key_ctrl_shift
	_key_events:{
		k13_1_0: function(){
			var rowInd = this.rowsCol._dhx_find(this.row)
			this.selectCell(this.rowsCol[rowInd+1], this.cell._cellIndex, true);
		},
		k13_0_1: function(){
			var rowInd = this.rowsCol._dhx_find(this.row)
			this.selectCell(this.rowsCol[rowInd-1], this.cell._cellIndex, true);
		},
		k13_0_0: function(){
			this.editStop();
			this.callEvent("onEnter", [
					(this.row ? this.row.idd : null),
					(this.cell ? this.cell._cellIndex : null)
			]);
			this._still_active=true;
		},
		k9_0_0: function(){
			this.editStop();
			if (!this.callEvent("onTab",[true])) return true;
			var z = this._getNextCell(null, 1);
			
			if (z){
				this.selectCell(z.parentNode, z._cellIndex, (this.row != z.parentNode), false, true);
				this._still_active=true;
			}
		},
		k9_0_1: function(){
			this.editStop();
			if (!this.callEvent("onTab",[false])) return false;
			var z = this._getNextCell(null, -1);
			
			if (z){
				this.selectCell(z.parentNode, z._cellIndex, (this.row != z.parentNode), false, true);
				this._still_active=true;
			}
		},
		k113_0_0: function(){
			if (this._f2kE)
				this.editCell();
		},
		k32_0_0: function(){
			var c = this.cells4(this.cell);
			
			if (!c.changeState||(c.changeState() === false))
				return false;
		},
		k27_0_0: function(){
			this.editStop(true);
		},
		k33_0_0: function(){
			if (this.pagingOn)
				this.changePage(this.currentPage-1);
			else
				this.scrollPage(-1);
		},
		k34_0_0: function(){
			if (this.pagingOn)
				this.changePage(this.currentPage+1);
			else
				this.scrollPage(1);
		},
		k37_0_0: function(){
			if (!this.editor&&this.isTreeGrid())
				this.collapseKids(this.row)
			else
				return false;
		},
		k39_0_0: function(){
			if (!this.editor&&this.isTreeGrid())
				this.expandKids(this.row)
			else
				return false;
		},
		k40_0_0: function(){
			var master = this._realfake?this._fake:this;
			if (this.editor&&this.editor.combo)
				this.editor.shiftNext();
			else {
				if (!this.row.idd) return;
				var rowInd = Math.max((master._r_select||0),this.getRowIndex(this.row.idd));
				var row = this._nextRow(rowInd, 1);
				if (row){
					master._r_select=null;
					this.selectCell(row, this.cell._cellIndex, true);
					if (master.pagingOn) master.showRow(row.idd);
				} else {
					if (!this.callEvent("onLastRow", [])) return false;
					this._key_events.k34_0_0.apply(this, []);
					if (this.pagingOn && this.rowsCol[rowInd+1])
						this.selectCell(rowInd+1, 0, true);
				}
			}
			this._still_active=true;
		},
		k38_0_0: function(){
			var master = this._realfake?this._fake:this;
			if (this.editor&&this.editor.combo)
				this.editor.shiftPrev();
			else {
				if (!this.row.idd) return;
				var rowInd = this.getRowIndex(this.row.idd)+1;
				if (rowInd != -1 && (!this.pagingOn || (rowInd!=1))){
					var nrow = this._nextRow(rowInd-1, -1);
					this.selectCell(nrow, this.cell._cellIndex, true);
					if (master.pagingOn && nrow) master.showRow(nrow.idd);
				} else {
					this._key_events.k33_0_0.apply(this, []);
					/*
					if (this.pagingOn && this.rowsCol[this.rowsBufferOutSize-1])
					this.selectCell(this.rowsBufferOutSize-1, 0, true);
					*/
				}
			}
			this._still_active=true;
		}
	},
	
	//(c)dhtmlx ltd. www.dhtmlx.com
	
	_build_master_row:function(){
		var t = document.createElement("DIV");
		var html = ["<table><tr>"];
		
		for (var i = 0; i < this._cCount; i++)html.push("<td></td>");
		html.push("</tr></table>");
		t.innerHTML=html.join("");
		this._master_row=t.firstChild.rows[0];
	},
	
	_prepareRow:function(new_id){ /*TODO: hidden columns */
		if (!this._master_row)
			this._build_master_row();
		
		var r = this._master_row.cloneNode(true);
		
		for (var i = 0; i < r.childNodes.length; i++){
			r.childNodes[i]._cellIndex=i;
			if (this._enbCid) r.childNodes[i].id="c_"+new_id+"_"+i;
			if (this.dragAndDropOff)
				this.dragger.addDraggableItem(r.childNodes[i], this);
		}
		r.idd=new_id;
		r.grid=this;
		
		return r;
	},
	
	//#non_xml_data:06042008{
	_process_jsarray_row:function(r, data){
		r._attrs={
		};
		
		for (var j = 0; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
		};
		
		this._fillRow(r, (this._c_order ? this._swapColumns(data) : data));
		return r;
	},
	_get_jsarray_data:function(data, ind){
		return data[ind];
	},
	_process_json_row:function(r, data){
		data = this._c_order ? this._swapColumns(data.data) : data.data;
		return this._process_some_row(r, data);
	},
	_process_some_row:function(r,data){
		r._attrs={};
		
		for (var j = 0; j < r.childNodes.length; j++)
			r.childNodes[j]._attrs={};
		
		this._fillRow(r, data);
		return r;
	},
	_get_json_data:function(data, ind){
		return data.data[ind];
	},
	
	
	_process_js_row:function(r, data){
		var arr = [];
		for (var i=0; i<this.columnIds.length; i++){
			arr[i] = data[this.columnIds[i]];
			if (!arr[i] && arr[i]!==0)
				arr[i]="";
		}
		this._process_some_row(r,arr);
		
		r._attrs = data;
		return r;
	},
	_get_js_data:function(data, ind){
		return data[this.columnIds[ind]];
	},
	_process_csv_row:function(r, data){
		r._attrs={
		};
		
		for (var j = 0; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
		};
		
		this._fillRow(r, (this._c_order ? this._swapColumns(data.split(this.csv.cell)) : data.split(this.csv.cell)));
		return r;
	},
	_get_csv_data:function(data, ind){
		return data.split(this.csv.cell)[ind];
	},
	//#}
	_process_store_row:function(row, data){
		var result = [];
		for (var i = 0; i < this.columnIds.length; i++)
			result[i] = data[this.columnIds[i]];
		for (var j = 0; j < row.childNodes.length; j++)
			row.childNodes[j]._attrs={};
		
		row._attrs = data;
		this._fillRow(row, result);
	},	
	//#xml_data:06042008{
	_process_xml_row:function(r, xml){		
		var cellsCol = dhx4.ajax.xpath(this.xml.cell, xml);
		var strAr = [];
		
		r._attrs=this._xml_attrs(xml);
		
		//load userdata
		if (this._ud_enabled){
			var udCol = dhx4.ajax.xpath("./userdata", xml);
			
			for (var i = udCol.length-1; i >= 0; i--){
				var u_record = "";
				for (var j=0; j < udCol[i].childNodes.length; j++)
					u_record += udCol[i].childNodes[j].nodeValue;
				
				this.setUserData(r.idd,udCol[i].getAttribute("name"), u_record);
			}
		}
		
		//load cell data
		for (var j = 0; j < cellsCol.length; j++){
			var cellVal = cellsCol[this._c_order?this._c_order[j]:j];
			if (!cellVal) continue;
			var cind = r._childIndexes?r._childIndexes[j]:j;
			var exc = cellVal.getAttribute("type");
			
			if (r.childNodes[cind]){
				if (exc)
					r.childNodes[cind]._cellType=exc;
				r.childNodes[cind]._attrs=this._xml_attrs(cellVal);
			}
			
			if (!cellVal.getAttribute("xmlcontent")){
				if (cellVal.firstChild)
					cellVal=cellVal.firstChild.wholeText||cellVal.firstChild.data;
				else
					cellVal="";
			}
			
			strAr.push(cellVal);
		}
		
		for (j < cellsCol.length; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
		};
		
		//treegrid
		if (r.parentNode&&r.parentNode.tagName == "row")
			r._attrs["parent"]=r.parentNode.getAttribute("idd");
		
		//back to common code
		this._fillRow(r, strAr);
		return r;
	},
	_get_xml_data:function(data, ind){ 
		data=data.firstChild;
		
		while (true){
			if (!data)
				return "";
			
			if (data.tagName == "cell")
				ind--;
			
			if (ind < 0)
				break;
			data=data.nextSibling;
		}
		return (data.firstChild ? data.firstChild.data : "");
	},
	//#}	
	_fillRow:function(r, text){
		if (this.editor && this.editor.parentNode && this.editor.parentNode.idd == r.idd)
			this.editStop();
		
		for (var i = 0; i < r.childNodes.length; i++){
			if ((i < text.length)||(this.defVal[i])){
				
				var ii=r.childNodes[i]._cellIndex;
				var val = text[ii];
				var aeditor = this.cells4(r.childNodes[i]);
				
				if ((this.defVal[ii])&&((val == "")||( typeof (val) == "undefined")))
					val=this.defVal[ii];
				
				if (aeditor) aeditor.setValue(val)
			} else {
				r.childNodes[i].innerHTML="&nbsp;";
				r.childNodes[i]._clearCell=true;
			}
		}
		
		return r;
	},
	
	_postRowProcessing:function(r,donly){ 
		if (r._attrs["class"])
			r._css=r.className=r._attrs["class"];
		
		if (r._attrs.locked)
			r._locked=true;
		
		if (r._attrs.bgColor)
			r.bgColor=r._attrs.bgColor;
		var cor=0;	
		
		for (var i = 0; i < r.childNodes.length; i++){
			var c=r.childNodes[i];
			var ii=c._cellIndex;
			//style attribute
			var s = c._attrs.style||r._attrs.style;
			
			if (s)
				c.style.cssText+=";"+s;
			
			if (c._attrs["class"])
				c.className+=c._attrs["class"];
			s=c._attrs.align||this.cellAlign[ii];
			
			
			if (s)
				c.align=s;
			c.vAlign=c._attrs.valign||this.cellVAlign[ii];
			var color = c._attrs.bgColor||this.columnColor[ii];
			
			
			if (color)
				c.bgColor=color;
			
			if (c._attrs["colspan"] && !donly){ 
				this.setColspan(r.idd, i+cor, c._attrs["colspan"]);
				//i+=(c._attrs["colspan"]-1);
				cor+=(c._attrs["colspan"]-1);
			}
			
			if (this._hrrar&&this._hrrar[ii]&&!donly){
				c.style.display="none";
			}
		};
		this.callEvent("onRowCreated", [
				r.idd,
				r,
				null
		]);
	},
	/**
	*   @desc: load data from external file ( xml, json, jsarray, csv )
	*   @param: url - url to external file
	*   @param: call - after loading callback function, optional, can be ommited
	*   @param: type - type of data (xml,csv,json,jsarray) , optional, xml by default
	*   @type:  public
	*/			
	load:function(url, call, type){
		this.callEvent("onXLS", [this]);
		if (arguments.length == 2 && typeof call != "function"){
			type=call;
			call=null;
		}
		this._last_load_type = type = type||this._last_load_type||"xml";
		
		if (!this.xmlFileUrl)
			this.xmlFileUrl=url;
		this._data_type=type;
		
		this.xmlLoader = this.doLoadDetails;
		
		var that = this;
		this.xmlLoader = function(xml){
			if (!that.callEvent) return;
			that["_process_"+type](xml.xmlDoc);
			if (!that._contextCallTimer)
				that.callEvent("onXLE", [that,0,0,xml.xmlDoc,type]);
			
			if (call){
				call();
				call=null;
			}
		};
		return dhx4.ajax.get(url, this.xmlLoader);
	},
	//#__pro_feature:21092006{		
	loadXMLString:function(str, afterCall){
		if (window.console && window.console.info)
		  window.console.info("loadXMLString was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");

		this.parse( { responseXML: dhx4.ajax.parse(str) }, afterCall, "xml")
	},
	//#}
	loadXML:function(url, afterCall){
		if (window.console && window.console.info)
			window.console.info("loadXML was deprecated", "http://docs.dhtmlx.com/migration__index.html#migrationfrom43to44");

		this.load(url, afterCall, "xml")
	},
	/**
	*   @desc: load data from local datasource ( xml string, csv string, xml island, xml object, json objecs , javascript array )
	*   @param: data - string or object
	*   @param: type - data type (xml,json,jsarray,csv), optional, data threated as xml by default
	*   @type:  public
	*/			
	parse:function(data, call, type){
		if (arguments.length == 2 && typeof call != "function"){
			type=call;
			call=null;
		}
		this._last_load_type = type = type||this._last_load_type||"xml";
		this._data_type=type;
		
		if (type == "xml" && typeof data == "string")
			data = { responseXML: dhx4.ajax.parse(data) };
		
		this["_process_"+type](data);
		if (!this._contextCallTimer)
			this.callEvent("onXLE", [this,0,0,data,type]);
		if (call)
			call();
	},
	
	xml:{
		top: "rows",
		row: "./row",
		cell: "./cell",
		s_row: "row",
		s_cell: "cell",
		row_attrs: [],
		cell_attrs: []
	},
	
	csv:{
		row: "\n",
		cell: ","
	},
	
	_xml_attrs:function(node){
		var data = {
		};
		
		if (node.attributes.length){
			for (var i = 0; i < node.attributes.length; i++)data[node.attributes[i].name]=node.attributes[i].value;
		}
		
		return data;
	},
	//#xml_data:06042008{	
	_process_xml:function(xhr){
		if (this._refresh_mode) return this._refreshFromXML(xhr);
		this._parsing=true;
		var top = dhx4.ajax.xmltop(this.xml.top, xhr);
		if (top.tagName!=this.xml.top) return;
		var skey = top.getAttribute("dhx_security");
		if (skey)
			dhtmlx.security_key = skey;
		
		//#config_from_xml:20092006{
		this._parseHead(top);
		//#}
		var rows = dhx4.ajax.xpath(this.xml.row, top)
		var cr = parseInt(top.getAttribute("pos")||0);
		var total = parseInt(top.getAttribute("total_count")||0);
		if (!this.pagingOn)
			var total = Math.min(total, 32000000/this._srdh);
		
		var reset = false;
		if (total && total!=this.rowsBuffer.length){
			if (!this.rowsBuffer[total-1]){
				if (this.rowsBuffer.length)
					reset=true;
				this.rowsBuffer[total-1]=null;
			} 
			if (total<this.rowsBuffer.length){
				this.rowsBuffer.splice(total, this.rowsBuffer.length - total);
				reset = true;
			}
		}
		
		
		if (this.isTreeGrid())
			return this._process_tree_xml(top);
		
		
		for (var i = 0; i < rows.length; i++){
			if (this.rowsBuffer[i+cr])
				continue;
			var id = rows[i].getAttribute("id")||(i+cr+1);
			this.rowsBuffer[i+cr]={
				idd: id,
				data: rows[i],
				_parser: this._process_xml_row,
				_locator: this._get_xml_data
			};
			
			this.rowsAr[id]=rows[i];
			//this.callEvent("onRowCreated",[r.idd]);
		}
		
		this.callEvent("onDataReady", []);
		if (reset && this._srnd){
			var h = this.objBox.scrollTop;
			this._reset_view();
			this.objBox.scrollTop = h;
		} else {
			this.render_dataset();
		}
		
		this._parsing=false;
	},
	//#}
	//#non_xml_data:06042008{	
	_process_jsarray:function(data){
		this._parsing=true;
		data = data.responseText || data;
		if (typeof data == "string"){
			eval("dhtmlx.temp="+data+";");
			data = dhtmlx.temp;
		}
		
		for (var i = 0; i < data.length; i++){
			var id = i+1;
			this.rowsBuffer.push({
					idd: id,
					data: data[i],
					_parser: this._process_jsarray_row,
					_locator: this._get_jsarray_data
			});
			
			this.rowsAr[id]=data[i];
			//this.callEvent("onRowCreated",[r.idd]);
		}
		this.render_dataset();
		this._parsing=false;
	},
	
	_process_csv:function(data){
		this._parsing=true;
		data=data.responseText || data;
		data=data.replace(/\r/g,"");
		data=data.split(this.csv.row);
		if (this._csvHdr){
			this.clearAll();
			var thead=data.splice(0,1)[0].split(this.csv.cell);
			if (!this._csvAID) thead.splice(0,1);
			this.setHeader(thead.join(this.delim));
			this.init();
		}
		
		for (var i = 0; i < data.length; i++){
			if (!data[i] && i==data.length-1) continue; //skip new line at end of text
			if (this._csvAID){
				var id = i+1;
				this.rowsBuffer.push({
						idd: id,
						data: data[i],
						_parser: this._process_csv_row,
						_locator: this._get_csv_data
				});
			} else {
				var temp = data[i].split(this.csv.cell);
				var id = temp.splice(0,1)[0];
				this.rowsBuffer.push({
						idd: id,
						data: temp,
						_parser: this._process_jsarray_row,
						_locator: this._get_jsarray_data
				});
			}
			
			
			this.rowsAr[id]=data[i];
			//this.callEvent("onRowCreated",[r.idd]);
		}
		this.render_dataset();
		this._parsing=false;
	},
	
	_process_js:function(data){
		return this._process_json(data, "js");
	},
	
	_process_json:function(data, mode){
		this._parsing=true;
		
		var data = data.responseText || data;
		if (typeof data == "string"){
			eval("dhtmlx.temp="+data+";");
			data = dhtmlx.temp;
		}
		
		if (mode == "js"){
			if (data.data)
				data = data.data;
			for (var i = 0; i < data.length; i++){
				var row = data[i];
				var id  = row.id||(i+1);
				this.rowsBuffer.push({
						idd: id,
						data: row,
						_parser: this._process_js_row,
						_locator: this._get_js_data
				});
				
				this.rowsAr[id]=data[i];
			}
		} else {
			if (data.rows){
				for (var i = 0; i < data.rows.length; i++){
					var id = data.rows[i].id;
					this.rowsBuffer.push({
							idd: id,
							data: data.rows[i],
							_parser: this._process_json_row,
							_locator: this._get_json_data
					});
					
					this.rowsAr[id]=data.rows[i];
				}
			}
		}
		if (data.dhx_security)
			dhtmlx.security_key = data.dhx_security;
		
		this.callEvent("onDataReady", []);
		this.render_dataset();
		this._parsing=false;
	},
	//#}	
	render_dataset:function(min, max){ 
		//normal mode - render all
		//var p=this.obj.parentNode;
		//p.removeChild(this.obj,true)
		if (this._srnd){
			if (this._fillers)
				return this._update_srnd_view();
			
			max=Math.min((this._get_view_size()+(this._srnd_pr||0)), this.rowsBuffer.length);
			
		}
		
		if (this.pagingOn){
			min=Math.max((min||0),(this.currentPage-1)*this.rowsBufferOutSize);
			max=Math.min(this.currentPage*this.rowsBufferOutSize, this.rowsBuffer.length)
		} else {
			min=min||0;
			max=max||this.rowsBuffer.length;
		}
		
		for (var i = min; i < max; i++){
			var r = this.render_row(i)
			
			if (r == -1){
				if (this.xmlFileUrl){
					if (this.callEvent("onDynXLS",[i,(this._dpref?this._dpref:(max-i))]))
						this.load(this.xmlFileUrl+dhtmlx.url(this.xmlFileUrl)+"posStart="+i+"&count="+(this._dpref?this._dpref:(max-i)), this._data_type);
				}
				max=i;
				break;
			}
			
			if (!r.parentNode||!r.parentNode.tagName){ 
				this._insertRowAt(r, i);
				if (r._attrs["selected"] || r._attrs["select"]){
					this.selectRow(r,r._attrs["call"]?true:false,true);
					r._attrs["selected"]=r._attrs["select"]=null;
				}
			}
			
			
			if (this._ads_count && i-min==this._ads_count){
				var that=this;
				this._context_parsing=this._context_parsing||this._parsing;
				return this._contextCallTimer=window.setTimeout(function(){
						that._contextCallTimer=null;
						that.render_dataset(i,max);
						if (!that._contextCallTimer){
							if(that._context_parsing)
								that.callEvent("onXLE",[])
							else 
								that._fixAlterCss();
							that._context_parsing=false;
						}
				},this._ads_time)
			}
		}
		if (this._ads_count && i == max)
			this.callEvent("onDistributedEnd",[]);
		
		if (this._srnd&&!this._fillers){
			var add_count = this.rowsBuffer.length-max;
			this._fillers = [];
			if (this._fake && !this._realfake) this._fake._fillers = [];
			
			var block_size = Math.round(990000/this._srdh);
			while (add_count > 0){
				var add_step = (_isIE || window._FFrv)?Math.min(add_count, block_size):add_count;
				var new_filler = this._add_filler(max, add_step);
				if (new_filler)
					this._fillers.push(new_filler);
				add_count -= add_step;
				max += add_step;
			}				
		}
		
		//p.appendChild(this.obj)
		this.setSizes();
	},
	
	render_row:function(ind){
		if (!this.rowsBuffer[ind])
			return -1;
		
		if (this.rowsBuffer[ind]._parser){
			var r = this.rowsBuffer[ind];
			if (this.rowsAr[r.idd] && this.rowsAr[r.idd].tagName=="TR")
				return this.rowsBuffer[ind]=this.rowsAr[r.idd];
			var row = this._prepareRow(r.idd);
			this.rowsBuffer[ind]=row;
			this.rowsAr[r.idd]=row;
			
			r._parser.call(this, row, r.data);
			this._postRowProcessing(row);
			return row;
		}
		return this.rowsBuffer[ind];
	},
	
	
	_get_cell_value:function(row, ind, method){
		if (row._locator){
			/*if (!this._data_cache[row.idd])
			this._data_cache[row.idd]=[];
			if (this._data_cache[row.idd][ind]) 
			return this._data_cache[row.idd][ind];
			else
			return this._data_cache[row.idd][ind]=row._locator.call(this,row.data,ind);
			*/
			if (this._c_order)
				ind=this._c_order[ind];
			return row._locator.call(this, row.data, ind);
		}
		return this.cells3(row, ind)[method ? method : "getValue"]();
	},
	//#sorting:06042008{	
	/**
	*   @desc: sort grid
	*   @param: col - index of column, by which grid need to be sorted
	*   @param: type - sorting type (str,int,date), optional, by default sorting type taken from column setting
	*   @param: order - sorting order (asc,des), optional, by default sorting order based on previous sorting operation
	*   @type:  public
	*/		
	sortRows:function(col, type, order){
		this.editStop();
		//default values
		order=(order||"asc").toLowerCase();
		type=(type||this.fldSort[col]);
		col=col||0;
		
		if (this.isTreeGrid())
			this.sortTreeRows(col, type, order);
		else{
			
			var arrTS = {
			};
			
			var atype = this.cellType[col];
			var amet = "getValue";
			
			if (atype == "link")
				amet="getContent";
			
			if (atype == "dhxCalendar"||atype == "dhxCalendarA")
				amet="getDate";
				
			if (atype == "co"||atype == "coro")
				amet="getText";
				
			for (var i = 0;
				i < this.rowsBuffer.length;
				i++)arrTS[this.rowsBuffer[i].idd]=this._get_cell_value(this.rowsBuffer[i], col, amet);
				
				this._sortRows(col, type, order, arrTS);
		}
		this.callEvent("onAfterSorting", [col,type,order]);
	},
	/**
	*	@desc: 
	*	@type: private
	*/
	_sortCore:function(col, type, order, arrTS, s){
		var sort = "sort";
		
		if (this._sst){
			s["stablesort"]=this.rowsCol.stablesort;
			sort="stablesort";
		}
		//#__pro_feature:21092006{	
		//#custom_sort:21092006{
		if (type.length > 4)
			type=window[type];
		
		if (type == 'cus'){
			var cstr=this._customSorts[col];
			s[sort](function(a, b){
					return cstr(arrTS[a.idd], arrTS[b.idd], order, a.idd, b.idd);
			});
		}
		else if (typeof (type) == 'function'){
			s[sort](function(a, b){
					return type(arrTS[a.idd], arrTS[b.idd], order, a.idd, b.idd);
			});
		}
		else
			//#}
		//#}
		if (type == 'str'){
			s[sort](function(a, b){
					if (order == "asc")
						return arrTS[a.idd] > arrTS[b.idd] ? 1 : (arrTS[a.idd] < arrTS[b.idd] ? -1 : 0);
					else
						return arrTS[a.idd] < arrTS[b.idd] ? 1 : (arrTS[a.idd] > arrTS[b.idd] ? -1 : 0);
			});
		}
		else if (type == 'int'){
			s[sort](function(a, b){
					var aVal = parseFloat(arrTS[a.idd]);
					aVal=isNaN(aVal) ? -99999999999999 : aVal;
					var bVal = parseFloat(arrTS[b.idd]);
					bVal=isNaN(bVal) ? -99999999999999 : bVal;
					
					if (order == "asc")
						return aVal-bVal;
					else
						return bVal-aVal;
			});
		}
		else if (type == 'date'){
			s[sort](function(a, b){
					var aVal = Date.parse(arrTS[a.idd])||(Date.parse("01/01/1900"));
					var bVal = Date.parse(arrTS[b.idd])||(Date.parse("01/01/1900"));
					
					if (order == "asc")
						return aVal-bVal
					else
						return bVal-aVal
			});
		}
	},
	/**
	*   @desc: inner sorting routine
	*   @type: private
	*   @topic: 7
	*/
	_sortRows:function(col, type, order, arrTS){
		this._sortCore(col, type, order, arrTS, this.rowsBuffer);
		this._reset_view();
		this.callEvent("onGridReconstructed", []);
	},
	//#}		
	_reset_view:function(skip){
		if (!this.obj.rows[0]) return;
		if (this._lahRw) this._unsetRowHover(0, true); //remove hovering during reset
		this.callEvent("onResetView",[]);
		var tb = this.obj.rows[0].parentNode;
		var tr = tb.removeChild(tb.childNodes[0], true)
		if (_isKHTML) //Safari 2x
			for (var i = tb.parentNode.childNodes.length-1; i >= 0; i--) { if (tb.parentNode.childNodes[i].tagName=="TR") tb.parentNode.removeChild(tb.parentNode.childNodes[i],true); }
		else if (_isIE)
			for (var i = tb.childNodes.length-1; i >= 0; i--) tb.childNodes[i].removeNode(true);
		else
			tb.innerHTML="";
		tb.appendChild(tr)
		this.rowsCol=dhtmlxArray();
		if (this._sst)
			this.enableStableSorting(true);
		this._fillers=this.undefined;
		if (!skip){
			if (_isIE && this._srnd){
				// var p=this._get_view_size;
				// this._get_view_size=function(){ return 1; }
				this.render_dataset();
				// this._get_view_size=p;
			}
			else
				this.render_dataset();
		}
		
		
	},
	
	/**
	*   @desc: delete row from the grid
	*   @param: row_id - row ID
	*   @type:  public
	*/		
	deleteRow:function(row_id, node){
		if (!node)
			node=this.getRowById(row_id)
		
		if (!node)
			return;
		
		this.editStop();
		if (!this._realfake)
			if (this.callEvent("onBeforeRowDeleted", [row_id]) == false)
			return false;
		
		var pid=0;
		if (this.cellType._dhx_find("tree") != -1 && !this._realfake){
			pid=this._h2.get[row_id].parent.id;
			this._removeTrGrRow(node);
		}
		else {
			if (node.parentNode)
				node.parentNode.removeChild(node);
			
			var ind = this.rowsCol._dhx_find(node);
			
			if (ind != -1)
				this.rowsCol._dhx_removeAt(ind);
			
			for (var i = 0; i < this.rowsBuffer.length; i++)
			if (this.rowsBuffer[i]&&this.rowsBuffer[i].idd == row_id){
				this.rowsBuffer._dhx_removeAt(i);
				ind=i;
				break;
			}
		}
		this.rowsAr[row_id]=null;
		
		for (var i = 0; i < this.selectedRows.length; i++)
			if (this.selectedRows[i].idd == row_id)
			this.selectedRows._dhx_removeAt(i);
		
		if (this._srnd) {
		    if (this._fillers) {
		        for (var i = 0; i < this._fillers.length; i++) {
		            var f = this._fillers[i]
		            if (!f) continue; //can be null	
		            if (f[0] >= ind)
		                this._update_fillers(i, 0, -1);
		            else if (f[0] + f[1] > ind)
		                this._update_fillers(i, -1, 0);
		        };
		    }
			
			this._update_srnd_view();
		}
		
		if (this.pagingOn)
			this.changePage();
		if (!this._realfake)  this.callEvent("onAfterRowDeleted", [row_id,pid]);
		this.callEvent("onGridReconstructed", []);
		if (this._ahgr) this.setSizes();
		return true;
	},
	
	_addRow:function(new_id, text, ind){
		if (ind == -1|| typeof ind == "undefined")
			ind=this.rowsBuffer.length;
		if (typeof text == "string") text=text.split(this.delim);
		var row = this._prepareRow(new_id);
		row._attrs={
		};
		
		//for (var j = 0; j < row.childNodes.length; j++)row.childNodes[j]._attrs={
		//};
		for (var j = 0; j < row.childNodes.length; j++) {
		    row.childNodes[j].className = (this.cellClassNames && this.cellClassNames[j]) || "";
		    row.childNodes[j]._attrs = (this.cellAttrs && this.cellAttrs[j]) || {};
		    var originCell = this.hwReport && this.hwReport.getOriginCellById(row.childNodes[j]._attrs.sid);
		    if (originCell) {
		        row.childNodes[j]._disabled = originCell && originCell.getIsDisabled();
		    }
		}
		
		this.rowsAr[row.idd]=row;
		if (this._h2) this._h2.get[row.idd].buff=row;	//treegrid specific
		this._fillRow(row, text);
		this._postRowProcessing(row);
		if (this._skipInsert){
			this._skipInsert=false;
			return this.rowsAr[row.idd]=row;
		}
		
		if (this.pagingOn){
			this.rowsBuffer._dhx_insertAt(ind,row);
			this.rowsAr[row.idd]=row;
			return row;
		}
		
		if (this._fillers){ 
			this.rowsCol._dhx_insertAt(ind, null);
			this.rowsBuffer._dhx_insertAt(ind,row);
			if (this._fake) this._fake.rowsCol._dhx_insertAt(ind, null);
			this.rowsAr[row.idd]=row;
			var found = false;
			
			for (var i = 0; i < this._fillers.length; i++){
				var f = this._fillers[i];
				
				if (f&&f[0] <= ind&&(f[0]+f[1]) >= ind){
					f[1]=f[1]+1;
					var nh = f[2].firstChild.style.height=parseInt(f[2].firstChild.style.height)+this._srdh+"px";
					found=true;
					if (this._fake){
						this._fake._fillers[i][1]++;
						this._fake._fillers[i][2].firstChild.style.height = nh;
					}
				}
				
				if (f&&f[0] > ind){
					f[0]=f[0]+1
					if (this._fake) this._fake._fillers[i][0]++;
				}
			}
			
			if (!found)
			this._fillers.push(this._add_filler(ind, 1, (ind == 0 ? {
					parentNode: this.obj.rows[0].parentNode,
					nextSibling: (this.rowsCol[1])
			} : this.rowsCol[ind-1])));
			
			return row;
		}
		this.rowsBuffer._dhx_insertAt(ind,row);
		return this._insertRowAt(row, ind);
	},
	
	/**
	*   @desc: add row to the grid
	*   @param: new_id - row ID, must be unique
	*   @param: text - row values, may be a comma separated list or an array
	*   @param: ind - index of new row, optional, row added to the last position by default
	*   @type:  public
	*/	
	addRow:function(new_id, text, ind){
		var r = this._addRow(new_id, text, ind);
		
		if (!this.dragContext)
			this.callEvent("onRowAdded", [new_id]);
		
		if (this.pagingOn)
			this.changePage(this.currentPage)
		
		if (this._srnd)
			this._update_srnd_view();
		
		r._added=true;
		
		if (this._srnd && !this._fillers)
			this._fillers = [];
		
		if (this._ahgr)
			this.setSizes();
		this.callEvent("onGridReconstructed", []);
		return r;
	},
	
	_insertRowAt:function(r, ind, skip){
		this.rowsAr[r.idd]=r;
		
		if (this._skipInsert){
			this._skipInsert=false;
			return r;
		}
		
		if ((ind < 0)||((!ind)&&(parseInt(ind) !== 0)))
			ind=this.rowsCol.length;
		else {
			if (ind > this.rowsCol.length)
				ind=this.rowsCol.length;
		}
		
		if (this._cssEven){
			var css = r.className.replace(this._cssUnEven, "");
			if ((this._cssSP ? this.getLevel(r.idd) : ind)%2 == 1)
				r.className=css+" "+this._cssUnEven+(this._cssSU ? (" "+this._cssUnEven+"_"+this.getLevel(r.idd)) : "");
			else
				r.className=css+" "+this._cssEven+(this._cssSU ? (" "+this._cssEven+"_"+this.getLevel(r.idd)) : "");
		}
		/*
		if (r._skipInsert) {                
		this.rowsAr[r.idd] = r;
		return r;
		}*/
		if (!skip)
			if ((ind == (this.obj.rows.length-1))||(!this.rowsCol[ind]))
			if (_isKHTML)
			this.obj.appendChild(r);
		else {
			this.obj.firstChild.appendChild(r);
		}
		else {
			this.rowsCol[ind].parentNode.insertBefore(r, this.rowsCol[ind]);
		}
		
		this.rowsCol._dhx_insertAt(ind, r);
		this.callEvent("onRowInserted",[r, ind]);
		return r;
	},
	
	getRowById:function(id){
		var row = this.rowsAr[id];
		
		if (row){
			if (row.tagName != "TR"){
				for (var i = 0; i < this.rowsBuffer.length; i++)
					if (this.rowsBuffer[i] && this.rowsBuffer[i].idd == id)
					return this.render_row(i);
				if (this._h2) return this.render_row(null,row.idd);
			}
			return row;
		}
		return null;
	},
	
	/**
	*   @desc: gets dhtmlXGridCellObject object (if no arguments then gets dhtmlXGridCellObject object of currently selected cell)
	*   @param: row_id -  row id
	*   @param: col -  column index
	*   @returns: dhtmlXGridCellObject object (see its methods below)
	*   @type: public
	*   @topic: 4
	*/
	cellById:function(row_id, col){
		return this.cells(row_id, col);
	},
	/**
	*   @desc: gets dhtmlXGridCellObject object (if no arguments then gets dhtmlXGridCellObject object of currently selected cell)
	*   @param: row_id -  row id
	*   @param: col -  column index
	*   @returns: dhtmlXGridCellObject object (use it to get/set value to cell etc.)
	*   @type: public
	*   @topic: 4
	*/
	cells:function(row_id, col){
		if (arguments.length == 0)
			return this.cells4(this.cell);
		else
		    var c = this.getRowById(row_id);
		if (!c) {
		    debugger
		    return {};
		}
		var cell = (c._childIndexes ? c.childNodes[c._childIndexes[col]] : c.childNodes[col]);
		if (!cell && c._childIndexes)
			cell = c.firstChild || {};
		return this.cells4(cell);
	},
	/**
	*   @desc: gets dhtmlXGridCellObject object
	*   @param: row_index -  row index
	*   @param: col -  column index
	*   @returns: dhtmlXGridCellObject object (see its methods below)
	*   @type: public
	*   @topic: 4
	*/
	cellByIndex:function(row_index, col){
		return this.cells2(row_index, col);
	},
	/**
	*   @desc: gets dhtmlXGridCellObject object
	*   @param: row_index -  row index
	*   @param: col -  column index
	*   @returns: dhtmlXGridCellObject object (see its methods below)
	*   @type: public
	*   @topic: 4
	*/
	cells2:function(row_index, col){
		var c = this.render_row(row_index);
		var cell = (c._childIndexes ? c.childNodes[c._childIndexes[col]] : c.childNodes[col]);
		if (!cell && c._childIndexes)
			cell = c.firstChild || {};
		return this.cells4(cell);
	},
	/**
	*   @desc: gets exCell editor for row  object and column id
	*   @type: private
	*   @topic: 4
	*/
	cells3:function(row, col){
		var cell = (row._childIndexes ? row.childNodes[row._childIndexes[col]] : row.childNodes[col]);
		return this.cells4(cell);
	},
	/**
	*   @desc: gets exCell editor for cell  object
	*   @type: private
	*   @topic: 4
	*/
	cells4:function(cell){
		var type = window["eXcell_"+(cell._cellType||this.cellType[cell._cellIndex])];
		
		if (type)
			return new type(cell);
	},	
	cells5:function(cell, type){ 
		var type = type||(cell._cellType||this.cellType[cell._cellIndex]);
		
		if (!this._ecache[type]){
			if (!window["eXcell_"+type])
				var tex = eXcell_ro;
			else
				var tex = window["eXcell_"+type];
			
			this._ecache[type]=new tex(cell);
		}
		this._ecache[type].cell=cell;
		return this._ecache[type];
	},
	dma:function(mode){
		if (!this._ecache)
		this._ecache={
		};
		
		if (mode&&!this._dma){
			this._dma=this.cells4;
			this.cells4=this.cells5;
		} else if (!mode&&this._dma){
			this.cells4=this._dma;
			this._dma=null;
		}
	},
	
	/**
	*   @desc: returns count of row in grid ( in case of dynamic mode it will return expected count of rows )
	*   @type:  public
	*	@returns: count of rows in grid
	*/	
	getRowsNum:function(){
		return this.rowsBuffer.length;
	},
	
	
	/**
	*   @desc: enables/disables mode when readonly cell is not available with tab 
	*   @param: mode - (boolean) true/false
	*   @type:  public
	*/
	enableEditTabOnly:function(mode){
		if (arguments.length > 0)
			this.smartTabOrder=dhx4.s2b(mode);
		else
			this.smartTabOrder=true;
	},
	/**
	*   @desc: sets elements which get focus when tab is pressed in the last or first (tab+shift) cell 
	*   @param: start - html object or its id - gets focus when tab+shift are pressed in the first cell  
	*   @param: end - html object or its id - gets focus when tab is pressed in the last cell  
	*   @type:  public
	*/
	setExternalTabOrder:function(start, end){
		var grid = this;
		this.tabStart=( typeof (start) == "object") ? start : document.getElementById(start);
		
		var oldkeydown_start = this.tabStart.onkeydown;
		this.tabStart.onkeydown=function(e){
			if (oldkeydown_start)
				oldkeydown_start.call(this, e);
			
			var ev = (e||window.event);
			if (ev.keyCode == 9 && !ev.shiftKey){
				
				ev.cancelBubble=true;		
				grid.selectCell(0, 0, 0, 0, 1);
				
				if (grid.smartTabOrder && grid.cells2(0, 0).isDisabled()){
					grid._key_events["k9_0_0"].call(grid);
				}
				this.blur();
				return false;
			}
		};
		if(_isOpera) this.tabStart.onkeypress = this.tabStart.onkeydown;
		this.tabEnd=( typeof (end) == "object") ? end : document.getElementById(end);
		
		var oldkeydown_end= this.tabEnd.onkeydown;
		this.tabEnd.onkeydown=this.tabEnd.onkeypress=function(e){
			if (oldkeydown_end)
				oldkeydown_end.call(this, e);
			
			var ev = (e||window.event);
			if (ev.keyCode == 9 && ev.shiftKey){
				ev.cancelBubble=true;
				grid.selectCell((grid.getRowsNum()-1), (grid.getColumnCount()-1), 0, 0, 1);
				
				if (grid.smartTabOrder && grid.cells2((grid.getRowsNum()-1), (grid.getColumnCount()-1)).isDisabled()){
					grid._key_events["k9_0_1"].call(grid);
				}
				this.blur();
				return false;
			}
		};
		if(_isOpera) this.tabEnd.onkeypress = this.tabEnd.onkeydown;
	},
	/**
	*   @desc: returns unique ID
	*   @type:  public
	*/	
	uid:function(){
		if (!this._ui_seed) this._ui_seed=(new Date()).valueOf();
		return this._ui_seed++;
	},
	setIconset:function(name){
		this.iconset = name;
	},
	/**
	*   @desc: clears existing grid state and load new XML
	*   @type:  public
	*/
	clearAndLoad:function(){
		if (this._last_load_request){
			//abort last loading if new issued
			var last = this._last_load_request.xmlDoc;
			if (last.readyState != 4){
				try{
					last.onreadystatechange = function(){};
					last.abort();
				} catch(e){}
			}
		};

		var t=this._pgn_skin; this._pgn_skin=null;
		this.clearAll();
		this._pgn_skin=t;
		this._last_load_request = this.load.apply(this,arguments);
	},
	/**
	*   @desc: returns details about current grid state
	*   @type:  public
	*/
	getStateOfView:function(){
		if (this.pagingOn){
			var start = (this.currentPage-1)*this.rowsBufferOutSize;
			return [this.currentPage, start, Math.min(start+this.rowsBufferOutSize,this.rowsBuffer.length), this.rowsBuffer.length ];
		}

		var min=Math.floor(this.objBox.scrollTop/this._srdh);
		var max=Math.ceil(parseInt(this.objBox.offsetHeight)/this._srdh);

		if (this.multiLine){
			var pxHeight = this.objBox.scrollTop;
			min = 0;
			while(pxHeight >= 0) {
				pxHeight-=this.rowsCol[min]?this.rowsCol[min].offsetHeight:this._srdh;
				min++;
			}
			min--;

			pxHeight += this.objBox.offsetHeight;
			max = 0;
			while (pxHeight >=0 ){
				pxHeight-=this.rowsCol[min+max]?this.rowsCol[min+max].offsetHeight:this._srdh;
				max++;
			}
		}

		return [
			min,
			max,
			this.rowsBuffer.length
		];
	}
};

//grid
(function(){
		//local helpers
		function direct_set(name,value){ this[name]=value; 	}
		function direct_call(name,value){ this[name].call(this,value); 	}
		function joined_call(name,value){ this[name].call(this,value.join(this.delim));  }
		function set_options(name,value){
			for (var i=0; i < value.length; i++) 
			if (typeof value[i] == "object"){
				var combo = this.getCombo(i);
				for (var key in value[i])
					combo.put(key, value[i][key]);
			}
		}
		function header_set(name,value,obj){
			//make a matrix
			var rows = 1;
			var header = [];
			function add(i,j,value){
				if (!header[j]) header[j]=[];
				if (typeof value == "object") value.toString=function(){ return this.text; }
				header[j][i]=value;
			}
			
			for (var i=0; i<value.length; i++) {
				if (typeof(value[i])=="object" && value[i].length){
					for (var j=0; j < value[i].length; j++)
						add(i,j,value[i][j]);		
				} else
				add(i,0,value[i]);		
			}
			for (var i=0; i<header.length; i++)
			for (var j=0; j<header[0].length; j++){
				var h=header[i][j];
				header[i][j]=(h||"").toString()||"&nbsp;";
				if (h&&h.colspan)
					for (var k=1; k < h.colspan; k++) add(j+k,i,"#cspan");
				if (h&&h.rowspan)
					for (var k=1; k < h.rowspan; k++) add(j,i+k,"#rspan");
			}
			
			this.setHeader(header[0]);
			for (var i=1; i < header.length; i++) 
				this.attachHeader(header[i]);
		}
		
		//defenitions
		var columns_map=[
			{name:"label", 	def:"&nbsp;", 	operation:"setHeader",		type:header_set		},
			{name:"id", 	def:"", 		operation:"columnIds",		type:direct_set		},
			{name:"width", 	def:"*", 		operation:"setInitWidths", 	type:joined_call	},
			{name:"align", 	def:"left", 	operation:"cellAlign",		type:direct_set		},
			{name:"valign", def:"middle", 	operation:"cellVAlign",		type:direct_set		},
			{name:"sort", 	def:"na", 		operation:"fldSort",		type:direct_set		},
			{name:"type", 	def:"ro", 		operation:"setColTypes",	type:joined_call	},
			{name:"options",def:"", 		operation:"",				type:set_options	}
		];
		
		//extending	
		dhtmlx.extend_api("dhtmlXGridObject",{
				_init:function(obj){
					return [obj.parent];
				},
				image_path:"setImagePath",
				columns:"columns",
				rows:"rows",
				headers:"headers",
				skin:"setSkin",
				smart_rendering:"enableSmartRendering",
				css:"enableAlterCss",
				auto_height:"enableAutoHeight",
				save_hidden:"enableAutoHiddenColumnsSaving",
				save_cookie:"enableAutoSaving",
				save_size:"enableAutoSizeSaving",
				auto_width:"enableAutoWidth",
				block_selection:"enableBlockSelection",
				csv_id:"enableCSVAutoID",
				csv_header:"enableCSVHeader",
				cell_ids:"enableCellIds",
				colspan:"enableColSpan",
				column_move:"enableColumnMove",
				context_menu:"enableContextMenu",
				distributed:"enableDistributedParsing",
				drag:"enableDragAndDrop",
				drag_order:"enableDragOrder",
				tabulation:"enableEditTabOnly",
				header_images:"enableHeaderImages",
				header_menu:"enableHeaderMenu",
				keymap:"enableKeyboardSupport",
				mouse_navigation:"enableLightMouseNavigation",
				markers:"enableMarkedCells",
				math_editing:"enableMathEditing",
				math_serialization:"enableMathSerialization",
				drag_copy:"enableMercyDrag",
				multiline:"enableMultiline",
				multiselect:"enableMultiselect",
				save_column_order:"enableOrderSaving",
				hover:"enableRowsHover",
				rowspan:"enableRowspan",
				smart:"enableSmartRendering",
				save_sorting:"enableSortingSaving",
				stable_sorting:"enableStableSorting",
				undo:"enableUndoRedo",
				csv_cell:"setCSVDelimiter",
				date_format:"setDateFormat",
				drag_behavior:"setDragBehavior",
				editable:"setEditable",
				without_header:"setNoHeader",
				submit_changed:"submitOnlyChanged",
				submit_serialization:"submitSerialization",
				submit_selected:"submitOnlySelected",
				submit_id:"submitOnlyRowID",		
				xml:"load"
		},{
			columns:function(obj){
				for (var j=0; j<columns_map.length; j++){
					var settings = [];
					for (var i=0; i<obj.length; i++)
						settings[i]=obj[i][columns_map[j].name]||columns_map[j].def;
					var type=columns_map[j].type||direct_call;
					type.call(this,columns_map[j].operation,settings,obj);
				}
				this.init();
			},
			rows:function(obj){
				
			},
			headers:function(obj){
				for (var i=0; i < obj.length; i++) 
					this.attachHeader(obj[i]);
			}
		});
		
})();


dhtmlXGridObject.prototype._dp_init=function(dp){
	dp.attachEvent("insertCallback", function(upd, id) {
			if (this.obj._h2)
				this.obj.addRow(id, row, null, parent);
			else
				this.obj.addRow(id, [], 0);
			
			var row = this.obj.getRowById(id);
			if (row){
				this.obj._process_xml_row(row, upd.firstChild);
				this.obj._postRowProcessing(row);	
			}
	});
	dp.attachEvent("updateCallback", function(upd, id) {
			var row = this.obj.getRowById(id);
			if (row){
				this.obj._process_xml_row(row, upd.firstChild);
				this.obj._postRowProcessing(row);	
			}
	});
	dp.attachEvent("deleteCallback", function(upd, id) {
			this.obj.setUserData(id, this.action_param, "true_deleted");
			this.obj.deleteRow(id);
	});
	
	
	dp._methods=["setRowTextStyle","setCellTextStyle","changeRowId","deleteRow"];
	this.attachEvent("onEditCell",function(state,id,index){
			if (dp._columns && !dp._columns[index]) return true;
			var cell = this.cells(id,index)
			if (state==1){
				if(cell.isCheckbox()){
					dp.setUpdated(id,true)
				}
			} else if (state==2){
				if(cell.wasChanged()){
					dp.setUpdated(id,true)
				}
			}
			return true;
	});
	this.attachEvent("onRowPaste",function(id){
			dp.setUpdated(id,true)
	});
	this.attachEvent("onUndo",function(id){
			dp.setUpdated(id,true)
	});
	this.attachEvent("onRowIdChange",function(id,newid){
			var ind=dp.findRow(id);
			if (ind<dp.updatedRows.length)
				dp.updatedRows[ind]=newid;
	});
	this.attachEvent("onSelectStateChanged",function(rowId){
			if(dp.updateMode=="row")
				dp.sendData();
			return true;
	});
	this.attachEvent("onEnter",function(rowId,celInd){
			if(dp.updateMode=="row")
				dp.sendData();
			return true;
	});
	this.attachEvent("onBeforeRowDeleted",function(rowId){
			if (dp._silent_mode || (!this.rowsAr[rowId])) return true;
			if (this.dragContext && dp.dnd) {
				window.setTimeout(function(){
						dp.setUpdated(rowId,true);
				},1);
				return true;
			}
			var z=dp.getState(rowId);
			if (this._h2){
				this._h2.forEachChild(rowId,function(el){
						dp.setUpdated(el.id,false);
						dp.markRow(el.id,true,"deleted");
				},this);
			}
			if (z=="inserted") {  dp.set_invalid(rowId,false); dp.setUpdated(rowId,false);		return true; }
			if (z=="deleted")  return false;
			if (z=="true_deleted")  { dp.setUpdated(rowId,false); return true; }
			
			dp.setUpdated(rowId,true,"deleted");
			return false;
	});
	this.attachEvent("onBindUpdate", function(data, key, id){
		dp.setUpdated(id, true);
	});
	this.attachEvent("onRowAdded",function(rowId){
			if (this.dragContext && dp.dnd) return true;
			dp.setUpdated(rowId,true,"inserted")
			return true;
	});
	dp._getRowData=function(rowId,pref){
		var data = [];
		
		data["gr_id"]=rowId;
		if (this.obj.isTreeGrid())
			data["gr_pid"]=this.obj.getParentId(rowId);
		
		var r=this.obj.getRowById(rowId);
		for (var i=0; i<this.obj._cCount; i++){
			if (this.obj._c_order)
				var i_c=this.obj._c_order[i];
			else
				var i_c=i;
			
			var c=this.obj.cells(r.idd,i);
			if (this._changed && !c.wasChanged()) continue;
			if (this._endnm)
				data[this.obj.getColumnId(i)]=c.getValue();
			else
				data["c"+i_c]=c.getValue();
		}
		
		var udata=this.obj.UserData[rowId];
		if (udata){
			for (var j=0; j<udata.keys.length; j++)
				if (udata.keys[j] && udata.keys[j].indexOf("__")!=0)
				data[udata.keys[j]]=udata.values[j];
		}
		var udata=this.obj.UserData["gridglobaluserdata"];
		if (udata){
			for (var j=0; j<udata.keys.length; j++)
				data[udata.keys[j]]=udata.values[j];
		}
		return data;
	};
	dp._clearUpdateFlag=function(rowId){
		var row=this.obj.getRowById(rowId);
		if (row)
			for (var j=0; j<this.obj._cCount; j++)
			this.obj.cells(rowId,j).cell.wasChanged=false;	//using cells because of split
	};
	dp.checkBeforeUpdate=function(rowId){ 
		var valid=true; var c_invalid=[];
		for (var i=0; i<this.obj._cCount; i++)
		if (this.mandatoryFields[i]){
			var res=this.mandatoryFields[i].call(this.obj,this.obj.cells(rowId,i).getValue(),rowId,i);
			if (typeof res == "string"){
				this.messages.push(res);
				valid = false;
			} else {
				valid&=res;
				c_invalid[i]=!res;
			}
		}
		if (!valid){
			this.set_invalid(rowId,"invalid",c_invalid);
			this.setUpdated(rowId,false);
		}
		return valid;
	};	
};


dhx4.attachEvent("onGridCreated", function(grid){
		//make separate config array for each grid
		grid._con_f_used = [].concat(grid._con_f_used);
		dhtmlXGridObject.prototype._con_f_used=[];
		
		var clear_url=function(url){
			url=url.replace(/(\?|\&)connector[^\f]*/g,"");
			return url+(url.indexOf("?")!=-1?"&":"?")+"connector=true"+(this.hdr.rows.length > 0 ? "&dhx_no_header=1":"");
		};
		var combine_urls=function(url){
			return clear_url.call(this,url)+(this._connector_sorting||"")+(this._connector_filter||"");
		};
		var sorting_url=function(url,ind,dir){
			this._connector_sorting="&dhx_sort["+ind+"]="+dir;
			return combine_urls.call(this,url);
		};
		var filtering_url=function(url,inds,vals){
			var chunks = [];
			for (var i=0; i<inds.length; i++)
				chunks[i]="dhx_filter["+inds[i]+"]="+encodeURIComponent(vals[i]);
			this._connector_filter="&"+chunks.join("&");
			return combine_urls.call(this,url);
		};
		grid.attachEvent("onCollectValues",function(ind){
				if (this._con_f_used[ind]){
					if (typeof(this._con_f_used[ind]) == "object")
						return this._con_f_used[ind];
					else
						return false;
				}
				return true;
		});	
		grid.attachEvent("onDynXLS",function(){
				if (this.xmlFileUrl)
					this.xmlFileUrl=combine_urls.call(this,this.xmlFileUrl);
				return true;
		});				
		grid.attachEvent("onBeforeSorting",function(ind,type,dir){
				if (type=="connector"){
					var self=this;
					this.clearAndLoad(sorting_url.call(this,this.xmlFileUrl,ind,dir),function(){
							self.setSortImgState(true,ind,dir);
					});
					return false;
				}
				return true;
		});
		grid.attachEvent("onFilterStart",function(a,b){
				if (this._con_f_used.length){
					var ss = this.getSortingState();
					var self=this;
					this.clearAndLoad(filtering_url.call(this,this.xmlFileUrl,a,b));
					if (ss.length)
						self.setSortImgState(true,ss[0],ss[1]);
					return false;
				}
				return true;
		});
});

dhtmlXGridObject.prototype._con_f_used=[];
dhtmlXGridObject.prototype._in_header_connector_text_filter=function(t,i){
	if (!this._con_f_used[i])
		this._con_f_used[i]=1;
	return this._in_header_text_filter(t,i);
};
dhtmlXGridObject.prototype._in_header_connector_select_filter=function(t,i){
	if (!this._con_f_used[i])
		this._con_f_used[i]=2;
	return this._in_header_select_filter(t,i);
};

if (!dhtmlXGridObject.prototype.load_connector){
	
	dhtmlXGridObject.prototype.load_connector=dhtmlXGridObject.prototype.load;
	dhtmlXGridObject.prototype.load=function(url, call, type){
		if (!this._colls_loaded && this.cellType){
			var ar=[];
			for (var i=0; i < this.cellType.length; i++)
				if (this.cellType[i].indexOf("co")==0 || this.cellType[i].indexOf("clist")==0 || this._con_f_used[i]==2) ar.push(i);
			if (ar.length)
				arguments[0]+=(arguments[0].indexOf("?")!=-1?"&":"?")+"connector=true&dhx_colls="+ar.join(",");
		}
		return this.load_connector.apply(this,arguments);
	};
	dhtmlXGridObject.prototype._parseHead_connector=dhtmlXGridObject.prototype._parseHead;
	dhtmlXGridObject.prototype._parseHead=function(url, call, type){
		this._parseHead_connector.apply(this,arguments);
		if (!this._colls_loaded){
			var cols = dhx4.ajax.xpath("./coll_options", arguments[0]);
			for (var i=0; i < cols.length; i++){
				var f = cols[i].getAttribute("for");
				var v = [];
				var combo=null;
				if (this.cellType[f] == "combo")
					combo = this.getColumnCombo(f);
				else if (this.cellType[f].indexOf("co")==0)
					combo=this.getCombo(f);
				
				var os = dhx4.ajax.xpath("./item",cols[i]);
				var opts = [];
				for (var j=0; j<os.length; j++){
					var val=os[j].getAttribute("value");
					
					if (combo){
						var lab=os[j].getAttribute("label")||val;
						
						if (combo.addOption)
							opts.push([val, lab]);
						else
							combo.put(val,lab);
						
						v[v.length]=lab;
					} else
					v[v.length]=val;
				}
				if (opts.length){
					if (combo)
						combo.addOption(opts);
				} else if (v.length && !combo)
				if (this.registerCList)
					this.registerCList(f*1, v);
				
				
				if (this._con_f_used[f*1])
					this._con_f_used[f*1]=v;
			}
			this._colls_loaded=true;
		}
	};
	
}	

dhtmlXGridObject.prototype.getRowData = function( /*string*/ rowId) {
	var result = {};
	var colsNum = this.getColumnsNum();
	for (var index = 0; index < colsNum; index++) {
		var colId = this.getColumnId(index);
		if (colId) {
			result[colId] = this.cells(rowId, index).getValue();
		}
	}
	return result;
};

dhtmlXGridObject.prototype.setRowData = function( /*string*/ rowId, /*json*/ rowJson) {
	var colsNum = this.getColumnsNum();
	for (var index = 0; index < colsNum; index++) {
		var colId = this.getColumnId(index);
		if (colId && rowJson.hasOwnProperty(colId)) {
			this.cells(rowId, index).setValue(rowJson[colId]);
		}
	}
};

dhtmlXGridObject.prototype.clearAddedState = function() {
	this.forEachRow(function(id) {
		var row = this.rowsAr[id];
		if (row.tagName != "TR") {
			return
		}
		row._added = false;
	});
	this._added_rows = [];
};


//(c)dhtmlx ltd. www.dhtmlx.com

/**
*	@desc: dhtmlxGrid cell object constructor (shouldn't be accesed directly. Use cells and cells2 methods of the grid instead)
*	@type: cell
*	@returns: dhtmlxGrid cell
*/
function dhtmlXGridCellObject(obj){
	/**
	*	@desc: desctructor, clean used memory
	*	@type: public
	*/
	this.destructor=function(){
		this.cell.obj=null;
		this.cell=null;
		this.grid=null;
		this.base=null;
		return null;
	}
	this.cell=obj;
	/**
	*	@desc: gets Value of cell
	*	@type: public
	*/
	this.getValue=function(){
		if ((this.cell.textContent)&&(this.cell.textContent.tagName == "TEXTAREA"))
			return this.cell.textContent.value;
		else
			return this.cell.innerHTML._dhx_trim(); //innerText;
	}

	/**
	*	@desc: gets math formula of cell if any
	*	@type: public
	*/
	this.getMathValue=function(){
		if (this.cell.original)
			return this.cell.original; //innerText;
		else
			return this.getValue();
	}
	
//#excell_methods:04062008{
	/**
	*	@desc: determ. font style if it was set
	*	@returns: font name only if it was set for the cell
	*	@type: public
	*/
	this.getFont=function(){
		arOut=new Array(3);

		if (this.cell.style.fontFamily)
			arOut[0]=this.cell.style.fontFamily

		if (this.cell.style.fontWeight == 'bold'||this.cell.parentNode.style.fontWeight == 'bold')
			arOut[1]='bold';

		if (this.cell.style.fontStyle == 'italic'||this.cell.parentNode.style.fontWeight == 'italic')
			arOut[1]+='italic';

		if (this.cell.style.fontSize)
			arOut[2]=this.cell.style.fontSize
		else
			arOut[2]="";
		return arOut.join("-")
	}
	/**
	*	@desc: determ. cell's text color
	*	@returns: cell's text color
	*	@type: public
	*/
	this.getTextColor=function(){
		if (this.cell.style.color)
			return this.cell.style.color
		else
			return "#000000";
	}
	/**
	*	@desc: determ. cell's background color
	*	@returns: cell's background color
	*	@type: public
	*/
	this.getBgColor=function(){
		return this.cell.style.backgroundColor || "#FFFFFF";
	}
	/**
	*	@desc: determines horisontal align od the cell
	*	@returns: horisontal align of cell content
	*	@type: public
	*/
	this.getHorAlign=function(){
		if (this.cell.style.textAlign)
			return this.cell.style.textAlign;

		else if (this.cell.style.textAlign)
			return this.cell.style.textAlign;

		else
			return "left";
	}
	/**
	*	@desc: gets width of the cell in pixel
	*	@returns: width of the cell in pixels
	*	@type: public
	*/
	this.getWidth=function(){
		return this.cell.scrollWidth;
	}

	/**
	*	@desc: sets font family to the cell
	*	@param: val - string in format: Arial-bold(italic,bolditalic,underline)-12px
	*	@type: public
	*/
	this.setFont=function(val){
		fntAr=val.split("-");
		this.cell.style.fontFamily=fntAr[0];
		this.cell.style.fontSize=fntAr[fntAr.length-1]

		if (fntAr.length == 3){
			if (/bold/.test(fntAr[1]))
				this.cell.style.fontWeight="bold";

			if (/italic/.test(fntAr[1]))
				this.cell.style.fontStyle="italic";

			if (/underline/.test(fntAr[1]))
				this.cell.style.textDecoration="underline";
		}
	}
	/**
	*	@desc: sets text color to the cell
	*	@param: val - color value (name or hex)
	*	@type: public
	*/
	this.setTextColor=function(val){
		this.cell.style.color=val;
	}
	/**
	*	@desc: sets background color to the cell
	*	@param: val - color value (name or hex)
	*	@type: public
	*/
	this.setBgColor=function(val){
		if (val == "")
			val=null;
		this.cell.style.background=val;
	}
	/**
	*	@desc: sets horisontal align to the cell
	*	@param: val - value in single-letter or full format(exmp: r or right)
	*	@type: public
	*/
	this.setHorAlign=function(val){
		if (val.length == 1){
			if (val == 'c')
				this.cell.style.textAlign='center'

			else if (val == 'l')
				this.cell.style.textAlign='left';

			else
				this.cell.style.textAlign='right';
		} else
			this.cell.style.textAlign=val
	}
//#}
	/**
	*	@desc: determines whether cell value was changed
	*	@returns: true if cell value was changed, otherwise - false
	*	@type: public
	*/
	this.wasChanged=function(){
		if (this.cell.wasChanged)
			return true;
		else
			return false;
	}
	/**
	*	@desc: determines whether first child of the cell is checkbox or radio
	*	@returns: true if first child of the cell is input element of type radio or checkbox
	*	@type: deprecated
	*/
	this.isCheckbox=function(){
		var ch = this.cell.firstChild;

		if (ch&&ch.tagName == 'INPUT'){
			type=ch.type;

			if (type == 'radio'||type == 'checkbox')
				return true;
			else
				return false;
		} else
			return false;
	}
	/**
	*	@desc: determines whether radio or checkbox inside is checked
	*	@returns: true if first child of the cell is checked
	*	@type: public
	*/
	this.isChecked=function(){
		if (this.isCheckbox()){
			return this.cell.firstChild.checked;
		}
	}
	/**
	*	@desc: determines whether cell content (radio,checkbox) is disabled
	*	@returns: true if first child of the cell is disabled
	*	@type: public
	*/
	this.isDisabled=function(){
		return this.cell._disabled;
	}
	/**
	*	@desc: checks checkbox or radion
	*	@param: fl - true or false
	*	@type: public
	*/
	this.setChecked=function(fl){
		if (this.isCheckbox()){
			if (fl != 'true'&&fl != 1)
				fl=false;
			this.cell.firstChild.checked=fl;
		}
	}
	/**
	*	@desc: disables radio or checkbox
	*	@param: fl - true or false
	*	@type: public
	*/
	this.setDisabled=function(fl){
		if (fl != 'true'&&fl != 1)
			fl=false;

		if (this.isCheckbox()){
			this.cell.firstChild.disabled=fl;

			if (this.disabledF)
				this.disabledF(fl);
		}
		this.cell._disabled=fl;
	}
}

dhtmlXGridCellObject.prototype={
	getAttribute: function(name){
		return this.cell._attrs[name];
	},
	setAttribute: function(name, value){
		this.cell._attrs[name]=value;
	},
	getInput:function(){
		if (this.obj && (this.obj.tagName=="INPUT" || this.obj.tagName=="TEXTAREA")) return this.obj;
		
		var inps=(this.obj||this.cell).getElementsByTagName("TEXTAREA");
		if (!inps.length)
			inps=(this.obj||this.cell).getElementsByTagName("INPUT");
		return inps[0];
	}
}

/**
*	@desc: sets value to the cell
*	@param: val - new value
*	@type: public
*/
dhtmlXGridCellObject.prototype.setValue=function(val){
	if (( typeof (val) != "number")&&(!val||val.toString()._dhx_trim() == "")){
		val="&nbsp;"
		this.cell._clearCell=true;
	} else
		this.cell._clearCell=false;
	this.setCValue(val);
}
/**
*	@desc: sets value to the cell
*	@param: val - new value
*	@param: val2
*	@type: private
*/
dhtmlXGridCellObject.prototype.getTitle=function(){
	return (_isIE ? this.cell.innerText : this.cell.textContent);
}

dhtmlXGridCellObject.prototype.setCValue=function(val, val2){
	this.cell.innerHTML=val;
//#__pro_feature:21092006{
//#on_cell_changed:23102006{
	this.grid.callEvent("onCellChanged", [
		this.cell.parentNode.idd,
		this.cell._cellIndex,
		(arguments.length > 1 ? val2 : val)
	]);
//#}
//#}
}

dhtmlXGridCellObject.prototype.setCTxtValue=function(val){
	this.cell.innerHTML="";
	this.cell.appendChild(document.createTextNode(val));
//#__pro_feature:21092006{	
//#on_cell_changed:23102006{
	this.grid.callEvent("onCellChanged", [
		this.cell.parentNode.idd,
		this.cell._cellIndex,
		val
	]);
//#}
//#}
}

/**
*	@desc: sets text representation of cell which contains math formula ( setLabel doesn't triger math calculations as setValue do)
*	@param: val - new value
*	@type: public
*/
dhtmlXGridCellObject.prototype.setLabel=function(val){
	this.cell.innerHTML=val;
}

/**
*	@desc: get formula of ExCell ( actual only for math based exCells )
*	@type: public
*/
dhtmlXGridCellObject.prototype.getMath=function(){
	if (this._val)
		return this.val;
	else
		return this.getValue();
}

/**
*	@desc: dhtmlxGrid cell editor constructor (base for all eXcells). Shouldn't be accessed directly
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell(){
	this.obj=null; //editor
	//this.cell = null//cell to get value from
	this.val=null; //current value (before edit)
	/**
	*	@desc: occures on space for example 
	*	@type: private
	*/
	this.changeState=function(){
		return false
	}
	/**
	*	@desc: opens editor
	*	@type: private
	*/
	this.edit=function(){
		this.val=this.getValue()
	} //
	/**
	*	@desc: return value to cell, closes editor
	*	@returns: if cell's value was changed (true) or not
	*	@type: private
	*/
	this.detach=function(){
		return false
	} //
	/**
	*	@desc: gets position (left-right) of element
	*	@param: oNode - element to get position of
	*	@type: private
	*	@topic: 8
	*/
	this.getPosition=function(oNode){
		var oCurrentNode = oNode;
		var iLeft = 0;
		var iTop = 0;

		while (oCurrentNode.tagName != "BODY"){
			iLeft+=oCurrentNode.offsetLeft;
			iTop+=oCurrentNode.offsetTop;
			oCurrentNode=oCurrentNode.offsetParent;
		}
		return new Array(iLeft, iTop);
	}
}
eXcell.prototype=new dhtmlXGridCellObject;


/**
*	@desc: simple text editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ed(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
		this.cell.atag=(!this.grid.multiLine) ? "INPUT" : "TEXTAREA";
		this.val=this.getValue();
		this.obj=document.createElement(this.cell.atag);
		this.obj.setAttribute("autocomplete", "off");
		this.obj.style.height=(this.cell.offsetHeight-(this.grid.multiLine ? 9 : 4))+"px";
		
		this.obj.className="dhx_combo_edit";
		this.obj.wrap="soft";
		this.obj.style.textAlign=this.cell.style.textAlign;
		this.obj.onclick=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.onmousedown=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.value=this.val
		this.cell.innerHTML="";
		this.cell.appendChild(this.obj);

		this.obj.onselectstart=function(e){
			if (!e)
				e=event;
			e.cancelBubble=true;
			return true;
		};
		if (_isIE){
			this.obj.focus();
			this.obj.blur();
		}
		this.obj.focus();
	}
	this.getValue=function(){
		if ((this.cell.firstChild)&&((this.cell.atag)&&(this.cell.firstChild.tagName == this.cell.atag)))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		return this.cell.innerHTML.toString()._dhx_trim();
	}

	this.detach=function(){
		this.setValue(this.obj.value);
		return this.val != this.getValue();
	}
}
eXcell_ed.prototype=new eXcell;

/**
*	@desc: pure text editor ( HTML not supported )
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_edtxt(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.getValue=function(){
		if ((this.cell.firstChild)&&((this.cell.atag)&&(this.cell.firstChild.tagName == this.cell.atag)))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		return (_isIE ? this.cell.innerText : this.cell.textContent);
	}
	this.setValue=function(val){
		if (!val||val.toString()._dhx_trim() == ""){
			val=" ";
			this.cell._clearCell=true;
		} else
			this.cell._clearCell=false;
		this.setCTxtValue(val);
	}
}
eXcell_edtxt.prototype=new eXcell_ed;
//#__pro_feature:21092006{
/**
*	@desc: simple numeric text editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*	@edition: professional
*/
function eXcell_edn(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.getValue=function(){
		//this.grid.editStop();
		if ((this.cell.firstChild)&&(this.cell.firstChild.tagName == "TEXTAREA"))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		return this.cell._orig_value||this.grid._aplNFb(this.cell.innerHTML.toString()._dhx_trim(), this.cell._cellIndex);
	}

	this.detach=function(){
		var tv = this.obj.value;
		this.setValue(tv);
		return this.val != this.getValue();
	}
}
eXcell_edn.prototype=new eXcell_ed;
eXcell_edn.prototype.setValue=function(val){ 
	if (!val||val.toString()._dhx_trim() == ""){
		this.cell._clearCell=true;
		return this.setCValue("&nbsp;",0);
	} else {
		this.cell._clearCell=false;
		this.cell._orig_value = val;
	}
	this.setCValue(this.grid._aplNF(val, this.cell._cellIndex), val);
}
//#}

//#ch_excell:04062008{
/**
*	@desc: checkbox editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ch(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}

	this.disabledF=function(fl){
		if ((fl == true)||(fl == 1))
			this.cell.innerHTML=this.cell.innerHTML.replace("item_chk0.", "item_chk0_dis.").replace("item_chk1.",
				"item_chk1_dis.");
		else
			this.cell.innerHTML=this.cell.innerHTML.replace("item_chk0_dis.", "item_chk0.").replace("item_chk1_dis.",
				"item_chk1.");
	}

	this.changeState=function(fromClick){
		//nb:
		if (fromClick===true && !this.grid.isActive) {
			if (window.globalActiveDHTMLGridObject != null && window.globalActiveDHTMLGridObject != this.grid && window.globalActiveDHTMLGridObject.isActive) window.globalActiveDHTMLGridObject.setActive(false);
			this.grid.setActive(true);
		}
		if ((!this.grid.isEditable)||(this.cell.parentNode._locked)||(this.isDisabled()))
			return;

		if (this.grid.callEvent("onEditCell", [
			0,
			this.cell.parentNode.idd,
			this.cell._cellIndex
		])){
			this.val=this.getValue()

			if (this.val == "1")
				this.setValue("0")
			else
				this.setValue("1")

			this.cell.wasChanged=true;
			//nb:
			this.grid.callEvent("onEditCell", [
				1,
				this.cell.parentNode.idd,
				this.cell._cellIndex
			]);

			this.grid.callEvent("onCheckbox", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);

			this.grid.callEvent("onCheck", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);
		} else { //preserve editing (not tested thoroughly for this editor)
			this.editor=null;
		}
	}
	this.getValue=function(){
		return this.cell.chstate ? this.cell.chstate.toString() : "0";
	}

	this.isCheckbox=function(){
		return true;
	}
	this.isChecked=function(){
		if (this.getValue() == "1")
			return true;
		else
			return false;
	}

	this.setChecked=function(fl){
		this.setValue(fl.toString())
	}
	this.detach=function(){
		return this.val != this.getValue();
	}
	this.edit=null;
}
eXcell_ch.prototype=new eXcell;
eXcell_ch.prototype.setValue=function(val){
	this.cell.style.verticalAlign="middle"; //nb:to center checkbox in line
	//val can be int
	if (val){
		val=val.toString()._dhx_trim();

		if ((val == "false")||(val == "0"))
			val="";
	}

	if (val){
		val="1";
		this.cell.chstate="1";
	} else {
		val="0";
		this.cell.chstate="0"
	}
	var obj = this;
	this.cell.setAttribute("excell", "ch");
	this.setCValue("<img src='"+this.grid.imgURL+"item_chk"+val
		+".gif' onclick='new eXcell_ch(this.parentNode).changeState(true); (arguments[0]||event).cancelBubble=true; '>",
		this.cell.chstate);
}
//#}
//#ra_excell:04062008{
/**
*	@desc: radio editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ra(cell){
	this.base=eXcell_ch;
	this.base(cell)
	this.grid=cell.parentNode.grid;

	this.disabledF=function(fl){
		if ((fl == true)||(fl == 1))
			this.cell.innerHTML=this.cell.innerHTML.replace("radio_chk0.", "radio_chk0_dis.").replace("radio_chk1.",
				"radio_chk1_dis.");
		else
			this.cell.innerHTML=this.cell.innerHTML.replace("radio_chk0_dis.", "radio_chk0.").replace("radio_chk1_dis.",
				"radio_chk1.");
	}

	this.changeState=function(mode){
		if (mode===false && this.getValue()==1) return;

		if ((!this.grid.isEditable)||(this.cell.parentNode._locked)||(this.isDisabled()))
			return;

		if (this.grid.callEvent("onEditCell", [
			0,
			this.cell.parentNode.idd,
			this.cell._cellIndex
		]) != false){
			this.val=this.getValue()

			if (this.val == "1")
				this.setValue("0")
			else
				this.setValue("1")
			this.cell.wasChanged=true;
			//nb:
			this.grid.callEvent("onEditCell", [
				1,
				this.cell.parentNode.idd,
				this.cell._cellIndex
			]);

			this.grid.callEvent("onCheckbox", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);

			this.grid.callEvent("onCheck", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
			]);
		} else { //preserve editing (not tested thoroughly for this editor)
			this.editor=null;
		}
	}
	this.edit=null;
}
eXcell_ra.prototype=new eXcell_ch;
eXcell_ra.prototype.setValue=function(val){
	this.cell.style.verticalAlign="middle"; //nb:to center checkbox in line

	if (val){
		val=val.toString()._dhx_trim();

		if ((val == "false")||(val == "0"))
			val="";
	}

	if (val){
		if (!this.grid._RaSeCol)
			this.grid._RaSeCol=[];

		if (this.grid._RaSeCol[this.cell._cellIndex]){
			var z = this.grid.cells(this.grid._RaSeCol[this.cell._cellIndex], this.cell._cellIndex);
			z.setValue("0")
			if (this.grid.rowsAr[z.cell.parentNode.idd])
			this.grid.callEvent("onEditCell", [
				1,
				z.cell.parentNode.idd,
				z.cell._cellIndex
			]);
		}

		this.grid._RaSeCol[this.cell._cellIndex]=this.cell.parentNode.idd;

		val="1";
		this.cell.chstate="1";
	} else {
		val="0";
		this.cell.chstate="0"
	}
	this.cell.setAttribute("excell", "ra");
	this.setCValue("<img src='"+this.grid.imgURL+"radio_chk"+val+".gif' onclick='new eXcell_ra(this.parentNode).changeState(false);'>",
		this.cell.chstate);
}
//#}
//#txt_excell:04062008{
/**
*	@desc: multilene popup editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_txt(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
		this.val=this.getValue()
		this.obj=document.createElement("TEXTAREA");
		this.obj.className="dhx_textarea";

		this.obj.onclick=function(e){
			(e||event).cancelBubble=true
		}
		var arPos = this.grid.getPosition(this.cell); //,this.grid.objBox

		this.obj.value=this.val;

		this.obj.style.display="";
		this.obj.style.textAlign=this.cell.style.textAlign;

		document.body.appendChild(this.obj); //nb:
		if(_isOpera) this.obj.onkeypress=function(ev){ if (ev.keyCode == 9||ev.keyCode == 27) return false; }
		this.obj.onkeydown=function(e){
			var ev = (e||event);

			if (ev.keyCode == 9||ev.keyCode == 27){
				globalActiveDHTMLGridObject.entBox.focus();
				globalActiveDHTMLGridObject.doKey({
					keyCode: ev.keyCode,
					shiftKey: ev.shiftKey,
					srcElement: "0"
					});

				return false;
			}
		}

		this.obj.style.left=arPos[0]+"px";
		this.obj.style.top=arPos[1]+this.cell.offsetHeight+"px";

		if (this.cell.offsetWidth < 200)
			var pw = 200;
		else
			var pw = this.cell.offsetWidth;
		this.obj.style.width=pw+16+"px"

		if (_isIE) { this.obj.select(); this.obj.value=this.obj.value; }//dzen of IE
		this.obj.focus()
	}
	this.detach=function(){
		var a_val = "";

		a_val=this.obj.value;

		if (a_val == ""){
			this.cell._clearCell=true;
		}
		else
			this.cell._clearCell=false;
		this.setValue(a_val);
		document.body.removeChild(this.obj);
		this.obj=null;
		return this.val != this.getValue();
	}
	this.getValue=function(){
		if (this.obj){
			return this.obj.value;
		}
				
		if (this.cell._clearCell)
			return "";

		if (typeof this.cell._brval != "undefined") return this.cell._brval;

		if ((!this.grid.multiLine))
			return this.cell._brval||this.cell.innerHTML;
		else
			return this.cell._brval||this.cell.innerHTML.replace(/<br[^>]*>/gi, "\n")._dhx_trim(); //innerText;
	}
}

eXcell_txt.prototype=new eXcell;

/**
*	@desc: multiline text editor without HTML support
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_txttxt(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.getValue=function(){
		if ((this.cell.firstChild)&&(this.cell.firstChild.tagName == "TEXTAREA"))
			return this.cell.firstChild.value;

		if (this.cell._clearCell)
			return "";

		if ((!this.grid.multiLine)&&this.cell._brval)
			return this.cell._brval;

		return (_isIE ? this.cell.innerText : this.cell.textContent);
	}
	this.setValue=function(val){
		this.cell._brval=val;

		if (!val||val.toString()._dhx_trim() == ""){
			val=" ";
			this.cell._clearCell=true;
		} else
			this.cell._clearCell=false;
		this.setCTxtValue(val);
	}
}

eXcell_txttxt.prototype=new eXcell_txt;

eXcell_txt.prototype.setValue=function(val){
	this.cell._brval=val;

	if (!val||val.toString()._dhx_trim() == ""){
		val="&nbsp;"
		this.cell._clearCell=true;
	} else
		this.cell._clearCell=false;

	if ((!this.grid.multiLine) || this.cell._clearCell)
		this.setCValue(val, this.cell._brval);
	else
		this.setCValue(val.replace(/\n/g, "<br/>"), val);
}
//#}
//#co_excell:04062008{
/**
*	@desc: combobox editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_co(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
		this.combo=(this.cell._combo||this.grid.getCombo(this.cell._cellIndex));
		this.editable=true
	}
	this.shiftNext=function(){
		var z = this.list.options[this.list.selectedIndex+1];

		if (z)
			z.selected=true;
		this.obj.value=this.list.options[this.list.selectedIndex].text;

		return true;
	}
	this.shiftPrev=function(){
		if (this.list.selectedIndex != 0){
			var z = this.list.options[this.list.selectedIndex-1];

			if (z)
				z.selected=true;
			this.obj.value=this.list.options[this.list.selectedIndex].text;
		}

		return true;
	}

	this.edit=function(){
		this.val=this.getValue();
		this.text=this.getText()._dhx_trim();
		var arPos = this.grid.getPosition(this.cell) //,this.grid.objBox)

		this.obj=document.createElement("TEXTAREA");
		this.obj.className="dhx_combo_edit";

		this.obj.style.height=(this.cell.offsetHeight-(this.grid.multiLine ? 9 : 4))+"px";

		this.obj.wrap="soft";
		this.obj.style.textAlign=this.cell.style.textAlign;
		this.obj.onclick=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.onmousedown=function(e){
			(e||event).cancelBubble=true
		}
		this.obj.value=this.text
		this.obj.onselectstart=function(e){
			if (!e)
				e=event;
			e.cancelBubble=true;
			return true;
		};
		var editor_obj = this;
		this.obj.onkeyup=function(e){
			var key=(e||event).keyCode;
			if (key==38 || key==40 || key==9) return;
			var val = this.readonly ? String.fromCharCode(key) : this.value;
			
			var c = editor_obj.list.options;

			for (var i = 0; i < c.length; i++)
				if (c[i].text.indexOf(val) == 0)
					return c[i].selected=true;
		}
		this.list=document.createElement("SELECT");

		this.list.className='dhx_combo_select';
		this.list.style.width=this.cell.offsetWidth+"px";
		this.list.style.left=arPos[0]+"px";                       //arPos[0]
		this.list.style.top=arPos[1]+this.cell.offsetHeight+"px"; //arPos[1]+this.cell.offsetHeight;
		this.list.onclick=function(e){
			var ev = e||window.event;
			var cell = ev.target||ev.srcElement

			//tbl.editor_obj.val=cell.combo_val;
			if (cell.tagName == "OPTION")
				cell=cell.parentNode;
			//editor_obj.list.value = cell.value;
			editor_obj.editable=false;
			editor_obj.grid.editStop();
			ev.cancelBubble = true;
		}
		var comboKeys = this.combo.getKeys();
		var fl = false
		var selOptId = 0;

		for (var i = 0; i < comboKeys.length; i++){
			var val = this.combo.get(comboKeys[i])
			this.list.options[this.list.options.length]=new Option(val, comboKeys[i]);

			if (comboKeys[i] == this.val){
				selOptId=this.list.options.length-1;
				fl=true;
			}
		}

		if (fl == false){ //if no such value in combo list
			this.list.options[this.list.options.length]=new Option(this.text, this.val === null ? "" : this.val);
			selOptId=this.list.options.length-1;
		}
		document.body.appendChild(this.list) //nb:this.grid.objBox.appendChild(this.listBox);
		this.list.size="6";
		this.cstate=1;

		if (this.editable){
			this.cell.innerHTML="";
		}
		else {
			this.obj.style.width="0px";
			this.obj.style.height="0px";
		}
		this.cell.appendChild(this.obj);
		this.list.options[selOptId].selected=true;

		//fix for coro - FF scrolls grid in incorrect position
		if (this.editable){
			this.obj.focus();
			this.obj.focus();
		}

		if (!this.editable){
			this.obj.style.visibility="hidden";
			this.obj.style.position="absolute";
			this.list.focus();
			this.list.onkeydown=function(e){
				e=e||window.event;
				editor_obj.grid.setActive(true)

				if (e.keyCode < 30)
					return editor_obj.grid.doKey({
						target: editor_obj.cell,
						keyCode: e.keyCode,
						shiftKey: e.shiftKey,
						ctrlKey: e.ctrlKey
						})
			}
		}
	}

	this.getValue=function(){
		return ((this.cell.combo_value == window.undefined) ? "" : this.cell.combo_value);
	}
	this.detach=function(){
		if (this.val != this.getValue()){
			this.cell.wasChanged=true;
		}

		if (this.list.parentNode != null){
			if (this.editable){
					var ind = this.list.options[this.list.selectedIndex]
					if (ind&&ind.text == this.obj.value)
						this.setValue(this.list.value)
					else{
						var combo=(this.cell._combo||this.grid.getCombo(this.cell._cellIndex));
						var val=combo.values._dhx_find(this.obj.value);
						if (val!=-1) this.setValue(combo.keys[val]);
						else this.setValue(this.cell.combo_value=this.obj.value);
					}
			}
			else
				this.setValue(this.list.value)
		}

		if (this.list.parentNode)
			this.list.parentNode.removeChild(this.list);

		if (this.obj.parentNode)
			this.obj.parentNode.removeChild(this.obj);

		return this.val != this.getValue();
	}
}
eXcell_co.prototype=new eXcell;
eXcell_co.prototype.getText=function(){
	return this.cell.innerHTML;
}
eXcell_co.prototype.setValue=function(val){
	if (typeof (val) == "object"){
		var optCol = dhx4.ajax.xpath("./option", val);

		if (optCol.length)
			this.cell._combo=new dhtmlXGridComboObject();

		for (var j = 0;
			j < optCol.length;
			j++)this.cell._combo.put(optCol[j].getAttribute("value"),
			optCol[j].firstChild
				? optCol[j].firstChild.data
				: "");
		val=val.firstChild.data;
	}

	if ((val||"").toString()._dhx_trim() == "")
		val=null
	this.cell.combo_value=val;
	
	if (val !== null){
		var label = (this.cell._combo||this.grid.getCombo(this.cell._cellIndex)).get(val);
		this.setCValue(label===null?val:label, val);
	}else
		this.setCValue("&nbsp;", val);

	
}
/**
*	@desc: selectbox editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_coro(cell){
	this.base=eXcell_co;
	this.base(cell)
	this.editable=false;
}
eXcell_coro.prototype=new eXcell_co;

function eXcell_cotxt(cell){
	this.base=eXcell_co;
	this.base(cell)
}
eXcell_cotxt.prototype=new eXcell_co;
eXcell_cotxt.prototype.getText=function(){
	return (_isIE ? this.cell.innerText : this.cell.textContent);
}
eXcell_cotxt.prototype.setValue=function(val){
	if (typeof (val) == "object"){
		var optCol = dhx4.ajax.xpath("./option", val);

		if (optCol.length)
			this.cell._combo=new dhtmlXGridComboObject();

		for (var j = 0;
			j < optCol.length;
			j++)this.cell._combo.put(optCol[j].getAttribute("value"),
			optCol[j].firstChild
				? optCol[j].firstChild.data
				: "");
		val=val.firstChild.data;
	}

	if ((val||"").toString()._dhx_trim() == "")
		val=null

	if (val !== null)
		this.setCTxtValue((this.cell._combo||this.grid.getCombo(this.cell._cellIndex)).get(val)||val, val);
	else
		this.setCTxtValue(" ", val);

	this.cell.combo_value=val;
}

function eXcell_corotxt(cell){
	this.base=eXcell_co;
	this.base(cell)
	this.editable=false;
}
eXcell_corotxt.prototype=new eXcell_cotxt;
//#}

//#cp_excell:04062008{
/**
*	@desc: color picker editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_cp(cell){
	try{
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	catch (er){}
	this.edit=function(){
		this.val=this.getValue()
		this.obj=document.createElement("SPAN");
		this.obj.style.border="1px solid black";
		this.obj.style.position="absolute";
		var arPos = this.grid.getPosition(this.cell); //,this.grid.objBox
		this.colorPanel(4, this.obj)
		document.body.appendChild(this.obj);          //this.grid.objBox.appendChild(this.obj);
		this.obj.style.left=arPos[0]+"px";
		this.obj.style.zIndex=1000;
		this.obj.style.top=arPos[1]+this.cell.offsetHeight+"px";
	}
	this.toolDNum=function(value){
		if (value.length == 1)
			value='0'+value;
		return value;
	}
	this.colorPanel=function(index, parent){
		var tbl = document.createElement("TABLE");
		parent.appendChild(tbl)
		tbl.cellSpacing=0;
		tbl.editor_obj=this;
		tbl.style.cursor="default";
		tbl.onclick=function(e){
			var ev = e||window.event
			var cell = ev.target||ev.srcElement;
			var ed = cell.parentNode.parentNode.parentNode.editor_obj
			if (ed){
				ed.setValue(cell._bg);
				ed.grid.editStop();
			}
		}
		var cnt = 256 / index;
		for (var j = 0; j <= (256 / cnt); j++){
			var r = tbl.insertRow(j);

			for (var i = 0; i <= (256 / cnt); i++){
				for (var n = 0; n <= (256 / cnt); n++){
					R=new Number(cnt*j)-(j == 0 ? 0 : 1)
					G=new Number(cnt*i)-(i == 0 ? 0 : 1)
					B=new Number(cnt*n)-(n == 0 ? 0 : 1)
					var rgb =
						this.toolDNum(R.toString(16))+""+this.toolDNum(G.toString(16))+""+this.toolDNum(B.toString(16));
					var c = r.insertCell(i);
					c.width="10px";
					c.innerHTML="&nbsp;"; //R+":"+G+":"+B;//
					c.title=rgb.toUpperCase()
					c.style.backgroundColor="#"+rgb
					c._bg="#"+rgb;

					if (this.val != null&&"#"+rgb.toUpperCase() == this.val.toUpperCase()){
						c.style.border="2px solid white"
					}
				}
			}
		}
	}
	this.getValue=function(){
		return this.cell.firstChild._bg||""; //this.getBgColor()
	}
	this.getRed=function(){
		return Number(parseInt(this.getValue().substr(1, 2), 16))
	}
	this.getGreen=function(){
		return Number(parseInt(this.getValue().substr(3, 2), 16))
	}
	this.getBlue=function(){
		return Number(parseInt(this.getValue().substr(5, 2), 16))
	}
	this.detach=function(){
		if (this.obj.offsetParent != null)
			document.body.removeChild(this.obj);
		//this.obj.removeNode(true)
		return this.val != this.getValue();
	}
}
eXcell_cp.prototype=new eXcell;
eXcell_cp.prototype.setValue=function(val){
    this.setCValue("<div style='width:100%;height:"+((this.grid.multiLine?"100%":23))+";background-color:"+(val||"")
		+";border:0px;'>&nbsp;</div>",
		val);
	this.cell.firstChild._bg=val;
}
//#}

//#img_excell:04062008{
/**
*	@desc: image editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
/*
	The corresponding  cell value in XML should be a "^" delimited list of following values:
	1st - image src
	2nd - image alt text (optional)
	3rd - link (optional)
	4rd - target (optional, default is _self)
*/
function eXcell_img(cell){
	try{
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	catch (er){}
	this.getValue=function(){
		if (this.cell.firstChild.tagName == "IMG")
			return this.cell.firstChild.src+(this.cell.titFl != null
				? "^"+this.cell._brval
				: "");
			else if (this.cell.firstChild.tagName == "A"){
			var out = this.cell.firstChild.firstChild.src+(this.cell.titFl != null ? "^"+this.cell._brval : "");
			out+="^"+this.cell.lnk;

			if (this.cell.trg)
				out+="^"+this.cell.trg
			return out;
		}
	}
	this.isDisabled=function(){
		return true;
	}
}
eXcell_img.prototype=new eXcell;
eXcell_img.prototype.getTitle=function(){
	return this.cell._brval
}
eXcell_img.prototype.setValue=function(val){
	var title = val;

	if ((val||"").indexOf("^") != -1){
		var ar = val.split("^");
		val=ar[0]
		title=this.cell._attrs.title||ar[1];

		//link
		if (ar.length > 2){
			this.cell.lnk=ar[2]

			if (ar[3])
				this.cell.trg=ar[3]
		}
		this.cell.titFl="1";
	}
	if (!this.grid.multiLine)
		this.setCValue("<img src='"+this.grid.iconURL+(val||"")._dhx_trim()+"' border='0' style='max-height:"+(this.grid._srdh-4)+"px'>", val);
	else
		this.setCValue("<img src='"+this.grid.iconURL+(val||"")._dhx_trim()+"' border='0'>", val);

	if (this.cell.lnk){
		this.cell.innerHTML="<a href='"+this.cell.lnk+"' target='"+this.cell.trg+"'>"+this.cell.innerHTML+"</a>"
	}
	this.cell._brval=title;
}
function eXcell_icon(cell){
	this.base=eXcell_ed;
	this.base(cell)
	try{
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	catch (er){}

	this.setValue=function(val){
		this.cell._raw_value = val;
		this.setCValue('<div class="dhx_grid_icon"><i class="fa fa-'+val.toString()._dhx_trim()+'"></i></div>');
	}
	this.getValue=function(){
		return this.cell._raw_value;
	}
	this.isDisabled=function(){
		return true;
	}
}
eXcell_icon.prototype=new eXcell_ed;
//#}

//#price_excell:04062008{
/**
*	@desc: text editor with price (USD) formatting
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_price(cell){
	this.base=eXcell_ed;
	this.base(cell)
	this.getValue=function(){
		if (this.cell.childNodes.length > 1)
			return this.cell.childNodes[1].innerHTML.toString()._dhx_trim()
		else
			return "0";
	}
}

eXcell_price.prototype=new eXcell_ed;
eXcell_price.prototype.setValue=function(val){
	if (isNaN(parseFloat(val))){
		val=this.val||0;
	}
	var color = "green";

	if (val < 0)
		color="red";

	this.setCValue("<span>$</span><span style='padding-right:2px;color:"+color+";'>"+val+"</span>", val);
}
//#}

//#dyn_excells:04062008{
/**
*	@desc: text editor with additional formatting for positive and negative numbers (arrow down/up and color)
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_dyn(cell){
	this.base=eXcell_ed;
	this.base(cell)
	this.getValue=function(){
		if (!this.cell.firstChild.childNodes[1]) return "";
		var value = this.cell.firstChild.childNodes[1].innerHTML.toString()._dhx_trim()
		var k = this.grid._aplNFb(value, this.cell._cellIndex);
		if (isNaN(Number(k))) {
			return value;
		}
		return k;
	}
}

eXcell_dyn.prototype=new eXcell_ed;
eXcell_dyn.prototype.getValue=function(){
	var value = eXcell_ed.prototype.getValue.call(this);
	return 
	
}
eXcell_dyn.prototype.setValue=function(val){
	if (!val||isNaN(Number(val))){
		if (val!=="")
			val=0;
	} else {
		if (val > 0){
			var color = "green";
			var img = "dyn_up.gif";
		} else if (val == 0){
			var color = "black";
			var img = "dyn_.gif";
		} else {
			var color = "red";
			var img = "dyn_down.gif";
		}
		val = this.grid._aplNF(val, this.cell._cellIndex);
	}

	this.setCValue("<div class='grid_cell_dyn'><img src='"+this.grid.imgURL+""+img
		+"'><span style='color:"+color+";'>"+val
		+"</span></div>",
		val);
}
//#}

/**
*	@desc: readonly editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_ro(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.getValue=function(){
		return this.cell._clearCell?"":this.cell.innerHTML.toString()._dhx_trim();
	}
}
eXcell_ro.prototype=new eXcell;


window.eXcell_hidden = function(cell){
	if (cell){
		this.cell=cell;
		this.grid=this.cell.parentNode.grid;
	}
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.getValue=function(){
		return this.cell.val;
	}
}
eXcell_hidden.prototype=new eXcell;
eXcell_hidden.prototype.setValue = function(value){
	this.cell.val = value;
}

function eXcell_ron(cell){
	this.cell=cell;
	this.grid=this.cell.parentNode.grid;
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.getValue=function(){
		return this.cell._clearCell?"":this.cell._orig_value||this.grid._aplNFb(this.cell.innerHTML.toString()._dhx_trim(), this.cell._cellIndex).toString();
	}
}
eXcell_ron.prototype=new eXcell;
eXcell_ron.prototype.setValue=function(val){ 
	if (val === 0){}
	else if (!val||val.toString()._dhx_trim() == ""){
		this.setCValue("&nbsp;");
		return this.cell._clearCell=true;
	}
	this.cell._orig_value = val;
	this.cell._clearCell=false;
	this.setCValue(val?this.grid._aplNF(val, this.cell._cellIndex):"0");
}


/**
*	@desc: readonly pure text editor (without HTML support)
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_rotxt(cell){
	this.cell=cell;
	this.grid=this.cell.parentNode.grid;
	this.edit=function(){
	}

	this.isDisabled=function(){
		return true;
	}
	this.setValue=function(val){
		if (!val){
			val=" ";
			this.cell._clearCell = true;
		}
		else
			this.cell._clearCell = false;
			
		this.setCTxtValue(val);
	}
	this.getValue=function(){
		if (this.cell._clearCell)
			return "";
		return (_isIE ? this.cell.innerText : this.cell.textContent);
	}	
}
eXcell_rotxt.prototype=new eXcell;

/**
	*	@desc: combobox object constructor (shouldn't be accessed directly - instead please use getCombo(...) method of the grid)
	*	@type: private
	*	@returns: combobox for dhtmlxGrid
	*/
function dhtmlXGridComboObject(){
	this.keys=new dhtmlxArray();
	this.values=new dhtmlxArray();
	/**
	*	@desc: puts new combination of key and value into combobox
	*	@type: public
	*	@param: key - object to use as a key (should be a string in the case of combobox)
	*	@param: value - object value of combobox line
	*/
	this.put=function(key, value){
		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] == key){
				this.values[i]=value;
				return true;
			}
		}
		this.values[this.values.length]=value;
		this.keys[this.keys.length]=key;
	}
	/**
	*	@desc: gets value corresponding to the given key
	*	@type: public
	*	@param: key - object to use as a key (should be a string in the case of combobox)
	*	@returns: value correspond. to given key or null if no such key
	*/
	this.get=function(key){
		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] == key){
				return this.values[i];
			}
		}
		return null;
	}
	/**
	*	@desc: clears combobox
	*	@type: public
	*/
	this.clear=function(){
		/*for(var i=0;i<this.keys.length;i++){
				this.keys._dhx_removeAt(i);
				this.values._dhx_removeAt(i);
		}*/
		this.keys=new dhtmlxArray();
		this.values=new dhtmlxArray();
	}
	/**
	*	@desc: remove pair of key-value from combobox with given key 
	*	@type: public
	*	@param: key - object to use as a key
	*/
	this.remove=function(key){
		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] == key){
				this.keys._dhx_removeAt(i);
				this.values._dhx_removeAt(i);
				return true;
			}
		}
	}
	/**
	*	@desc: gets the size of combobox 
	*	@type: public
	*	@returns: current size of combobox
	*/
	this.size=function(){
		var j = 0;

		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] != null)
				j++;
		}
		return j;
	}
	/**
	*	@desc: gets array of all available keys present in combobox
	*	@type: public
	*	@returns: array of all available keys
	*/
	this.getKeys=function(){
		var keyAr = new Array(0);

		for (var i = 0; i < this.keys.length; i++){
			if (this.keys[i] != null)
				keyAr[keyAr.length]=this.keys[i];
		}
		return keyAr;
	}

	/**
	*	@desc: save curent state
	*	@type: public
	*/
	this.save=function(){
		this._save=new Array();

		for (var i = 0; i < this.keys.length; i++)this._save[i]=[
			this.keys[i],
			this.values[i]
		];
	}


	/**
	*	@desc: restore saved state
	*	@type: public
	*/
	this.restore=function(){
		if (this._save){
			this.keys[i]=new Array();
			this.values[i]=new Array();

			for (var i = 0; i < this._save.length; i++){
				this.keys[i]=this._save[i][0];
				this.values[i]=this._save[i][1];
			}
		}
	}
	return this;
}

function Hashtable(){
	this.keys=new dhtmlxArray();
	this.values=new dhtmlxArray();
	return this;
}
Hashtable.prototype=new dhtmlXGridComboObject;

//(c)dhtmlx ltd. www.dhtmlx.com
if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype.attachGrid = function(config) {
		
		this.callEvent("_onBeforeContentAttach",["grid"]);
		
		var obj = document.createElement("DIV");
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.style.position = "relative";
		obj.style.overflow = "hidden";
		this._attachObject(obj);
		
		this.dataType = "grid";
		if (config && typeof config === "object" && !config.tagName){
			config.parent = obj;
			obj = config;
		}
		this.dataObj = new dhtmlXGridObject(obj);
		this.dataObj.setSkin(this.conf.skin);
		
		// fix for grid atatched to tabbar for safari on ios 5.1.7
		if (typeof(window.dhtmlXTabBarCell) == "function" && this instanceof window.dhtmlXTabBarCell && navigator.userAgent.match(/7[\.\d]* mobile/gi) != null && navigator.userAgent.match(/AppleWebKit/gi) != null) {
			this.dataObj.objBox.style.webkitOverflowScrolling = "auto";
		}
		
		// fix layout cell for material
		if (this.conf.skin == "material" && typeof(window.dhtmlXLayoutCell) == "function" && this instanceof window.dhtmlXLayoutCell) {
			this.cell.childNodes[this.conf.idx.cont].style.overflow = "hidden";
		}
		
		
		// keep border for window and remove for other
		if (this.conf.skin == "dhx_skyblue" && typeof(window.dhtmlXWindowsCell) == "function" && this instanceof window.dhtmlXWindowsCell) {
			this.dataObj.entBox.style.border = "1px solid #a4bed4";
			this.dataObj._sizeFix = 0;
		} else {
			this.dataObj.entBox.style.border = "0px solid white";
			this.dataObj._sizeFix = 2;
		}
		
		obj = null;
		
		this.callEvent("_onContentAttach",[]);
		
		return this.dataObj;
	};
	
}

;
///<jscompress sourcefile="dhtmlxgrid_rowspan.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: set rowspan with specified length starting from specified cell
*   @param: rowID - row Id
*	@param: colInd - column index
*	@param: length - length of rowspan
*	@edition: professional
*   @type:  public
*/

/**
* 修复数据行中同时存在合并行合并列时合并异常的问题
*/
dhtmlXGridObject.prototype.setRowspan = function (rowID, colInd, length) {
    if (length == 1) {
        return;
    }
    var c = this[this._bfs_cells ? "_bfs_cells" : "cells"](rowID, colInd).cell;
    var r = this.rowsAr[rowID];

    if (c.rowSpan && c.rowSpan != 1) {
        var ur = r.nextSibling;
        for (var i = 1; i < c.rowSpan; i++) {
            var tc = ur.childNodes[ur._childIndexes[c._cellIndex + 1]]
            var ti = document.createElement("TD");
            ti.innerHTML = "&nbsp;";
            ti._cellIndex = c._cellIndex;
            ti._clearCell = true;
            if (tc)
                tc.parentNode.insertBefore(ti, tc);
            else
                ur.parentNode.appendChild(ti);
            this._shiftIndexes(ur, c._cellIndex, -1);
            ur = ur.nextSibling;
        }
    }

    c.rowSpan = length;
    if (!this._h2)
        r = r.nextSibling || this.rowsCol[this.rowsCol._dhx_find(r) + 1];
    else
        r = this.rowsAr[this._h2.get[r.idd].parent.childs[this._h2.get[r.idd].index + 1].id];

    var kids = [];
    for (var i = 1; i < length; i++) {
        var ct = null;
        for (var j = 0; j < c.colSpan; j++) {
            if (this._fake && !this._realfake)
                ct = this._bfs_cells3(r, colInd + j).cell;
            else
                ct = this.cells3(r, colInd + j).cell;
            this._shiftIndexes(r, c._cellIndex + j, 1);
            if (ct)
                ct.parentNode.removeChild(ct);
        }

        kids.push(r);

        if (!this._h2)
            r = r.nextSibling || this.rowsCol[this.rowsCol._dhx_find(r) + 1];
        else {
            var r = this._h2.get[r.idd].parent.childs[this._h2.get[r.idd].index + 1];
            if (r) r = this.rowsAr[r.id];
        }
    }

    this.rowsAr[rowID]._rowSpan = this.rowsAr[rowID]._rowSpan || {};
    this.rowsAr[rowID]._rowSpan[colInd] = kids;
    if (this._fake && !this._realfake && colInd < this._fake._cCount)
        this._fake.setRowspan(rowID, colInd, length)
}

dhtmlXGridObject.prototype._shiftIndexes=function(r,pos,ind){
		if (!r._childIndexes){
    	r._childIndexes=new Array();
        for (var z=0; z<r.childNodes.length; z++)
            r._childIndexes[z]=z;
		}
		
		for (var z=0; z<r._childIndexes.length; z++)
			if (z>pos)
			    r._childIndexes[z]=Math.max(r._childIndexes[z]-ind, 0);
    
        //纠正_childIndexes
		//for (var i = 0; i < r._childIndexes.length - 1; i++) {
		//    if (r._childIndexes[i + 1] < r._childIndexes[i]) {
		//        r._childIndexes[i] = r._childIndexes[i + 1];
		//    }
		//}
}

/**
*   @desc: enable rowspan in grid
*   @type:  public
*	@edition: professional
*/
dhtmlXGridObject.prototype.enableRowspan=function(){
    this._erspan=true;
	this.enableRowspan=function(){};
	this.attachEvent("onAfterSorting",function(){
		if (this._dload) return; //can't be helped
		for (var i=1; i<this.obj.rows.length; i++)	
		  if (this.obj.rows[i]._rowSpan){
		  	var master=this.obj.rows[i];
		  	for (var kname in master._rowSpan){
			  	var row=master;
				var kids=row._rowSpan[kname];
			  	for (var j=0; j < kids.length; j++) {
			  		if(row.nextSibling)
			  			row.parentNode.insertBefore(kids[j],row.nextSibling);
			  		else 
			  			row.parentNode.appendChild(kids[j]);
			  		if (this._fake){ // split mode
			  		    var frow=this._fake.rowsAr[row.idd];
			  		    var fkid=this._fake.rowsAr[kids[j].idd];
			  		    if(frow.nextSibling)
			  		  	    frow.parentNode.insertBefore(fkid,frow.nextSibling);
			  		    else 
			  			  frow.parentNode.appendChild(fkid);
			  			 this._correctRowHeight(row.idd);
			  		}
			 		row=row.nextSibling;
			  	}
		    }
	  }
	  var t = this.rowsCol.stablesort;
	  this.rowsCol=new dhtmlxArray();
	  this.rowsCol.stablesort=t;
	  
	  for (var i=1; i<this.obj.rows.length; i++)	
	  	this.rowsCol.push(this.obj.rows[i]);
	  
	}) 

	this.attachEvent("onXLE", function (a, b, c, xml) {
	    if (this._srnd) {
	        var renderdeRowsNum = Math.min((this._get_view_size() + (this._srnd_pr || 0)), this.rowsBuffer.length);
	        for (var i = 0; i < renderdeRowsNum; i++) {
	            var row = this.render_row(i);
	            var childs = row.childNodes;
	            for (var j = 0; j < childs.length; j++) {
	                var rowspan = childs[j]._attrs["rowspan"];
	                if ((i + rowspan) >= renderdeRowsNum) {
	                    childs[j]._attrs["total_rowspan"] = rowspan;
	                    rowspan = renderdeRowsNum - i;
	                }
	                if (rowspan > 1) {
	                    this.setRowspan(row.idd, childs[j]._cellIndex, rowspan);
	                }
	            }
	        }
	    }
	    else {
	        for (var i = (xml && xml.pos) || 0; i < this.rowsBuffer.length; i++) {
	            var row = this.render_row(i);
	            var childs = row.childNodes;
	            for (var j = 0; j < childs.length; j++) {
	                if (childs[j]._attrs["rowspan"]) {
	                    this.setRowspan(row.idd, childs[j]._cellIndex, childs[j]._attrs["rowspan"]);
	                }
	            }
	        }
	    }
	});
}

;
///<jscompress sourcefile="dhtmlxgrid_validation.js" />
/*
filename：dhtmlxgrid_validation.js
creater：
date created：2016.11.19
description：校验组件
date modified：2018.04.17
modifier：刘志伟
version：2.3.2.0329
others：
copyright：Copyright @1999-2016, hwkj, All Rights Reserved
*/
var feildLengths = {};
dhtmlxValidation = function () { };
dhtmlxValidation.prototype = {
    trackInput: function (el, rule, callback_error, callback_correct) {
        dhtmlxEvent(el, "keyup", function (e) {
            if (dhtmlxValidation._timer) {
                window.clearTimeout(dhtmlxValidation._timer);
                dhtmlxValidation._timer = null;
            }
            dhtmlxValidation._timer = window.setTimeout(function () {

                if (!dhtmlxValidation.checkInput(el, rule)) {
                    if (!callback_error || callback_error(el, el.value, rule))
                        el.className += " dhtmlx_live_validation_error";
                } else {
                    el.className = el.className.replace(/[ ]*dhtmlx_live_validation_error/g, "");
                    if (callback_correct)
                        callback_correct(el, el.value, rule);
                }

            }, 250);
        });
    },
    checkInput: function (input, rule) {
        return this.checkValue(input.value, rule);
    },
    checkValue: function (id, ind, value, rule, ruleEx, errMsgs) {
        var final_res = {};
        if (!this["is" + rule])
            alert("校验规则不存在: " + rule);
        else {
            final_res = this["is" + rule](id, ind, value, ruleEx, errMsgs);
        }
        return final_res;
    },
    isEmpty: function (id, ind, value, ruleEx, errMsg) {
        var isresult = (value == '');
        return { result: isresult, type: "Error", errMsg: errMsg || "值须为空" };
    },
    isNotEmpty: function (id, ind, value, ruleEx, errMsg) {

        var isresult = (value instanceof Array ? value.length > 0 : !value == ''); // array in case of multiselect
        return { result: isresult, type: "Error", errMsg: errMsg || "值不能为空" };
    },
    isValidBoolean: function (id, ind, value, ruleEx, errMsg) {
        var isresult = !!value.toString().match(/^(0|1|true|false)$/);
        return { result: isresult, type: "Error", errMsg: errMsg || "值须为true或是false" };
    },
    isValidEmail: function (id, ind, value, ruleEx, errMsg) {

        if (value) {
            var isresult = !!value.toString().match(/(^[a-z0-9]([0-9a-z\-_\.]*)@([0-9a-z_\-\.]*)([.][a-z]{3})$)|(^[a-z]([0-9a-z_\.\-]*)@([0-9a-z_\-\.]*)(\.[a-z]{2,4})$)|(^(\/)$)/i);
            return { result: isresult, type: "Error", errMsg: errMsg || "邮箱输入不正确" };
        }
        else {
            return { result: true, type: "Success", errMsg: "" };
        }
    },
    isValidTelePhone: function (id, ind, value, ruleEx, errMsg) {
        if (value) {
            var isresult = !!value.toString().match(/^([0-9]{3,4}[-\s]{0,1})?[0-9]{7,8}$|(^(\/)$)/);
            return { result: isresult, type: "Error", errMsg: errMsg || "电话号码输入不正确！" };
        }
        else {
            return { result: true, type: "Success", errMsg: "" };
        }
    },
    isValidCellPhone: function (id, ind, value, ruleEx, errMsg) {
        if (value) {
            var isresult = !!value.toString().match(/^((\+?86)|(\(\+86\)))?(1[34578]\d{9})$|(^(\/)$)/);
            return { result: isresult, type: "Error", errMsg: errMsg || "手机号码输入不正确！" };
        }
        else {
            return { result: true, type: "Success", errMsg: "" };
        }
    },
    isValidIdCard: function (id, ind, value, ruleEx, errMsg) {
        if (value) {
            var isresult = !!value.toString().match(/^([1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$)|(^[1-9]\d{5}\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{2}$)|(^(\/)$)/);
            return { result: isresult, type: "Error", errMsg: errMsg || "身份证号输入不正确！" };
        }
        else {
            return { result: true, type: "Success", errMsg: "" };
        }
    },
    isValidPostCode: function (id, ind, value, ruleEx, errMsg) {
        if (value) {
            var isresult = !!value.toString().match(/^[1-9]\d{5}(?!\d)|(^(\/)$)/);
            return { result: isresult, type: "Error", errMsg: errMsg || "邮编输入不正确！" };
        }
        else {
            return { result: true, type: "Success", errMsg: "" };
        }
    },
    
    isValidInteger: function (id, ind, value, ruleEx, errMsg) {
        if (value) {
            var isresult = !!value.toString().match(/(^[-|+]?\d+$)|(^(\/)$)/);
            return { result: isresult, type: "Error", errMsg: errMsg || "值须为整数" };
        }
        else {
            return { result: true, type: "Success", errMsg: "" };
        }
    },
    isValidNumeric: function (id, ind, value, ruleEx, errMsg) {
        if (value) {

            var isresult = !!value.toString().match(/(^[-|+]?\d\d*[\.|,]\d*$)|(^[-|+]?\d\d*$)|(^[-|+]?[\.|,]\d\d*$)|(^(\/)$)/);
            return { result: isresult, type: "Error", errMsg: errMsg || "值须为数字" };
        }
        else {
            return { result: true, type: "Success", errMsg: "" };
        }
    },
    isValidAplhaNumeric: function (id, ind, value, ruleEx, errMsg) {
        if (value) {
            var isresult = !!value.toString().match(/^[_\-a-z0-9]+$|(^(\/)$)/gi);
            return { result: isresult, type: "Error", errMsg: errMsg || "值不符合数值规范" };
        }
        else {
            return { result: true, type: "Success", errMsg: "" };
        }
    },
    // 0000-00-00 00:00:00 to 9999-12-31 59:59:59 (no it is not a "valid DATE" function)
    isValidDatetime: function (id, ind, value, ruleEx, errMsg) {
        if (value && value.constructor != Date) {
            //  var dt = value.toString().match(/^(\d{4})-(\d{2})-(\d{2})\s(\d{2}):(\d{2}):(\d{2})$/);
            // var isresult = dt && !!(dt[1] <= 9999 && dt[2] <= 12 && dt[3] <= 31 && dt[4] <= 59 && dt[5] <= 59 && dt[6] <= 59) || false;
            /* update by zhenglingyun in 2015-04-17 15:55*/
            var dt = value.toString().match(/^(\d{4})-(\d{2})-(\d{2})\s(\d{2}):(\d{2})[:(\d{2})]{0,1}$/);
     
            var isresult =true;
            if (dt!=null&&dt.length == 6) {
                isresult = dt && !!(dt[1] <= 9999 && dt[2] <= 12 && dt[3] <= 31 && dt[4] <= 59 && dt[5] <= 59) || false;
            }
            else if (dt != null && dt.length == 7) {
                isresult = dt && !!(dt[1] <= 9999 && dt[2] <= 12 && dt[3] <= 31 && dt[4] <= 59 && dt[5] <= 59 && dt[6] <= 59) || false;
            }
            return { result: isresult, type: "Error", errMsg: errMsg || "值不符合时间规范" };
        }
        else {
            return { result: true, type: "Success", errMsg: "" };
        }
    },
    // 0000-00-00 to 9999-12-31
    isValidDate: function (id, ind, value, ruleEx, errMsg) {
        if (value && value.constructor != Date) {
            var d = value.toString().match(/^(\d{4})-(\d{2})-(\d{2})$/);
            var isresult = d && !!(d[1] <= 9999 && d[2] <= 12 && d[3] <= 31) || false;
            return { result: isresult, type: "Error", errMsg: errMsg || "值不符合日期规范" };
        }
        else {
            return { result: true, type: "Success", errMsg: "" };
        }
    },

    isValidYear: function (id, ind, value, ruleEx, errMsg) {
        if (value && value.constructor != Date) {
            var d = value.toString().replace("-", "").match(/^(\d{4})$/);
            var isresult = d && !!(d[1] <= 9999) || false;
            return { result: isresult, type: "Error", errMsg: errMsg || "值不符合年规范" };
        }
        else {
            return { result: true, type: "Success", errMsg: "" };
        }
    },
    // 0000-00-00 to 9999-12
    isValidYearMouth: function (id, ind, value, ruleEx, errMsg) {
        if (value && value.constructor != Date) {
            var d = value.toString().replace("-", "").match(/^(\d{4})(\d{2})$/);
            var isresult = d && !!(d[1] <= 9999 && d[2] <= 12) || false;
            return { result: isresult, type: "Error", errMsg: errMsg || "值不符合年月规范" };
        }
        else {
            return { result: true, type: "Success", errMsg: "" };
        }
    },
    // 00:00:00 to 59:59:59
    isValidTime: function (id, ind, value, ruleEx, errMsg) {
        if (value && value.constructor != Date) {
            var t = value.toString().match(/^(\d{1,2}):(\d{1,2}):(\d{1,2})$/);
            var isresult = t && !!(t[1] <= 24 && t[2] <= 59 && t[3] <= 59) || false;
            return { result: isresult, type: "Error", errMsg: errMsg || "值不符合时间规范" };
        }
        else {
            return { result: true, type: "Success", errMsg: "" };
        }
    },
    // 0.0.0.0 to 255.255.255.255
    isValidIPv4: function (id, ind, value, ruleEx, errMsg) {
        if (value) {
            var ip = value.toString().match(/^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/);
            var isresult = ip && !!(ip[1] <= 255 && ip[2] <= 255 && ip[3] <= 255 && ip[4] <= 255) || false;
            return { result: isresult, type: "Error", errMsg: errMsg || "值不符合IP地址规范" };
        }
        else {
            return { result: true, type: "Success", errMsg: "" };
        }
    },
    isValidCurrency: function (id, ind, value, ruleEx, errMsg) { // Q: Should I consider those signs valid too ? : ¢|€|₤|₦|¥
        if (value) {
            var isresult = value.toString().match(/^\$?\s?\d+?([\.,\,]?\d+)?\s?\$?$/) && true || false;
            return { result: isresult, type: "Error", errMsg: errMsg || "isValidCurrency" };
        }
        else {
            return { result: true, type: "Success", errMsg: "" };
        }
    },
    // Social Security Number (999-99-9999 or 999999999)
    isValidSSN: function (id, ind, value, ruleEx, errMsg) {
        if (value) {
            var isresult = value.toString().match(/^\d{3}\-?\d{2}\-?\d{4}$/) && true || false;
            return { result: isresult, type: "Error", errMsg: errMsg || "值必须isValidSSN" };
        }
        else {
            return { result: true, type: "Success", errMsg: "" };
        }
    },
    // Social Insurance Number (999999999)
    isValidSIN: function (id, ind, value, ruleEx, errMsg) {
        if (value) {
            var isresult = value.toString().match(/^\d{9}$/) && true || false;
            return { result: isresult, type: "Error", errMsg: errMsg || "值必须isValidSIN" };
        }
        else {
            return { result: true, type: "Success", errMsg: "" };
        }
    },
    isValidLength: function (id, ind, value, ruleEx, errMsg) {
        ruleEx = ruleEx.split(",");
        if (!isNaN(+ruleEx[0]) && !isNaN(+ruleEx[1])) {
            if (value.length <= ruleEx[1] && value.length >= ruleEx[0]) {
                return { result: true, type: "Success", errMsg: "" };
            }
            else {
                return { result: false, type: "Error", errMsg: errMsg || "字符数须不少于 " + ruleEx[0] + " 个并且不多于" + ruleEx[1] + "个，当前共有字符 " + value.length + " 个" };
            }
        }
    },
    isValidLessLength: function (id, ind, value, ruleEx, errMsg) {
        if (!isNaN(+ruleEx)) {
            var length = +ruleEx;
            if (value.length <= length) {
                return { result: true, type: "Success", errMsg: "" };
            }
            else {
                return { result: false, type: "Error", errMsg: errMsg || "字符数须不多于 " + length + " 个，当前共有字符 " + value.length + " 个" };
            }
        }
    },
    isValidGreaterLength: function (id, ind, value, ruleEx, errMsg) {
		return { result: true, type: "Success", errMsg: "" };
        if (!isNaN(+ruleEx)) {
            var length = +ruleEx;
            if (value.length >= length) {
                return { result: true, type: "Success", errMsg: "" };
            }
            else {
                return { result: false, type: "Error", errMsg: errMsg || "字符数须不少于" + length + " 个，当前共有字符 " + value.length + " 个" };
            }
        }
    },
    isValidRegExp: function (id, ind, value, ruleEx, errMsg) {
        if (ruleEx && ruleEx.length > 0) {
            ruleEx = ruleEx._dhx_trim();
            var regExp;
            if (ruleEx.indexOf("/") === 0) {
                regExp = eval(ruleEx);
            }
            else {
                regExp = new RegExp(ruleEx);
            }
            
            var res = regExp.test(value);
            var ress = { result: res, type: (res ? "Success" : "Error"), errMsg: errMsg || (res ? "" : "数据格式不正确") };
            return ress;
        }
        return { result: false, type: "Error", errMsg: "正则表达式不存在！" }
    },
    /*数字校验： 大于等于指定值*/
    isValidMoreThan: function (id, ind, value, ruleEx, errMsg) {
        var res = false;
        if (ruleEx && ruleEx.length > 0) {
            if (isNaN(ruleEx)) {
                res = true;
            } else if (!isNaN(value)) {
                if (+value >= +ruleEx) {
                    res = true;
                }
            }
            var ress = { result: res, type: (res ? "Success" : "Error"), errMsg: errMsg || (res ? "" : "值应大于等于 " + ruleEx) };
            return ress;
        }
    },
    /*数字校验： 小于等于指定值*/
    isValidLessThan: function (id, ind, value, ruleEx, errMsg) {
        var res = false;
        if (ruleEx && ruleEx.length > 0) {
            if (isNaN(ruleEx)) {
                res = true;
            } else if (!isNaN(value)) {
                if (+value <= +ruleEx) {
                    res = true;
                }
            }
            var ress = { result: res, type: (res ? "Success" : "Error"), errMsg: errMsg || (res ? "" : "值应小于等于 " + ruleEx) };
            return ress;
        }
    },
    /*数字校验： 小数位数*/
    isValidDecimal: function (id, ind, value, ruleEx, errMsg) {
        var res = false;
        if (ruleEx && ruleEx.length > 0) {
            var arr = value.split(".");
            if (arr.length == 2) {
                if (value.split(".")[1].length <= +ruleEx) {
                    res = true;
                }
            } else if (arr.length == 1) {
                res = true;
            }
            var ress = { result: res, type: (res ? "Success" : "Error"), errMsg: errMsg || (res ? "" : "小数位最多精确到第 " + ruleEx + " 位") };
            return ress;
        }
    }

};
dhtmlxValidation = new dhtmlxValidation();
//extension for the grid
dhtmlXGridObject.prototype.enableValidation = function (mode, live) {
    mode = convertStringToBoolean(mode);
    if (mode) {
        this._validators = { data: [] };
    } else
        this._validators = false;

    if (arguments.length > 1)
        this._validators._live = live;
    if (!this._validators._event)
        this._validators._event = this.attachEvent("onEditCell", this.validationEvent);

};
dhtmlXGridObject.prototype.setColValidators = function (vals) {
    if (this.isRowNumber) {
        if (vals instanceof Array) {
            vals.splice(0, 0, "");
        }
        if (typeof vals == "string") {
            vals = "," + vals
        }
    }
    if (!this._validators) this.enableValidation(true);
    if (typeof vals == "string") vals = vals.split(this.delim);
    this._validators.data = vals;
};
dhtmlXGridObject.prototype.validationEvent = function (stage, id, ind, newval, oldval) {

    var v = this._validators;
    if (!v) return true; // validators disabled
    var rule = (v.data[ind] || this.cells(id, ind).getAttribute("validate")) || "";

    if (stage == 1 && rule) {
        var ed = this.editor || (this._fake || {}).editor;
        if (!ed) return true; //event was trigered by checkbox
        ed.cell.className = ed.cell.className.replace(/[ ]*dhtmlx_validation_error/g, "");

        //mafei 20150127 numeric only input numeric
        if (rule && (rule.toLowerCase() == "validnumeric")) {
            var cell_keypressLimit = function (ob) {
                if (typeof (window.addEventListener) == "function") {
                    ed.obj.addEventListener("keyup", function () {
                        ob.t_value = ob.t_value || "";
                        if (!ob.value.match(/^[\+\-]?\d*?\.?\d*?$/)) ob.value = ob.t_value;
                        else ob.t_value = ob.value;
                        if (ob.value.match(/^(?:[\+\-]?\d+(?:\.\d+)?)?$/)) ob.o_value = ob.value;

                    }, false);
                } else {
                    ed.obj.attachEvent("onkeyup", function () {
                        ob.t_value = ob.t_value || "";
                        if (!ob.value.match(/^[\+\-]?\d*?\.?\d*?$/)) ob.value = ob.t_value;
                        else ob.t_value = ob.value;
                        if (ob.value.match(/^(?:[\+\-]?\d+(?:\.\d+)?)?$/)) ob.o_value = ob.value;
                    })
                }

            }
            if (ed.obj && !ed.obj._keypressLimit) {

                ed.obj._keypressLimit = cell_keypressLimit;
                cell_keypressLimit(ed.obj);
            }

        }

        if (v._live) {
            var grid = this;
            dhtmlxValidation.trackInput(ed.getInput(), rule, function (element, value, rule) {
                return grid.callEvent("onLiveValidationError", [id, ind, value, element, rule]);
            }, function (element, value, rule) {
                return grid.callEvent("onLiveValidationCorrect", [id, ind, value, element, rule]);
            });
        }
    }

    if (stage == 2)
        this.validateCell(id, ind, rule, newval);

    return true;
};

dhtmlXGridObject.prototype.validateCell = function (id, ind, rule, value, ruleEx, errMsgs) {
    rule = rule || (this._validators.data[ind] || this.cells(id, ind).getAttribute("validate"));
    value = value || this.cells(id, ind).getValue();
    if (!rule) return;
    var cell = this.cells(id, ind).cell;
    var result = dhtmlxValidation.checkValue(id, ind, value, rule, ruleEx, errMsgs);

    if (result.result) {
        this.callEvent("onValidationCorrect", [id, ind, value]);
        cell.className = cell.className.replace(/[ ]*dhtmlx_validation_error1/g, "");
    }
    else {
        if (this.callEvent("onValidationError", [id, ind, value, result, rule])) {
            cell.className += " dhtmlx_validation_error1";
        }
    }
    return result;
};;
///<jscompress sourcefile="dhtmlxgrid_excell_combo.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com  
*/

dhx4.attachEvent("onGridCreated", function(grid){
	if (!window.dhx_globalImgPath) window.dhx_globalImgPath = grid.imgURL;
	
	grid._col_combos = [];
	for (var i=0; i<grid._cCount; i++) {
		if(grid.cellType[i].indexOf("combo") == 0) {
			grid._col_combos[i] = eXcell_combo.prototype.initCombo.call({grid:grid},i);
		}
	}
	
	if (!grid._loading_handler_set) {
		grid._loading_handler_set = grid.attachEvent("onXLE", function(a,b,c,xml,type){
				if (type != "xml") return;
				eXcell_combo.prototype.fillColumnCombos(this,xml);
				this.detachEvent(this._loading_handler_set);
				this._loading_handler_set = null;
		});
	}
});


function eXcell_combo(cell) {
	
	if (!cell) return;
	
	this.cell = cell;
	this.grid = cell.parentNode.grid;
	this._combo_pre = "";
	
	this.edit = function(){
		if (!window.dhx_globalImgPath) window.dhx_globalImgPath = this.grid.imgURL;
		
		this.val = this.getValue();
		var val = this.getText();
		if (this.cell._clearCell) val="";
		this.cell.innerHTML = "";
		
		if (!this.cell._brval) {
			this.combo = (this.grid._realfake?this.grid._fake:this.grid)._col_combos[this.cell._cellIndex];
		} else {
			this.combo = this.cell._brval;
		}
		this.cell.appendChild(this.combo.DOMParent);

		this.combo.DOMParent.style.margin = "0";
		
		this.combo.DOMelem_input.focus();
		this.combo.setSize(this.cell.offsetWidth-2);
		if (!this.combo._xml) {
			if (this.combo.getIndexByValue(this.cell.combo_value)!=-1) {
				this.combo.selectOption(this.combo.getIndexByValue(this.cell.combo_value));
			} else {
				if (this.combo.getOptionByLabel(val)) {
					this.combo.selectOption(this.combo.getIndexByValue(this.combo.getOptionByLabel(val).value));
				} else {
					this.combo.unSelectOption();
				}
			}
		} else {
			this.combo.setComboText(val);
		}
		this.combo.openSelect();
	}
	
	this.selectComboOption = function(val,obj){
		obj.selectOption(obj.getIndexByValue(obj.getOptionByLabel(val).value));
	}
	
	this.getValue = function(val){
		return this.cell.combo_value||"";
	}
	
	this.getText = function(val){
		var c = this.cell;
		if (this._combo_pre == "" && c.childNodes[1]) {
			c = c.childNodes[1];
		} else {
			c.childNodes[0].childNodes[1];
		}
		return (_isIE ? c.innerText : c.textContent);
	}
	
	this.setValue = function(val){
		
		if (typeof(val) == "object"){
			
			this.cell._brval = this.initCombo();
			var index = this.cell._cellIndex;
			var idd = this.cell.parentNode.idd;
			if (!val.firstChild) {
				this.cell.combo_value = "&nbsp;";
				this.cell._clearCell = true;
			} else {
				this.cell.combo_value = val.firstChild.data;
			}
			this.setComboOptions(this.cell._brval, val, this.grid, index, idd);
			
		} else {
			this.cell.combo_value = val;
			var cm = null;
			if ((cm = this.cell._brval) && (typeof(this.cell._brval) == "object")) {
				val = (cm.getOption(val)||{}).text||val;
			} else if (cm = this.grid._col_combos[this.cell._cellIndex]||((this.grid._fake) && (cm = this.grid._fake._col_combos[this.cell._cellIndex]))) {
				val = (cm.getOption(val)||{}).text||val;
			}
			
			if ((val||"").toString()._dhx_trim()=="") val = null;
			
			if (val !== null) {
				this.setComboCValue(val);
			} else {
				this.setComboCValue("&nbsp;", "");
				this.cell._clearCell = true;
			}
		}
	}
	
	this.detach = function(){
		var p = this.combo.getParent();
		if (p.parentNode == this.cell) {
			this.cell.removeChild(p);
		} else {
			return false;
		}
		var val = this.cell.combo_value;
		this.combo._confirmSelect("blur");
		
		if (!this.combo.getComboText() || this.combo.getComboText().toString()._dhx_trim()=="") {
			this.setComboCValue("&nbsp;");
			this.cell._clearCell=true;
		} else {
			this.setComboCValue(this.combo.getComboText().replace(/\&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"),this.combo.getActualValue());
			this.cell._clearCell = false;
		}
		
		this.cell.combo_value = this.combo.getActualValue();
		this.combo.closeAll();
		this.grid._still_active=true;
		this.grid.setActive(1);
		return val!=this.cell.combo_value;
	}
}


eXcell_combo.prototype = new eXcell;
eXcell_combo_v = function(cell){
	var combo = new eXcell_combo(cell);
	combo._combo_pre = "<img src='"+(window.dhx_globalImgPath?window.dhx_globalImgPath:this.grid.imgURL)+"combo_select"+(dhtmlx.skin?"_"+dhtmlx.skin:"")+".gif' class='dhxgrid_combo_icon'/>";
	return combo;
};

eXcell_combo.prototype.initCombo = function(index){
	
	var container = document.createElement("DIV");
	container.className = "dhxcombo_in_grid_parent";
	var type = this.grid.defVal[arguments.length?index:this.cell._cellIndex];
	var combo = new dhtmlXCombo(container, "combo", 0, type);
	this.grid.defVal[arguments.length?index:this.cell._cellIndex] = "";
	
	var grid = this.grid;
	combo.DOMelem.onmousedown = combo.DOMelem.onclick = function(e){
		e = e||event;
		e.cancelBubble = true;
	};
	combo.DOMelem.onselectstart = function(e){
		e = e||event;
		e.cancelBubble = true;
		return true;
	};
	
	this.grid.attachEvent("onScroll", function(){
		if (combo._isListVisible()) combo._hideList();
	});
	
	combo.attachEvent("onKeyPressed",function(ev){
		if (ev==13 || ev==27) {
			grid.editStop();
			if (grid._fake) grid._fake.editStop();
		}
	});
	
	return combo;
	
};

eXcell_combo.prototype.fillColumnCombos = function(grid,xml){
	if (!xml) return;
	var top  = dhx4.ajax.xmltop("rows", xml, -1);
	if (top && top.tagName !== "DIV"){
		grid.combo_columns = grid.combo_columns||[];
		columns = dhx4.ajax.xpath("//column", top);
		for (var i=0; i<columns.length; i++) {
			if ((columns[i].getAttribute("type")||"").indexOf("combo") == 0) {
				grid.combo_columns[grid.combo_columns.length] = i;
				this.setComboOptions(grid._col_combos[i], columns[i], grid, i);
			}
		}
	}
};

eXcell_combo.prototype.setComboCValue = function(value, value2) {
   	if (this._combo_pre != "") {
		var height = (this.cell.offsetHeight?this.cell.offsetHeight+"px":0);
   		value = "<div style='width:100%;position:relative;height:100%;overflow:hidden;'>"+this._combo_pre+"<span>"+value+"</span></div>";
   	}
   	if (arguments.length > 1) {
  		this.setCValue(value,value2);
	} else {
		this.setCValue(value);
	}
};

eXcell_combo.prototype.setComboOptions = function(combo, obj, grid, index, idd) {
	
	if (window.dhx4.s2b(obj.getAttribute("xmlcontent"))) {
		
		if (!obj.getAttribute("source")) {
			options = obj.childNodes;
			var _optArr = [];
			for (var i=0; i < options.length; i++){
				if(options[i].tagName =="option"){
					var text_opt = options[i].firstChild? options[i].firstChild.data:"";
					_optArr[_optArr.length]= [options[i].getAttribute("value"),text_opt, (options[i].getAttribute("css")||"")];
				}
			}
			combo.addOption(_optArr)
			if(arguments.length == 4){
				grid.forEachRowA(function(id){
						var c = grid.cells(id,index);
						if(!c.cell._brval&&!c.cell._cellType&&(c.cell._cellIndex==index)){
							if(c.cell.combo_value=="") c.setComboCValue("&nbsp;","");
							else{
								if(!combo.getOption(c.cell.combo_value))
									c.setComboCValue(c.cell.combo_value);
								else c.setComboCValue(combo.getOption(c.cell.combo_value).text, c.cell.combo_value);
							}
						}
				});	
			}
			else {
				var c = (this.cell)?this:grid.cells(idd,index);
				if(obj.getAttribute("text")) {
					if(obj.getAttribute("text")._dhx_trim()=="") c.setComboCValue("&nbsp;",""); 
					else c.setComboCValue(obj.getAttribute("text")); 
				}
				else{
					if((!c.cell.combo_value)||(c.cell.combo_value._dhx_trim()=="")) c.setComboCValue("&nbsp;","");
					else{
						if(!combo.getOption(c.cell.combo_value))
							c.setComboCValue(c.cell.combo_value);
						else c.setComboCValue(combo.getOption(c.cell.combo_value).text, c.cell.combo_value);
					}
				}
			}
			
		}
	}
	
	if (obj.getAttribute("source")) {
		if (obj.getAttribute("auto") && window.dhx4.s2b(obj.getAttribute("auto"))) {
			
			if (obj.getAttribute("xmlcontent")) {
				var c = (this.cell)?this:grid.cells(idd,index);
				if (obj.getAttribute("text")) c.setComboCValue(obj.getAttribute("text"));
			} else {
				grid.forEachRowA(function(id){
					var c = grid.cells(id,index);
					if (!c.cell._brval && !c.cell._cellType) {
						var str = c.cell.combo_value.toString();
						if (str.indexOf("^") != -1) {
							var arr = str.split("^");
							c.cell.combo_value = arr[0];
							c.setComboCValue(arr[1]);
						}
					}
				});
			}
			combo.enableFilteringMode(true, obj.getAttribute("source"), window.dhx4.s2b(obj.getAttribute("cache")||true), window.dhx4.s2b(obj.getAttribute("sub")||false));
			
		} else {
			
			var that = this;
			var length = arguments.length; 
			combo.load(obj.getAttribute("source"), function(){
				if (length == 4) {
					grid.forEachRow(function(id){
						var c = grid.cells(id,index);
						if (!c.cell._brval && !c.cell._cellType) {
							if (combo.getOption(c.cell.combo_value)) {
								c.setComboCValue(combo.getOption(c.cell.combo_value).text, c.cell.combo_value);
							} else {
								if ((c.cell.combo_value||"").toString()._dhx_trim() == "") {
									c.setComboCValue("&nbsp;","");
									c.cell._clearCell=true;
								} else {
									c.setComboCValue(c.cell.combo_value);
								}
							}
						}
					});
				} else {
					//var c = (that.cell)? that : grid.cells(idd,index);
					var c = grid.cells(idd,index);
					//c.setCValue(obj.getAttribute("text"));
					if (combo.getOption(c.cell.combo_value)) {
						c.setComboCValue(combo.getOption(c.cell.combo_value).text, c.cell.combo_value);
					} else {
						c.setComboCValue(c.cell.combo_value);
					}
				}
			});
			
		}
	}
	if (!obj.getAttribute("auto") || !window.dhx4.s2b(obj.getAttribute("auto"))) {
		if (obj.getAttribute("editable") && !window.dhx4.s2b(obj.getAttribute("editable"))) combo.readonly(true);
		if (obj.getAttribute("filter") && window.dhx4.s2b(obj.getAttribute("filter"))) combo.enableFilteringMode(true);
	}
	
};

eXcell_combo.prototype.getCellCombo = function() {
	
	if (this.cell._brval) return this.cell._brval;
	
	this.cell._brval = this.initCombo();
	return this.cell._brval;
	
};

eXcell_combo.prototype.refreshCell = function() {
	this.setValue(this.getValue());
};

dhtmlXGridObject.prototype.getColumnCombo = function(index) {
	if (this._col_combos && this._col_combos[index]) return this._col_combos[index];
	
	if (!this._col_combos) this._col_combos = [];
	this._col_combos[index] = eXcell_combo.prototype.initCombo.call({grid:this},index);
	return this._col_combos[index];
	
};

dhtmlXGridObject.prototype.refreshComboColumn = function(index) {
	this.forEachRow(function(id){
		if (this.cells(id,index).refreshCell) this.cells(id,index).refreshCell();
	});
};

;
///<jscompress sourcefile="dhtmlxgrid_excell_cntr.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: auto counter editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_cntr(cell){
	this.cell = cell;
    this.grid = this.cell.parentNode.grid;
	if (!this.grid._ex_cntr_ready && !this._realfake){
		this.grid._ex_cntr_ready=true;
		if (this.grid._h2)
			this.grid.attachEvent("onOpenEn",function(id){
				this.resetCounter(cell._cellIndex);
			});
		var fix_cnt = function(){ 
			var that=this;
			window.setTimeout(function(){ 
				if (!that.resetCounter) return;
				if (that._fake && !that._realfake && cell._cellIndex<that._fake._cCount) 
					that._fake.resetCounter(cell._cellIndex); 
				else
				    that.resetCounter(cell._cellIndex);
			},1);
			return true;
		};

		this.grid.attachEvent("onBeforeSorting", fix_cnt);
		this.grid.attachEvent("onFilterEnd", fix_cnt);
	}
	
	

	this.edit = function(){}
	this.getValue = function(){
		return this.cell.innerHTML;
	}
	this.setValue = function(val){
		this.cell.style.paddingRight = "2px";
		var cell=this.cell;
		
		window.setTimeout(function(){
			if (!cell.parentNode) return;
			var val=cell.parentNode.rowIndex;
			if (cell.parentNode.grid.currentPage || val<0 || cell.parentNode.grid._srnd) val=cell.parentNode.grid.rowsBuffer._dhx_find(cell.parentNode)+1;
			if (val<=0) return;
			cell.innerHTML = val;
			if (cell.parentNode.grid._fake && cell._cellIndex<cell.parentNode.grid._fake._cCount && cell.parentNode.grid._fake.rowsAr[cell.parentNode.idd]) cell.parentNode.grid._fake.cells(cell.parentNode.idd,cell._cellIndex).setCValue(val);
			cell=null;
		},100);
	}
}
dhtmlXGridObject.prototype.resetCounter=function(ind){
	if (this._fake && !this._realfake && ind < this._fake._cCount) this._fake.resetCounter(ind,this.currentPage);
	var i=arguments[0]||0;
	if (this.currentPage)
		i=(this.currentPage-1)*this.rowsBufferOutSize;
	for (i=0; i<this.rowsBuffer.length; i++)
		if (this.rowsBuffer[i] && this.rowsBuffer[i].tagName == "TR" && this.rowsAr[this.rowsBuffer[i].idd])
			this.rowsAr[this.rowsBuffer[i].idd].childNodes[ind].innerHTML=i+1;
}
eXcell_cntr.prototype = new eXcell;
//(c)dhtmlx ltd. www.dhtmlx.com

;
///<jscompress sourcefile="dhtmlxgrid_excell_link.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/


/*
HTML Link eXcell v.1.0  for dhtmlxGrid 
(c)DHTMLX LTD. 2005


The corresponding  cell value in XML should be a "^" delimited list of following values:
1st - Link Text 
2nd - URL (optional)
3rd - target (optional, default is _blank)

Samples:
<cell>Stephen King</cell>
<cell>Stephen King^http://www.stephenking.com/</cell>
<cell>Stephen King^http://www.stephenking.com/^_self</cell>
*/

/**
*	@desc: link editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/

function eXcell_link(cell){
	this.cell = cell;
    this.grid = this.cell.parentNode.grid;
    this.isDisabled=function(){return true;}
	this.edit = function(){}
	this.getValue = function(){
		if(this.cell.firstChild.getAttribute){
			var target = this.cell.firstChild.getAttribute("target")
			return this.cell.firstChild.innerHTML+"^"+this.cell.firstChild.getAttribute("href")+(target?("^"+target):"");
		}

		else
			return "";
	}
	this.setValue = function(val){
		if((typeof(val)!="number") && (!val || val.toString()._dhx_trim()=="")){		
			this.setCValue("&nbsp;",valsAr);			
			return (this.cell._clearCell=true);
		}
		var valsAr = val.split("^");
		if(valsAr.length==1)
			valsAr[1] = "";
		else{
			if(valsAr.length>1){
				valsAr[1] = "href='"+valsAr[1]+"'";
				if(valsAr.length==3)
					valsAr[1]+= " target='"+valsAr[2]+"'";
				else
					valsAr[1]+= " target='_blank'";
			}
		}

		this.setCValue("<a "+valsAr[1]+" onclick='(_isIE?event:arguments[0]).cancelBubble = true;'>"+valsAr[0]+"</a>",valsAr);
	}
}

eXcell_link.prototype = new eXcell;
eXcell_link.prototype.getTitle=function(){
	var z=this.cell.firstChild;
	return ((z&&z.tagName)?z.getAttribute("href"):"");
}
eXcell_link.prototype.getContent=function(){
	var z=this.cell.firstChild;
	return ((z&&z.tagName)?z.innerHTML:"");
}
//(c)dhtmlx ltd. www.dhtmlx.com

;
///<jscompress sourcefile="dhtmlxgrid_excell_dhxcalendar.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function eXcell_dhxCalendar(cell) {
	if (cell) {
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
		
		if (!this.grid._grid_calendarA) {
			
			var cal = this.grid._grid_calendarA = new dhtmlxCalendarObject();
			this.grid.callEvent("onDhxCalendarCreated", [cal]);
			
			var sgrid = this.grid;
			cal.attachEvent("onClick",function(){
                    		this._last_operation_calendar=true;
                    		window.setTimeout(function(){sgrid.editStop()},1);
                    		return true;
                    	});
                    	
                    	var zFunc = function(e){ (e||event).cancelBubble=true; }
                    	dhtmlxEvent(cal.base, "click", zFunc);
                    	cal = null;
                }
	}
}
eXcell_dhxCalendar.prototype = new eXcell;

eXcell_dhxCalendar.prototype.edit = function() {
	
	var arPos = this.grid.getPosition(this.cell);
	this.grid._grid_calendarA._show(false, false);
	this.grid._grid_calendarA.setPosition(arPos[0],arPos[1]+this.cell.offsetHeight);
	this.grid._grid_calendarA._last_operation_calendar = false;
	
	
	this.grid.callEvent("onCalendarShow", [this.grid._grid_calendarA, this.cell.parentNode.idd, this.cell._cellIndex]);
	//var arPos = this.grid.getPosition(this.cell);
	//var pval=this._date2str2(this.cell.val||new Date());
	//window._grid_calendar.render(arPos[0],arPos[1]+this.cell.offsetHeight,this,pval);
	this.cell._cediton = true;
	this.val = this.cell.val;
	this._val = this.cell.innerHTML;
	// alert(this.cell.val);
	var t = this.grid._grid_calendarA.draw;
	this.grid._grid_calendarA.draw = function(){};
	this.grid._grid_calendarA.setDateFormat((this.grid._dtmask||"%d/%m/%Y"));
	this.grid._grid_calendarA.setDate(this.val||(new Date()));
	this.grid._grid_calendarA.draw = t;
	
	//this.grid._grid_calendarA.draw();
}
eXcell_dhxCalendar.prototype.getDate = function() {
	if (this.cell.val) return this.cell.val;
	return null;
}

eXcell_dhxCalendar.prototype.getValue = function() {
	if (this.cell._clearCell) return "";
	if (this.grid._dtmask_inc && this.cell.val) return this.grid._grid_calendarA.getFormatedDate(this.grid._dtmask_inc, this.cell.val).toString();
	return this.cell.innerHTML.toString()._dhx_trim()
}

eXcell_dhxCalendar.prototype.detach = function() {
	if (!this.grid._grid_calendarA) return;
	this.grid._grid_calendarA.hide();
	if (this.cell._cediton) this.cell._cediton = false; else return;
	
	if (this.grid._grid_calendarA._last_operation_calendar) {
		var z1=this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"));
		var z2=this.grid._grid_calendarA.getDate();
		this.cell.val=new Date(z2);
		this.setCValue(z1,z2);
		this.cell._clearCell = !z1;
		var t = this.val;
		this.val = this._val;
		return (this.cell.val.valueOf()!=(t||"").valueOf());
	}
	return false;
}


eXcell_dhxCalendar.prototype.setValue = function(val) {
	
	if (val && typeof val == "object") {
		this.cell.val=val;
		this.cell._clearCell=false;
		this.setCValue(this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),val).toString(),this.cell.val);
		return;
	}
	
	
	if (!val || val.toString()._dhx_trim()=="") {
		val="&nbsp";
		this.cell._clearCell=true;
		this.cell.val="";
	} else{
		this.cell._clearCell=false;
		this.cell.val=new Date(this.grid._grid_calendarA.setFormatedDate((this.grid._dtmask_inc||this.grid._dtmask||"%d/%m/%Y"),val.toString(),null,true));
		if (this.grid._dtmask_inc)
			val = this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),this.cell.val);
	}
	
	if ((this.cell.val=="NaN")||(this.cell.val=="Invalid Date")) {
		this.cell._clearCell=true;
		this.cell.val=new Date();
		this.setCValue("&nbsp;",0);
	} else {
		this.setCValue((val||"").toString(),this.cell.val);
	}
}


function eXcell_dhxCalendarA(cell) {
	if (cell) {
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
		
		if (!this.grid._grid_calendarA) {
			
			var cal = this.grid._grid_calendarA = new dhtmlxCalendarObject();
			this.grid.callEvent("onDhxCalendarCreated",[cal]);
			
			var sgrid=this.grid;
			cal.attachEvent("onClick",function() {
				this._last_operation_calendar=true;
				window.setTimeout(function() {sgrid.editStop()},1);
				return true;
                    	});
                    	
                    	var zFunc=function(e) { (e||event).cancelBubble=true;  }
                    	dhtmlxEvent(cal.base,"click",zFunc);
                }      
	}
}
eXcell_dhxCalendarA.prototype = new eXcell;

eXcell_dhxCalendarA.prototype.edit = function() {
	var arPos = this.grid.getPosition(this.cell);
	
	this.grid._grid_calendarA._show(false, false);
	this.grid._grid_calendarA.setPosition(arPos[0]*1+this.cell.offsetWidth,arPos[1]*1);
	this.grid.callEvent("onCalendarShow",[this.grid._grid_calendarA,this.cell.parentNode.idd,this.cell._cellIndex]);
	this.grid._grid_calendarA._last_operation_calendar=false;
	
	this.cell._cediton=true;
	this.val=this.cell.val;
	this._val=this.cell.innerHTML;
	
	var t=this.grid._grid_calendarA.draw; this.grid._grid_calendarA.draw=function() {};
	this.grid._grid_calendarA.setDateFormat((this.grid._dtmask||"%d/%m/%Y"));
	this.grid._grid_calendarA.setDate(this.val);
	this.grid._grid_calendarA.draw=t;
	
	this.cell.atag=((!this.grid.multiLine)&&(_isKHTML||_isMacOS||_isFF))?"INPUT":"TEXTAREA";
	
	this.obj = document.createElement(this.cell.atag);
	this.obj.style.height = (this.cell.offsetHeight-4)+"px";
	this.obj.className="dhx_combo_edit";
	this.obj.wrap = "soft";
	this.obj.style.textAlign = this.cell.align;
	this.obj.onclick = function(e) {(e||event).cancelBubble = true}
	this.obj.onmousedown = function(e) {(e||event).cancelBubble = true}
	this.obj.value = this.getValue();
	this.cell.innerHTML = "";
	this.cell.appendChild(this.obj);
	if (window.dhx4.isIE) {
		this.obj.style.overflow = "visible";
		if ((this.grid.multiLine)&&(this.obj.offsetHeight>=18)&&(this.obj.offsetHeight<40)) {
			this.obj.style.height = "36px";
			this.obj.style.overflow = "scroll";
		}
	}
	this.obj.onselectstart=function(e) {
		if (!e) e=event;
		e.cancelBubble = true;
		return true;
	};
	this.obj.focus()
	this.obj.focus()
	
}

eXcell_dhxCalendarA.prototype.getDate = function() {
	if (this.cell.val) return this.cell.val;
	return null;
}

eXcell_dhxCalendarA.prototype.getValue = function() {
	if (this.cell._clearCell) return "";
	if (this.grid._dtmask_inc && this.cell.val)
		return this.grid._grid_calendarA.getFormatedDate(this.grid._dtmask_inc, this.cell.val).toString();
	return this.cell.innerHTML.toString()._dhx_trim()
}

eXcell_dhxCalendarA.prototype.detach = function() {
	if (!this.grid._grid_calendarA) return;
	this.grid._grid_calendarA.hide();
	if (this.cell._cediton) this.cell._cediton=false; else return;
	if (this.grid._grid_calendarA._last_operation_calendar) {
		this.grid._grid_calendarA._last_operation_calendar=false;
		var z1=this.grid._grid_calendarA.getFormatedDate(this.grid._dtmask||"%d/%m/%Y");
		var z2=this.grid._grid_calendarA.getDate();
		this.cell.val=new Date(z2);
		this.setCValue(z1,z2);
		this.cell._clearCell = !z1;
		var t = this.val;
		this.val=this._val;
		return (this.cell.val.valueOf()!=(t||"").valueOf());
	}
	this.setValue(this.obj.value);
	var t = this.val;
	this.val = this._val;
	return (this.cell.val.valueOf()!=(t||"").valueOf());
}

eXcell_dhxCalendarA.prototype.setValue = function(val) {
	if (val && typeof val == "object") {
		this.cell.val=val;
		this.cell._clearCell=false;
		this.setCValue(this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),val).toString(),this.cell.val);
		return;
	}
	
	if (!val || val.toString()._dhx_trim()=="") {
		val="&nbsp";
		this.cell._clearCell=true;
		this.cell.val="";
	} else {
		this.cell._clearCell = false;
		this.cell.val = new Date(this.grid._grid_calendarA.setFormatedDate((this.grid._dtmask_inc||this.grid._dtmask||"%d/%m/%Y"),val.toString(),null,true));
		if (this.grid._dtmask_inc)
			val = this.grid._grid_calendarA.getFormatedDate((this.grid._dtmask||"%d/%m/%Y"),this.cell.val);
	}
	
	if ((this.cell.val=="NaN")||(this.cell.val=="Invalid Date")) {
		this.cell.val=new Date();
		this.cell._clearCell=true;
		this.setCValue("&nbsp;",0);
	} else {
		this.setCValue((val||"").toString(),this.cell.val);
	}
}

;
///<jscompress sourcefile="dhtmlxgrid_excell_vmdcheckbox.js" />
/*
filename：dhtmlxgrid_excell_checkbox_tb.js
creater：刘志伟
date created：2016.11.19
description：扩展复选框组件
date modified：2018.09.14
modifier：刘志伟
version：2.3.16.0726
others：
copyright：Copyright @1999-2016, hwkj, All Rights Reserved
*/
function eXcell_vmdcheckbox(cell) {
	if(!cell) return;

	var that = this;
	this.cell = cell;
	this.grid = cell.parentNode.grid;
	this.hwReport = this.grid.hwReport;
	this.options = {}

	this.getcheckbox = function() {
	    return this.cell.checkbox;
	}

	this.getValue = function() {
	    return (this.cell.checkbox && this.cell.checkbox.getValue() != null) ? this.cell.checkbox.getValue() : (this.cell._val || "");
	}

	this.setValue = function (val) {
		this.cell._val = val;
	    this.cell.checkbox = this.initCheckBox();
	    this.cell.checkbox.setValue(val);
	    this.grid.callEvent("onCellChanged", [
            this.cell.parentNode.idd,
            this.cell._cellIndex,
            val
	    ]);
	}

	this.isDisabled = function () {
	    if (this.grid._disabled) {
	        return true;
	    }
	    return this.cell._disabled;
	}

	this.edit = function () {
	    this.val = this.getValue();
		this.cell.checkbox.moveToNext();
	}

	this.detach = function() {
		this.cell.checkbox.clearSelectStatus();
		this.cell.checkbox.currentSelectId = null;
		this.cell.checkbox.hasSelected = false;
		this.grid.editor = null;

		return false;
	}
}

eXcell_vmdcheckbox.prototype = new eXcell;

eXcell_vmdcheckbox.prototype.initCheckBox = function (index) {
    var that = this;
    if (this.cell.checkbox) {
        return this.cell.checkbox;
    }
	var oCell = this.hwReport.getOriginCellById(this.cell._attrs.sid);
	var cellType = this.hwReport.cellTypes.get(oCell.fillcelltype);
	var container = document.createElement("div");
	this.cell.appendChild(container);

	var checkbox = new dhtmlXCheckBox(container, {
	    mode: cellType.mode
	});
	var rptStore = cellType.bindsource && cellType.bindsource.tablename && this.hwReport.getQueryStoreByName(cellType.bindsource.tablename);
	if (rptStore && rptStore.dhtmlxDatastore) {
	    checkbox.sync(rptStore.dhtmlxDatastore, {
	        text: (cellType.bindsource.showcolumn || "text").toLowerCase(),
	        value: (cellType.bindsource.valuecolumn || "value").toLowerCase(),
	        seperator: cellType.seperator,
	        mode: cellType.mode,
	        style: cellType.mode == "radio" ? "rad" : "chk",
	        enableAll: window.dhx4.s2b(cellType.isallselect)
	    }, this);
	}

	checkbox.attachEvent("onCheckChanged", function (newValue, oldValue) {

	    that.grid.callEvent("onCellChanged", [
					that.cell.parentNode.idd,
					that.cell._cellIndex,
					newValue
	    ]);

	    that.grid.callEvent("onEditCell", [
					2,
					that.cell.parentNode.idd,
					that.cell._cellIndex,
					newValue,
					oldValue
	    ]);
	});
	
	return checkbox;
};

eXcell_vmdcheckbox.prototype.getCellCheckBox = function() {
	if(this.cell.checkbox) return this.cell.checkbox;
	this.cell.checkbox = this.initCheckBox();
	return this.cell.checkbox;
};;
///<jscompress sourcefile="dhtmlxgrid_excell_vmdnum.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function eXcell_vmdnum(cell) {
    var that = this;
    try {
        this.cell = cell;
        this.grid = this.cell.parentNode.grid;
        this.hwReport = this.grid.hwReport;
        var originCell = this.hwReport.getOriginCellById(this.cell._attrs.sid);
        this.cellType = this.hwReport.cellTypes.get(originCell.fillcelltype);
        this.number = this.hwReport.numbers.get(originCell.number) || {};

        if (!this.cell.DOMelem_input) {
            this.cell.atag = "INPUT";
            this.cell.DOMelem_input = document.createElement(this.cell.atag);
            this.cell.DOMelem_input.setAttribute("autocomplete", "off");

            this.cell.DOMelem_input.className = "dhx_combo_edit";
            this.cell.DOMelem_input.wrap = "soft";
            this.cell.DOMelem_input.style.marginLeft = "0px";
            this.cell.DOMelem_input.style.textAlign = this.cell.style.textAlign;

            if (this.grid._disabled || this.isDisabled()) {
                this.cell.DOMelem_input.setAttribute("readonly", "readonly");
            }
            //放开之后自由格式不调用edit，但是不放开在ie下不响应鼠标焦点，所以在自由格式下置null
            this.cell.DOMelem_input.onclick = function (e) {
                (e || event).cancelBubble = true
            }

            this.cell.DOMelem_input.onkeyup = function (e) {
                var lastChar = (e.srcElement.value + "").substr((e.srcElement.value + "").length - 1)
                if ((e.srcElement.value + "").indexOf(".") != (e.srcElement.value + "").length - 1 && lastChar != "0" && e.srcElement.value != "-" && e.srcElement.value != "+") {
                    e.srcElement.value = that.format(e.srcElement.value);
                }
            }

            this.cell.DOMelem_input.onmousedown = function (e) {
                if (that.cell._editorshow) {
                    if (that.grid._doClick(e || window.event) !== false) {
                        if (that.grid._sclE)
                            that.grid.editCell(e || window.event);
                        else
                            that.grid.editStop();
                    }
                }
                (e || event).cancelBubble = true
            }

            this.cell.DOMelem_input.onselectstart = function (e) {
                if (!e)
                    e = event;
                e.cancelBubble = true;
                return true;
            };
        }

    } catch (er) {
    }

    this.isDisabled = function () {
        if (this.grid._disabled) {
            return true;
        }
        return this.cell._disabled;
    }

    this.setDisabled = function (fl) {
        if (fl != 'true' && fl != 1)
            fl = false;

        this.cell._disabled = fl;
        if (fl) {
            this.cell.DOMelem_input.setAttribute("readonly", "readonly");
        }
        else {
            this.cell.DOMelem_input.removeAttribute("readonly");
        }
    }

    this.edit = function () {
        this.val = this.getValue();

        if (!this.cell._editorshow) {
            this.cell.className += " " + this.hwReport.reportId + "-p-0";
            this.cell.DOMelem_input.style.width = this.cell.clientWidth + "px";
            this.cell.DOMelem_input.style.height = (this.cell.clientHeight - 3) + "px";
            this.cell.DOMelem_input.value = this.val
            this.cell.innerHTML = "";
            this.cell.appendChild(this.cell.DOMelem_input);
            this.cell.DOMelem_input.focus();
        }
        else {
            if (_isIE) {
                this.cell.DOMelem_input.focus();
                this.cell.DOMelem_input.blur();
            }
            this.cell.DOMelem_input.focus();
        }
        if (!/dhxcombo_actv/g.test(this.cell.DOMelem_input.className)) {
            this.cell.DOMelem_input.className += " dhxcombo_actv";
        }
    }
    
    /**
    * 显示编辑器
    */
    this.showEditor = function () {
        var that = this;
        var val = this.getValue();
        this.cell.DOMelem_input.onclick = null;
        this.cell.DOMelem_input.style.width = this.cell.clientWidth + "px";
        this.cell.DOMelem_input.value = val;
        this.cell.innerHTML = ""
        this.cell.appendChild(this.cell.DOMelem_input);
        this.cell._editorshow = true;

        this.grid.attachEvent("onSetSizes", function () {
            that.cell.DOMelem_input.style.width = that.cell.clientWidth + "px";
        });
    }

    this.getValue = function () {

        if ((this.cell.firstChild) && ((this.cell.atag) && (this.cell.firstChild.tagName == this.cell.atag)))
            return this.cell.firstChild.value;

        if (this.cell._clearCell)
            return "";

        return this.cell.innerHTML.toString()._dhx_trim();
    }
    this.setValue = function (val) {
        //var re = new RegExp("[a-z]|[A-Z]", "i")
        val = this.format(val);
        if (isNaN(val)) {
            val = "&nbsp;";
            this.cell._clearCell = true;
        }
        else {
            this.cell._clearCell = false;
        }


        if (this.cell._editorshow) {
            this.cell.DOMelem_input.value = val;
        }
        else {
            this.cell.innerHTML = val;
        }
        //#__pro_feature:21092006{
        //#on_cell_changed:23102006{
        this.grid.callEvent("onCellChanged", [
            this.cell.parentNode.idd,
            this.cell._cellIndex,
            this.cell._clearCell ? "" : val
        ]);

    }

    this.format = function (val) {
        var numType = this.number.type;
        val = parseFloat(val);
        switch (numType) {
            case '0': //常规
                if (isNaN(val)) {
                    return "";
                }
                return val;
                break;
            case '1': //数字
                if (isNaN(val)) {
                    return "";
                }
                var decimal = parseInt(this.number.decimal || -1);
                if (decimal < 0) {
                    return val;
                }
                val = val.toFixed(decimal);
                if (!dhx.s2b(this.number.zerovisible)) {
                    val = parseFloat(val);
                }
                return val;
                break;
            default:
                if (isNaN(val)) {
                    return "";
                }
                return val;
                break;
        }
    }

    this.detach = function () {
        this.cell.DOMelem_input.className = this.cell.DOMelem_input.className.replace(/dhxcombo_actv/g, "");
        this.cell.className = this.cell.className.replace(new RegExp(this.hwReport.reportId + "-p-0", "gi"), " ");
        var tv = this.cell.DOMelem_input.value;
        this.setValue(tv);
        return this.val != this.getValue();
    }
}
eXcell_vmdnum.prototype = new eXcell;
//(c)dhtmlx ltd. www.dhtmlx.com
;
///<jscompress sourcefile="dhtmlxgrid_excell_vmdlink.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/


/*
HTML Link eXcell v.1.0  for dhtmlxGrid 
(c)DHTMLX LTD. 2005


The corresponding  cell value in XML should be a "^" delimited list of following values:
1st - Link Text 
2nd - URL (optional)
3rd - target (optional, default is _blank)

Samples:
<cell>Stephen King</cell>
<cell>Stephen King^http://www.stephenking.com/</cell>
<cell>Stephen King^http://www.stephenking.com/^_self</cell>
*/

/**
*	@desc: link editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/

function eXcell_vmdlink(cell) {
	this.cell = cell;
    this.grid = this.cell.parentNode.grid;
    this.isDisabled=function(){return true;}
	this.edit = function(){}
	this.getValue = function(){
		if(this.cell.firstChild.getAttribute){
		    var target = this.cell.firstChild.getAttribute("target");
		    return this.cell.firstChild.innerHTML;
			//return this.cell.firstChild.innerHTML+"^"+this.cell.firstChild.getAttribute("href")+(target?("^"+target):"");
		}

		else
			return "";
	}
	this.setValue = function (val) {
	    var that = this;
		if((typeof(val)!="number") && (!val || val.toString()._dhx_trim()=="")){		
			this.setCValue("&nbsp;",valsAr);			
			return (this.cell._clearCell=true);
		}
		var valsAr = val.split("^");
		if(valsAr.length==1)
			valsAr[1] = "";
		else{
		    if (valsAr.length > 1) {
				valsAr[1] = "href='"+valsAr[1]+"'";
				if(valsAr.length==3)
					valsAr[1]+= " target='"+valsAr[2]+"'";
				else
					valsAr[1]+= " target='_blank'";
			}
		}

		this.setCValue("<div style ='color:blue;cursor:pointer;text-decoration:underline;' " + valsAr[1] + " onclick='(_isIE?event:arguments[0]).cancelBubble = true;this.parentNode.parentNode.grid.hyperlinkClick(this)'>" + valsAr[0] + "</div>", valsAr[0]);
	}
}

eXcell_vmdlink.prototype = new eXcell;

eXcell_vmdlink.prototype.getTitle = function () {
    var z = this.cell.firstChild;
    return (_isIE ? z.innerText : z.textContent);
	//return ((z&&z.tagName)?z.getAttribute("href"):"");
}

eXcell_vmdlink.prototype.getContent = function () {
	var z=this.cell.firstChild;
	return ((z&&z.tagName)?z.innerHTML:"");
}

dhtmlXGridObject.prototype.hyperlinkClick = function (el) {
    var cellObj = this.cells4(el.parentNode);
    var _attrs = cellObj.cell._attrs;
    var originCell = this.hwReport.getOriginCellById(_attrs.sid);
    var cellType = this.hwReport.cellTypes.get(originCell.fillcelltype);
    var url = (cellType && cellType.url && dhx.trim(cellType.url.replace("?", ""))) || "";
    var urlParams = url ? url.split("&").filter(function (item) {return !!item }).map(function (item) { return item.split("=").map(function (a) { return dhx.trim(a) }) }) : [];
    for (var i = 0; i < urlParams.length; i++) {
        //if (/^\{[\w\W]+\}$/g.test(urlParams[i][1]) || /\{@value\}/g.test(urlParams[i][1]) || this.hwReport.checkParamType(urlParams[i][1]) != "string") {
        urlParams[i][1] = this.hwReport.getValue(urlParams[i][1], cellObj);
        //}
    }
    this.editor = cellObj;
    this.cell = cellObj.cell;
    this.row = cellObj.cell.parentNode;
    var LeftLinkClickName = "onLeftLinkClick";
    this.hwReport.callEvent("onLeftLinkClick", [this, cellObj, urlParams.map(function (item) { return item.join("=") }).join("&")]);
    if (this.LeftLinkClickName) {
        LeftLinkClickName = this.LeftLinkClickName;
    }
    if (Ext.isFunction(window[LeftLinkClickName])) {
        window[LeftLinkClickName](urlParams.map(function (item) { return item.join("=") }).join("&"), this, cellObj);
    }
    if (Ext.isFunction(window[this.hwReport.reportId + "_LeftLinkClick"])) {
        window[this.hwReport.reportId + "_LeftLinkClick"](urlParams.map(function (item) { return item.join("=") }).join("&"), this, cellObj);
    }
    this.editor = null;
}
//(c)dhtmlx ltd. www.dhtmlx.com

;
///<jscompress sourcefile="dhtmlxgrid_excell_vmdupload.js" />
/*
filename：dhtmlxgrid_excell_hwupload.js
creater：刘志伟
date created：2016.11.19
description：上传组件
date modified：2018.07.09
modifier：刘志伟
version：2.3.12.0711
others：
copyright：Copyright @1999-2016, hwkj, All Rights Reserved
*/
function eXcell_vmdupload(cell) {
    var that = this;
    if (cell) {
        this.cell = cell;
        this.grid = this.cell.parentNode.grid;
        this.hwReport = this.grid.hwReport;

        var oCell = this.hwReport.getOriginCellById(cell._attrs.sid);
        var cellType = this.hwReport.cellTypes.get(oCell.fillcelltype);
        this.cell.style.padding = "0px";

        this.hwReport.uploadCells = this.hwReport.uploadCells || {};
        this.hwReport.uploadCells[cell.parentNode.idd + "_" + cell._cellIndex] = cell;

        if (!this.hwReport.upload_onReportRendered_id) {
            this.hwReport.upload_onReportRendered_id = this.hwReport.attachEvent("onRendered", function () {
                for (var item in that.hwReport.uploadCells) {
                    var td = that.hwReport.uploadCells[item];
                    if(!td._uploader){
						td._uploader = that.grid._uploader_render(td);
                        td._uploader.doLayout();
					}
                }
            });
        }
    }

    window.dhx4._eventable(this);
    this.isDisabled = function () {
        return true;
    }

    //设置值
    this.setValue = function (val) {
        this.cell._val = val;
        if (this.cell._uploader) {
            this.cell._uploader.setValue(val);
        }else{
            this.cell._uploader = that.grid._uploader_render( this.cell);
           this.cell._uploader.doLayout();
        }
        //this.cell.uploader = this.initUpload(this.cell.parentNode.idd, this.cell._cellIndex, this._dataIndex, this.cell.offsetWidth);
        //this.cell.uploader.setValue(val);
    }

    this.getValue = function (key) {
        var cell = this.cell;
        var uploader = cell._uploader;
        var uploadValue="";
        if (key) {
            if (uploader) {
                if (Object.keys(uploader._files).length > 0) {
                    uploadValue= this.getUploadValue(uploader._files,key);
                }
                else if((uploader.isWdk && key == "id") || key == 'path'){
                    uploadValue = cell._val;
                }
            }
        }
        else{
            uploadValue="";
        }
        return uploadValue;
    }

    this.getUploadValue=function(files,key){
        var upPath="";
        var upName="";
        var upId="";
        var upSize="";
        var upExt="";
        if(files){
            for(fileKey in files){
                var upFile=files[fileKey];
                upPath+=(upFile.path+",");
                upName+=(upFile.name+",");
                upId+=(upFile.id+",");
                upSize+=(upFile.size+",");
                if(upFile.name){
                    var extStr=upFile.name.substring(upFile.name.indexOf("."));
                    upExt+=(extStr+",");
                }
            }
        }
        switch (key) {
            case "path":
            if(upPath&&upPath.length>0){
               return upPath.substring(0,upPath.length-1);
            }
                break;
            case "name":
                if(upName&&upName.length>0){
                    return upName.substring(0,upName.length-1);
                }
                break;
            case "id":
                if(upId&&upId.length>0){
                    return upId.substring(0,upId.length-1);
                }
                break;
            case "size":
                if(upSize&&upSize.length>0){
                    return upSize.substring(0,upSize.length-1);
                }
                break;
            case "ext":
                if(upExt&&upExt.length>0){
                    return upExt.substring(0,upExt.length-1);
                }
                break;
        }
    }

    this.showProgress = function () {
        var uploadContainer = document.createElement("DIV");
        //对象id
        uploadContainer.id = "dhxgrid_upload_container";
        uploadContainer.className = "dhxgrid_file_uploader";
        uploadContainer.style.width = this.cell.offsetWidth + "px";
        uploadContainer.style.height = this.cell.offsetHeight + "px";

        this.cell.appendChild(uploadContainer);
    }

    this.hideController = function () {
            if (this.cell.controller) {
                this.cell.uploadContainer.removeChild(this.cell.controller);
                this.cell.controller = null;
            }
    },

    //删除文件
    this.hwuploadDel = function (docid) {
        document.getElementById(this.hwupload_rendStr(docid, "bm") + "_a").style.display = "none";
        document.getElementById(this.hwupload_rendStr(docid, "bm") + "_del").style.display = "none";
        var brrTmp = this.cell.val.split(',');
        this.lastVal = "";
        for (var i = 0; i < brrTmp.length; i++) {
            if (brrTmp[i].indexOf(docid) < 0) {
                this.lastVal += brrTmp[i] + ","
            }
        }
        this.lastVal = this.lastVal.substr(0, this.lastVal.length - 1);
        cellUpdate(this.cell, this.lastVal);
        this.cell.val = this.lastVal;
    }

    /*flag:flag=bm表示要求返回编码；flag==mc表示要求返回名称*/
    this.hwupload_rendStr = function (str, flag) {
        if (flag == "bm") {
            if (str)
                return str.substr(0, str.indexOf(':'))
            else
                return null;
        }

        if (flag == "mc") {
            if (str)
                return str.substr(str.indexOf(':') + 1, str.length)
            else
                return null;
        }
    }
}
eXcell_vmdupload.prototype = new eXcell;

eXcell_vmdupload.prototype.getCellUploader = function () {
    return this.cell._uploader;
};

/*初始化上传控件 */
dhtmlXGridObject.prototype._uploader_render = function (cell) {

    var that = this;
    cell._attrs['title'] = " ";

    var oCell = this.hwReport.getOriginCellById(cell._attrs.sid);
    var cellType = this.hwReport.cellTypes.get(oCell.fillcelltype);
    var isWdk = cellType.wordMode;
    var isShowAll = !oCell.data && !oCell.datavalue; //如果单元格中不绑定字段，则显示所有查询出来的文件

    //上传控件对象
    var uploadContainer = document.createElement("DIV");
    uploadContainer.id = "dhxgrid_upload_container";
    uploadContainer.className = "dhxgrid_file_uploader";
    cell.appendChild(uploadContainer);

    var dataHost = vmd.MicService.getDasIp();
    var hwFao = new HwFao(dataHost, "wdk");//地址:端口和存储标识(服务管理员分配)
    var wdkHost = (vmd.projectInfo && vmd.projectInfo.docIp) || "";
    var callCode = "vmdcode";
    var uploadUrl = isWdk ? hwFao.getWdkUploadUrl(wdkHost, callCode, "") : hwFao.getUploadUrl("");

    if (isWdk && !wdkHost) {
        Ext.Msg.show({
            title: "提示",
            msg: "配置文档库上传后需配置文档中心！",
            buttons: Ext.Msg.OK,
            icon: Ext.Msg.ERROR
        });
    }

    var uploader = new dhtmlXFileUpload(uploadContainer, {
        swfPath: this.hwReport.dhtmxlUrl + "/lib/dhtmlx/sources/dhtmlxFileUpload/codebase/uploader.swf",
        flashPath: this.hwReport.dhtmxlUrl + "/lib/dhtmlx/sources/dhtmlxFileUpload/codebase/flashplayerpp_install_cn.zip",
        swfUrl: uploadUrl,
        swfLogs: "enabled",
        fileType: cellType.filetype,
        numPerPage: parseInt(cellType.pageexp),
        cols: parseInt(cellType.colexp),
        showmode: cellType.showmode,
        isShowAll: isShowAll,
        dataHost: dataHost, //查询上传服务时用到的地址
        wdkHost: wdkHost
    });
    uploader.val = cell._val;
    uploader.cellObj = this;
    uploader.grid = this.grid;
    uploader.enableTitleScreen(false);
    uploader.setURL(uploadUrl);
    uploader.setIsWdk(isWdk);
    uploader.setAutoStart(true);
    uploader.setDeletable(cellType.delete == "0" ? false : true);
    uploader.setAddable(cellType.add == "0" ? false : true);
    uploader.setInfoable(false);
    uploader.setUploadable(false);
    uploader.setCancelable(false);

    var rptStore = cellType.bindsource && cellType.bindsource.tablename && this.hwReport.getQueryStoreByName(cellType.bindsource.tablename);
    if (rptStore && rptStore.dhtmlxDatastore) {
        uploader.sync(rptStore.dhtmlxDatastore, {
            name: cellType.bindsource.filename && cellType.bindsource.filename.toLowerCase(),
            path: cellType.bindsource.filepath && cellType.bindsource.filepath.toLowerCase(),
            docid: cellType.bindsource.docid && cellType.bindsource.docid.toLowerCase(),
            size: cellType.bindsource.filesize && cellType.bindsource.filesize.toLowerCase(),
            ext: cellType.bindsource.fileext && cellType.bindsource.fileext.toLowerCase(),
            mode: cellType.wordMode
        }, this);
    }

    //if (cellType.upmaxnum == 1) {
    //    uploader.buttons["browse"].style.right = "20px";
    //    uploader.p_controls.style.width = "60px";
    //    uploader.p_controls.style.right = "60px";
    //    uploader.buttons["clear"].style.display = "none";
    //}

    //uploader.callEvent = function (evName, evData) {
    //    return that.callEvent(evName, evData);
    //}

    uploader.attachEvent("onBeforeFileAdd", function (name, size) {
        var fileID;
        var maxAccessUploadFile = parseInt(cellType.upmaxnum);
        var serverFileCount = 0;
        for (fileID in uploader._files) {
            if (uploader._files[fileID].server && uploader._files[fileID].storageState != "delete") {
                serverFileCount++;
            }
        }
        if (serverFileCount >= maxAccessUploadFile) {
            Ext.Msg.show({
                title: "提示",
                msg: "文件最多允许上传" + maxAccessUploadFile + "个，已存在文件数量为" + serverFileCount + "个，无法继续添加！",
                buttons: Ext.Msg.OK,
                icon: Ext.Msg.INFO
            });
            return false;
        }

        uploader.showProgress();
        return true;
    });

    uploader.attachEvent("onBeforeFileRemove", function (name, size) {
        if (confirm("是否删除文件\"" + name + "\"？")) {
            return true;
        }
        return false;
    });

    uploader.attachEvent("onImgClick", function (file) {
        var picviewPath = vmd.virtualPath + "/report/picview/index.html";
        var path = file.path.indexOf("http://") == -1 ? ("http://" + dataHost.replace("http://", "") + "/wdk/" + file.path) : file.path;
        var path = path.replace("/thumbnail/", "/");
        window.open(path, "_blank");
    });

    //this.attachEvent("onFileAdd", function (id, name, fileID) {
    //    cell.parentNode.style.height = (uploader.p_files.offsetHeight) + "px";
    //    var grid = uploader.grid;
    //    grid.setSizes();
    //});

    uploader.attachEvent("onFileRemove", function (name, serverName, id, dataID, timeStamp) {
        uploader.doLayout();

        var oldFiles = [];
        for (fileID in uploader._oldFiles) {
            var file = uploader._oldFiles[fileID];
            oldFiles.push({
                path: file.path,
                name: file.name,
                id: file.id,
                size: file.size,
                ext: file.ext||(file.name&&file.name.substring(file.name.indexOf("."))),
                state: file.storageState
            });
        }

        // 添加或者删除上传文件，获取文件信息
        var newFiles = [];
        uploader._oldFiles = {};
        for (fileID in uploader._files) {
            var file = uploader._files[fileID];
            uploader._oldFiles[fileID] = dhx4._copyObj(file);
            newFiles.push( {
                path: file.path,
                name: file.name,
                id: file.id,
                size: file.size,
                ext: file.ext||(file.name&&file.name.substring(file.name.indexOf("."))),
                state: file.storageState
            });
        }
        if (uploader._delFiles) {
            for (fileID in uploader._delFiles) {
                var file = uploader._delFiles[fileID];
                newFiles.push({
                    path: file.path,
                    name: file.name,
                    id: file.id,
                    size: file.size,
                    ext: file.ext||(file.name&&file.name.substring(file.name.indexOf("."))),
                    state: file.storageState
                });
            }
        }

        that.grid.callEvent("onCellChanged", [
                cell.parentNode.idd,
                cell._cellIndex,
                newFiles
        ]);

        that.grid.callEvent("onEditCell", [
            2,
            cell.parentNode.idd,
            cell._cellIndex,
            newFiles,
            oldFiles
        ]);
    });

    //上传成功的回调函数
    uploader.attachEvent("onUploadFile", function (name, serverName, extra, t, response, id, fileID) {
        //解析返回的文本
        var fileID;

        uploader.hideProgress();
        var response = eval('(' + response + ')');
        var result = response.data[0];
        var file = uploader._files[fileID];
        file.absPath = result.absolutePath;
        file.relativePath = result.relativePath;
        file.path = result.path;
        file.id = result.docid || (new Date().valueOf());

        var maxAccessUploadFile = parseInt(cellType.upmaxnum);
        var fileCount = uploader._getAddFileCount();

        //如果上传文件超过最大允许上传数，则将最早上传的文件删除
        if (fileCount > maxAccessUploadFile) {
            var firstFileID = null;
            for (fileID in uploader._files) {
                if (!uploader._files[fileID].server) {
                    if (firstFileID) {
                        var firstFile = uploader._files[firstFileID];
                        if (firstFile.timestamp > uploader._files[fileID].timestamp) {
                            firstFileID = fileID;
                        }
                    }
                    else {
                        firstFileID = fileID;
                    }
                }
            }
            if (firstFileID) {
                uploader._items[firstFileID].parentNode.removeChild(uploader._items[firstFileID]);
                delete uploader._files[firstFileID];
                delete uploader._items[firstFileID];
                fileCount = maxAccessUploadFile;
            }
        }

        if (uploader.checkAllUpload()) {

            uploader.doLayout();

            var oldFiles = [];
            for (fileID in uploader._oldFiles) {
                var file = uploader._oldFiles[fileID];
                oldFiles.push({
                    path: file.path,
                    name: file.name,
                    id: file.id,
                    size: file.size,
                    ext: file.name.substring(file.name.indexOf(".")),
                    state: file.storageState
                });
            }

            // 添加或者删除上传文件，获取文件信息
            var newFiles = [];
            uploader._oldFiles = {};
            for (fileID in uploader._files) {
                var file = uploader._files[fileID];
                uploader._oldFiles[fileID] = dhx4._copyObj(file);
                newFiles.push({
                    path: file.path,
                    name: file.name,
                    id: file.id,
                    size: file.size,
                    ext: file.name.substring(file.name.indexOf(".")),
                    state: file.storageState
                });
            }

            if (uploader._delFiles) {
                for (fileID in uploader._delFiles) {
                    var file = uploader._delFiles[fileID];
                    newFiles.push({
                        path: file.path,
                        name: file.name,
                        id: file.id,
                        size: file.size,
                        ext: file.name.substring(file.name.indexOf(".")),
                        state: file.storageState
                    });
                }
            }

            that.grid.callEvent("onCellChanged", [
                      cell.parentNode.idd,
                      cell._cellIndex,
                      newFiles
            ]);

            that.grid.callEvent("onEditCell", [
                2,
                cell.parentNode.idd,
                cell._cellIndex,
                newFiles,
                oldFiles
            ]);

            that.grid.callEvent("uploadComplete", [that, response]);
        }

    });

    //文件上传失败时返回错误信息
    uploader.attachEvent("onUploadFail", function (a, b) {
        if (window.Ext) {
            Ext.Msg.show({
                title: "警告",
                msg: "上传" + a + "失败!",
                buttons: Ext.Msg.OK,
                icon: Ext.Msg.ERROR
            });
        }
        else {
            dhtmlx.alert({ title: "警告信息", ok: "确定", type: "alert-error", text: "上传" + a + "失败!" });
        }
    });

    //鼠标执行上传组件单元格时控制添加删除的显示与隐藏
    cell.onmouseover = function (e) {
        (e || event).cancelBubble = true;
        if (cell._disabled) {
            return;
        }
        if (uploader._deletable || uploader._addable) {
            uploader.p_controls.style.visibility = "visible";
        }
    }

    cell.onmouseout = function (e) {
        (e || event).cancelBubble = true;
        var toElement = (e || event).toElement;
        uploader.p_controls.style.visibility = "hidden";
    }
    return uploader;
}
;
///<jscompress sourcefile="dhtmlxgrid_excell_vmdtree.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhx4.attachEvent("onGridCreated", function(grid) {
	if(!window.dhx_globalImgPath) window.dhx_globalImgPath = grid.imgURL;

	var hwReport = grid.hwReport;
	if (!hwReport) {
	    return;
	}

	for (var key in hwReport._cell_trees) {
	    if (!hwReport._cell_trees[key].obj) {
	        hwReport._cell_trees[key].obj = hwReport._cell_trees[key].init(grid);
	    }
	}

	if (!hwReport._loading_handler_set_tree) {
	    hwReport._loading_handler_set_tree = hwReport.attachEvent("onStoreSuccess", function (_store) {
	        if (_store.trees) {
	            for (var i = 0; i < _store.trees.length; i++) {
	                eXcell_vmdtree.prototype.fillCellCombos(hwReport, _store.trees[i]);
	            }
	        }
	    });
	}
});

function eXcell_vmdtree(cell) {
	if(!cell) return;
	this.cell = cell;
	this.grid = cell.parentNode.grid;
	this.hwReport = this.grid.hwReport;
	this.cellType = this.hwReport._cell_trees[this.cell._attrs.sid];
	this.combo_tree = this.cellType.obj;

	this._combo_pre = "";
		if(this.hwReport&&this.hwReport.vmdreport&&this.hwReport.vmdreport.xtype=="vmd.datainput")
	{
		var originCell = this.hwReport.getOriginCellById(this.cell._attrs.sid);
		if (originCell && cell.rowSpan == 1&&originCell.childs.indexOf(cell.parentNode.idd + "_" + cell.cellIndex)<0) {
             originCell.childs.push(cell.parentNode.idd + "_" + cell.cellIndex);	
		}
	}	
	this.edit = function () {
	    var that = this;
		if(!window.dhx_globalImgPath) window.dhx_globalImgPath = this.grid.imgURL;
		this.val = this.getValue();
		var val = this.getText();
		if(this.cell._clearCell) val = "";

		var s = window.dhx4.screenDim();

		var bw = this.cell.clientWidth * this.cellType.percentWidth;
		var bh = this.combo_tree.base.offsetHeight;
		this.combo_tree.base.style.width = bw + "px";
		this.combo_tree.setSizes();
		//var bw = this.combo_tree.base.offsetWidth;

		var cellBoundingRect = this.cell.getBoundingClientRect();
		var top = cellBoundingRect.top + cellBoundingRect.height;
		var left = cellBoundingRect.left;
		if ((top + bh) > s.bottom) {
		    top = cellBoundingRect.top - bh;
		}
		if ((left + bw) > s.right) {
		    left = cellBoundingRect.left - (bw - cellBoundingRect.width);
		}

		if (!/dhxcombo_actv/g.test(this.combo_tree.DOMelem.className)) {
		    this.combo_tree.DOMelem.className += " dhxcombo_actv";
		}
		if (!this.cell._editorshow) {
		    this.cell.className += " " + this.hwReport.reportId + "-p-0";
		}
		else {
		    this.combo_tree.DOMelem_input.onclick = function (e) {
		        if (!e) e = event;
		        e.cancelBubble = true;
		        return true;
		    }
		}
		this.cell.innerHTML = "";
		this.cell.appendChild(this.combo_tree.DOMParent);

		var top = (this.combo_tree.DOMParent.clientHeight - this.combo_tree.DOMelem.clientHeight) / 2;
		if (top < 1) {
		    top = 0;
		}
		this.combo_tree.DOMelem.style.top = top + "px";
		this.combo_tree.DOMParent.firstChild.style.width = this.cell.clientWidth + "px";
		this.combo_tree.DOMelem_input.style.width = (this.cell.clientWidth - 24) + "px";
		this.combo_tree.DOMelem_input.focus();
		this.combo_tree.DOMelem_input.value = val;
        var h=0;
		if(this.combo_tree.base.style.height){
			h=	this.combo_tree.base.style.height.split('p')[0];
		}
		var ch=document.body.clientHeight;
		if(ch-cellBoundingRect.top - cellBoundingRect.height>h){
			this.combo_tree.base.style.top =(cellBoundingRect.top +cellBoundingRect.height)+"px";
		}else {
			if(cellBoundingRect.top>h){
				this.combo_tree.base.style.top = (cellBoundingRect.top-h) + "px"
			}else{
				if(ch>h){
					this.combo_tree.base.style.top =(ch- h )+ "px"
				}
			}
		}

	//	this.combo_tree.base.style.top = top + "px"
		this.combo_tree.base.style.left = (left - 1) + "px"
		this.combo_tree.base.style.visibility = "visible"
		this.combo_tree.area.focus();
		this.combo_tree.setSizes();

		function setComboValue(val) {
		    if (that.combo_tree.items[that.cell.combo_value]) {
		        that.combo_tree.selectItem(that.cell.combo_value);
		    } else {
		        if (that.combo_tree.items[val]) {
		            that.combo_tree.selectItem(val);
		        } else {
		            if (that.combo_tree.getSelectedId())
		                that.combo_tree.unselectItem(that.combo_tree.getSelectedId())
		        }
		    }
		}
		setComboValue(val);

		var conditions = this.cellType && this.cellType.bindsource && this.cellType.bindsource.conditions;
	    //条件过滤
		if (conditions && conditions.length > 0) {
		    this.combo_tree.filterByDataStore(function (item, value) {
		        for (var i = 0; i < conditions.length; i++) {
		            if (item[conditions[i]["field"]] != that.hwReport.getValue(conditions[i]["value"], that)) {
		                return false;
		            }
		            return true;
		        }
		    });
		    setComboValue(val);
		}
		else if (this.combo_tree.rptStore) {
		    this.combo_tree.rptStore.update(function () {
		        setComboValue(val);
		    }, function () { });
		}
	}

    /**
    * 显示编辑器
    */
	this.showEditor = function () {
	    var val = this.getText();
	    this.cell.innerHTML = ""
	    this.combo_tree.DOMelem.style.width = this.cell.clientWidth + "px";
	    this.combo_tree.DOMelem_input.style.width = (this.cell.clientWidth - 24) + "px";
	    this.combo_tree.DOMelem_input.value = val;
	    this.cell.appendChild(this.combo_tree.DOMParent);
	    this.combo_tree.DOMelem.style.top = (this.combo_tree.DOMParent.clientHeight - this.combo_tree.DOMelem.clientHeight) / 2 + "px";

	    this.cell._editorshow = true;
	}


	this.getValue = function(val) {
		return this.cell.combo_value || "";
	}

	this.getText = function (val) {
	    var c = this.cell;
	    if (c._editorshow) {
	        return c.firstChild.firstChild.firstChild.value;
	    }
	    return (_isIE ? c.innerText : c.textContent);
	}

	this.setValue = function(val) {
	    this.cell.combo_value = val;
	    var cm = null;
	    if ((cm = this.cell._brval) && (typeof (this.cell._brval) == "object")) {
	        val = (cm.items[val] && cm.items[val].text) || val;
	    } else if (cm = this.hwReport._cell_trees[this.cell._attrs.sid].obj) {
	        val = (cm.items[val] && cm.items[val].text) || val;
	        var tmpVal = cm.items[val];
	        if (tmpVal) {
	            val = tmpVal;
	        }
	        else if (cm.rule && cm.rptStore) {
	            tmpVal = cm.rptStore.find(function (item) {
	                return item[cm.rule['value']] + "" == val + ""
	            });
	            if (tmpVal) {
	                val = {
	                    value: tmpVal[cm.rule['value']],
	                    text: tmpVal[cm.rule['text']]
	                }
	            }
	        }
	        val = (val || {}).text || val;
	    }

	    if ((val || "").toString()._dhx_trim() == "") val = null;

	    if (val !== null) {
	        this.setComboCValue(val, this.cell.combo_value);
	    } else {
	        this.setComboCValue("&nbsp;", "");
	        this.cell._clearCell = true;
	    }
	}

	this.detach = function() {
	    this.combo_tree.DOMelem_input.onclick = null;
	    this.cell.className = this.cell.className.replace(new RegExp(this.hwReport.reportId + "-p-0", "gi"), " ");
	    this.combo_tree.DOMelem.className = this.combo_tree.DOMelem.className.replace(/dhxcombo_actv/g, "");
		var p = this.combo_tree.base;
		p.style.visibility = "hidden";
		var oldval = this.getValue();
		var oldtxt = this.getText();

		if(!this.combo_tree.getSelectedId() || !this.combo_tree.items[this.combo_tree.getSelectedId()] || this.combo_tree.items[this.combo_tree.getSelectedId()].text._dhx_trim() == "") {
		    this.cell.combo_value = oldval;
		    this.setComboCValue(oldtxt, oldval);
		} else {
			this.setComboCValue(this.combo_tree.items[this.combo_tree.getSelectedId()].text.replace(/\&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), this.combo_tree.getSelectedId());
			this.cell._clearCell = false;
			this.cell.combo_value = this.combo_tree.getSelectedId();
		}
		this.grid._still_active = true;
		this.grid.setActive(1);
		return oldval != this.cell.combo_value;
	}
}

eXcell_vmdtree.prototype = new eXcell;
eXcell_vmdtree.prototype.init = function(index) {

	var container = document.createElement("DIV");
	container.className = "dhxtree_in_grid_parent";
	var type = this.grid.defVal[arguments.length ? index : this.cell._cellIndex];
	var tree = new dhtmlXTreeView(container);
	var grid = this.grid;

	tree.DOMParent = document.createElement("DIV");
	tree.DOMParent.className = "dhxcombo_in_grid_parent";
	tree.DOMParent.innerHTML = "<div class='dhxcombo_material'><input type='text' class='dhxcombo_input' autocomplete='off'>" +
            "<input type='hidden' value=''>" + // value
            "<input type='hidden' value='false'>" + // new_value
            "<div class='dhxcombo_select_button'><div class='dhxcombo_select_img'></div></div></div>";

	tree.DOMelem = tree.DOMParent.firstChild;
	tree.DOMelem_input = tree.DOMParent.firstChild.firstChild;

	document.body.appendChild(tree.base); //.parentElement);
	//设置 下拉树的大小和显示样式
	tree.base.style.width = "250px";
	tree.base.style.height = (this.cellType.height || 250) + "px";
	tree.base.style.position = "absolute";
	tree.base.style.visibility = "hidden";
	tree.attachEvent("_onBeforeOpen", function(id, state) {
		var a = grid.editStop;
		grid.editStop = function () {
		    grid.editStop = a;
		};

		return true;
	})
	this.grid.attachEvent("onScroll", function() {
		tree.base.style.visibility = "hidden"
	});

	return tree;

};

eXcell_vmdtree.prototype.fillCellCombos = function (hwReport, cellId) {
    var grid = hwReport.grid;
    var oCell = hwReport.getOriginCellById(cellId);
    for (var i = 0; i < oCell.childs.length; i++) {
        var cellObj = grid.cells.apply(grid, oCell.childs[i].split("_"));
        cellObj.refreshCell();
    }
};

eXcell_vmdtree.prototype.setComboCValue = function (value, value2) {
    if (this.cell._editorshow) {
        this.cell.innerHTML = this.combo_tree.DOMParent.outerHTML;
        this.cell.firstChild.firstChild.firstChild.value = (value == "&nbsp;" ? "" : value);
        this.grid.callEvent("onCellChanged", [
            this.cell.parentNode.idd,
            this.cell._cellIndex,
            value2
        ]);
    }
    else {
        //this.setCValue(value, value2);
    
    //IE下的兼容
    var oldsubgridhtml;
    if(dhx.isIE)  oldsubgridhtml=this.combo_tree.DOMParent.innerHTML;
    
        this.setCValue(value, value2);
    
    if(dhx.isIE && oldsubgridhtml){
      this.combo_tree.DOMParent.innerHTML=oldsubgridhtml;
        this.combo_tree.DOMParent.firstChild.firstChild.value=(value == "&nbsp;" ? "" : value);
    }

    }
};

eXcell_vmdtree.prototype.getCellCombo = function() {

	if(this.cell._brval) return this.cell._brval;

	this.cell._brval = this.init();
	return this.cell._brval;

};

eXcell_vmdtree.prototype.refreshCell = function() {
	this.setValue(this.getValue());
};

dhtmlXTreeView.prototype._signInit = function () {
    this.attachEvent("_onTreeClick", function (e, flow) {
        if (flow.stop == true) return; // check if cancelled by prev attached function
        var t = (e.target || e.srcElement);
        if (t.tagName.toLowerCase() == "i") t = t.parentNode; // check if icon
        if ((t.parentNode.className || "").match(/dhxtreeview_item_text/) != null)
        {
            //箭头
            if(t == t.parentNode.childNodes[this.conf.idx.sign]){
                this._openCloseItem(t.parentNode.parentNode._itemId, true);
                flow.stop = true;
            }
            //只选叶子节点
            else if(this._selectableType == "leaf" && this.getSubItems(t.parentNode.parentNode._itemId).length > 0){
                this._openCloseItem(t.parentNode.parentNode._itemId, true);
                flow.stop = true;
            }
            else if (this._selectableType == "parent" && this.getSubItems(t.parentNode.parentNode._itemId).length == 0) {
                flow.stop = true;
            }
        }
        else if ((t.parentNode.className || "").match(/dhxtreeview_item/) != null) {
            //只选叶子节点
            if (this._selectableType == "leaf" && this.getSubItems(t.parentNode._itemId).length > 0) {
                this._openCloseItem(t.parentNode._itemId, true);
                flow.stop = true;
            }
            else if (this._selectableType == "parent" && this.getSubItems(t.parentNode._itemId).length == 0) {
                flow.stop = true;
            }
        }
    });
};;
///<jscompress sourcefile="dhtmlxgrid_excell_vmded.js" />
/*
filename：dhtmlxgrid_excell_vmdguid.js
creater：刘志伟
date created：2019.03.14
description：guid组件
date modified：2019.03.14
modifier：刘志伟
version：2.3.3.0425
others：
copyright：Copyright @1999-2016, hwkj, All Rights Reserved
*/
/**
*	@desc: simple text editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_vmded(cell) {
    var that = this;
    if (cell) {
        this.cell = cell;
        this.grid = this.cell.parentNode.grid;
        this.hwReport = this.grid.hwReport;
        var originCell = this.hwReport.getOriginCellById(this.cell._attrs.sid);
        this.cellType = originCell && this.hwReport.cellTypes.get(originCell.fillcelltype);

        if (!this.cell.DOMelem_input) {
            this.cell.atag = (!this.cellType || !this.cellType.ismultiline) ? "INPUT" : "TEXTAREA";
            this.cell.DOMelem_input = document.createElement(this.cell.atag);
            this.cell.DOMelem_input.setAttribute("autocomplete", "off");

            this.cell.DOMelem_input.className = "dhx_combo_edit";
            this.cell.DOMelem_input.wrap = "soft";
            this.cell.DOMelem_input.style.marginLeft = "0px";
            this.cell.DOMelem_input.style.textAlign = this.cell.style.textAlign;

            if (this.grid._disabled || this.isDisabled()) {
                this.cell.DOMelem_input.setAttribute("readonly", "readonly");
            }

            if (this.cell.atag == "TEXTAREA") {
                this.cell.DOMelem_input.onkeydown = function (e) {
                    var ev = e || window.event;
                    if (ev.keyCode == 13) { //如果按的是enter键 13是enter 
                        ev.cancelBubble = true;
                        return true;
                    }
                    return true;
                }
            }
            //放开之后自由格式不调用edit，但是不放开在ie下不响应鼠标焦点，所以在自由格式下置null
            this.cell.DOMelem_input.onclick = function (e) {
                (e || event).cancelBubble = true
            }

            this.cell.DOMelem_input.onmousedown = function (e) {
                if (that.cell._editorshow) {
                    if (that.grid._doClick(e || window.event) !== false) {
                        if (that.grid._sclE)
                            that.grid.editCell(e || window.event);
                        else
                            that.grid.editStop();
                    }
                }

                (e || event).cancelBubble = true
            }

            this.cell.DOMelem_input.onselectstart = function (e) {
                if (!e)
                    e = event;
                e.cancelBubble = true;
                return true;
            };
        }
    }

    this.isDisabled = function () {
        if (this.grid._disabled) {
            return true;
        }
        return this.cell._disabled;
    }

    this.setDisabled = function (fl) {
        if (fl != 'true' && fl != 1)
            fl = false;

        this.cell._disabled = fl;
        if (fl) {
            this.cell.DOMelem_input.setAttribute("readonly", "readonly");
        }
        else {
            this.cell.DOMelem_input.removeAttribute("readonly");
        }
    }

    this.edit = function () {
        this.val = this.getValue();

        if (!this.cell._editorshow) {
            this.cell.className += " " + this.hwReport.reportId + "-p-0";
            this.cell.DOMelem_input.style.width = this.cell.clientWidth + "px";
            this.cell.DOMelem_input.style.height = (this.cell.clientHeight - 3) + "px";
            this.cell.DOMelem_input.value = this.val;
            this.cell.innerHTML = "";
            this.cell.appendChild(this.cell.DOMelem_input);
        }
        if (!/dhxcombo_actv/g.test(this.cell.DOMelem_input.className)) {
            this.cell.DOMelem_input.className += " dhxcombo_actv";
        }

        if (_isIE) {
            this.cell.DOMelem_input.focus();
            this.cell.DOMelem_input.blur();
        }
        	//如果单元格不是全部可视，则向下滚动显示出全部单元格再进行编辑 2019.12.27 lf
		if(dhx.getOffset(this.cell).top+ (this.cell.clientHeight - 3)>document.body.clientHeight){
            this.hwReport.grid.objBox.scrollTop += dhx.getOffset(this.cell).top+ (this.cell.clientHeight - 3)-document.body.clientHeight;
        }
        this.cell.DOMelem_input.focus();
    }

    /**
  * 显示编辑器
  */
    this.showEditor = function () {
        var that = this;
        var val = this.getValue();
        if (this.cell.atag == "TEXTAREA") {
            this.cell.DOMelem_input.style.height = (this.cell.clientHeight - 3) + "px";
        }
        this.cell.DOMelem_input.onclick = null;
        this.cell.DOMelem_input.style.width = this.cell.clientWidth + "px";
        this.cell.DOMelem_input.value = val;
        this.cell.innerHTML = ""
        this.cell.appendChild(this.cell.DOMelem_input);
        this.cell._editorshow = true;

        this.grid.attachEvent("onSetSizes", function () {
            that.cell.DOMelem_input.style.width = that.cell.clientWidth + "px";
        });
    }

    this.setValue = function (val) {
        if ((typeof (val) != "number") && (!val || val.toString()._dhx_trim() == "")) {
            this.cell._clearCell = true;
        } else {
            this.cell._clearCell = false;
            if (this.cell.atag == "TEXTAREA") {
                val = val.replace(/\n/g, "<br/>")
            }
        }

        if (this.cell._editorshow) {
            this.cell.DOMelem_input.value = val;
            this.grid.callEvent("onCellChanged", [
                this.cell.parentNode.idd,
                this.cell._cellIndex,
                this.cell._clearCell ? "" : val
            ]);
        }
        else {
            this.setCValue(this.cell._clearCell ? "&nbsp;" : val, val);
        }
    }

    this.getValue = function () {
        if ((this.cell.firstChild) && ((this.cell.atag) && (this.cell.firstChild.tagName == this.cell.atag)))
            return this.cell.firstChild.value;

        if (this.cell._clearCell)
            return "";

        if (this.cell.atag == "TEXTAREA") {
            return this.cell.innerHTML.toString()._dhx_trim().replace(/<br(\/){0,1}>/g, "\n");
        }

        return this.cell.innerHTML.toString()._dhx_trim();
    }

    this.detach = function () {
        this.cell.DOMelem_input.className = this.cell.DOMelem_input.className.replace(/dhxcombo_actv/g, "");
        this.cell.className = this.cell.className.replace(new RegExp(this.hwReport.reportId + "-p-0", "gi"), " ");
        if (this.cell._editorshow == true) {
            this.grid.callEvent("onCellChanged", [
                this.cell.parentNode.idd,
                this.cell._cellIndex,
                this.cell.DOMelem_input.value
            ]);
        }
        else {
            this.setValue(this.cell.DOMelem_input.value);
        }
        return this.val != this.getValue();
    }
}
eXcell_vmded.prototype = new eXcell;
;
///<jscompress sourcefile="dhtmlxgrid_excell_vmdgrid.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhx4.attachEvent("onGridCreated", function (grid) {
    if (!window.dhx_globalImgPath) window.dhx_globalImgPath = grid.imgURL;

    var hwReport = grid.hwReport;
    if (!hwReport) {
        return;
    }

    for (var key in hwReport._cell_grids) {
        if (!hwReport._cell_grids[key].obj) {
            hwReport._cell_grids[key].obj = hwReport._cell_grids[key].init(grid);
        }
    }

    if (!hwReport._loading_handler_set_grid) {
        hwReport._loading_handler_set_grid = hwReport.attachEvent("onStoreSuccess", function (_store) {
            if (_store.grids) {
                for (var i = 0; i < _store.grids.length; i++) {
                    eXcell_vmdgrid.prototype.fillCellCombos(hwReport, _store.grids[i]);
                }
            }
        });
    }
});

function eXcell_vmdgrid(cell) {
    
    if (cell) {
        this.cell = cell;
        this.grid = this.cell.parentNode.grid;
        this.hwReport = this.grid.hwReport;

        this.cellType = this.hwReport._cell_grids[this.cell._attrs.sid];
        this.subgrid = this.cellType.obj;

        if (this.grid._disabled || this.isDisabled()) {
            this.subgrid.DOMelem_input.setAttribute("readonly", "readonly");
        }
    }

    this.isDisabled = function () {
        if (this.grid._disabled) {
            return true;
        }
        return this.cell._disabled;
    }

    this.setDisabled = function (fl) {
        if (fl != 'true' && fl != 1)
            fl = false;

        this.cell._disabled = fl;
        if (fl) {
            if (this.cell.firstChild && this.cell.firstChild.firstChild && this.cell.firstChild.firstChild.firstChild) {
                this.cell.firstChild.firstChild.firstChild.setAttribute("readonly", "readonly");
            }
            this.subgrid.DOMelem_input.setAttribute("readonly", "readonly");
        }
        else {
            if (this.cell.firstChild && this.cell.firstChild.firstChild && this.cell.firstChild.firstChild.firstChild) {
                this.cell.firstChild.firstChild.firstChild.removeAttribute("readonly");
            }
            this.subgrid.DOMelem_input.removeAttribute("readonly");
        }
    }

    this.edit = function () {
        var that = this;
        this.val = this.cell.combo_value;
        var text = this.getText();

        if (!/dhxcombo_actv/g.test(this.subgrid.DOMelem.className)) {
            this.subgrid.DOMelem.className += " dhxcombo_actv";
        }
        if (!this.cell._editorshow) {
            this.cell.className += " " + this.hwReport.reportId + "-p-0";
        }
        this.cell.innerHTML = "";

        this.subgrid.DOMParent.firstChild && (this.subgrid.DOMParent.firstChild.style.width = this.cell.clientWidth + "px");
        this.subgrid.DOMelem_input.style.width = (this.cell.clientWidth - 21) + "px";
        this.cell.appendChild(this.subgrid.DOMParent);
        
        this.subgrid.DOMelem_input.focus();
        this.subgrid.entBox.style.display = 'block';
        this.subgrid.entBox.style.zIndex="99";


        var top = (this.subgrid.DOMParent.clientHeight - this.subgrid.DOMelem.clientHeight) / 2;
        if (top < 1) {
            top = 0;
        }
        this.subgrid.DOMelem.style.top = top + "px";

        var s = window.dhx4.screenDim();
        var bh = this.subgrid.entBox.offsetHeight;
        //var bw = this.subgrid.entBox.offsetWidth;
        var bw = this.cell.clientWidth * this.cellType.percentWidth;

        var cellBoundingRect = this.cell.getBoundingClientRect();
        var top = cellBoundingRect.top + cellBoundingRect.height;
        var left = cellBoundingRect.left;
        if ((top + bh) > s.bottom) {
            top = cellBoundingRect.top - bh;
        }
        if ((left + bw) > s.right) {
            left = cellBoundingRect.left - (bw - cellBoundingRect.width);
        }

        this.subgrid.entBox.style.top = top + "px";
        this.subgrid.entBox.style.left = (left - 1) + "px";
        this.subgrid.entBox.style.width = bw + "px";
        this.subgrid.entBox.style.position = "absolute";
        this.subgrid.setSizes();
        var a = this.grid.editStop;
        this.grid.editStop = function () { };

        function setComboValue() {
            if (that.cellType.ismulti) {
                var combo_values = (that.cell.combo_value || "").split(that.cellType.seperator);
                var combo_texts = [];
                //取消选择
                for (var a in that.subgrid.rowsAr) {
                    var row = that.subgrid.rowsAr[a];
                    if (row && row.idd) {
                        var cellObj = that.subgrid.cells(a, 0);
                        if (cellObj.isCheckbox()) {
                            cellObj.setValue(0);
                        }
                        row.className = row.className.replace(" rowselected", "");
                    }
                }

                for (var i = 0; i < combo_values.length; i++) {
                    var row = that.subgrid.getRowById(combo_values[i]);
                    if (row) {
                        var checkCellObj = that.subgrid.cells(combo_values[i], 0);
                        var cellObj = that.subgrid.cells(combo_values[i], that.subgrid.getSubGridShowIndex());

                        checkCellObj.setChecked(true);
                        if (!/rowselected/g.test(row.className)) {
                            row.className += " rowselected";
                        }
                        that.subgrid.showRow(combo_values[i]);
                        combo_texts.push(cellObj.getValue());
                    }
                }
                that.subgrid.DOMelem_input.value = combo_texts.join(that.cellType.seperator);
                that.subgrid._is_checked_all_col0 = that.subgrid._is_checked_all_col0 == undefined ? that.subgrid.isCheckedAll(0) : that.subgrid._is_checked_all_col0;
                if (that.subgrid._is_checked_all_col0) {
                    that.subgrid.DOMelem_check_all.src = that.subgrid.DOMelem_check_all.src.replace("item_chk0.gif", "item_chk1.gif");
                }
                else {
                    that.subgrid.DOMelem_check_all.src = that.subgrid.DOMelem_check_all.src.replace("item_chk1.gif", "item_chk0.gif");
                }
            }
            else {
                that.subgrid.clearSelection();
                if (that.subgrid.getRowById(that.cell.combo_value))
                    that.subgrid.setSelectedRow(that.cell.combo_value);

                that.subgrid.DOMelem_input.value = text;
            }
        }

        setComboValue();

        this.subgrid.setActive(true)
        
        var cellType = this.hwReport._cell_grids[this.cell._attrs.sid];
        var conditions = cellType && cellType.bindsource && cellType.bindsource.conditions;
        if (conditions && conditions.length > 0) {
            this.subgrid.filterByDataStore(function (item, value) {
                for(var i = 0; i < conditions.length; i++){
                    if (item[conditions[i]["field"]] != that.hwReport.getValue(conditions[i]["value"], that)) {
                        return false;
                    }
                    return true;
                }
            });
            setComboValue();
        }
        else if (this.subgrid.rptStore) {
            this.subgrid.rptStore.update(function () {
                setComboValue()
            }, function () { });
        }

        this.grid.editStop = a;
        
    }

    /**
    * 显示编辑器
    */
    this.showEditor = function () {
        var that = this;
        var val = this.getText();
        this.cell.innerHTML = ""
        this.subgrid.DOMelem.style.width = this.cell.clientWidth + "px";
        this.subgrid.DOMelem_input.style.width = (this.cell.clientWidth - 24) + "px";
        this.subgrid.DOMelem_input.value = val;
        this.cell.appendChild(this.subgrid.DOMParent);
        this.subgrid.DOMelem.style.top = (this.subgrid.DOMParent.clientHeight - this.subgrid.DOMelem.clientHeight) / 2 + "px";

        this.cell._editorshow = true;

        this.grid.attachEvent("onSetSizes", function () {
            if (that.cell.firstChild && that.cell.firstChild.firstChild) {
                that.cell.firstChild.firstChild.style.width = that.cell.clientWidth + "px";
                that.cell.firstChild.firstChild.firstChild.style.width = (that.cell.clientWidth - 24) + "px";
            }

            that.subgrid.DOMelem.style.width = that.cell.clientWidth + "px";
            that.subgrid.DOMelem_input.style.width = (that.cell.clientWidth - 24) + "px";
        });
    }

    this.getValue = function () {
        return this.cell.combo_value || "";
    }

    this.getText = function (val) {
        var c = this.cell;
        if (c._editorshow) {
            return c.firstChild.firstChild.firstChild.value;
        }
        return (_isIE ? c.innerText : c.textContent);
    }

    this.setValue = function (val) {
        var that = this;
        this.cell.combo_value = val;

        if (this.cellType.ismulti) {
            var vals = (val || "").split(this.cellType.seperator);
            var texts = [];
            var _hasValueIngrid = false;
            for (var i = 0; i < vals.length; i++) {
                var tmpText = this.subgrid.getRowById(vals[i]) && this.subgrid.cells(vals[i], this.subgrid.getSubGridShowIndex());
                tmpText = tmpText && tmpText.getValue();
                if (!tmpText && this.subgrid.rule && this.subgrid.rptStore) {
                    tmpText = this.subgrid.rptStore.find(function (item) {
                        return item[that.subgrid.rule['value']] + "" == vals[i] + ""
                    });
                    tmpText = tmpText && tmpText[this.subgrid.rule['text']];
                }
                if (tmpText != null) {
                    _hasValueIngrid = true;
                }
                texts.push(tmpText || "");
            }
            var tmpVal = _hasValueIngrid ? texts.join(this.cellType.seperator) : "";
            if (tmpVal) {
                val = tmpVal;
            }
            else if (this.cellType && this.cellType.noValueClear) {
                val = "&nbsp;"
            }
        }
        else {
            if (this.subgrid.getRowById(val)) {
                val = this.subgrid.cells(val, this.subgrid.getSubGridShowIndex());
                if (val) val = val.getValue();
                else val = "";
            }
            else if (this.subgrid.rule && this.subgrid.rptStore) {
                tmpVal = this.subgrid.rptStore.find(function (item) {
                    return item[that.subgrid.rule['value']] + "" == val + ""
                });
                val = (tmpVal && tmpVal[this.subgrid.rule['text']]) || val;
            }
        }

        this.setComboCValue((val || "&nbsp;"), this.cell.combo_value);
    }

    this.detach = function () {
        var that = this;
        var val = this.cell.combo_value;
        this.cell.className = this.cell.className.replace(new RegExp(this.hwReport.reportId + "-p-0", "gi"), " ");
        this.subgrid.DOMelem.className = this.subgrid.DOMelem.className.replace(/dhxcombo_actv/g, "");

        if (!this.subgrid) return;
        this.subgrid.entBox.style.display = 'none';
        if (this.cellType.ismulti) {
            var checkIds = this.subgrid.getCheckedRowsAr(0);
            var checkedTexts = checkIds.map(function (v) {
                var cellObj = that.subgrid.cells(v, that.subgrid.getSubGridShowIndex());
                return (cellObj && cellObj.getValue()) || "";
            });
            if (checkedTexts.length == 0) {
                this.setComboCValue("&nbsp;", "");
                this.cell._clearCell = true;
            }
            else {
                this.setComboCValue(checkedTexts.join(this.cellType.seperator), checkIds.map(function (v) {return v.replace(/__\d+__/,"") }).join(this.cellType.seperator));
                this.cell._clearCell = false;
            }
            this.cell.combo_value = checkIds.map(function (v) { return v.replace(/__\d+__/, "") }).join(this.cellType.seperator);
        }
        else {
            var selectedId = this.subgrid.getSelectedId();
            var cellObj = selectedId && (that.subgrid.getSubGridShowIndex() || that.subgrid.getSubGridShowIndex() == 0) && that.subgrid.cells(selectedId, that.subgrid.getSubGridShowIndex());
            if (cellObj && cellObj.getValue()) {
                this.setComboCValue(cellObj.getValue(), selectedId.replace(/__\d+__/,""));
                this.cell._clearCell = false;
            }
            else {
                this.setComboCValue("&nbsp;", "");
                this.cell._clearCell = true;
            }
            this.cell.combo_value = selectedId && selectedId.replace(/__\d+__/,"");
        }

        if (that.subgrid.datastore) {
            that.subgrid.filterByDataStore(function (item, value) {
                return true;
            });
        }

        //this.grid.setActive(true)
        return this.cell.combo_value != val;
    }
}

eXcell_vmdgrid.prototype = new eXcell;
eXcell_vmdgrid.prototype.init = function (index) {
    
    var container = document.createElement("DIV");
    container.style.display = "none";
    container.style.zIndex = 99999;
    document.body.appendChild(container);
    container.className = "dhxgrid_in_grid_parent";
    var subgrid = new dhtmlXGridObject(container);

    subgrid.DOMParent = document.createElement("DIV");
    subgrid.DOMParent.className = "dhxcombo_in_grid_parent";
    subgrid.DOMParent.innerHTML = "<div class='dhxcombo_material'><input type='text' class='dhxcombo_input' autocomplete='off'>" +
            "<input type='hidden' value=''>" + // value
            "<input type='hidden' value='false'>" + // new_value
            "<div class='dhxcombo_select_button'><div class='dhxcombo_select_img'></div></div></div>";

    subgrid.DOMelem = subgrid.DOMParent.firstChild;
    subgrid.DOMelem_input = subgrid.DOMParent.firstChild.firstChild;

    var that = this;
    subgrid.subgridcelltype = this.cellType;
    this.grid.attachEvent("onScroll", function () {
        subgrid.entBox.style.display = 'none';
    });
    subgrid.entBox.onclick = function (event) { (event || window.event).cancelBubble = true; return false; }
    subgrid.attachEvent("onRowSelect", function (id) {
        //携带
        var multicolumns = that.cellType && that.cellType.bindsource && that.cellType.bindsource.multicolumns;
        if(multicolumns){
            for (var i = 0; i < multicolumns.length; i++) {
                var cellId = multicolumns[i].cellid;
                if (!cellId) {
                    continue;
                }
                var value = subgrid.cells(id, i).getValue();
                var targetCell = that.grid.hwReport.getCells(cellId);
                if (targetCell && targetCell.length == 1) {
                    var oValue = targetCell[0].getValue();
                    targetCell[0].setValue(value);

                    that.grid.callEvent("onEditCell", [
                        2,
                        targetCell[0].cell.parentNode.idd,
                        targetCell[0].cell._cellIndex,
                        value,
                        oValue
                    ]);
                }
            }
        }
        var isFirst = this._lastSelectTime == undefined ? true : false;
        this._lastSelectTime = this._lastSelectTime || new Date().valueOf();
        var currentTime = new Date().valueOf();
        var distance = currentTime - this._lastSelectTime;
        this._lastSelectTime = currentTime;
        if (that.__isEditStop == false) {
            if (isFirst || distance > 500) {
                that.__isEditStop = true;
            }
        }
        else {
            that.grid.editStop();
        }
        return true;
    });

    subgrid.attachEvent("onCheck", function (rId, cInd, state) {
        var checkIds = subgrid.getCheckedRowsAr(0);
        var checkedTexts = checkIds.map(function (v) {
            var cellObj = subgrid.cells(v, subgrid.getSubGridShowIndex());
            return (cellObj && cellObj.getValue()) || "";
        });
        subgrid.DOMelem_input.value = checkedTexts.join(that.cellType.seperator);

        var row = subgrid.getRowById(rId);
        if (state) {
            row.className += " rowselected";
            subgrid._is_checked_all_col0 = subgrid.isCheckedAll(0);
            if (subgrid._is_checked_all_col0) {
                subgrid.DOMelem_check_all.src = subgrid.DOMelem_check_all.src.replace("item_chk0.gif", "item_chk1.gif");
            }
        }
        else {
            subgrid._is_checked_all_col0 = false;
            row.className = row.className.replace(/ rowselected/g, "");
            subgrid.DOMelem_check_all.src = subgrid.DOMelem_check_all.src.replace("item_chk1.gif", "item_chk0.gif");
        }
    });

    subgrid.attachEvent("onXLE", function (grid_obj, count) {
        if (that.cellType.ismulti) {
            var checkCell = this.hdr.rows[1].cells[0];
            checkCell.firstChild.innerHTML = "<img src='" + this.imgURL + "item_chk0.gif' />";
            subgrid.DOMelem_check_all = checkCell.firstChild.firstChild;

            subgrid.DOMelem_check_all.onclick = function (e) {
                //执行选中操作
                if (/item_chk0.gif/g.test(this.src)) {
					var data=subgrid.rptStore.dhtmlxDatastore;
					var count=data.dataCount();
					for(var i=0;i<count;i++){
						var id=data.idByIndex(i);
						var item1=data.item(id);
						item1.chkid="1";	
					}
					data.refresh();
                    var checkedTexts = [];
                    for (var a in subgrid.rowsAr) {
                        var row = subgrid.rowsAr[a];
                        if (row && row.idd) {
                            var cellObj = subgrid.cells(a, 0);
                            if (cellObj.isCheckbox()) {
                                cellObj.setValue(1);
                            }
                            checkedTexts.push(subgrid.cells(a, subgrid.getSubGridShowIndex()).getValue());
                            if (!/rowselected/g.test(row.className)) {
                                row.className += " rowselected";
                            }
                        }
                    }
                    
                    this.src = this.src.replace("item_chk0.gif", "item_chk1.gif");
                    subgrid._is_checked_all_col0 = true;
					subgrid.DOMelem_input.value = checkedTexts.join(that.cellType.seperator);
					checkCell.firstChild.innerHTML = "<img src='" + this.src + "' />";
					subgrid.DOMelem_check_all = checkCell.firstChild.firstChild;
					subgrid.DOMelem_check_all.onclick=this.onclick;
                }
                else {
					var data=subgrid.rptStore.dhtmlxDatastore;
					var count=data.dataCount();
					for(var i=0;i<count;i++){
						var id=data.idByIndex(i);
						var item1=data.item(id);
						item1.chkid=undefined;
						//data.update(id,item1);
					}
					data.refresh();
                    for (var a in subgrid.rowsAr) {
                        var row = subgrid.rowsAr[a];
                        if (row && row.idd) {
                            var cellObj = subgrid.cells(a, 0);
                            if (cellObj.isCheckbox()) {
                                cellObj.setValue(0);
                            }
                            row.className = row.className.replace(" rowselected","");
                        }
                    }

                    this.src = this.src.replace("item_chk1.gif", "item_chk0.gif");
                    subgrid._is_checked_all_col0 = false;
					subgrid.DOMelem_input.value = "";
					checkCell.firstChild.innerHTML = "<img src='" + this.src + "' />";
					subgrid.DOMelem_check_all = checkCell.firstChild.firstChild;
					subgrid.DOMelem_check_all.onclick=this.onclick;
					
				}
				e.stopPropagation(); 
            }
        }
    });

    function _doOnInputKeyUp(e) {
        if (e.keyCode == 9 || e.keyCode == 13 ||
            e.keyCode == 37 || e.keyCode == 38 || e.keyCode == 39 || e.keyCode == 40 ||
            e.ctrlKey || e.shiftKey || e.altKey) return;

        var filterValue = dhx.trim(subgrid.DOMelem_input.value);
        subgrid.filterByDataStore(function (item, value) {
            if (filterValue == "") {
                return true;
            }
            
            if (item[subgrid.rule.value].toString().indexOf(filterValue) != -1 || item[subgrid.rule.text].toString().indexOf(filterValue) != -1) {
                return true;
            }
            return false;
        });
    }

    function _doOnInputKeyDown(e) {
        e = e || event;

        // console.log("onkeypress ", e.keyCode, " ", e.charCode)

        // up (38) /down (40)
        if ((e.keyCode == 38 || e.keyCode == 40) && !e.ctrlKey && !e.shiftKey && !e.altKey) {
            if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
            e.cancelBubble = true;
            var dataCursor = e.keyCode == 40 ? 0 : (subgrid.getRowsNum() - 1);
            that.__isEditStop = false;
            if (!subgrid.getSelectedRowId()) {
                subgrid.selectRow(dataCursor, true, false, true);
            }
            else {
                subgrid.doKey(e);
            }
        }

        // F2
        if (e.keyCode == 113) {
           
        }

        // esc
        if (e.keyCode == 27) {
           
        }

        // enter
        if (e.keyCode == 13) {
            if (e.preventDefault) e.preventDefault(); // if combo attached to form
            e.cancelBubble = true;
            that.__isEditStop = false;
            subgrid.callEvent("onRowSelect", [
								subgrid.getSelectedRowId(),
								0
            ]);
            that.grid.callEvent("onKeyPress", [e.keyCode || e.charCode, e.ctrlKey, e.shiftKey]);
        }

    }

    function _doOnInputKeyPress(e) {
        e = e || event;
        //that.grid.callEvent("onKeyPress", [e.keyCode || e.charCode, e.ctrlKey, e.shiftKey]);
    }

    function _doOnInputFocus(e) {

    }

    function _doOnInputBlur(e) {

    }

    function _doOnBodyMouseDown(e) {

    }

    function _doOnBaseMouseDown(e) {
        e = e || event;
        e.cancelBubble = true;
    }

    var evs_nodes = [
		{ node: document.body, evs: { mousedown: "_doOnBodyMouseDown" } },
		{ node: subgrid.DOMParent, evs: { mousedown: "_doOnBaseMouseDown" } },
		{ node: subgrid.DOMelem_input, evs: { keyup: "_doOnInputKeyUp", keydown: "_doOnInputKeyDown", keypress: "_doOnInputKeyPress", focus: "_doOnInputFocus", blur: "_doOnInputBlur" } }
    ];
    for (var q = 0; q < evs_nodes.length; q++) {
        for (var a in evs_nodes[q].evs) {
            if (typeof (window.addEventListener) == "function") {
                evs_nodes[q].node.addEventListener(a, eval(evs_nodes[q].evs[a]), false);
            } else {
                evs_nodes[q].node.attachEvent("on" + a, eval(evs_nodes[q].evs[a]));
            }
        }
    }

    subgrid._chRRS = false;

    return subgrid;

};

eXcell_vmdgrid.prototype.fillCellCombos = function (hwReport, cellId) {
    var grid = hwReport.grid;
    var oCell = hwReport.getOriginCellById(cellId);

    if (hwReport.bindDatastore) {
        for (var i = 0; i < grid.rowsCol.length; i++) {
            var cellObj = grid.cells3(grid.rowsCol[i], oCell.index);
            cellObj.refreshCell && cellObj.refreshCell();
        }
    }
    else {
        for (var i = 0; i < oCell.childs.length; i++) {
            var cellObj = grid.cells.apply(grid, oCell.childs[i].split("_"));
            cellObj.refreshCell && cellObj.refreshCell();
        }
    }
};

eXcell_vmdgrid.prototype.setComboCValue = function (value, value2) {

    if (this.cell._editorshow) {
        this.cell.innerHTML = this.subgrid.DOMParent.outerHTML;
        this.cell.firstChild.firstChild.firstChild.value = (value == "&nbsp;" ? "" : value);
        this.grid.callEvent("onCellChanged", [
            this.cell.parentNode.idd,
            this.cell._cellIndex,
            value2
        ]);
    }
    else {
        //this.setCValue(value, value2);
    
    //IE下的兼容
    var oldsubgridhtml;
    if(dhx.isIE)  oldsubgridhtml=this.subgrid.DOMParent.innerHTML;
    
        this.setCValue(value, value2);
    
    if(dhx.isIE && oldsubgridhtml){
      this.subgrid.DOMParent.innerHTML=oldsubgridhtml;
        this.subgrid.DOMParent.firstChild.firstChild.value=(value == "&nbsp;" ? "" : value);
    }

    }
};

eXcell_vmdgrid.prototype.refreshCell = function () {
    this.setValue(this.getValue());
};

dhtmlXGridObject.prototype.getSubGridShowIndex = function () {

    var cellType = this.subgridcelltype;
    var showColumn = cellType.bindsource.showcolumn;
    if (!showColumn) return;
    var index = this.columnIds.indexOf(showColumn.toLowerCase());
    return index;
}

dhtmlXGridObject.prototype.getCheckedRowsAr = function (col_ind) {
    var d = new Array();
    this.forEachRow(function (id) {
        var cell = this.cells(id, col_ind);
        if (cell.changeState && cell.getValue() != 0)
            d.push(id);
    },true);
    return d;
};
///<jscompress sourcefile="dhtmlxgrid_excell_vmdch.js" />
/*
filename：dhtmlxgrid_excell_vmdch.js
creater：刘志伟
date created：2019.03.14
description：ch组件
date modified：2019.03.14
modifier：刘志伟
version：2.3.3.0425
others：
copyright：Copyright @1999-2016, hwkj, All Rights Reserved
*/
/**
*	@desc: simple text editor
*	@returns: dhtmlxGrid cell editor object
*	@type: public
*/
function eXcell_vmdch(cell) {
    if (cell) {
        this.cell = cell;
        this.grid = this.cell.parentNode.grid;
        this.hwReport = this.grid.hwReport;
        var originCell = this.hwReport.getOriginCellById(this.cell._attrs.sid);
        this.cellType = this.hwReport.cellTypes.get(originCell.fillcelltype);
    }

    this.isDisabled = function () {
        if (this.grid._disabled) {
            return true;
        }
        return this.cell._disabled;
    }

    this.disabledF = function (fl) {
        if ((fl == true) || (fl == 1))
            this.cell.innerHTML = this.cell.innerHTML.replace("item_chk0.", "item_chk0_dis.").replace("item_chk1.",
				"item_chk1_dis.");
        else
            this.cell.innerHTML = this.cell.innerHTML.replace("item_chk0_dis.", "item_chk0.").replace("item_chk1_dis.",
				"item_chk1.");
    }

    this.changeState = function (fromClick) {
        //nb:
        if (fromClick === true && !this.grid.isActive) {
            if (window.globalActiveDHTMLGridObject != null && window.globalActiveDHTMLGridObject != this.grid && window.globalActiveDHTMLGridObject.isActive) window.globalActiveDHTMLGridObject.setActive(false);
            this.grid.setActive(true);
        }
        if ((!this.grid.isEditable) || (this.cell.parentNode._locked) || (this.isDisabled()))
            return;

        if (this.grid.callEvent("onEditCell", [
			0,
			this.cell.parentNode.idd,
			this.cell._cellIndex
        ])) {
            this.val = this.getValue()

            if (this.val == "1")
                this.setValue("0")
            else
                this.setValue("1")

            this.cell.wasChanged = true;
            //nb:
            this.grid.callEvent("onEditCell", [
				2,
				this.cell.parentNode.idd,
				this.cell._cellIndex,
                this.getValue(),
                this.val
            ]);

            this.grid.callEvent("onCheckbox", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
            ]);

            this.grid.callEvent("onCheck", [
				this.cell.parentNode.idd,
				this.cell._cellIndex,
				(this.val != '1')
            ]);
        } else { //preserve editing (not tested thoroughly for this editor)
            this.editor = null;
        }
    }
    this.getValue = function () {
        return this.cell.chstate ? this.cell.chstate.toString() : "0";
    }

    this.isCheckbox = function () {
        return true;
    }
    this.isChecked = function () {
        if (this.getValue() == "1")
            return true;
        else
            return false;
    }

    this.setChecked = function (fl) {
        this.setValue(fl.toString())
    }
    this.detach = function () {
        return this.val != this.getValue();
    }
    this.edit = null;
}
eXcell_vmdch.prototype = new eXcell;
eXcell_vmdch.prototype.setValue = function (val) {

    this.cell.style.verticalAlign = "middle"; //nb:to center checkbox in line
    //val can be int
    if (val) {
        val = val.toString()._dhx_trim();

        if ((val == "false") || (val == "0"))
            val = "";
    }

    if (val) {
        val = "1";
        this.cell.chstate = "1";
    } else {
        val = "0";
        this.cell.chstate = "0"
    }
    var obj = this;
    this.cell.setAttribute("excell", "ch");
    this.setCValue("<img src='" + this.grid.imgURL + "item_chk" + val
		+ ".gif' style='vertical-align:middle;' onclick='new eXcell_vmdch(this.parentNode).changeState(true); (arguments[0]||event).cancelBubble=true; '>" + (this.cellType.displayLabel ? ("<span style='vertical-align:middle; margin-left:4px;' >" + this.cellType.displayLabel + "</span>") : ""),
		this.cell.chstate);
}
;
///<jscompress sourcefile="dhtmlxgrid_excell_vmdorder.js" />
/*
filename：dhtmlxgrid_excell_order_tb.js
creater：刘志伟
date created：2016.11.19
description：序号组件
date modified：2017.12.06
modifier：刘志伟
version：2.2.15.1129
others：
copyright：Copyright @1999-2016, hwkj, All Rights Reserved
*/
function eXcell_vmdorder(cell) {
    if (cell) {
        this.cell = cell;
        this.cell._disabled = true;
        this.grid = this.cell.parentNode.grid;
    }
    
    this.getValue = function () {
        
        if (typeof this.cell._brval != "undefined") return this.cell._brval;

        return this.cell._brval || this.cell.innerHTML.toString()._dhx_trim(); //innerText;
    }
    this.setValue = function (val) {
        var hwReport = this.grid.hwReport;
		if(hwReport.vmdreport&&hwReport.vmdreport.xtype=="vmd.datainput")
		{
			var cell=this.cell;
			var that=this;
			window.setTimeout(function(){
				if (!cell.parentNode) return;
				var val=cell.parentNode.rowIndex;
				if (cell.parentNode.grid.currentPage || val<0 || cell.parentNode.grid._srnd) val=cell.parentNode.grid.rowsBuffer._dhx_find(cell.parentNode)+1;
				if (val<=0) return;
					cell.innerHTML = val;
				if (cell.parentNode.grid._fake && cell._cellIndex<cell.parentNode.grid._fake._cCount && cell.parentNode.grid._fake.rowsAr[cell.parentNode.idd]) cell.parentNode.grid._fake.cells(cell.parentNode.idd,cell._cellIndex).setCValue(val);
					cell=null;
				that.setCValue(val);
			},100);
		}
		else
		{        
			var oCell = hwReport.getOriginCellById(this.cell._attrs.sid);
			if (!val && oCell) {
				var cellType = hwReport.cellTypes.get(oCell && oCell.fillcelltype);
				var start = (cellType && cellType.start) || 1;
				oCell._seed = oCell._seed || start;
				val = oCell._seed++;
			}
			val = val || "1";
			this.cell._brval = val;
			this.setCValue(val);
		}
    }
}

eXcell_vmdorder.prototype = new eXcell;


;
///<jscompress sourcefile="dhtmlxgrid_excell_vmdsubreport.js" />
/*
filename：dhtmlxgrid_eXcell_vmdsubreport.js
creater：刘志伟
date created：2016.11.19
description：子填报
date modified：2018.05.21
modifier：刘志伟
version：2.3.3.0425
others：
copyright：Copyright @1999-2016, hwkj, All Rights Reserved
*/
function eXcell_vmdsubreport(cell) {
    var that = this;
    if (cell) {
        this.cell = cell;
        this.grid = this.cell.parentNode.grid;
        this.hwReport = this.grid.hwReport;
        var oCell = this.hwReport.getOriginCellById(cell._attrs.sid);
        var cellType = this.hwReport.cellTypes.get(oCell.fillcelltype);

        this.cell.style.padding = "0px";

        //cellType.subrptshowmode = "popup";
        //嵌入式子表
        if (cellType.subrptshowmode == "embed") {
            this.hwReport.embedSubReportCells = this.hwReport.embedSubReportCells || {};
            this.hwReport.embedSubReportCells[cell.parentNode.idd + "_" + cell._cellIndex] = cell;
        }
        else if (cellType.subrptshowmode == "expand" && cellType.spread == "1") {
            this.hwReport.expandSubReportCells = this.hwReport.expandSubReportCells || {};
            this.hwReport.expandSubReportCells[cell.parentNode.idd + "_" + cell._cellIndex] = cell;
        }

        if (!this.hwReport.sub_onReportRendered_id) {
            this.hwReport.sub_onReportRendered_id = this.hwReport.attachEvent("onRendered", function () {
                if (!that.hwReport.isEmpty(that.hwReport.expandSubReportCells)) {
                    for (var item in that.hwReport.expandSubReportCells) {
                        that.grid._expandMonolite_vmd.apply(that.hwReport.expandSubReportCells[item].firstChild, [window.event]);
                    }
                }

                if (!that.hwReport.isEmpty(that.hwReport.embedSubReportCells)) {
                    that.grid._flow = [];
                    for (var item in that.hwReport.embedSubReportCells) {
                        var td = that.hwReport.embedSubReportCells[item];
                        var sub = that.grid._sub_vmdreport_render(td, "embed");
                        that.grid._flow[td.parentNode.idd] = td._d;
                        that.grid.attachEvent("onGridReconstructed", function () {
                            if ((this.pagingOn && !this.parentGrid) || this._srnd) this._collapsMonolite_vmd();
                            else this._correctMonolite_vmd(null, false);
                        });
                        that.grid.attachEvent("onClearAll", function () {
                            for (var i in this._flow) {
                                if (this._flow[i] && this._flow[i].parentNode) this._flow[i].parentNode.removeChild(this._flow[i]);
                            }; this._flow = [];
                        });
                        that.grid.callEvent("onSubReportOpen", [td.parentNode.idd, td._cellIndex, sub]);
                    }
                }
            });
        }
    }

    this.setValue = function (val) {
        this.cell._sub_row_type = "vmdsubreport";

        var oCell = this.hwReport.getOriginCellById(this.cell._attrs.sid);
        var cellType = this.hwReport.cellTypes.get(oCell.fillcelltype);
        if (cellType.subrptshowmode == "popup") {
            this._setState("pop.png");
        }
        else if (cellType.subrptshowmode == "embed") { }
        else {
            this._setState(val ? "plus.gif" : "plus.gif");
        }
    }

    this.getValue = function () {
        return this.cell._attrs.data;
    }

    this._setState = function (m, v) {
        var that = this;
        var cell = v || this.cell;
        var oCell = this.hwReport.getOriginCellById(cell._attrs.sid);
        var cellType = this.hwReport.cellTypes.get(oCell.fillcelltype);
        var innerHTML = "";
        if (m != "minus.gif") {
            innerHTML = "<div style='cursor:pointer;'>"
                + "<img src='" + this.grid.imgURL + m + "' style='width:18px;height:18px;float:left;'/>"
                + "<span style='line-height:18px;'>" + (cell._attrs.data || "&nbsp;") + "</span>"
                + "</div>";
            cell.className = cell.className.replace(this.hwReport.reportId + "-v-top", "");
        }
        else {
            var oldHeight = cell.parentNode.oldHeight || cell.offsetHeight;
            var paddingTop = parseInt((oldHeight - cell.firstChild.offsetHeight) / 2);
            innerHTML = "<div style='cursor:pointer;padding-top:" + paddingTop + "px;'>"
                + "<img src='" + this.grid.imgURL + m + "' style='width:18px;height:18px;float:left;'/>"
                + "<span style='line-height:18px;'>" + (cell._attrs.data || "") + "</span>"
                + "</div>";
            cell.className += " " + this.hwReport.reportId + "-v-top";
        }
        
        cell.innerHTML = innerHTML;
        cell.firstChild.onclick = function(e){
            if (cellType.subrptshowmode == "popup") {
                that.grid.openSubReportInWindow.apply(that.grid, [e, cell])
            }
            else {
                that.grid._expandMonolite_vmd.apply(cell.firstChild, [e]);
            }
        }
    }
}
eXcell_vmdsubreport.prototype = new eXcell;

dhtmlXGridObject.prototype._sub_vmdreport_render = function (cell, subType) {
    if (cell._d) {
        cell._d.parentNode.removeChild(cell._d);
    }
    var that = this;
    var d = document.createElement("DIV");
    d.ctrl = { rId: cell.parentNode.idd, cIndex: cell._cellIndex };
    d.style.cssText = "position:absolute;width:" + (cell.offsetWidth) + "px; height:" + cell.offsetHeight + "px; left:" + cell.offsetLeft + "px; top:" + cell.offsetTop + "px; overflow-x:hidden; font-family:Tahoma; font-size:8pt; margin-bottom:0px;";
    d.className = "dhx_sub_row ";
    this.objBox.appendChild(d);
    cell._d = d;

    var c = document.createElement("DIV");
    c.id = "sub_" + cell.parentNode.idd + "_" + cell._cellIndex;
    d.appendChild(c);

    var oCell = this.hwReport.getOriginCellById(cell._attrs.sid);
    var cellType = this.hwReport.cellTypes.get(oCell.fillcelltype);
    var subjson = this.hwReport.subs[cellType.subrptindex];
    var subReport = new HwReport(this.hwReport.vmdreport, d, c, cell.offsetWidth, cell.offsetHeight, true, true, true, subType);

    if (!subjson) {
        return subReport;
    }

    subReport.attachEvent("onSectionSeverSuccess", function () {
        subReport.vmdreport.myMask.hide();
    });

    subReport.init();
    subReport.parse(subjson);
    subReport.analysis();
    subReport.integrateMatrix();
    subReport.insertRules();

    subReport.prepare();
    subReport.initContainer();
    subReport.initMenus();
    subReport.initGrid();
    subReport.attachGridEvent();
    subReport.updateDatastore();

    subReport.grid.attachEvent("onSetSizes", function () {
        that.hwReport.grid._detectHeight_tb(d, cell);
        that.hwReport.grid._correctMonolite_vmd();
        that.hwReport.setSize();
        that.hwReport.setPosition();
    });

    this.hwReport.subReports.put(subjson.name, subReport);
    subReport.parentReport = this.hwReport;
    return subReport;
}

dhtmlXGridObject.prototype._expandMonolite_vmd = function (n, show, hide) {
    var td = this.parentNode;
    var row = td.parentNode;
    var that = row.grid;

    if (n || window.event) {
        if (!hide && !row._expanded) that.editStop();
        (n || event).cancelBubble = true;
    }

    var c = that.getUserData(row.idd, "__sub_row");

    if (!that._sub_row_editor)
        that._sub_row_editor = new eXcell_vmdsubreport(td);

    if (row._expanded && !show) {
        that._sub_row_editor._setState("plus.gif", td);
        td._previous_content = row._expanded;
        that.objBox.removeChild(row._expanded);
        row._expanded = false;
        row.style.height = (row.oldHeight || 20) + "px";
        td.style.height = (row.oldHeight || 20) + "px";

        if (that._fake) {
            that._fake.rowsAr[row.idd].style.height = (row.oldHeight || 20) + "px";
            that._fake.rowsAr[row.idd].firstChild.style.height = (row.oldHeight || 20) + "px";
        }

        for (var i = 0; i < row.cells.length; i++)
            row.cells[i].style.verticalAlign = "middle";

        delete that._flow[row.idd];
        that._correctMonolite_vmd();
        row._expanded.ctrl = null;
    } else if (!row._expanded && !hide) {
        that._sub_row_editor._setState("minus.gif", td);
        row.oldHeight = row.oldHeight || td.offsetHeight/* - 4*/;
        if (td._previous_content) {
            var d = td._previous_content;
            d.ctrl = td;
            that.objBox.appendChild(d);
            that._detectHeight_tb(d, td, parseInt(d.style.height))
        }
        else {
            if (td._sub_row_type)
                td.sub_report = that._sub_vmdreport_render(td, "expand");
            else
                td._d.innerHTML = c;
            
            that._detectHeight_tb(td._d, td)
        }

        if (!that._flow) {
            that.attachEvent("onGridReconstructed", function () {
                if ((this.pagingOn && !this.parentGrid) || this._srnd) this._collapsMonolite_vmd();
                else this._correctMonolite_vmd();
            });
            that.attachEvent("onResizeEnd", function () { this._correctMonolite_vmd(true); });
            that.attachEvent("onAfterCMove", function () { this._correctMonolite_vmd(true); });
            that.attachEvent("onDrop", function () { this._correctMonolite_vmd(true); });
            that.attachEvent("onBeforePageChanged", function () { this._collapsMonolite_vmd(); return true; });
            that.attachEvent("onGroupStateChanged", function () { this._correctMonolite_vmd(); return true; });
            that.attachEvent("onFilterEnd", function () { this._collapsMonolite_vmd(); });
            that.attachEvent("onUnGroup", function () { this._collapsMonolite_vmd(); });
            that.attachEvent("onPageChanged", function () { this._collapsMonolite_vmd(); });

            that.attachEvent("onXLE", function () { this._collapsMonolite_vmd(); });
            that.attachEvent("onClearAll", function () {
                for (var i in this._flow) {
                    if (this._flow[i] && this._flow[i].parentNode) this._flow[i].parentNode.removeChild(this._flow[i]);
                }; this._flow = [];
            });
            //that.attachEvent("onEditCell", function (a, b, c) { if ((a !== 2) && this._flow[b] && this.cellType[c] != "ch" && this.cellType[c] != "ra") this._expandMonolite_vmd.apply(this._flow[b].ctrl.firstChild, [0, false, true]); return true; });
            that.attachEvent("onCellChanged", function (id, ind) {
                if (!this._flow[id]) return;
                var c = this.cells(id, ind).cell;
                c.style.verticalAlign = "top";
            });

            that._flow = [];
        }

        that._flow[row.idd] = td._d;
        that._correctMonolite_vmd();
        //d.style.top=row.offsetTop+20+"px";

        var padtop = that._srdh > 30 ? 11 : 3;
        if (that.multiLine) padtop = 0;

        for (var i = 0; i < row.cells.length; i++)
            row.cells[i].style.verticalAlign = "top";
        if (that._fake) {
            var frow = that._fake.rowsAr[row.idd];
            for (var i = 0; i < frow.cells.length; i++) {
                frow.cells[i].style.verticalAlign = "top";
            }
        }
        row._expanded = td._d;
    }
    if (that._ahgr) {
        that.setSizes();
    }
    if (!!row._expanded) {
        that.callEvent("onSubReportOpen", [row.idd, td._cellIndex, td.sub_report]);
    }
    else{
        that.callEvent("onSubReportClose", [row.idd, td._cellIndex, td.sub_report]);
    }
}

dhtmlXGridObject.prototype._detectHeight_tb = function (d, td, h) {
    var l = td.offsetLeft ;
    d.style.left = l + "px";
    //d.style.width = Math.max(0, td.offsetWidth) + "px"
    var h = h || d.firstChild.scrollHeight;
    d.style.overflow = "hidden";
    d.style.height = h + "px";
    var row = td.parentNode;
    td.parentNode.style.height = (row.oldHeight || 20) + h * 1 + "px";
    td.style.height = (row.oldHeight || 20) + h * 1 + "px";
    if (this._fake) {
        var tr = this._fake.rowsAr[td.parentNode.idd];
        tr.style.height = (row.oldHeight || 20) + h * 1 + "px";
        tr.firstChild.style.height = (row.oldHeight || 20) + h * 1 + "px";
    }
}

dhtmlXGridObject.prototype._correctMonolite_vmd = function (mode, header) {
    if (this._in_correction) return;
    this._in_correction = true;

    for (var a in this._flow)
        if (this._flow[a] && this._flow[a].tagName == "DIV")
            if (this.rowsAr[a]) {
                if (this.rowsAr[a].style.display == "none") {
                    this.cells4(this._flow[a].ctrl).close();
                    continue;
                }
                this._flow[a].style.top = this.rowsAr[a].offsetTop + (header == false ? -1 : (this.rowsAr[a].oldHeight || 20)) + 1 + "px";
                if (mode) {
                    var l = this._flow[a].ctrl.offsetLeft + this._flow[a].ctrl.offsetWidth;
                    this._flow[a].style.left = l + "px";
                    this._flow[a].style.width = this.rowsAr[a].offsetWidth - l - 4 + "px"
                }
            }
            else {
                this._flow[a].ctrl = null;
                this.objBox.removeChild(this._flow[a]);
                delete this._flow[a];
            }

    this._in_correction = false;
}

dhtmlXGridObject.prototype._collapsMonolite_vmd = function () {
    for (var a in this._flow)
        if (this._flow[a] && this._flow[a].tagName == "DIV")
            if (this.rowsAr[a])
                this.cells4(this._flow[a].ctrl).close();
}

dhtmlXGridObject.prototype.openSubReportInWindow = function (e, cell, left, right, width, height) {
    var that = this;
    if (e || window.event) {
        this.editStop();
        (e || event).cancelBubble = true;
    }

    var grid = this;
    var hwReport = this.hwReport;
    var oCell = hwReport.getOriginCellById(cell._attrs.sid);
    var cellType = hwReport.cellTypes.get(oCell.fillcelltype);
    var winId = "win_" + cell._attrs.sid;

    hwReport.wins = hwReport.wins || {};
    reportWin = hwReport.wins[winId];
    if (reportWin) {
        reportWin.show();
        return;
    }

    var winLeft = left || 0;
    var winRight = right || 0;
    var winWidth = width || 600;
    var winHeight = height || 320;

    var dhxWins = hwReport.dhxWins = hwReport.dhxWins || new dhtmlXWindows();
    var reportWin = dhxWins.createConfirmWindow(winId, winLeft, winRight, winWidth, winHeight);
    reportWin.center();
    reportWin.setModal(true);
    reportWin.setText(cell._attrs.data || "");
    //reportWin.cell.firstChild.style.overflow = "auto";
    //reportWin.button("close").disable();
    hwReport.wins[winId] = reportWin;

    var c = document.createElement("DIV");
    c.id = winId;
    c.style.position = "relative";
    reportWin.cell.firstChild.appendChild(c);

    reportWin.button("close").attachEvent("onClick", function () {
        reportWin.setModal(false);
        reportWin.hide();
        that.callEvent("onSubReportClose", [cell.parentNode.idd, cell._cellIndex, subReport]);
        return false;
    });

    var oCell = this.hwReport.getOriginCellById(cell._attrs.sid);
    var cellType = this.hwReport.cellTypes.get(oCell.fillcelltype);

    var subjson = this.hwReport.subs[cellType.subrptindex];
    var subReport = new HwReport(this.hwReport.vmdreport, reportWin.cell.firstChild, c, reportWin.cell.firstChild.clientWidth, reportWin.cell.firstChild.clientHeight);

    if (!subjson) {
        return subReport;
    }

    subReport.init();
    subReport.parse(subjson);
    subReport.analysis();
    subReport.integrateMatrix();
    subReport.insertRules();

    subReport.prepare();
    subReport.initContainer();
    subReport.initMenus();
    subReport.initGrid();
    subReport.attachGridEvent();
    subReport.updateDatastore();

    this.hwReport.subReports.put(subjson.name, subReport);
    subReport.parentReport = this.hwReport;

    reportWin.attachEvent("onResizeFinish", function (win) {
        subReport.setSize(win.cell.clientWidth, win.cell.clientHeight);
        subReport.setPosition();
    });

    reportWin.attachEvent("onResizeFinish", function (win) {
        subReport.setSize(win.cell.clientWidth, win.cell.clientHeight);
        subReport.setPosition();
    });

    reportWin.attachEvent("onShow", function (win) {
        that.callEvent("onSubReportOpen", [cell.parentNode.idd, cell._cellIndex, subReport]);
    });

    this.callEvent("onSubReportOpen", [cell.parentNode.idd, cell._cellIndex, subReport]);
};
///<jscompress sourcefile="dhtmlxgrid_excell_vmdguid.js" />
/*
filename：dhtmlxgrid_excell_vmdguid.js
creater：刘志伟
date created：2019.03.14
description：guid组件
date modified：2019.03.14
modifier：刘志伟
version：2.3.3.0425
others：
copyright：Copyright @1999-2016, hwkj, All Rights Reserved
*/
function eXcell_vmdguid(cell) {
    if (cell) {
        this.cell = cell;
        this.cell._disabled = true;
        this.grid = this.cell.parentNode.grid;
    }
    
    this.getValue = function () {
        
        if (typeof this.cell._brval != "undefined") return this.cell._brval;

        return this.cell._brval || this.cell.innerHTML.toString()._dhx_trim(); //innerText;
    }
    this.setValue = function (val) {
        var hwReport = this.grid.hwReport;
        var oCell = hwReport.getOriginCellById(this.cell._attrs.sid);
        var cellType = hwReport.cellTypes.get(oCell && oCell.fillcelltype);
        var len = (cellType && cellType.len) || 32;
        val = val || vmd.getGuid(len);
        this.cell._brval = val;

        this.setCValue(val);
    }
}

eXcell_vmdguid.prototype = new eXcell;
;
///<jscompress sourcefile="dhtmlxgrid_excell_vmdbutton.js" />
/*
filename：dhtmlxgrid_excell_vmdbutton.js
creater：刘志伟
date created：2016.11.19
description：按钮组件
date modified：2019.03.15
modifier：李份
version：2.2.15.1129
others：
copyright：Copyright @1999-2016, hwkj, All Rights Reserved
*/
function eXcell_vmdbutton(cell) {
    
    if (cell) {
        this.cell = cell;
        this.grid = this.cell.parentNode.grid;
        this.hwReport = this.grid.hwReport;
    }
    var that = this;
    this.conf = {};

    this.isDisabled = function () {
        if (this.grid._disabled) {
            return true;
        }
        return this.cell._disabled;
    }

    this.setValue = function (val) {
        var oCell = this.hwReport.getOriginCellById(cell._attrs.sid);
        var cellType = this.hwReport.cellTypes.get(oCell.fillcelltype);
        this.cell.innerHTML = "";
        if (cellType.bottontype == "none") {
            this.cell._val = cellType.name;
            this.cell.innerHTML = "<input type='button' class=' noprint' value='" + (cellType.name || val) + "'/>";
            this.cell.firstChild.onclick = function (e) {
                (e || event).cancelBubble = true;
                that.hwReport.callEvent("onEditRow", [
                    "label",
                    that.cell.parentNode.idd,
                    that.cell._cellIndex
                ])
                return false;
            }
        }
        else if (cellType.bottontype == "add-delete") {
            this.cell._val = "add-delete";
            this.cell.innerHTML = ""
                + "<img class='noprint' src='" + this.grid.imgURL + "add.png'/>"
                + "<img class='noprint' src='" + this.grid.imgURL + "delete.png'/>";;
            this.cell.children[0].onclick = function (e) {
                (e || event).cancelBubble = true;
                that.hwReport.callEvent("onEditRow", [
                    "add",
                    that.cell.parentNode.idd,
                    that.cell._cellIndex
                ])
                return false;
            }
            this.cell.children[1].onclick = function (e) {
                (e || event).cancelBubble = true;
                that.hwReport.callEvent("onEditRow", [
                    "delete",
                    that.cell.parentNode.idd,
                    that.cell._cellIndex
                ])
                return false;
            }
        }
        else if (cellType.bottontype) {
            var buttonTypeMap = {
                "insertrow": "add",
                "deleterow": "delete",
                "editrow": "edit",
                "retract": "retract",
                "expend": "expend",
                "moveup": "moveup",
                "movedown": "movedown"
            }
            var buttonType = cellType.bottontype == "extend_retract" ? buttonTypeMap[cellType.status] : buttonTypeMap[cellType.bottontype];
            this.cell._val = buttonType;
            if (cellType.text) {
                if (cellType.labelpos == "left") {
                    this.cell.innerHTML = "<span>" + cellType.text + "</span>" + "<img class='noprint' src='" + this.grid.imgURL + buttonType + ".png'/>";
                }
                else {
                    this.cell.innerHTML = "<img class='noprint' src='" + this.grid.imgURL + buttonType + ".png'/>" + "<span>" + cellType.text + "</span>";
                }
                this.cell.firstChild.onclick = function (e) {
                    (e || event).cancelBubble = true;
                    that.hwReport.callEvent("onEditRow", [
                        buttonType,
                        that.cell.parentNode.idd,
                        that.cell._cellIndex
                    ])
                    return false;
                }
                this.cell.lastChild.onclick = function (e) {
                    (e || event).cancelBubble = true;
                    that.hwReport.callEvent("onEditRow", [
                        buttonType,
                        that.cell.parentNode.idd,
                        that.cell._cellIndex
                    ])
                    return false;
                }
            }
            else {
                this.cell.innerHTML = "<img class='noprint' src='" + this.grid.imgURL + buttonType + ".png'/>";
                this.cell.firstChild.onclick = function (e) {
                    (e || event).cancelBubble = true;
                    that.hwReport.callEvent("onEditRow", [
                        buttonType,
                        that.cell.parentNode.idd,
                        that.cell._cellIndex
                    ])
                    return false;
                }
            }

        }
        else if (val) {
            this.cell._val = val;
            this.cell.innerHTML = "<span class='noprint'>" + val + "</span>";
            this.cell.firstChild.onclick = function (e) {
                (e || event).cancelBubble = true;
                that.hwReport.callEvent("onEditRow", [
                    "label",
                    that.cell.parentNode.idd,
                    that.cell._cellIndex
                ])
                return false;
            }
        }

        this.conf.evs_nodes = [
            { node: document.body, evs: { mousedown: "_doOnBodyMouseDown" } },
            { node: this.cell, evs: { keyup: "_doOnInputKeyUp", keydown: "_doOnInputKeyDown", keypress: "_doOnInputKeyPress", focus: "_doOnInputFocus", blur: "_doOnInputBlur", input: "_doOnInputInput" } }
        ];
        for (var q = 0; q < this.conf.evs_nodes.length; q++) {
            for (var a in this.conf.evs_nodes[q].evs) {
                if (window.addEventListener) {
                    this.conf.evs_nodes[q].node.addEventListener(a, this[this.conf.evs_nodes[q].evs[a]], false);
                } else {
                    this.conf.evs_nodes[q].node.attachEvent("on" + a, this[this.conf.evs_nodes[q].evs[a]]);
                }
            }
        }
    }

    this.getValue = function () {
        return this.cell._val;
    }

    this.detach = null;
    this.edit = null;

    this._doOnInputKeyDown = function (e) {

        e = e || event;

        // console.log("onkeypress ", e.keyCode, " ", e.charCode)

        // up (38) /down (40)
        if ((e.keyCode == 38 || e.keyCode == 40) && !e.ctrlKey && !e.shiftKey && !e.altKey) {
            if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
            e.cancelBubble = true;
            that._keyOnUpDown(e.keyCode == 38 ? -1 : 1);
        }

        // F2
        if (e.keyCode == 113) {
            if (!that._isListVisible()) {
                that._showList();
                if (that.cell.firstChild.value == that.conf.last_text) {
                    that._setSelected(that.conf.last_selected, true, true);
                    that.cell.firstChild.value = that.conf.last_text;
                    that.conf.f_server_last = that.cell.firstChild.value.toLowerCase();
                } else {
                    that.conf.f_server_last = that.cell.firstChild.value.toLowerCase();
                    if (that.conf.f_mode == false) that._checkForMatch();
                }
            } else {

            }
        }

        // esc
        if (e.keyCode == 27) {
            // cancel operation, restore last value
            if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
            e.cancelBubble = true;
            that._cancelSelect();
        }

        // enter
        if (e.keyCode == 13) {
            if (e.preventDefault) e.preventDefault(); // if combo attached to form
            that._confirmSelect("kbd");
        }

        that.conf.clear_key = true;
        that.callEvent("onKeyPressed", [e.keyCode || e.charCode]);
    }
}
eXcell_vmdbutton.prototype = new eXcell;;
///<jscompress sourcefile="dhtmlxgrid_excell_vmdcombo.js" />
/*
Product Name: dhtmlxSuite
Version: 5.0.8
Edition: Professional
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhx4.attachEvent("onGridCreated", function (grid) {
	if (!window.dhx_globalImgPath) window.dhx_globalImgPath = grid.imgURL;

	var hwReport = grid.hwReport;
	if (!hwReport) {
		return;
	}

	for (var key in hwReport._cell_combos) {
		var cellType = hwReport._cell_combos[key];
		if (!cellType.obj) {
			cellType.obj = cellType.init(grid);
		}
	}

	if (!hwReport._loading_handler_set_combo) {
		hwReport._loading_handler_set_combo = hwReport.attachEvent("onStoreSuccess", function (_store) {
			if (_store.combos) {
				for (var i = 0; i < _store.combos.length; i++) {
					eXcell_vmdcombo.prototype.fillCellCombos(hwReport, _store.combos[i]);
				}
			}
		});
	}
});

function eXcell_vmdcombo(cell) {

	if (!cell) return;

	this.cell = cell;
	this.grid = cell.parentNode.grid;
	this._combo_pre = "";

	this.hwReport = this.grid.hwReport;
	this.cellType = this.hwReport._cell_combos[this.cell._attrs.sid];
	this.combo = this.cellType.obj;

	if (this.grid._disabled || this.isDisabled()) {
		this.combo.DOMelem_input.setAttribute("readonly", "readonly");
	}

	this.isDisabled = function () {
		if (this.grid._disabled) {
			return true;
		}
		return this.cell._disabled;
	}

	this.setDisabled = function (fl) {
		if (fl != 'true' && fl != 1)
			fl = false;

		this.cell._disabled = fl;
		if (fl) {
			if (this.cell.firstChild && this.cell.firstChild.firstChild && this.cell.firstChild.firstChild.firstChild) {
				this.cell.firstChild.firstChild.firstChild.setAttribute("readonly", "readonly");
			}
			this.combo.DOMelem_input.setAttribute("readonly", "readonly");
		}
		else {
			if (this.cell.firstChild && this.cell.firstChild.firstChild && this.cell.firstChild.firstChild.firstChild) {
				this.cell.firstChild.firstChild.firstChild.removeAttribute("readonly");
			}
			this.combo.DOMelem_input.removeAttribute("readonly");
		}
	}

	this.edit = function(){
		if (!window.dhx_globalImgPath) window.dhx_globalImgPath = this.grid.imgURL;
		var that = this;

		this.val = this.getValue();
		var val = this.getText();
		this.cell.innerHTML = "";

		if (!this.cell._editorshow) {
			this.cell.style.padding = "0px";
		}

		this.cell.appendChild(this.combo.DOMParent);

		this.combo.DOMParent.style.margin = "0";
		this.combo.DOMelem_input.focus();
		this.combo.base.style.width = this.cell.clientWidth + "px";
		this.combo.base.firstChild.style.width = (this.cell.clientWidth - (this.combo.conf.i_ofs + 1)) + "px";
		this.combo.DOMelem.style.top = (this.combo.DOMParent.clientHeight - this.combo.DOMelem.clientHeight) / 2 + "px";
		//this.combo.base.firstChild.style.marginLeft = (this.conf.combo_image ? this.conf.i_ofs + "px" : "0px");
		//this.combo.base.style.paddingBottom = "0px";
		//this.combo.base.style.borderBottom = "0px solid #dfdfdf";
		this.combo.conf.combo_width = this.cell.clientWidth * this.cellType.percentWidth;

		function setComboValue(val) {
			//下拉框多选
			if (that.cellType.ismulti) {
				var combo_values = (that.cell.combo_value || "").split(that.cellType.seperator);
				var combo_texts = [];

				if (that.combo.conf.last_hover != null) {
					that.combo.t[that.combo.conf.last_hover].obj.setSelected(that.combo.t[that.combo.conf.last_hover].item, false);
					that.combo.conf.last_hover = null;
				}
				that.combo.base.firstChild.value = "";
				//if (that.combo.conf.f_mode != false) {
				//    that.combo._filterOpts(true);
				//}

				that.combo.forEachOption(function (optId) {
					that.combo.setChecked(optId.index, false);
				});

				for (var i = 0; i < combo_values.length; i++) {
					var option = that.combo.getOption(combo_values[i]);
					if (option) {
						that.combo.setChecked(option.index, true);
						that.combo.selectOption(option.index);
						combo_texts.push(option.text);
					}
				}
				that.combo.DOMelem_input.value = combo_texts.join(that.cellType.seperator);
			}
			else {
				if (that.combo.getIndexByValue(that.cell.combo_value) != -1) {
					that.combo.selectOption(that.combo.getIndexByValue(that.cell.combo_value));
				} else {
					if (that.combo.getOptionByLabel(val)) {
						that.combo.selectOption(that.combo.getIndexByValue(that.combo.getOptionByLabel(val).value));
					} else {
						that.combo.unSelectOption();
					}
				}
				that.combo.DOMelem_input.value = val;
			}
		}

		setComboValue(val);

		var conditions = this.cellType && this.cellType.bindsource && this.cellType.bindsource.conditions;
		//条件过滤
		if (conditions && conditions.length > 0) {
			this.combo.filterByDataStore(function (item, value) {
				for(var i = 0; i < conditions.length; i++){
					if (item[conditions[i]["field"]] != that.hwReport.getValue(conditions[i]["value"], that)) {
						return false;
					}
					return true;
				}
			});
			setComboValue(val);
		}
		else if (this.combo.rptStore) {
			this.combo._ishideList = false;
			this.combo.rptStore.update(function () {
				setComboValue(val);
				that.combo.openSelect();
			}, function () { });
		}
		this.combo.openSelect();
	}

	/**
	 * 显示编辑器
	 */
	this.showEditor = function () {
		var that = this;
		var val = this.getText();
		this.cell.innerHTML = ""
		this.combo.DOMelem.style.width = this.cell.clientWidth + "px";
		this.combo.DOMelem_input.style.width = (this.cell.clientWidth - 24) + "px";
		this.combo.DOMelem_input.value = val;
		this.cell.appendChild(this.combo.DOMParent);
		this.combo.DOMelem.style.top = (this.combo.DOMParent.clientHeight - this.combo.DOMelem.clientHeight) / 2 + "px";

		this.cell._editorshow = true;

		this.grid.attachEvent("onSetSizes", function () {
			if (that.cell.firstChild && that.cell.firstChild.firstChild) {
				that.cell.firstChild.firstChild.style.width = that.cell.clientWidth + "px";
				that.cell.firstChild.firstChild.firstChild.style.width = (that.cell.clientWidth - 24) + "px";
			}

			that.combo.DOMelem.style.width = that.cell.clientWidth + "px";
			that.combo.DOMelem_input.style.width = (that.cell.clientWidth - 24) + "px";
		});
	}

	this.selectComboOption = function(val,obj){
		obj.selectOption(obj.getIndexByValue(obj.getOptionByLabel(val).value));
	}

	this.getValue = function(val){
		return this.cell.combo_value||"";
	}

	this.getText = function(val){
		var c = this.cell;
		if (c._editorshow) {
			return c.firstChild.firstChild.firstChild.value;
		}
		if (this._combo_pre == "" && c.childNodes[1]) {
			c = c.childNodes[1];
		} else {
			c.childNodes[0].childNodes[1];
		}
		return dhx4.trim(_isIE ? c.innerText : c.textContent);
	}

	this.setValue = function(val){
		this.cell.combo_value = val;
		var cm = null;
		if ((cm = this.cell._brval) && (typeof (this.cell._brval) == "object")) {
			if (this.cellType.ismulti) {
				var vals = (val || "").split(this.cellType.seperator);
				var texts = [];
				for (var i = 0; i < vals.length; i++) {
					texts.push((cm.getOption(vals[i]) || {}).text || "");
				}
				val = texts.join(this.cellType.seperator);
			}
			else {
				val = (cm.getOption(val) || {}).text || val;
			}
		} else if (cm = this.hwReport._cell_combos[this.cell._attrs.sid].obj) {
			if (this.cellType.ismulti) {
				var tmpVal;
				var vals = (val || "").split(this.cellType.seperator);
				var texts = [];
				for (var i = 0; i < vals.length; i++) {
					var tmpText = cm.getOption(vals[i]) && cm.getOption(vals[i]).text;
					if (!tmpText && cm.rule && cm.rptStore) {
						tmpText = cm.rptStore.find(function (item) {
							return item[cm.rule['value']] + "" == vals[i] + ""
						});
						tmpText = tmpText && tmpText[cm.rule['text']];
					}
					texts.push(tmpText || "");
				}
				var tmpVal = texts.join(this.cellType.seperator);
				if (tmpVal) {
					val = tmpVal;
				}
				else if (this.cellType && this.cellType.noValueClear) {
					val = "&nbsp;"
				}
			}
			else {
				var tmpVal = cm.getOption(val);
				if (tmpVal) {
					val = tmpVal;
				}
				else if (cm.rule && cm.rptStore) {
					//默认显示第一项
					if(val === "" && this.cellType.showFirstTerm) {
						tmpVal = cm.rptStore.first();
					}
					else {
						tmpVal = cm.rptStore.find(function (item) {
							return item[cm.rule['value']] + "" == val + ""
						});
					}
					if (tmpVal) {
						val = {
							value: tmpVal[cm.rule['value']] + "",
							text: tmpVal[cm.rule['text']] + ""
						}
					}
					else if (this.cellType && this.cellType.noValueClear) {
						val = {
							value: "",
							text: "&nbsp;"
						}
						if (cm.rptStore.dataRequestCompleted) {
							var oCell = this.hwReport.getOriginCellById(this.cell._attrs.sid);
							var dsName = oCell && oCell.dsName && oCell.dsName[0];
							var dsField = oCell && oCell.dsField && oCell.dsField[0];
							var dsStore = this.hwReport.queryDatastores.get(dsName) || this.hwReport.bindDatastore;
							var rowId = this.cell.parentNode.idd;
							if (dsStore && dsField) {
								dsStore.updateValue(rowId, dsField, '')
							}
							this.cell.combo_value=tmpVal||"";
						}
					}
				}
				val = dhx._isObj(val) ? val.text : val;
			}
		}

		if ((val || "").toString()._dhx_trim() == "") val = null;

		if (val !== null) {
			this.setComboCValue(val, this.cell.combo_value);
		} else {
			this.setComboCValue("&nbsp;", "");
			this.cell._clearCell = true;
		}
	}

	this.detach = function () {
		var that = this;
		var p = this.combo.getParent();
		if (p.parentNode == this.cell) {
			this.cell.removeChild(p);
		} else {
			return false;
		}

		var val = this.cell.combo_value;
		this.combo._confirmSelect("blur");
		this.cell.style.padding = "";
		this.combo.DOMParent.firstChild.className = this.combo.DOMParent.firstChild.className.replace(/dhxcombo_actv/g, "");

		if (this.cellType.ismulti) {
			var checkedValues = this.combo.getChecked();
			if (checkedValues.length == 0) {
				this.setComboCValue("&nbsp;", "");
				this.cell._clearCell = true;
			}
			else {
				this.setComboCValue(
					checkedValues.map(function (v) {
						return that.combo.getOption(v).text;
					}).join(this.cellType.seperator), checkedValues.join(this.cellType.seperator));
				this.cell._clearCell = false;
			}
			this.cell.combo_value = checkedValues.join(this.cellType.seperator)
		}
		else{
			if (!this.combo.getComboText() || this.combo.getComboText().toString()._dhx_trim()=="") {
				this.setComboCValue("&nbsp;", "");
				this.cell._clearCell=true;
			} else {
				this.setComboCValue(this.combo.getComboText().replace(/\&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"),this.combo.getActualValue());
				this.cell._clearCell = false;
			}
			this.cell.combo_value = this.combo.getActualValue();
		}

		this.combo.closeAll();
		this.grid._still_active=true;
		this.grid.setActive(1);
		return val!=this.cell.combo_value;
	}
}


eXcell_vmdcombo.prototype = new eXcell;
eXcell_vmdcombo.prototype.init = function (cellType) {
	var that = this;
	var type = "";
	if (cellType.ismulti) {
		type = "checkbox";
	}
	var container = document.createElement("DIV");
	container.className = "dhxcombo_in_grid_parent";

	var combo = new dhtmlXCombo(container, "combo", 0, type);
	combo.enableFilteringMode("between");
	var grid = this.grid;
	combo.DOMelem.onmousedown = combo.DOMelem.onclick = function(e){
		e = e||event;
		e.cancelBubble = true;
	};
	combo.DOMelem.onselectstart = function(e){
		e = e||event;
		e.cancelBubble = true;
		return true;
	};

	this.grid.attachEvent("onScroll", function(){
		if (combo._isListVisible()) combo._hideList();
	});

	if (cellType.ismulti) {
		combo.attachEvent("onCheck", function (value, state) {
			var a = grid.editStop;
			grid.editStop = function () {
				grid.editStop = a;
			};
			var checkedValues = combo.getChecked();
			combo.DOMelem_input.value = checkedValues.map(function (v) {
				return combo.getOption(v).text;
			}).join(cellType.seperator);
		});
	}

	//combo.attachEvent("onKeyPressed",function(ev){
	//	if (ev==13 || ev==27) {
	//		grid.editStop();
	//		if (grid._fake) grid._fake.editStop();
	//	}
	//});

	return combo;

};

eXcell_vmdcombo.prototype.fillCellCombos = function (hwReport, cellId) {
	var grid = hwReport.grid;
	var oCell = hwReport.getOriginCellById(cellId);
	if (hwReport.bindDatastore) {
		for (var i = 0; i < grid.rowsCol.length; i++) {
			var cellObj = grid.cells3(grid.rowsCol[i], oCell.index);
			cellObj.refreshCell&& cellObj.refreshCell();
		}
	}
	else {
		for (var i = 0; i < oCell.childs.length; i++) {
			var cellObj = grid.cells.apply(grid, oCell.childs[i].split("_"));
			cellObj.refreshCell&&cellObj.refreshCell();
		}
	}
};

eXcell_vmdcombo.prototype.setComboCValue = function (value, value2) {
	if (this._combo_pre != "") {
		var height = (this.cell.offsetHeight?this.cell.offsetHeight+"px":0);
		value = "<div style='width:100%;position:relative;height:100%;overflow:hidden;'>"+this._combo_pre+"<span>"+value+"</span></div>";
	}
	if (this.cell._editorshow) {
		this.cell.innerHTML = this.combo.DOMParent.outerHTML;
		this.cell.firstChild.firstChild.firstChild.value = (value == "&nbsp;" ? "" : value);
		this.grid.callEvent("onCellChanged", [
			this.cell.parentNode.idd,
			this.cell._cellIndex,
			value2
		]);
	}
	else {
		this.setCValue(value, value2);
	}
};

eXcell_vmdcombo.prototype.refreshCell = function () {
	this.setValue(this.getValue());
};

dhtmlXCombo.prototype.modes.checkbox.image = false;
;
///<jscompress sourcefile="dhtmlxgrid_excell_vmdapprove.js" />
/*
filename：dhtmlxgrid_excell_hwapprove.js
creater：刘志伟
date created：2016.11.19
description：审批组件
date modified：2018.03.12
modifier：刘志伟
version：2.2.15.1129
others：
copyright：Copyright @1999-2016, hwkj, All Rights Reserved
*/
/*初始化加载*/
function eXcell_vmdapprove(cell) {
    var that = this;
    if (cell) {
        this.cell = cell;
        this.grid = this.cell.parentNode.grid;
        this.hwReport = this.grid.hwReport;

        if (!cell._approve) {
            cell._approve = that.grid._approve_render(cell);
        }

        this.hwReport.approveCells = this.hwReport.approveCells || {};
        this.hwReport.approveCells[cell.parentNode.idd + "_" + cell._cellIndex] = cell;
        if (!this.hwReport.approve_onReportRendered_id) {
            this.hwReport.approve_onReportRendered_id = this.hwReport.attachEvent("onRendered", function () {
                if (!that.hwReport.isEmpty(that.hwReport.approveCells)) {
                    for (var item in that.hwReport.approveCells) {
                        var td = that.hwReport.approveCells[item];
                        td._approve.doLayout();
                        if (td._disabled) {
                            td._approve.setDisabled();
                        }
                    }
                }
            })
        }
    }

    this.edit = function () {
        this.cell.className = this.cell.className.replace(/editable/g, " ");
    }

    this.detach = function () {
        this.grid.editor = null;
    }

    /*设置值*/
    this.setValue = function (val) {
    }

    this.setDisabled = function () {
        this.cell._disabled = true;
        this.cell._approve.setDisabled();
    }

    this.getValue = function (key) {
        return this.cell._approve.getValue(key);
    }

    this.updateValue = function () {
        this.cell._approve.updateValue();
    }
}
eXcell_vmdapprove.prototype = new eXcell;

dhtmlXGridObject.prototype._approve_render = function (cell) {
    if (cell._d) {
        cell._d.parentNode.removeChild(cell._d);
    }
    var that = this;
    var d = document.createElement("DIV");
    d.style.cssText = "position:relative;overflow:hidden;";
    d.className = "dhx_approve ";
    cell.innerHTML = "";
    cell.className += " " + this.hwReport.reportId + "-p-0";
    cell._d = d;
    cell.appendChild(d);

    var oCell = this.hwReport.getOriginCellById(cell._attrs.sid);
    var cellType = this.hwReport.cellTypes.get(oCell.fillcelltype);

    var approve = new dhtmlXApprove(this.hwReport, cell, cellType.items);
    approve.render();
    approve.attachEvent("onApproval", function () {
        var values = approve.getAllValue();

        that.callEvent("onCellChanged", [
					cell.parentNode.idd,
					cell._cellIndex,
					values
        ]);
        
        that.callEvent("onEditCell", [
					2,
					cell.parentNode.idd,
					cell._cellIndex,
					values,
					approve.oldValues
        ]);

        var params = [];
        for (var key in values) {
            if (values.hasOwnProperty(key)) {
                params.push({key: key, value: values[key]});
            }
        }
        params = params.map(function (v) {return v.key + "=" + v.value });
        that.hwReport.callEvent("onApproval", [that, cell.parentNode.idd, cell._cellIndex, approve.result, values]);

        var ApproveAgreeClickName = "myApproveAgree";
        if (this.ApproveAgreeClickName) {
            ApproveAgreeClickName = this.ApproveAgreeClickName;
        }
        if (Ext.isFunction(window[ApproveAgreeClickName])) {
            window[ApproveAgreeClickName](params.join("&"));
        }
        if (Ext.isFunction(window[this.hwReport.reportId + "_myApproveAgree"])) {
            window[this.hwReport.reportId + "_myApproveAgree"](params.join("&"));
        }
    })

    approve.attachEvent("onValueCalculated", function () {
        //含有数据集的表达式运算完成，通知修改入库数据集中的旧值
        that.callEvent("onValueCalculated", [
            cell.parentNode.idd,
            cell._cellIndex,
            approve.getAllValue()
        ]);
    })
    
    return approve;
}

function dhtmlXApprove(hwReport, cell, opt) {
    this.cell = cell;
    this.oldValues = {
        department: "",
        opinions: "",
        seal: "",
        person: "",
        date: "",
        result: ""
    };
    
    this.defaultOptions = {
        padding: 10,
        personMaxHeight: 25, //审批人最大默认高度
        sealMaxHeight: 120,//审批章最大默认高度
        buttonWidth: 60,
        buttonHeight: 25,
        buttonPadding: 20,
        dateInputWidth: 80,
        dateInputHeight: 25
    }
    window.dhx4._eventable(this);
    this.hwReport = hwReport;
    this.options = opt;
    this._items = {};

    if (typeof (cell._d) == "string") {
        this.container = document.getElementById(cell._d);
    } else {
        this.container = cell._d;
    }

    this.render = function () {
        var that = this;
        //处理审批结果
        this.result = "";
        this.bindQueryStore = {}; //审批组件用到的数据集
        var agreeOptions = this.findOptions("Agree");
        var disAgreeOptions = this.findOptions("DisAgree");
        var senBackOptions = this.findOptions("SenBack");

        var resultValue = dhx.trim(agreeOptions.value || disAgreeOptions.value || senBackOptions.value || "");
        if (resultValue.indexOf("=") == 0) {
            this.cansetDisabled = false;
            resultValue = this.hwReport.getValue(resultValue.replace("=", ""));
        }
        this.result = resultValue;
        this.oldValues.result = resultValue;

        this.initDepartment();
        this.initComment();
        this.initDate();
        this.initAgreeButton();
        this.initDisAgreeButton();
        this.initSenBackButton();
        this.initPerson();
        this.initSeal();

        if (this.result) {
            this.setComplete();
        }
    }

    //审批部门
    this.initDepartment = function () {
        var options = this.findOptions("ApprovalDepartment");
        if (options == null || options.isshow == '0') {
            return;
        }

        var departmentDiv = this._items["department"] = document.createElement("div");
        departmentDiv.style = this.getFontStyle(options) +
            ";position:absolute;text-align:left";

        var labelvalue = dhx.trim(options.labelvalue || "");
        if (labelvalue.indexOf("=") == 0) {
            labelvalue = this.hwReport.getValue(labelvalue.replace("=", ""));
        }
        var value = dhx.trim(options.value || "");
        if (value.indexOf("=") == 0) {
            value = this.hwReport.getValue(value.replace("=", ""));
        }
        this.oldValues.department = value;
        departmentDiv.innerHTML = "<span>" + labelvalue + "</span>" + "<span>" + value + "</span>";
        this.container.appendChild(departmentDiv);
    }

    //审批意见
    this.initComment = function () {
        var options = this.findOptions("ApprovalComment");
        if (options == null || options.isshow == '0') {
            return;
        }
        
        var commentDiv = this._items["comment"] = document.createElement("div");
        commentDiv.style = this.getFontStyle(options) +
            ";position:absolute;text-align:left";

        var labelvalue = dhx.trim(options.labelvalue || "");
        if (labelvalue.indexOf("=") == 0) {
            labelvalue = this.hwReport.getValue(labelvalue.replace("=", ""));
        }
        var value = dhx.trim(options.value || "");
        if (value.indexOf("=") == 0) {
            value = this.hwReport.getValue(value.replace("=", ""));
        }
        this.oldValues.opinions = value;
        commentDiv.innerHTML = "<span style='position: relative;line-height:1;vertical-align:top;top: 3px'>" + labelvalue + "</span>" + "<textarea  class='approve_options' style='" + this.getFontStyle(options) + "'>" + value + "</textarea>";
        this.container.appendChild(commentDiv);
    }

    //审批章
    this.initSeal = function () {
        var that = this;
        var options = this.findOptions("ApprovalSeal"); //审批章
        var sealDiv = this._items["seal"] = document.createElement("div");
        sealDiv.style = this.getFontStyle(options) + ";position:absolute;text-align:left;";
        var labelvalue = dhx.trim(options.labelvalue || "");
        if (labelvalue.indexOf("=") == 0) {
            labelvalue = this.hwReport.getValue(labelvalue.replace("=", ""));
        }

        sealDiv.innerHTML = "<span style='display: inline-block;vertical-align: middle'>" + labelvalue + "</span>";
        
        if(options.src){
            var imgSrc = dhx.trim(options.src || "");
            if (imgSrc.indexOf("=") == 0) {
                imgSrc = this.hwReport.getValue(imgSrc.replace("=", ""));
            }

            var image = sealDiv. _image = new Image();
            image.onload = function () {
                that.doLayout();
            };
            image.src = imgSrc;
            this.oldValues.seal = imgSrc;
            image.style = "display: inline-block;vertical-align: middle;";
            //如果没有审批，签章和签名不显示,审批完成后显示
            if (!this.result) {
                image.style.visibility = "hidden";
            }
            sealDiv.appendChild(image);

        }
        this.container.appendChild(sealDiv);
    };

    //审批人
    this.initPerson = function () {
        var that = this;
        var options = this.findOptions("ApprovalPerson");//审批人
        var personDiv = this._items["person"] = document.createElement("div");
        personDiv.style = this.getFontStyle(options) + ";position:absolute;text-align:left;";

        var labelvalue = dhx.trim(options.labelvalue || "");
        if (labelvalue.indexOf("=") == 0) {
            labelvalue = this.hwReport.getValue(labelvalue.replace("=", ""));
        }

        var value = dhx.trim(options.value || "");
        if (value.indexOf("=") == 0) {
            value = this.hwReport.getValue(value.replace("=", ""));
        }

        this.oldValues.person = value;
        personDiv.innerHTML = "<span style='display: inline-block;vertical-align: middle'>" + labelvalue + "</span>" + "<span style='display: inline-block;vertical-align: middle'>" + value + "</span>";

        //有签名图片时
        if (options.namepicture) {
            var imgSrc = dhx.trim(options.namepicture || "");
            if (imgSrc.indexOf("=") == 0) {
                imgSrc = this.hwReport.getValue(imgSrc.replace("=", ""));
            }

            var image = personDiv._image = new Image();
            image.onload = function () {
                that.doLayout();
            };
            image.src = imgSrc;
            image.style = "display: inline-block;vertical-align: middle;";
            //如果没有审批，签章和签名不显示,审批完成后显示
            if (!this.result) {
                image.style.visibility = "hidden";
            }
            personDiv.appendChild(image);
        }
        this.container.appendChild(personDiv);
    };

    /*审批日期*/
    this.initDate = function () {
        var options = this.findOptions("ApprovalDate");
        if (options == null || options.isshow == '0') {
            return;
        }
        
        var dateDiv = this._items["date"] = document.createElement("div");
        dateDiv.style = this.getFontStyle(options) + ";position:absolute;text-align:left;z-index:1;";

        var labelvalue = dhx.trim(options.labelvalue || "");
        if (labelvalue.indexOf("=") == 0) {
            labelvalue = this.hwReport.getValue(labelvalue.replace("=", ""));
        }
        var value = dhx.trim(options.value || "");
        if (value.indexOf("=") == 0) {
            value = this.hwReport.getValue(value.replace("=", ""));
        }
        var dateformat = this.getFormat(options.dateformat || "%Y-%m-%d");

        dateDiv.innerHTML = "<span style='display: inline-block;vertical-align: middle;'>" + labelvalue + "</span>" +
            "<input class='approve_date' unselectable=on style='" + this.getFontStyle(options) + "'>";

        this._laydate = laydate.render({
            elem: dateDiv.children[1], //指定元素
            format: dateformat,
            type: this.getType(dateformat),
            done: function (val, date) {
                //that.setValue(val);
            }
        }).laydate;

        value = this._laydate.parse(0, this.strToDateJSON(value));
        dateDiv.children[1].value = value;

        this.oldValues.date = value;
        this.container.appendChild(dateDiv);
    }

    //同意
    this.initAgreeButton = function () {
        var that = this;
        var options = this.findOptions("Agree");
        
        //如果有审批结果，那么审批组件已经进行了审批，所以按钮不显示
        if (options == null || options.isshow == '0' || this.result) {
            return;
        }

        var btn = this._items["agree_button"] = document.createElement("input");
        btn.type = "button";
        btn.className = "approve_btn approve_agree";
        btn.style = this.getFontStyle(options) +
            ";position:absolute;" +
            ";width:" + ((options.width && !isNaN(options.width)) ? options.width : this.defaultOptions.buttonWidth) + "px" +
           ";height:" + ((options.height && !isNaN(options.height)) ? options.height : this.defaultOptions.buttonHeight) + "px";

        btn.value = options.labelvalue || "";
        btn.onclick = function () {
            that.result = 1;
            that.setComplete();
            that.callEvent("onApproval", []);
        }
        this.container.appendChild(btn);
    }

    //不同意
    this.initDisAgreeButton = function () {
        var that = this;
        var options = this.findOptions("DisAgree");

        //如果有审批结果，那么审批组件已经进行了审批，所以按钮不显示
        if (options == null || options.isshow == '0' || this.result) {
            return;
        }

        var btn = this._items["disagree_button"] = document.createElement("input");
        btn.type = "button";
        btn.className = "approve_btn approve_disagree";
        btn.style = this.getFontStyle(options) +
            ";position:absolute;" +
            ";width:" + ((options.width && !isNaN(options.width)) ? options.width : this.defaultOptions.buttonWidth) + "px" +
           ";height:" + ((options.height && !isNaN(options.height)) ? options.height : this.defaultOptions.buttonHeight) + "px";

        btn.value = options.labelvalue || "";
        btn.onclick = function () {
            that.result = 2;
            that.setComplete();
            that.callEvent("onApproval", []);
        }
        this.container.appendChild(btn);
    }

    //退回
    this.initSenBackButton = function () {
        var that = this;
        var options = this.findOptions("SenBack");

        //如果有审批结果，那么审批组件已经进行了审批，所以按钮不显示
        if (options == null || options.isshow == '0' || this.result) {
            return;
        }

        var btn = this._items["senback_button"] = document.createElement("input");
        btn.type = "button";
        btn.className = "approve_btn approve_back";
        btn.style = this.getFontStyle(options) +
            ";position:absolute;" +
            ";width:" + ((options.width && !isNaN(options.width)) ? options.width : this.defaultOptions.buttonWidth) + "px" +
           ";height:" + ((options.height && !isNaN(options.height)) ? options.height : this.defaultOptions.buttonHeight) + "px";

        btn.value = options.labelvalue || "";
        btn.onclick = function () {
            that.result = 3;
            that.setComplete();
            that.callEvent("onApproval", []);
        }
        this.container.appendChild(btn);
    }

    this.doLayout = function () {
        this.container.style.width = this.container.parentNode.clientWidth + "px";
        this.container.style.height = this.container.parentNode.clientHeight + "px";

        var departmentOptions = this.findOptions("ApprovalDepartment"); //审批部门
        var commentOptions = this.findOptions("ApprovalComment"); //审批意见
        var sealOptions = this.findOptions("ApprovalSeal"); //审批章
        var personOptions = this.findOptions("ApprovalPerson");//审批人
        var dateOptions = this.findOptions("ApprovalDate"); //审批日期
        var agreeOptions = this.findOptions("Agree");
        var disAgreeOptions = this.findOptions("DisAgree");
        var senBackOptions = this.findOptions("SenBack");
        
        var departmentDiv = this._items["department"];
        var commentDiv = this._items["comment"];
        var sealDiv = this._items["seal"];
        var personDiv = this._items["person"];

        var agree_button = this._items["agree_button"];
        var disagree_button = this._items["disagree_button"];
        var senback_button = this._items["senback_button"];
        var date = this._items["date"];

        //调整审批部门的位置和大小
        var departmentDivLeft = 0;
        var departmentDivTop = 0;
        if (departmentDiv) {
            departmentDivLeft = this.defaultOptions.padding
                    + ((!departmentOptions.x || isNaN(departmentOptions.x)) ? 0 : parseInt(departmentOptions.x));
            departmentDivTop = this.defaultOptions.padding
                    + ((!departmentOptions.y || isNaN(departmentOptions.y)) ? 0 : parseInt(departmentOptions.y));
            departmentDiv.style.left = departmentDivLeft + "px";
            departmentDiv.style.top = departmentDivTop + "px";
        }

        //调整按钮和日期的大小和位置
        //如果日期的宽度和高度未定义，默认高25px
        var dateDivLeft = 0;
        var dateDivTop = 0;
        if (date) {
            var dateInputWidth = (!dateOptions.width || isNaN(dateOptions.width) || parseInt(dateOptions.width) == 0)
                ? this.defaultOptions.dateInputWidth
                : parseInt(dateOptions.width);
                //: ((parseInt(dateOptions.width) - date.children[0].offsetWidth));
            var dateDivWidth = (!dateOptions.width || isNaN(dateOptions.width) || parseInt(dateOptions.width) == 0)
                ? (this.defaultOptions.dateInputWidth + date.children[0].offsetWidth) 
                : parseInt(dateOptions.width);
            var dateDivHeight = (!dateOptions.height || isNaN(dateOptions.height) || parseInt(dateOptions.height) == 0)
                ? this.defaultOptions.dateInputHeight
                : parseInt(dateOptions.height);
            date.children[1].style.height = dateDivHeight + "px";
            date.children[1].style.width = dateInputWidth + "px";

            dateDivLeft = this.container.clientWidth 
                - dateDivWidth 
                - this.defaultOptions.padding 
                + (!dateOptions.x || (isNaN(dateOptions.x)) ? 0 : parseInt(dateOptions.x));
            dateDivTop = this.container.clientHeight 
                - dateDivHeight 
                - this.defaultOptions.padding 
                + (!dateOptions.y || (isNaN(dateOptions.y)) ? 0 : parseInt(dateOptions.y));
            date.style.left = dateDivLeft + "px";
            date.style.top = dateDivTop + "px";
        }

        //调整审批人高度和位置
        var personDivLeft = 0;
        var personDivTop = 0;
        if (personDiv) {
            if (personDiv.children[2]) {
                var personWidth = (!personOptions.width || isNaN(personOptions.width) || parseInt(personOptions.width) == 0)
                    ? 0
                    : parseInt(personOptions.width);
                var personHeight = (!personOptions.height || isNaN(personOptions.height) || parseInt(personOptions.height) == 0)
                    ? 0
                    : parseInt(personOptions.height);
                if (personWidth) {
                    personDiv.children[2].style.width = personWidth + "px";
                }
                if (personHeight) {
                    personDiv.children[2].style.height = personHeight + "px";
                }
                if (!personWidth && !personHeight) {
                    personHeight = this.defaultOptions.personMaxHeight;
                    personDiv.children[2].style.height = this.defaultOptions.personMaxHeight + "px";
                }

                personDivLeft = this.container.clientWidth
                    - (personDiv.children[0].clientWidth + personDiv.children[1].clientWidth + personDiv.children[2].clientWidth)
                    - this.defaultOptions.padding
                    + (!personOptions.x || (isNaN(personOptions.x)) ? 0 : parseInt(personOptions.x));
                personDivTop = (dateDivTop || this.container.clientHeight)
                    - Math.max(personHeight, personDiv.children[2].clientHeight)
                    //- this.defaultOptions.padding
                    + (!personOptions.y || (isNaN(personOptions.y)) ? 0 : parseInt(personOptions.y));
            }
            else {
                personDivLeft = this.container.clientWidth
                    - (personDiv.children[0].clientWidth + personDiv.children[1].clientWidth)
                    - this.defaultOptions.padding
                    + (!personOptions.x || (isNaN(personOptions.x)) ? 0 : parseInt(personOptions.x));
                personDivTop = (dateDivTop || this.container.clientHeight)
                    - Math.max(personDiv.children[0].clientHeight, personDiv.children[1].clientHeight)
                    //- this.defaultOptions.padding
                    + (!personOptions.y || (isNaN(personOptions.y)) ? 0 : parseInt(personOptions.y));
            }
            personDiv.style.left = personDivLeft + "px";
            personDiv.style.top = personDivTop + "px";
        }

        //personMaxHeight
        //调整审批章大小和位置
        var sealDivLeft = 0;
        var sealDivTop = 0;
        if (sealDiv) {
            if (sealDiv.children[1]) {
                var sealWidth = (!sealOptions.width || isNaN(sealOptions.width) || parseInt(sealOptions.width) == 0)
                    ? 0
                    : parseInt(sealOptions.width);
                var sealHeight = (!sealOptions.height || isNaN(sealOptions.height) || parseInt(sealOptions.height) == 0)
                    ? 0
                    : parseInt(sealOptions.height);

                if (sealWidth) {
                    sealDiv.children[1].style.width = sealWidth + "px";
                }
                if (sealHeight) {
                    sealDiv.children[1].style.height = sealHeight + "px";
                }
                if (!sealHeight && !sealHeight) {
                    sealHeight = this.defaultOptions.sealMaxHeight;
                    sealDiv.children[1].style.height = sealHeight + "px";
                }

                sealDivLeft = this.container.clientWidth
                    - (sealDiv.children[0].clientWidth + sealDiv.children[1].clientWidth)
                    - this.defaultOptions.padding
                    + (!sealOptions.x || (isNaN(sealOptions.x)) ? 0 : parseInt(sealOptions.x));
                sealDivTop = (this.container.clientHeight)
                    - Math.max(sealHeight, sealDiv.children[0].clientHeight)
                    - this.defaultOptions.padding
                    + (!sealOptions.y || (isNaN(sealOptions.y)) ? 0 : parseInt(sealOptions.y));
            }
            else {
                sealDivLeft = this.container.clientWidth
                    - (sealDiv.children[0].clientWidth)
                    - this.defaultOptions.padding
                    + (!sealOptions.x || (isNaN(sealOptions.x)) ? 0 : parseInt(sealOptions.x));
                sealDivTop = (this.container.clientHeight)
                    - sealDiv.children[0].clientHeight
                    - this.defaultOptions.padding
                    + (!sealOptions.y || (isNaN(sealOptions.y)) ? 0 : parseInt(sealOptions.y));
            }
            sealDiv.style.left = sealDivLeft + "px";
            sealDiv.style.top = sealDivTop + "px";
        }

        //调整按钮位置
        var agree_button_left = 0;
        var agree_button_top = 0;
        if (agree_button) {
            agree_button_left = this.defaultOptions.padding
                + (!agreeOptions.x || (isNaN(agreeOptions.x)) ? 0 : parseInt(agreeOptions.x));
            agree_button_top = this.container.clientHeight - agree_button.offsetHeight
                - this.defaultOptions.padding
                + (!agreeOptions.y || (isNaN(agreeOptions.y)) ? 0 : parseInt(agreeOptions.y));
            agree_button.style.left = agree_button_left + "px";
            agree_button.style.top = agree_button_top + "px";
        }
        
        var disagree_button_left = 0;
        var disagree_button_top = 0;
        if (disagree_button) {
            disagree_button_left = agree_button_left
                + (agree_button ? agree_button.offsetWidth : 0)
                + (agree_button ? this.defaultOptions.buttonPadding : this.defaultOptions.padding)
                + (!disAgreeOptions.x || (isNaN(disAgreeOptions.x)) ? 0 : parseInt(disAgreeOptions.x));
            disagree_button_top = this.container.clientHeight
                - disagree_button.offsetHeight
                - this.defaultOptions.padding
                + (!disAgreeOptions.y || (isNaN(disAgreeOptions.y)) ? 0 : parseInt(disAgreeOptions.y));
            disagree_button.style.left = disagree_button_left + "px";
            disagree_button.style.top = disagree_button_top + "px";
        }
        
        var senback_button_left = 0;
        var senback_button_top = 0;
        if (senback_button) {
            senback_button_left = disagree_button_left
                + (disagree_button ? disagree_button.offsetWidth : 0)
                + ((agree_button || disagree_button) ? this.defaultOptions.buttonPadding : this.defaultOptions.padding)
                + (!senBackOptions.x || (isNaN(senBackOptions.x)) ? 0 : parseInt(senBackOptions.x));
            senback_button_top = this.container.clientHeight
                - disagree_button.offsetHeight
                - this.defaultOptions.padding
                + (!senBackOptions.y || (isNaN(senBackOptions.y)) ? 0 : parseInt(senBackOptions.y));
            senback_button.style.left = senback_button_left + "px";
            senback_button.style.top = senback_button_top + "px";
        }

        //调整审批意见的位置和大小
        var commentDivLeft = 0;
        var commentDivTop = 0;
        var ajustBaseBottom = [dateDivTop, personDivTop, agree_button_top, disagree_button_top, senback_button_top].filter(function (v) {return v > 0 });//调整底部时基于的组件顶部位置数组

        if (commentDiv) {
            commentDivLeft = this.defaultOptions.padding
                    + (!commentOptions.x || (isNaN(commentOptions.x)) ? 0 : parseInt(commentOptions.x));
            commentDivTop = departmentDivTop + (departmentDiv ? departmentDiv.clientHeight : 0)+ this.defaultOptions.padding
                    + (!commentOptions.y || (isNaN(commentOptions.y)) ? 0 : parseInt(commentOptions.y));

            //调整大小
            var commentDivWidth = (!commentOptions.width || isNaN(commentOptions.width) || parseInt(commentOptions.width) == 0)
                ? (this.container.clientWidth - this.defaultOptions.padding * 2 - commentDiv.children[0].offsetWidth)
                : parseInt(commentOptions.width)
                //: (parseInt(commentOptions.width) - commentDiv.children[0].offsetWidth);
            var commentDivHeight = (!commentOptions.height || isNaN(commentOptions.height) || parseInt(commentOptions.height) == 0)
                ? (Math.min.apply(null, ajustBaseBottom) - this.defaultOptions.padding - commentDivTop)
                : parseInt(commentOptions.height)

            commentDiv.style.left = commentDivLeft + "px";
            commentDiv.style.top = commentDivTop + "px";
            commentDiv.children[1].style.width = (commentDivWidth - 6) + "px";
            commentDiv.children[1].style.height = (commentDivHeight - 6) + "px";
        }
    };

    //禁用
    this.setDisabled = function () {
        //无权限：只显示单位和空白日期
        if (this.cansetDisabled == false || this.result) {
            return;
        }
        
        var departmentDiv = this._items["department"];
        var commentDiv = this._items["comment"];
        var sealDiv = this._items["seal"];
        var personDiv = this._items["person"];
        var agree_button = this._items["agree_button"];
        var disagree_button = this._items["disagree_button"];
        var senback_button = this._items["senback_button"];
        var date = this._items["date"];

        if (commentDiv) {
            commentDiv.style.display = "none";
        }
        if (sealDiv) {
            sealDiv.style.display = "none";
        }
        if (personDiv) {
            personDiv.style.display = "none";
        }
        if (agree_button) {
            agree_button.style.display = "none";
        }
        if (disagree_button) {
            disagree_button.style.display = "none";
        }
        if (senback_button) {
            senback_button.style.display = "none";
        }
        if (date) {
            date.children[0].innerHTML = "年    月    日（公章）";
            date.children[1].style.display = "none";
        }
    }

    //审批完成
    this.setComplete = function () {
        var departmentDiv = this._items["department"];
        var commentDiv = this._items["comment"];
        var sealDiv = this._items["seal"];
        var personDiv = this._items["person"];
        var agree_button = this._items["agree_button"];
        var disagree_button = this._items["disagree_button"];
        var senback_button = this._items["senback_button"];
        var date = this._items["date"];

        if (commentDiv) {
            commentDiv.children[1].setAttribute("readonly", "readonly");
            commentDiv.children[1].setAttribute("disabled", "disabled");
            commentDiv.children[1].style.border = "0px"; //去除外边框
            commentDiv.children[1].style.backgroundColor = "transparent";
            commentDiv.children[1].style.cursor = "default";
            commentDiv.children[1].style.overflow = "auto";
        }

        if (sealDiv && sealDiv.children[1]) {
            sealDiv.children[1].style.visibility = "";
        }

        if (personDiv && personDiv.children[2]) {
            personDiv.children[2].style.visibility = "";
        }

        if (date) {
            date.style.zIndex = "";
            date.children[1].setAttribute("disabled", "disabled");
            date.children[1].style.backgroundColor = "transparent";
            date.children[1].style.cursor = "default";
            date.children[1].style.borderWidth = "0px";
        }
        
        if (agree_button) {
            agree_button.style.display = "none"
        }
        if (disagree_button) {
            disagree_button.style.display = "none"
        }
        if (senback_button) {
            senback_button.style.display = "none"
        }
    }

    this.updateValue = function () {
        var that = this;
        var departmentDiv = this._items["department"];
        var commentDiv = this._items["comment"];
        var sealDiv = this._items["seal"];
        var personDiv = this._items["person"];
        var date = this._items["date"];

        var departmentOptions = this.findOptions("ApprovalDepartment"); //审批部门
        var commentOptions = this.findOptions("ApprovalComment"); //审批意见
        var sealOptions = this.findOptions("ApprovalSeal"); //审批章
        var personOptions = this.findOptions("ApprovalPerson");//审批人
        var dateOptions = this.findOptions("ApprovalDate"); //审批日期
        var agreeOptions = this.findOptions("Agree");
        var disAgreeOptions = this.findOptions("DisAgree");
        var senBackOptions = this.findOptions("SenBack");

        //审批部门
        if (departmentDiv) {
            var labelvalue = dhx.trim(departmentOptions.labelvalue || "").replace("=", "");
            if (this.hwReport.checkParamType(labelvalue) == "ds") {
                departmentDiv.children[0].innerHTML = this.hwReport.getValue(labelvalue);
            }
            var value = dhx.trim(departmentOptions.value || "").replace("=", "");
            if (this.hwReport.checkParamType(value) == "ds") {
                value = this.hwReport.getValue(value);
                value = this._laydate.parse(0, this.strToDateJSON(value));
                this.oldValues.department = value;
                departmentDiv.children[1].innerHTML = value;
                //数据集表达式运算完成
                that.callEvent("onValueCalculated", []);
            }
        }
        
        //审批意见
        if (commentDiv) {
            var labelvalue = dhx.trim(commentOptions.labelvalue || "").replace("=", "");
            if (this.hwReport.checkParamType(labelvalue) == "ds") {
                commentDiv.children[0].innerHTML = this.hwReport.getValue(labelvalue);
            }
            var value = dhx.trim(commentOptions.value || "").replace("=", "");
            if (this.hwReport.checkParamType(value) == "ds") {
                value = this.hwReport.getValue(value);
                this.oldValues.opinions = value;
                commentDiv.children[1].value = value;
                //数据集表达式运算完成
                that.callEvent("onValueCalculated", []);
            }
        }
        
        //审批章
        if (sealDiv) {
            var labelvalue = dhx.trim(sealOptions.labelvalue || "").replace("=", "");
            if (this.hwReport.checkParamType(labelvalue) == "ds") {
                sealDiv.children[0].innerHTML = this.hwReport.getValue(labelvalue);
            }
            var src = dhx.trim(sealOptions.src || "").replace("=", "");
            if (this.hwReport.checkParamType(src) == "ds") {
                src = this.hwReport.getValue(src);
                this.oldValues.seal = src;
                sealDiv._image.src = src;
                //数据集表达式运算完成
                that.callEvent("onValueCalculated", []);
            }
        }

        //审批人
        if (personDiv) {
            var labelvalue = dhx.trim(personOptions.labelvalue || "").replace("=", "");
            if (this.hwReport.checkParamType(labelvalue) == "ds") {
                personDiv.children[0].innerHTML = this.hwReport.getValue(labelvalue);
            }
            var value = dhx.trim(personOptions.value || "").replace("=", "");
            if (this.hwReport.checkParamType(value) == "ds") {
                value = this.hwReport.getValue(value);
                this.oldValues.person = value;
                personDiv.children[1].innerHTML = value;
                //数据集表达式运算完成
                that.callEvent("onValueCalculated", []);
            }
            var namepicture = dhx.trim(personOptions.namepicture || "").replace("=", "");
            if (this.hwReport.checkParamType(namepicture) == "ds") {
                namepicture = this.hwReport.getValue(namepicture);
                this.oldValues.person = namepicture;
                personDiv._image.src = namepicture;
                //数据集表达式运算完成
                that.callEvent("onValueCalculated", []);
            }
        }
        
        //审批日期
        if (date) {
            var labelvalue = dhx.trim(dateOptions.labelvalue || "").replace("=", "");
            if (this.hwReport.checkParamType(labelvalue) == "ds") {
                date.children[0].innerHTML = this.hwReport.getValue(labelvalue);
            }
            var value = dhx.trim(dateOptions.value || "").replace("=", "");
            if (this.hwReport.checkParamType(value) == "ds") {
                value = this._laydate.parse(0, this.strToDateJSON(this.hwReport.getValue(value)));
                this.oldValues.date = value;
                date.children[1].value = value;
                //数据集表达式运算完成
                that.callEvent("onValueCalculated", []);
            }
        }
        
        //审批结果
        var value = (agreeOptions.value || disAgreeOptions.value || senBackOptions.value || "").replace("=", "");
        if (this.hwReport.checkParamType(value) == "ds") {
            var rptStore = this.hwReport.getQueryStoreByName(value.split(".")[0]);
            var value = this.hwReport.getValue(value);
            this.result = value;
            this.oldValues.result = value;
            if (this.result) {
                this.setComplete();
            }
            else if (rptStore.dataRequestSuccess) {
                this.cansetDisabled = true;
                if (this.cell._disabled) {
                    this.setDisabled();
                }
            }

            //数据集表达式运算完成
            that.callEvent("onValueCalculated", []);
        }

        this.doLayout();
    }

    this.getValue = function (key) {
        return this.getAllValue()[key] || "";
    }

    this.getAllValue = function () {
        var departmentDiv = this._items["department"];
        var commentDiv = this._items["comment"];
        var sealDiv = this._items["seal"];
        var personDiv = this._items["person"];
        var date = this._items["date"];
        return {
            department: (departmentDiv && departmentDiv.children[1].innerHTML) || "",
            opinions: (commentDiv && commentDiv.children[1].value) || "",
            seal: (sealDiv.children[1] && sealDiv.children[1].src) || "",
            person: (personDiv.children[1] && personDiv.children[1].innerHTML) || (personDiv.children[2] && personDiv.children[2].src) || "",
            date: (date && date.children[1].value),
            result: this.result
        }
    }

    this.getFontStyle = function (options) {
        if (!options) return "";
        var style = "";
        if (options.fontcolor) style += ";color:" + options.fontcolor;
        if (options.fontname) style += ";font-family:" + options.fontname;
        if (options.fontsize) style += ";font-size:" + parseInt(options.fontsize) + "px";
        if (window.dhx4.s2b(options.italic)) style += ";font-style:italic";
        if (window.dhx4.s2b(options.fontweight)) style += ";font-weight: bold";
        if (window.dhx4.s2b(options.underline)) style += ";text-decoration: underline"

        return style;
    }

    this.findOptions = function (type) {
        for (var i = 0; i < this.options.length; i++) {
            if (this.options[i].type == type) {
                return this.options[i];
            }
        }
        return null;
    }
}

dhtmlXApprove.prototype.getFormat = function (format) {
    if (!format) {
        return "yyyy-MM-dd";
    }
    return format
        .replace(/%Y/g, "yyyy")
        .replace(/%y/g, "y")
        .replace(/%m/g, "MM")
        .replace(/%n/g, "M")
        .replace(/%d/g, "dd")
        .replace(/%j/g, "d")
        .replace(/%H/g, "HH")
        .replace(/%G/g, "H")
        .replace(/%i/g, "mm")
        .replace(/%s/g, "ss");
}

dhtmlXApprove.prototype.getType = function (format) {
    var type = "date"
    if (format.indexOf('y') >= 0)
        type = 'year'
    if (format.indexOf('M') >= 0)
        type = 'month'
    if (format.indexOf('d') >= 0)
        type = 'date'
    if (format.indexOf('H') >= 0 && format.indexOf('d') >= 0)
        type = 'datetime'
    if (format.indexOf('H') >= 0 && format.indexOf('d') < 0)
        type = 'time'
    return type;
}

dhtmlXApprove.prototype.strToDateJSON = function (val) {
    var dateTime = {};
    var laydate = this._laydate;
    var date = val ? new Date(val) : new Date();
    //标准日期格式
    if ((date != "NaN") && (date != "Invalid Date")) {
        dateTime.year = date.getFullYear(); //年
        dateTime.month = date.getMonth(); //月
        dateTime.date = date.getDate(); //日
        dateTime.hours = date.getHours();  //时
        dateTime.minutes = date.getMinutes(); //分
        dateTime.seconds = date.getSeconds(); //秒
        return dateTime;
    }

    var LIMIT_YEAR = [100, 200000];
    var value = (val.match(laydate.EXP_SPLIT) || []).slice(1);
    var error;
    for (var i = 0; i < laydate.format.length; i++) {
        var item = laydate.format[i];
        var thisv = parseFloat(value[i]);
        if (value[i].length < item.length) error = true;
        if (/yyyy|y/.test(item)) { //年
            if (thisv < LIMIT_YEAR[0]) thisv = LIMIT_YEAR[0], error = true; //年不能低于100年
            dateTime.year = thisv;
        } else if (/MM|M/.test(item)) { //月
            if (thisv < 1) thisv = 1, error = true;
            dateTime.month = thisv - 1;
        } else if (/dd|d/.test(item)) { //日
            if (thisv < 1) thisv = 1, error = true;
            dateTime.date = thisv;
        } else if (/HH|H/.test(item)) { //时
            if (thisv < 0) thisv = 0, error = true;
            dateTime.hours = thisv;
        } else if (/mm|m/.test(item)) { //分
            if (thisv < 0) thisv = 0, error = true;
            dateTime.minutes = thisv;
        } else if (/ss|s/.test(item)) { //秒
            if (thisv < 0) thisv = 0, error = true;
            dateTime.seconds = thisv;
        }
    };
    if (error) {
        date = new Date(val);
        dateTime.year = date.getFullYear(); //年
        dateTime.month = date.getMonth(); //月
        dateTime.date = date.getDate(); //日
        dateTime.hours = date.getHours();  //时
        dateTime.minutes = date.getMinutes(); //分
        dateTime.seconds = date.getSeconds(); //秒
        return dateTime;
    }
    return dateTime;
};
///<jscompress sourcefile="dhtmlxgrid_excell_vmdeditor.js" />
dhx4.attachEvent("onGridCreated", function (grid) {
    if (!window.dhx_globalImgPath) window.dhx_globalImgPath = grid.imgURL;

    var hwReport = grid.hwReport;
    if (!hwReport) {
        return;
    }

    var hasThisType = false;
    hwReport.cellTypes.each(function (name, _cellType, index) {
        if (_cellType.getType() == "vmdeditor") {
            hasThisType = true;
        }
    });
    if (!hasThisType) {
        return;
    }
    var dataHost = vmd.MicService.getDasIp();
    var wdkHost = (vmd.projectInfo && vmd.projectInfo.docIp) || "";
    var isWdk = !!wdkHost;
    var hwFao = !isWdk?(new HwFao(dataHost, "vmd")):(new HwFao(wdkHost, "wdk"));//地址:端口和存储标识(服务管理员分配)
	
	//mafei
    var filepath = (vmd.previewMode ? "modules/" : "release/") + vmd.projectInfo.projectId + "/editorfile"
    var uploadUrl = hwFao.getUploadUrl(filepath);
	//如果是文档库？不需要传递项目路径
    //if(isWdk) uploadUrl= hwFao.getWdkUploadUrl(wdkHost, 'wdk', "file")
    if (!hwReport._ueditor) {
        var d = document.createElement("DIV");
        d.id = hwReport.reportId + "_ueditor";
        d.style.cssText = "position:absolute; top: -9999px;";
        d.className = "dhx_editor ";
        grid.objBox.appendChild(d);
        var URL = hwReport.dhtmxlUrl + "/lib/ueditor/"
        var ue = UE.getEditor(d.id, {
            isShow: false
            , UEDITOR_HOME_URL: URL
            , serverUrl: uploadUrl
            , theme: 'default'
            , themePath: URL + "themes/"
            , dialogPath: hwReport.dhtmxlUrl + "/lib/ueditor/themes/"
            , listiconpath : URL+'themes/ueditor-list/'
        });
        ue.addListener('afterexeccommand', function (type, cmd) {
            var cmds = ["paragraph", "fontfamily", "fontsize", "customstyle", "forecolor", "backcolor","imagefloat",
                "lineheight", "lineheight", "insertunorderedlist", "insertorderedlist", "inserttable","rowspacing", "anchor", "link"];
            if (cmds.indexOf(cmd) != -1) {
                var a = grid.editStop;
                grid.editStop = function () {
                    grid.editStop = a;
                };
            }
        });
        ue.on("dialogdragstop", function () {
            var a = grid.editStop;
            grid.editStop = function () {
                grid.editStop = a;
            };
        })
		
		//项目路径
		ue.filepath=filepath;
		ue.getBasePath=function(){
			if(isWdk){
				return 'http://'+wdkHost+'/wdk/'
			}else{
				return vmd.virtualPath+'/'
			}
		}
		
		ue.getDirs=function(allowfiles,succcallback,erorcallback){
			hwFao.getDirs(filepath,allowfiles,succcallback,erorcallback);
		}
        hwReport._ueditor = ue;
    }
});

function eXcell_vmdeditor(cell) {

    if (!cell) return;

    this.cell = cell;
    this.grid = cell.parentNode.grid;
    this.hwReport = this.grid.hwReport;
    this._combo_pre = "";

    this.isDisabled = function () {
        if (this.grid._disabled) {
            return true;
        }
        return this.cell._disabled;
    }

    this.edit = function () {
        var val = this.val = this.getValue();
        this.cell.innerHTML = "";
        this.cell.className = this.cell.className.replace(/editable/g, " ");
        this.cell.className += " " + this.hwReport.reportId + "-p-0";
        if (!/ueditor/g.test(this.cell.className)) {
            this.cell.className += " ueditor";
        }

        var ue = this.hwReport._ueditor;
        ue.setContent(val);
        ue.setPosition(this.cell.offsetLeft, this.cell.offsetTop);
        ue.setShow();
        ue.setWidth(this.cell.clientWidth - 2);
        ue.setHeight(this.cell.clientHeight - 2, false, true);
    }

    this.getValue = function () {
        return this.cell.innerHTML || "";
    }

    this.detach = function () {
        var ue = this.hwReport._ueditor;
        var content = ue.getContent();
        //this.cell.innerHTML = content;
        this.setCValue(content);
        this.cell.className = this.cell.className.replace(new RegExp(this.hwReport.reportId + "-p-0", "gi"), " ");
        ue.setHide();
    }
}

eXcell_vmdeditor.prototype = new eXcell;;
///<jscompress sourcefile="dhtmlxgrid_excell_vmdlaydate.js" />

function eXcell_vmdlaydate(cell) {

    var that = this;
    if (!cell) return;

    this.cell = cell;
    this.grid = cell.parentNode.grid;
    this.hwReport = this.grid.hwReport;
    var originCell = this.hwReport.getOriginCellById(this.cell._attrs.sid);
    this.cellType = this.hwReport.cellTypes.get(originCell.fillcelltype);
    this.format = this.cellType.format;

    //日期容器
    if (!this.cell.DOMParent) {
        this.cell.DOMParent = document.createElement("DIV");
        this.cell.DOMParent.className = "dhxcombo_in_grid_parent";//"dhxcombo_material";
        this.cell.DOMParent.innerHTML = "<div class='dhxcombo_material'><input type='text' class='dhxcombo_input' autocomplete='off'>" +
                    "<div class='dhxcombo_select_button'><div class='dhxcalendar_select_img'></div></div></div>";
        this.cell.DOMelem = this.cell.DOMParent.firstChild;
        this.cell.DOMelem_input = this.cell.DOMelem.firstChild;
        this.cell.DOMelem_icon = this.cell.DOMelem.children[1];

        if (this.grid._disabled || this.isDisabled()) {
            this.cell.DOMelem_input.setAttribute("disabled", "disabled");
        }

        this.cell.DOMelem_icon.onclick = function (e) {
            if (!e) e = event;
            e.cancelBubble = true;
            that.grid.selectCell(that.cell.parentNode, that.cell._cellIndex, true, false, true);
            that.cell.DOMelem_input.focus();
            return true;
        }

        this.cell.DOMelem_input.onmousedown = function (e) {
            if (that.cell._editorshow) {
                if (that.grid._doClick(e || window.event) !== false) {
                    if (that.grid._sclE)
                        that.grid.editCell(e || window.event);
                    else
                        that.grid.editStop();
                }
            }
            (e || event).cancelBubble = true
        }

        this.cell.DOMelem_input.onselectstart = function (e) {
            if (!e) e = event;
            e.cancelBubble = true;
            return true;
        };
           
        this.cell._laydate = laydate.render({
            elem: this.cell.DOMelem_input, //指定元素
            format: this.toLaydateFormat(this.format),
            type: this.getType(this.format),
            ready: function () {
                //debugger
            },
            done: function (val, date) {
                that.cell.DOMelem_input.value = val;
                that.grid.editStop();
            }
        }).laydate;
    }

    this.isDisabled = function () {
        if (this.grid._disabled) {
            return true;
        }
        return this.cell._disabled;
    }

    this.setDisabled = function (fl) {
        if (fl != 'true' && fl != 1)
            fl = false;

        this.cell._disabled = fl;
        if (fl) {
            this.cell.DOMelem_input.setAttribute("disabled", "disabled");
        }
        else {
            this.cell.DOMelem_input.removeAttribute("disabled");
        }
    }

    this.edit = function () {
        this.val = this.getValue();

        if (!this.cell._editorshow) {
            this.cell.innerHTML = ""
            this.cell.className += " " + this.hwReport.reportId + "-p-0";
            this.cell.DOMelem.style.width = this.cell.clientWidth + "px";
            this.cell.DOMelem_input.style.width = (this.cell.clientWidth - 24) + "px";
            this.cell.DOMelem_input.value = this.val;
            this.cell.appendChild(this.cell.DOMParent);
            this.cell.DOMelem.style.top = (this.cell.DOMParent.clientHeight - this.cell.DOMelem.clientHeight) / 2 + "px";
            this.cell.DOMelem_input.focus();
        }
        else {
            this.cell.DOMelem_input.onclick = function (e) {
                if (!e) e = event;
                e.cancelBubble = true;
                return true;
            }
            if (this.cell._laydate.elemID && lay('#' + this.cell._laydate.elemID) && lay('#' + this.cell._laydate.elemID).length > 0) {

            }
            else {
                this.cell.DOMelem_input.focus();
            }
        }

        if (!/dhxcombo_actv/g.test(this.cell.DOMelem.className)) {
            this.cell.DOMelem.className += " dhxcombo_actv";
        }
    }

    /**
     * 显示编辑器
     */
    this.showEditor = function () {
        //return;
        var that = this;
        var val = this.getValue();
        this.cell.innerHTML = ""
        this.cell.DOMelem.style.width = this.cell.clientWidth + "px";
        this.cell.DOMelem_input.style.width = (this.cell.clientWidth - 24) + "px";
        this.cell.DOMelem_input.value = val;
        this.cell.appendChild(this.cell.DOMParent);

        var top = (this.cell.DOMParent.clientHeight - this.cell.DOMelem.clientHeight) / 2;
        if (top < 1) {
            top = 0;
        }
        this.cell.DOMelem.style.top = top + "px";

        this.cell._editorshow = true;

        this.grid.attachEvent("onSetSizes", function () {
            that.cell.DOMelem.style.width = that.cell.clientWidth + "px";
            that.cell.DOMelem_input.style.width = (that.cell.clientWidth - 24) + "px";
        });
    }

    this.setValue = function (val) {
        if (!val || val.toString()._dhx_trim() == "") {
            if (this.cellType.isdefultdate == "0") {
                val = "&nbsp";
                this.cell._clearCell = true;
                this.cell.val = null;
            }
            else {
                this.cell.val = this.strToDate();
                val = dhx4.date2str(this.cell.val, this.toDhtmlxFormat(this.format));
                this.cell._clearCell = false;
            }
        } else {
            this.cell._clearCell = false;
            this.cell.val = this.strToDate(val);
            val = dhx4.date2str(this.cell.val, this.toDhtmlxFormat(this.format));
        }

        if (this.cell._editorshow) {
            this.cell.firstChild.firstChild.firstChild.value = val == "&nbsp" ? "" : val;
        }
        else {
            if (this.cell.DOMParent.parentNode) {
                this.cell.removeChild(this.cell.DOMParent);
            }
            this.cell.innerHTML = val;
        }
        this.grid.callEvent("onCellChanged", [
            this.cell.parentNode.idd,
            this.cell._cellIndex,
            this.getValue()
            //this.cell.val == null ? "" : dhx4.date2str(this.cell.val, this.toDhtmlxFormat(this.format))
        ]);
    }

    this.getValue = function () {
        if (this.cell._clearCell) return "";

        if (this.cell._editorshow) {
            return this.cell.firstChild.firstChild.firstChild.value;
        }
        return this.cell.innerHTML.toString()._dhx_trim()
    }

    this.getDate = function () {
        return this.cell.val;
    }

    this.detach = function () {
        this.cell._laydate.remove();
        this.cell._laydate.elem = this.cell.DOMelem_input.onclick = null;
        this.cell.DOMelem.className = this.cell.DOMelem.className.replace(/dhxcombo_actv/g, "");
        this.cell.className = this.cell.className.replace(new RegExp(this.hwReport.reportId + "-p-0", "gi"), " ");
        this.setValue(this.cell.DOMelem_input.value);
    }
}

eXcell_vmdlaydate.prototype = new eXcell;

eXcell_vmdlaydate.prototype.toDhtmlxFormat = function (format) {
    if (!format) {
        return "%Y-%m-%d";
    }
    if(/%/g.test(format)){
        return format;
    }
    return format
        .replace(/yyyy/g, "%Y")
        .replace(/y/g, "%y")
        .replace(/MM/g, "%m")
        .replace(/M/g, "%n")
        .replace(/dd/g, "%D")
        .replace(/d/g, "%j")
        .replace(/%D/g, "%d")
        .replace(/HH/g, "%Z")
        .replace(/H/g, "%G")
        .replace(/mm/g, "%i")
        .replace(/ss/g, "%s")
        .replace(/Z/g, "H");
}

eXcell_vmdlaydate.prototype.toLaydateFormat = function (format) {
    if (!format) {
        return "yyyy-MM-dd";
    }
    return format
        .replace(/%Y/g, "yyyy")
        .replace(/%y/g, "y")
        .replace(/%m/g, "MM")
        .replace(/%n/g, "M")
        .replace(/%d/g, "dd")
        .replace(/%j/g, "d")
        .replace(/%H/g, "HH")
        .replace(/%G/g, "H")
        .replace(/%i/g, "mm")
        .replace(/%s/g, "ss");
}

eXcell_vmdlaydate.prototype.getType = function (format) {
    format = this.toLaydateFormat(format)
    var type = "date"
    if (format.indexOf('y') >= 0)
        type = 'year'
    if (format.indexOf('M') >= 0)
        type = 'month'
    if (format.indexOf('d') >= 0)
        type = 'date'
    if (format.indexOf('H') >= 0 && format.indexOf('d') >= 0)
        type = 'datetime'
    if (format.indexOf('H') >= 0 && format.indexOf('d') < 0)
        type = 'time'
    return type;
}

eXcell_vmdlaydate.prototype.strToDate = function (val) {
    if (!val) {
        return new Date();
    }
    if (typeof val === "object" && (val instanceof Date)) {
        return val;
    }
    val = dhx.trim(val).replace(/\//g, "-");
    var year, month, day, hour, minute, second, milliseconds = 0;
    var isDefaultFormat = true;
    //2014-1-20 8:50:00
    if (/\d{4}(-\d{1,2}){1,2}\s{1,}\d{1,2}(:\d{1,2}){1,2}(\.\d+){0,1}/.test(val)) {
        var date_time_arr = val.split(/\s+/).filter(function (v) { return v != null }, null);
        var date_arr = date_time_arr[0].split("-").map(function (v) { return parseInt(v.trim(), 10) }, null);
        var time_arr = date_time_arr[1].split(":").map(function (v) { return parseInt(v.trim(), 10) }, null);

        year = date_arr[0];
        month = date_arr[1];
        day = date_arr[2];

        hour = time_arr[0];
        minute = time_arr[1];
        second = time_arr[2];

        if (val.indexOf(".") != -1) {
            milliseconds = parseInt(val.split(".")[1], 10);
        }
    }

    //11-MAY-15 20:52:48.0 日-月-年 时:分:秒.毫秒
    else if (/\d{1,2}-([a-zA-Z]+)-\d{2,4}\s{1,}\d{1,2}(:\d{1,2}){2}(\.\d+){0,1}/.test(val)) {

        var monthsMap = {
            'january': 1, 'february': 2, 'march': 3, 'april': 4, 'may': 5, 'june': 6, 'july': 7,
            'august': 8, 'september': 9, 'october': 10, 'november': 11, 'december': 12,
            'jan': 1, 'feb': 2, 'mar': 3, 'apr': 4, 'may': 5, 'jun': 6, 'jul': 7, 'aug': 8, 'sep': 9, 'oct': 10, 'nov': 11, 'dec': 12
        }
        var date_time_arr = val.split(/\s+/).filter(function (v) { return v != null }, null);
        var date_arr = date_time_arr[0].split("-").map(function (v) { return v.trim() }, null);

        year = parseInt(date_arr[2].length == 2 ? ("20" + date_arr[2]) : date_arr[2], 10);
        month = monthsMap[date_arr[1].toLowerCase()];
        day = parseInt(date_arr[0]);

        var time_arr = date_time_arr[1].split(":").map(function (v) { return parseInt(v.trim(), 10) }, null);
        hour = time_arr[0];
        minute = time_arr[1];
        second = time_arr[2];

        if (val.indexOf(".") != -1) {
            milliseconds = parseInt(val.split(".")[1], 10);
        }
    }

        //2014-1-20
    else if (/\d{4}(-\d{1,2}){1,2}/.test(val)) {
        var date_arr =val.split("-").map(function (v) { return parseInt(v.trim(), 10) }, null);

        year = date_arr[0];
        month = date_arr[1];
        day = date_arr[2];
    }
    //8:50:00
    else if (/^\d{1,2}(:\d{1,2}){1,2}(\.\d+){0,1}$/.test(val)) {
        var time_arr = val.split(":").map(function (v) { return parseInt(v.trim(), 10) });
        hour = time_arr[0];
        minute = time_arr[1];
        second = time_arr[2];
        if (val.indexOf(".") != -1) {
            milliseconds = parseInt(val.split(".")[1], 10);
        }
    }
    //20140120 || 2014 || 201401
    else if (/^\d{4,8}$/.test(val)) {
        year = parseInt(val.substr(0, 4), 10);
        month = parseInt(val.substr(4, 2), 10);
        day = parseInt(val.substr(6, 2), 10);
    }
    //日期格式解析不了
    else {
        isDefaultFormat = false;
    }

    if (isDefaultFormat) {
        //修正年月日
        year = isNaN(year) ? 2000 : year;
        month = isNaN(month) ? 1 : month;
        day = isNaN(day) ? 1 : day;

        //修正时分秒
        hour = isNaN(hour) ? 0 : hour;
        minute = isNaN(minute) ? 0 : minute;
        second = isNaN(second) ? 0 : second;

        var date = new Date();
        date.setFullYear(year);
        date.setMonth(month - 1);
        date.setMonth(month - 1);
        date.setDate(day);
        date.setHours(hour);
        date.setMinutes(minute);
        date.setSeconds(second);
        date.setMilliseconds(milliseconds);
        return date;
    }
    return dhx4.str2date(val, this.toDhtmlxFormat(this.format))
};
///<jscompress sourcefile="dhtmlxgrid_excell_vmdpassw.js" />
/*
Product Name: dhtmlxSuite 
Version: 4.0 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact 
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function eXcell_vmdpassw(cell) {
    var that = this;
	if (cell){
		this.cell = cell;
		this.grid = this.cell.parentNode.grid;
		this.hwReport = this.grid.hwReport;
		var originCell = this.hwReport.getOriginCellById(this.cell._attrs.sid);
		this.cellType = this.hwReport.cellTypes.get(originCell.fillcelltype);

		if (!this.cell.DOMelem_input) {
		    this.cell.atag = "INPUT";
		    this.cell.DOMelem_input = document.createElement(this.cell.atag);
		    this.cell.DOMelem_input.setAttribute("autocomplete", "off");

		    this.cell.DOMelem_input.className = "dhx_combo_edit";
		    this.cell.DOMelem_input.type = "password";
		    this.cell.DOMelem_input.wrap = "soft";
		    this.cell.DOMelem_input.style.marginLeft = "0px";
		    this.cell.DOMelem_input.style.textAlign = this.cell.style.textAlign;

		    if (this.grid._disabled || this.isDisabled()) {
		        this.cell.DOMelem_input.setAttribute("readonly", "readonly");
		    }
		    //放开之后自由格式不调用edit，但是不放开在ie下不响应鼠标焦点，所以在自由格式下置null
		    this.cell.DOMelem_input.onclick = function (e) {
		        (e || event).cancelBubble = true
		    }

		    this.cell.DOMelem_input.onmousedown = function (e) {
		        if (that.cell._editorshow) {
		            if (that.grid._doClick(e || window.event) !== false) {
		                if (that.grid._sclE)
		                    that.grid.editCell(e || window.event);
		                else
		                    that.grid.editStop();
		            }
		        }
		        (e || event).cancelBubble = true
		    }

		    this.cell.DOMelem_input.onselectstart = function (e) {
		        if (!e)
		            e = event;
		        e.cancelBubble = true;
		        return true;
		    };
		}
	}

	this.isDisabled = function () {
	    if (this.grid._disabled) {
	        return true;
	    }
	    return this.cell._disabled;
	}

	this.setDisabled = function (fl) {
	    if (fl != 'true' && fl != 1)
	        fl = false;

	    this.cell._disabled = fl;
	    if (fl) {
	        this.cell.DOMelem_input.setAttribute("readonly", "readonly");
	    }
	    else {
	        this.cell.DOMelem_input.removeAttribute("readonly");
	    }
	}

	this.edit = function(){
	    this.val = this.getValue();


	    if (!this.cell._editorshow) {
	        this.cell.className += " " + this.hwReport.reportId + "-p-0";
	        this.cell.DOMelem_input.style.width = this.cell.clientWidth + "px";
	        this.cell.DOMelem_input.style.height = (this.cell.clientHeight - 3) + "px";
	        this.cell.DOMelem_input.value = this.val
	        this.cell.innerHTML = "";
	        this.cell.appendChild(this.cell.DOMelem_input);
	        this.cell.DOMelem_input.focus();
	    }
	    else {
	        if (_isIE) {
	            this.cell.DOMelem_input.focus();
	            this.cell.DOMelem_input.blur();
	        }
	        this.cell.DOMelem_input.focus();
	    }
	    if (!/dhxcombo_actv/g.test(this.cell.DOMelem_input.className)) {
	        this.cell.DOMelem_input.className += " dhxcombo_actv";
	    }		
	}

    /**
    * 显示编辑器
    */
	this.showEditor = function () {
	    var val = this.getValue();
	    this.cell.DOMelem_input.onclick = null;
	    this.cell.DOMelem_input.style.width = this.cell.clientWidth + "px";
	    this.cell.DOMelem_input.value = val;
	    this.cell.innerHTML = ""
	    this.cell.appendChild(this.cell.DOMelem_input);
	    this.cell._editorshow = true;
	}

	this.getValue = function(){
        return this.cell._rval;
	}
	this.setValue = function(val){
	    var str = "******";
	    if (this.cell._editorshow) {
	        this.cell.DOMelem_input.value = val;
	    }
	    else {
	        this.cell.innerHTML = str;
	    }
	    this.cell._rval = val;

	    this.grid.callEvent("onCellChanged", [
            this.cell.parentNode.idd,
            this.cell._cellIndex,
            this.cell._clearCell ? "" : val
	    ]);
	}

	this.detach = function(){
	    this.cell.DOMelem_input.className = this.cell.DOMelem_input.className.replace(/dhxcombo_actv/g, "");
	    this.cell.className = this.cell.className.replace(new RegExp(this.hwReport.reportId + "-p-0", "gi"), " ");
	    var tv = this.cell.DOMelem_input.value;
	    this.setValue(tv);
	    return this.val != this.getValue();
	}

}
eXcell_vmdpassw.prototype = new eXcell;
//(c)dhtmlx ltd. www.dhtmlx.com;
///<jscompress sourcefile="dhtmlxgrid_selection.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*     @desc: enables block selection mode in grid
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.enableBlockSelection = function(mode)
{
	if (typeof this._bs_mode == "undefined"){
		var self = this;
		this.obj.onmousedown = function(e) {
			if (self._bs_mode) self._OnSelectionStart((e||event),this); return true;
		}
		this._CSVRowDelimiter = this.csv.row;
		this.attachEvent("onResize", function() {self._HideSelection(); return true;});
		this.attachEvent("onGridReconstructed", function() {self._HideSelection(); return true;});
		this.attachEvent("onFilterEnd",this._HideSelection);
	}
	if (mode===false){
		this._bs_mode=false;
		return this._HideSelection();
	} else this._bs_mode=true;

	if (!window.dhx4.isIPad){
		var area = this._clip_area = document.createElement("textarea");
		area.style.cssText = "position:absolute; width:1px; height:1px; overflow:hidden; color:transparent; background-color:transparent; bottom:1px; right:1px; border:none;";

		area.onkeydown=function(e){
	            e=e||event;
	            if (e.keyCode == 86 && (e.ctrlKey || e.metaKey))
					self.pasteBlockFromClipboard()
		};
	    document.body.insertBefore(this._clip_area,document.body.firstChild);

	    dhtmlxEvent(this.entBox,"click",function(){
	        if (!self.editor && self._clip_area)
	            self._clip_area.select();
	    });
	}
}
/**
*     @desc:  affect block selection, so it will copy|paste only visible text , not values behind
*	  @param: mode - true/false
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.forceLabelSelection = function(mode)
{
	this._strictText = dhx4.s2b(mode)
}


dhtmlXGridObject.prototype.selectBlock = function(sx, sy, ex, ey)
{
	sy = this.getRowIndex(sy);
	ey = this.getRowIndex(ey);

	this._CreateSelection(sy, sx);
    this._selectionArea = this._RedrawSelectionPos(this.cells2(sy, sx).cell, this.cells2(ey, ex).cell);
    this._ShowSelection();
}

dhtmlXGridObject.prototype._OnSelectionStart = function(event, obj)
{

	var self = this;
	if (event.button == 2) return;
	var src = event.srcElement || event.target;
	if (this.editor){
		if (src.tagName && (src.tagName=="INPUT" || src.tagName=="TEXTAREA"))   return;
		this.editStop();
	}
	
	self.setActive(true);
	var pos = this.getPosition(this.obj);
	var x = event.clientX - pos[0] + (document.body.scrollLeft||(document.documentElement?document.documentElement.scrollLeft:0));
	var y = event.clientY - pos[1] + (document.body.scrollTop||(document.documentElement?document.documentElement.scrollTop:0));
	this._CreateSelection(x-4, y-4);

	if (src == this._selectionObj) {
		this._HideSelection();
		this._startSelectionCell = null;
	} else {
	    while (src && (!src.tagName || src.tagName.toLowerCase() != 'td'))
	        src = src.parentNode;
	    this._startSelectionCell = src;
	}
	
	if (this._startSelectionCell){
		if (!this.callEvent("onBeforeBlockSelected",[this._startSelectionCell.parentNode.idd, this._startSelectionCell._cellIndex]))
			return this._startSelectionCell = null;
	}
	
	    //this._ShowSelection();
	    this.obj.onmousedown = null;
		this.obj[_isIE?"onmouseleave":"onmouseout"] = function(e){ if (self._blsTimer) window.clearTimeout(self._blsTimer); };	    
		this.obj.onmmold=this.obj.onmousemove;
		this._init_pos=[x,y];
	    this._selectionObj.onmousemove = this.obj.onmousemove = function(e) {e = e||event; if (e.preventDefault) e.preventDefault(); else e.returnValue = false;  self._OnSelectionMove(e);}
	    
	    
	    this._oldDMP=document.body.onmouseup;
	    document.body.onmouseup = function(e) {e = e||event; self._OnSelectionStop(e, this); return true; }
	this.callEvent("onBeforeBlockSelection",[]);
	document.body.onselectstart = function(){return false};//avoid text select	    
}

dhtmlXGridObject.prototype._getCellByPos = function(x,y){
	x=x;//+this.objBox.scrollLeft;
	if (this._fake)
		x+=this._fake.objBox.scrollWidth;
	y=y;//+this.objBox.scrollTop;
	var _x=0;
	for (var i=0; i < this.obj.rows.length; i++) {
		y-=this.obj.rows[i].offsetHeight;
		if (y<=0) {
			_x=this.obj.rows[i];
			break;
		}
	}
	if (!_x || !_x.idd) return null;
	for (var i=0; i < this._cCount; i++) {
		x-=this.getColWidth(i);
		if (x<=0) {
			while(true){
				if (_x._childIndexes && _x._childIndexes[i+1]==_x._childIndexes[i])
					_x=_x.previousSibling;
				else {
					return this.cells(_x.idd,i).cell;
				}
				
			}
		}
	}
	return null;
}

dhtmlXGridObject.prototype._OnSelectionMove = function(event)
{ 
	
	var self=this;
	this._ShowSelection();
	var pos = this.getPosition(this.obj);
	var X = event.clientX - pos[0] + (document.body.scrollLeft||(document.documentElement?document.documentElement.scrollLeft:0));
	var Y = event.clientY - pos[1] + (document.body.scrollTop||(document.documentElement?document.documentElement.scrollTop:0));

	if ((Math.abs(this._init_pos[0]-X)<50) && (Math.abs(this._init_pos[1]-Y)<50)) return this._HideSelection();
	
	var temp = this._endSelectionCell;
	if(this._startSelectionCell==null)
 		this._endSelectionCell  = this._startSelectionCell = this.getFirstParentOfType(event.srcElement || event.target,"TD");		
	else
		if (event.srcElement || event.target) {
			if ((event.srcElement || event.target).className == "dhtmlxGrid_selection")
				this._endSelectionCell=(this._getCellByPos(X,Y)||this._endSelectionCell);
			else {
				var t = this.getFirstParentOfType(event.srcElement || event.target,"TD");
				if (t.parentNode.idd) this._endSelectionCell = t;
			}
		}
		
	if (this._endSelectionCell){
		if (!this.callEvent("onBeforeBlockSelected",[this._endSelectionCell.parentNode.idd, this._endSelectionCell._cellIndex]))
			this._endSelectionCell = temp;
	}
	
		/*
	//window.status = pos[0]+'+'+pos[1];
	var prevX = this._selectionObj.startX;
	var prevY = this._selectionObj.startY;
	var diffX = X - prevX;
	var diffY = Y - prevY;
	
	if (diffX < 0) {
        this._selectionObj.style.left = this._selectionObj.startX + diffX + 1+"px";
        diffX = 0 - diffX;
	} else {
		this._selectionObj.style.left = this._selectionObj.startX - 3+"px";
	}
	if (diffY < 0) {
		this._selectionObj.style.top = this._selectionObj.startY + diffY + 1+"px";
        diffY = 0 - diffY;
	} else {
		this._selectionObj.style.top = this._selectionObj.startY - 3+"px";
	}
    this._selectionObj.style.width = (diffX>4?diffX-4:0) + 'px';
    this._selectionObj.style.height = (diffY>4?diffY-4:0) + 'px';


/* AUTO SCROLL */
	var BottomRightX = this.objBox.scrollLeft + this.objBox.clientWidth;
	var BottomRightY = this.objBox.scrollTop + this.objBox.clientHeight;
	var TopLeftX = this.objBox.scrollLeft;
	var TopLeftY = this.objBox.scrollTop;

	var nextCall=false;
	if (this._blsTimer) window.clearTimeout(this._blsTimer);	
	
	if (X+20 >= BottomRightX) {
		this.objBox.scrollLeft = this.objBox.scrollLeft+20;
		nextCall=true;
	} else if (X-20 < TopLeftX) {
		this.objBox.scrollLeft = this.objBox.scrollLeft-20;
		nextCall=true;
	}
	if (Y+20 >= BottomRightY && !this._realfake) {
		this.objBox.scrollTop = this.objBox.scrollTop+20;
		nextCall=true;
	} else if (Y-20 < TopLeftY && !this._realfake) {
		this.objBox.scrollTop = this.objBox.scrollTop-20;
		nextCall=true;		
	}
	this._selectionArea = this._RedrawSelectionPos(this._startSelectionCell, this._endSelectionCell);
	

	if (nextCall){ 
		var a=event.clientX;
		var b=event.clientY;
		this._blsTimer=window.setTimeout(function(){self._OnSelectionMove({clientX:a,clientY:b})},100);
	}
	
}

dhtmlXGridObject.prototype._OnSelectionStop = function(event)
{
	var self = this;
	if (this._blsTimer) window.clearTimeout(this._blsTimer);	
	this.obj.onmousedown = function(e) {if (self._bs_mode)  self._OnSelectionStart((e||event), this); return true;}
	this.obj.onmousemove = this.obj.onmmold||null;
	this._selectionObj.onmousemove = null;
	document.body.onmouseup = this._oldDMP||null;
	if ( parseInt( this._selectionObj.style.width ) < 2 && parseInt( this._selectionObj.style.height ) < 2) {
		this._HideSelection();
	} else {
	    var src = this.getFirstParentOfType(event.srcElement || event.target,"TD");
	    if ((!src) || (!src.parentNode.idd)){
	    	src=this._endSelectionCell;
    		}
	    while (src && (!src.tagName || src.tagName.toLowerCase() != 'td'))
	        src = src.parentNode;
	    if (!src) 
	    	return this._HideSelection();
	    this._stopSelectionCell = src;
	    this._selectionArea = this._RedrawSelectionPos(this._startSelectionCell, this._stopSelectionCell);
		this.callEvent("onBlockSelected",[]);
	}
	document.body.onselectstart = function(){};//avoid text select
}

dhtmlXGridObject.prototype._RedrawSelectionPos = function(LeftTop, RightBottom)
{

	if (LeftTop.parentNode.grid != RightBottom.parentNode.grid)
		return this._selectionArea;

//	td._cellIndex
//
//	getRowIndex
	var pos = {};
	pos.LeftTopCol = LeftTop._cellIndex;
	pos.LeftTopRow = this.getRowIndex( LeftTop.parentNode.idd );
	pos.RightBottomCol = RightBottom._cellIndex;
	pos.RightBottomRow = this.getRowIndex( RightBottom.parentNode.idd );

	var LeftTop_width = LeftTop.offsetWidth;
	var LeftTop_height = LeftTop.offsetHeight;
	LeftTop = this.getPosition(LeftTop, this.obj);

	var RightBottom_width = RightBottom.offsetWidth;
	var RightBottom_height = RightBottom.offsetHeight;
	RightBottom = this.getPosition(RightBottom, this.obj);

    if (LeftTop[0] < RightBottom[0]) {
		var Left = LeftTop[0];
		var Right = RightBottom[0] + RightBottom_width;
    } else {
    	var foo = pos.RightBottomCol;
        pos.RightBottomCol = pos.LeftTopCol;
        pos.LeftTopCol = foo;
		var Left = RightBottom[0];
		var Right = LeftTop[0] + LeftTop_width;
    }

    if (LeftTop[1] < RightBottom[1]) {
		var Top = LeftTop[1];
		var Bottom = RightBottom[1] + RightBottom_height;
    } else {
    	var foo = pos.RightBottomRow;
        pos.RightBottomRow = pos.LeftTopRow;
        pos.LeftTopRow = foo;
		var Top = RightBottom[1];
		var Bottom = LeftTop[1] + LeftTop_height;
    }

    var Width = Right - Left;
    var Height = Bottom - Top;

	this._selectionObj.style.left = (Left - 1) + 'px';
	this._selectionObj.style.top = (Top - 1) + 'px';
	this._selectionObj.style.width =  Width  + 'px';
	this._selectionObj.style.height = Height + 'px';
	return pos;
}

dhtmlXGridObject.prototype._CreateSelection = function(x, y)
{
	if (this._selectionObj == null) {
		var div = document.createElement('div');
		div.style.position = 'absolute';
        div.style.display = 'none';
        div.className = 'dhtmlxGrid_selection';
        this._selectionObj = div;
        this._selectionObj.onclick = function (e) {
            (e || event).cancelBubble = true;
            this.parentNode.grid._HideSelection();
            return false;
        }
		this._selectionObj.onmousedown = function(e){
			e=e||event;
			if (e.button==2 || (_isMacOS&&e.ctrlKey))
				return this.parentNode.grid.callEvent("onBlockRightClick", ["BLOCK",e]);
		}
		this._selectionObj.oncontextmenu=function(e){(e||event).cancelBubble=true;return false;}
		this.objBox.appendChild(this._selectionObj);
	}
    //this._selectionObj.style.border = '1px solid #83abeb';
    this._selectionObj.style.width = '0px';
    this._selectionObj.style.height = '0px';
    //this._selectionObj.style.border = '0px';
	this._selectionObj.style.left = x + 'px';
	this._selectionObj.style.top  = y + 'px';
    this._selectionObj.startX = x;
    this._selectionObj.startY = y;
}

dhtmlXGridObject.prototype._ShowSelection = function()
{
	if (this._selectionObj)
	    this._selectionObj.style.display = '';
}

dhtmlXGridObject.prototype._HideSelection = function()
{
	
	if (this._selectionObj)
	    this._selectionObj.style.display = 'none';
    this._selectionArea = null;
    if (this._clip_area){
    	this._clip_area.value="";
    	this._clip_area.blur();
    }
}

dhtmlXGridObject.prototype.deleteBlock = function ()
{
    if (!this._clip_area) return;

    if (this._selectionArea != null) {
        var serialized = new Array();
        if (this._mathSerialization)
            this._agetm = "getMathValue";
        else if (this._strictText)
            this._agetm = "getTitle";
        else this._agetm = "getValue";

        for (var i = this._selectionArea.LeftTopRow; i <= this._selectionArea.RightBottomRow; i++) {
            this._serializeRowToCVS(this.rowsBuffer[i], null, this._selectionArea.LeftTopCol, this._selectionArea.RightBottomCol + 1, true);
        }
    }
}
/**
*     @desc: copy content of block selection into clipboard in csv format (delimiter as set for csv serialization)
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.copyBlockToClipboard = function(clear)
{
	if (!this._clip_area) return;

	if ( this._selectionArea != null ) {
	    var serialized = new Array();
	    if (this._mathSerialization)
	        this._agetm="getMathValue";
	    else if (this._strictText)
	        this._agetm="getTitle";
	    else this._agetm="getValue";

	    this._serialize_visible = true;

	    for (var i = this._selectionArea.LeftTopRow; i <= this._selectionArea.RightBottomRow; i++) {
	        var data = this._serializeRowToCVS(this.rowsBuffer[i], null, this._selectionArea.LeftTopCol, this._selectionArea.RightBottomCol + 1, clear);
	        if (!this._csvAID)
	            serialized[serialized.length] = data.substr(data.indexOf(this.csv.cell) + 1);	//remove row ID and add to array
	        else
	            serialized[serialized.length] = data;
	    }
	    serialized = serialized.join(this._CSVRowDelimiter);

	    this._clip_area.value = serialized;
	    this._clip_area.select();

	    this._serialize_visible = false;
	}
}
/**
*     @desc: paste content of clipboard into block selection of grid
*     @type: public
*     @topic: 0
*/
dhtmlXGridObject.prototype.pasteBlockFromClipboard = function(){
	if (!this._clip_area) return;

	this._clip_area.select();
    var self = this;
    window.setTimeout(function(){
        self._pasteBlockFromClipboard();
        self=null;
    },1);
}
dhtmlXGridObject.prototype._pasteBlockFromClipboard = function()
{
	var serialized = this._clip_area.value;
	if (!serialized) return;

    if (this._selectionArea != null) {
        var startRow = this._selectionArea.LeftTopRow;
        var startCol = this._selectionArea.LeftTopCol;
    } else if (this.cell != null && !this.editor) {
        var startRow = this.getRowIndex( this.cell.parentNode.idd );
        var startCol = this.cell._cellIndex;
    } else {
        return false;
    }

	serialized = this.csvParser.unblock(serialized, this.csv.cell, this.csv.row);

    var endRow = startRow+serialized.length;
    var endCol = startCol+serialized[0].length;
    if (endCol > this._cCount)
		endCol = this._cCount;
    var k = 0;
    for (var i=startRow; i<endRow; i++) {
        var row = this.render_row(i);
        if (row==-1) continue;
        var l = 0;
        for (var j=startCol; j<endCol; j++) {
        	if (this._hrrar[j] && !this._fake){
        		endCol = Math.min(endCol+1, this._cCount);
        		continue;
        	}
        	var ed = this.cells3(row, j);
        	if (ed.isDisabled()) {
        	    l++;
        	    continue;
        	}
        	if (this._onEditUndoRedo)
        		this._onEditUndoRedo(2, row.idd, j, serialized[ k ][ l ], ed.getValue());
        	if (ed.combo && ed.editable) {
				var comboVa = ed.combo.values||[];
				for(var n=0; n<comboVa.length; n++)
					if (serialized[ k ][ l ] == comboVa[n]){
						ed.setValue( ed.combo.keys[ n ]);
						comboVa=null;
						break;
					}
				if (comboVa!=null && ed.editable) ed.setValue( serialized[ k ][ l++ ] );
				else l++;
        	}else
        		ed[ ed.setImage ? "setLabel" : "setValue" ]( serialized[ k ][ l++ ] );
        	ed.cell.wasChanged=true;
        }
        this.callEvent("onRowPaste",[row.idd])
        k++;
    }
}

dhtmlXGridObject.prototype.getSelectedBlock = function() {
	// if block selection exists
	if (this._selectionArea)
		return this._selectionArea;
	else if (this.getSelectedRowId() !== null){
		// if one cell is selected
			return {
				LeftTopRow: this.getSelectedRowId(),
				LeftTopCol: this.getSelectedCellIndex(),
				RightBottomRow: this.getSelectedRowId(),
				RightBottomCol: this.getSelectedCellIndex()
			};
		} else
			return null;
};
//(c)dhtmlx ltd. www.dhtmlx.com

;
///<jscompress sourcefile="dhtmlxgrid_srnd.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: enable smart rendering mode
*   @type: public
*   @param: mode - true|false - enable|disable mode
*   @param: buffer - has sense only in dynamic loading mode, count of rows requrested from server by single operation, optional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableSmartRendering=function(mode,buffer,reserved){
	if (arguments.length>2){
		if (buffer && !this.rowsBuffer[buffer-1]) this.rowsBuffer[buffer-1]=0;
		buffer=reserved;
	}
	this._srnd=dhx4.s2b(mode);
	this._srdh=this._srdh||20;
	this._dpref=buffer||0;
	
};
/**
*   @desc: allows to pre-render rows during scrolling, make scrolling more smooth, but with small drop in overall perfomance
*   @type: public
*   @param: buffer - count of rows, which will be prerendered
*   @topic: 0
*/
dhtmlXGridObject.prototype.enablePreRendering=function(buffer){
	this._srnd_pr=parseInt(buffer||50);
};
/**
*   @desc: force grid in dyn. srnd mode fully load itself from server side
*   @type: public
*   @param: buffer - how much rows grid can request from server side in one operation
*   @topic: 0
*/
dhtmlXGridObject.prototype.forceFullLoading=function(buffer, callback){
	for (var i=0; i<this.rowsBuffer.length; i++)
		if (!this.rowsBuffer[i]){
			var usedbuffer = buffer || (this.rowsBuffer.length-i);
			if (this.callEvent("onDynXLS",[i,usedbuffer])){
				var self=this;
				this.load(this.xmlFileUrl+dhtmlx.url(this.xmlFileUrl)+"posStart="+i+"&count="+usedbuffer, function(){
					window.setTimeout(function(){	self.forceFullLoading(buffer, callback); },100); 
				}, this._data_type);
			}
			return;
		}
	if (callback) callback.call(this);
};

/**
*   @desc: set height which will be used in smart rendering mode for row calculation, function need to be used if you use custom skin for grid which changes default row height
*   @type: public
   @param: {int} height - awaited height of row
*   @returns: void
*   @topic: 0
*/      
dhtmlXGridObject.prototype.setAwaitedRowHeight = function(height) {
   this._srdh=parseInt(height);
};

dhtmlXGridObject.prototype._get_view_size=function(){
	return Math.floor(parseInt(this.entBox.offsetHeight)/this._srdh)+2;
};
dhtmlXGridObject.prototype._add_filler=function(pos,len,fil,rsflag){
	if (!len) return null;
	var id="__filler__";
	var row=this._prepareRow(id);
	row.firstChild.style.width="1px";
	row.firstChild.style.borderWidth = row.firstChild.style.padding = row.firstChild.style.margin ="0px";

	for (var i=1; i<row.childNodes.length; i++)
	    row.childNodes[i].style.display='none';
 	row.firstChild.style.height=len*this._srdh+"px";
 	fil=fil||this.rowsCol[pos];
 	if (fil && fil.nextSibling) 
 		fil.parentNode.insertBefore(row,fil.nextSibling);
 	else
 		if (_isKHTML)
 			this.obj.appendChild(row);
 		else
 			this.obj.rows[0].parentNode.appendChild(row);
 			
 	this.callEvent("onAddFiller",[pos,len,row,fil,rsflag]);
 	return [pos,len,row];
};
dhtmlXGridObject.prototype._update_srnd_view=function(){
	    var min=Math.floor(this.objBox.scrollTop/this._srdh);
        var max=min+this._get_view_size();
        if (this.multiLine) {
        // Calculate the min, by Stephane Bernard
            var pxHeight = this.objBox.scrollTop;
            min = 0;
            while(pxHeight > 0) {
                pxHeight-=this.rowsCol[min]?this.rowsCol[min].offsetHeight:this._srdh;
                min++;
            }
            // Calculate the max
            max=min+this._get_view_size();
            if (min>0) min--;
        }        
        max+=(this._srnd_pr||0);//pre-rendering
        if (max>this.rowsBuffer.length) max=this.rowsBuffer.length;

        for (var j=min; j<max; j++){ 
            if (!this.rowsCol[j]){
				var res=this._add_from_buffer(j);
				if (res==-1){
					if (this.xmlFileUrl){
						if (this._dpref && this.rowsBuffer[max-1]){
							//we have last row in sett, assuming that we in scrolling up process
							var rows_count = this._dpref?this._dpref:(max-j)
							var start_pos = Math.max(0, Math.min(j, max - this._dpref));
							this._current_load=[start_pos, max-start_pos];
						} else 
							this._current_load=[j,(this._dpref?this._dpref:(max-j))];
						if (this.callEvent("onDynXLS",this._current_load))
							this.load(this.xmlFileUrl+dhtmlx.url(this.xmlFileUrl)+"posStart="+this._current_load[0]+"&count="+this._current_load[1], this._data_type);
					}
					return;
				} else {
	               	if (this._tgle){
	               		this._updateLine(this._h2.get[this.rowsBuffer[j].idd],this.rowsBuffer[j]);
	               		this._updateParentLine(this._h2.get[this.rowsBuffer[j].idd],this.rowsBuffer[j]);
	           		}
					if (j && j==(this._realfake?this._fake:this)["_r_select"]){
						this.selectCell(j, this.cell?this.cell._cellIndex:0, true);
					}
				}
            }
		}
	if (this._fake && !this._realfake && this.multiLine) 
		this._fake.objBox.scrollTop = this.objBox.scrollTop;		
}
dhtmlXGridObject.prototype._add_from_buffer=function(ind){
	    var row=this.render_row(ind);
	    if (row==-1) return -1;
	    if (row._attrs["selected"] || row._attrs["select"]){
			this.selectRow(row,false,true);
			row._attrs["selected"]=row._attrs["select"]=null;
		}
						
	    if (!this._cssSP){ 
		    if (this._cssEven && ind%2 == 0 )
				row.className=this._cssEven+((row.className.indexOf("rowselected") != -1)?" rowselected ":" ")+(row._css||"");
			else if (this._cssUnEven && ind%2 == 1 )
			    row.className=this._cssUnEven+((row.className.indexOf("rowselected") != -1)?" rowselected ":" ")+(row._css||"");				
			} else if (this._h2) {
				var x=this._h2.get[row.idd];
				row.className+=" "+((x.level%2)?(this._cssUnEven+" "+this._cssUnEven):(this._cssEven+" "+this._cssEven))+"_"+x.level+(this.rowsAr[x.id]._css||"");
			}
			

	    //now we need to get location of node
	    for (var i=0; i<this._fillers.length; i++){
	    	var f=this._fillers[i];
	    	if (f && f[0]<=ind && (f[0]+f[1])>ind ){
	    		//filler found
	    		var pos=ind-f[0];
	    		if (pos==0){
	    			//start
	    			this._insert_before(ind,row,f[2]);
	    			this._update_fillers(i,-1,1);
	    		} else if (pos == f[1]-1){
	    			this._insert_after(ind,row,f[2]);
	    			this._update_fillers(i,-1,0);
	    		} else {
	    			this._fillers.push(this._add_filler(ind+1,f[1]-pos-1,f[2],1));
	    			this._insert_after(ind,row,f[2]);
	    			this._update_fillers(i,-f[1]+pos,0);
	    		}
	    		return;
	    	}
	    }
}
dhtmlXGridObject.prototype._update_fillers=function(ind,right,left){
	var f=this._fillers[ind];
	f[1]=f[1]+right;
	f[0]=f[0]+left;
	if (!f[1]){
		this.callEvent("onRemoveFiller",[f[2]]);
		f[2].parentNode.removeChild(f[2]);
		this._fillers.splice(ind,1);
	} else {
		f[2].firstChild.style.height=parseFloat(f[2].firstChild.style.height)+right*this._srdh+"px";	
		this.callEvent("onUpdateFiller",[f[2]]);
	}
}
dhtmlXGridObject.prototype._insert_before=function(ind,row,fil){
	fil.parentNode.insertBefore(row,fil);
	this.rowsCol[ind]=row;
	this.callEvent("onRowInserted",[row,null,fil,"before"]);
}
dhtmlXGridObject.prototype._insert_after=function(ind,row,fil){
	if (fil.nextSibling)
		fil.parentNode.insertBefore(row,fil.nextSibling);
	else
		fil.parentNode.appendChild(row);
	this.rowsCol[ind]=row;
	this.callEvent("onRowInserted",[row,null,fil,"after"]);
}

;
///<jscompress sourcefile="dhtmlxgrid_markers.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

  /**
  *   @desc: sets marked cells support to enabled or disabled state
  *   @type: public
  *   @param: state - true or false
  */
 dhtmlXGridObject.prototype.enableMarkedCells = function(fl){
  	this.markedRowsArr = new dhtmlxArray(0);
	this.markedCellsArr = new Array(0);
	this.lastMarkedRow = null;
	this.lastMarkedColumn = null;
 	this.markedCells = true;
	this.lastMarkMethod = 0;
	if(arguments.length>0){
		if(!dhx4.s2b(fl))
			this.markedCells = false;
	}
 };
  /**
  *   @desc: occures on cell click
  *   @type: private
  *   @param: [el] - cell to click on
  *   @param: [markMethod] - 0 - simple click, 1 - shift, 2 - ctrl
  */
 dhtmlXGridObject.prototype.doMark = function(el,markMethod){ 

				var _rowId = el.parentNode.idd;
				this.setActive(true);
				if (!_rowId) return;
				this.editStop();
				this.cell=el;
				this.row=el.parentNode;
				var _cellIndex = el._cellIndex;				
				
				if(!markMethod) markMethod = 0;
				
           	    if(markMethod==0){
                    this.unmarkAll() ;	 
                }
				else if(markMethod==1){
					
					if(this.lastMarkedRow) {
						var r_start = Math.min(this.getRowIndex(_rowId),this.getRowIndex(this.lastMarkedRow));
						var r_end = Math.max(this.getRowIndex(_rowId),this.getRowIndex(this.lastMarkedRow));
						
						var c_start = Math.min(_cellIndex,this.lastMarkedColumn);
						var c_end = Math.max(_cellIndex,this.lastMarkedColumn);
					
						for(var i = r_start; i < r_end+1; i++){
							for(var j = c_start; j < c_end+1; j++){
								this.mark(this.getRowId(i),j,true);
								
							}
						}
					}
				}
				else if(markMethod==2){
					if(this.markedRowsArr._dhx_find(_rowId)!=-1){ 
						for(var ci = 0; ci < this.markedCellsArr[_rowId].length; ci++){
							if(this.markedCellsArr[_rowId][ci]==_cellIndex){
								this.mark(_rowId,_cellIndex,false);
								return true;
							}
						}
						
					}
					
				}
				
				if(!this.markedCellsArr[_rowId]) 
					this.markedCellsArr[_rowId] = new dhtmlxArray(0);
				
				if(markMethod!=1) 
					this.mark(_rowId,_cellIndex);
					
				this.moveToVisible(this.cells(_rowId,_cellIndex).cell);
				this.lastMarkedRow = _rowId;
				this.lastMarkedColumn = _cellIndex;
				this.lastMarkMethod = markMethod;
				
 }
/**
  	*   @desc: sets selection or removes selection from specified cell
    *   @param: r - row object or row index
    *   @param: cInd - cell index
    *   @param: state - true or false 
	*   @type: public
 */
dhtmlXGridObject.prototype.mark = function(rid,cindex,fl){
	if(arguments.length>2){
		if(!dhx4.s2b(fl)){
			this.cells(rid,cindex).cell.className = this.cells(rid,cindex).cell.className.replace(/cellselected/g,"");
			if(this.markedRowsArr._dhx_find(rid)!=-1){
				var ci = this.markedCellsArr[rid]._dhx_find(cindex);
				if(ci!=-1){
					this.markedCellsArr[rid]._dhx_removeAt(ci);
					if(this.markedCellsArr[rid].length==0){
						this.markedRowsArr._dhx_removeAt(this.markedRowsArr._dhx_find(rid));
					}
					this.callEvent("onCellUnMarked",[rid,cindex]);
				}
			}
			return true;
		}
	}
	this.cells(rid,cindex).cell.className+= " cellselected";
	
	if(this.markedRowsArr._dhx_find(rid)==-1) 
		this.markedRowsArr[this.markedRowsArr.length] = rid;
		
	if(!this.markedCellsArr[rid]) 
		this.markedCellsArr[rid] = new dhtmlxArray(0);
	if(this.markedCellsArr[rid]._dhx_find(cindex)==-1){
		this.markedCellsArr[rid][this.markedCellsArr[rid].length] = cindex;
		this.callEvent("onCellMarked",[rid,cindex]);
	}
	
}
/**
  	*   @desc: removes selection from all marked cell
   	*   @type: public
 */
dhtmlXGridObject.prototype.unmarkAll = function(){
	if(this.markedRowsArr){
		for(var ri = 0; ri < this.markedRowsArr.length; ri++){
			var rid = this.markedRowsArr[ri];
			if (this.rowsAr[rid])
				for(var ci = 0; ci < this.markedCellsArr[rid].length; ci++){
					this.callEvent("onCellUnMarked",[rid,this.markedCellsArr[rid][ci]])
					this.cells(rid,this.markedCellsArr[rid][ci]).cell.className = this.cells(rid,this.markedCellsArr[rid][ci]).cell.className.replace(/cellselected/g,"");
				}
		} 
		this.markedRowsArr = new dhtmlxArray(0);
		this.markedCellsArr = new Array(0);
	}
	return true;
}
/**
  	*   @desc: gets marked cells
   	*   @returns: the array of marked cells	(pairs of row id and column index)
	*   @type: public
 */
dhtmlXGridObject.prototype.getMarked = function(){
	var marked = new Array();
	if(this.markedRowsArr)
	for(var ri = 0; ri < this.markedRowsArr.length; ri++){
		var rid = this.markedRowsArr[ri];
		for(var ci = 0; ci < this.markedCellsArr[rid].length; ci++){
			marked[marked.length] = [rid,this.markedCellsArr[rid][ci]];
		}
	} 
	return marked;		
}

;
///<jscompress sourcefile="dhtmlxgrid_math.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: cell with support for math formulas
*	@param: cell - cell object
*	@type:  private
*   @edition: Professional
*/
function eXcell_math(cell){
	if (cell){
		this.cell = cell;
    	this.grid = this.cell.parentNode.grid;
	}
	this.edit = function(){
		this.grid.editor = new eXcell_ed(this.cell);
		this.grid.editor.fix_self=true;
		this.grid.editor.getValue=this.cell.original?(function(){ return this.cell.original}):this.getValue;
		this.grid.editor.setValue=this.setValue;
		this.grid.editor.edit();
	}
	this.isDisabled = function(){ return !this.grid._mathEdit; }
	this.setValue = function(val){
				val=this.grid._compileSCL(val,this.cell,this.fix_self);
                if (this.grid._strangeParams[this.cell._cellIndex])
    				this.grid.cells5(this.cell,this.grid._strangeParams[this.cell._cellIndex]).setValue(val);
                else{
                    this.setCValue(val);
    	            this.cell._clearCell=false;
	            }
    }
    this.getValue = function(){
        if (this.grid._strangeParams[this.cell._cellIndex])
			return this.grid.cells5(this.cell,this.grid._strangeParams[this.cell._cellIndex]).getValue();
        
        return this.cell.innerHTML;
    }
}
eXcell_math.prototype = new eXcell;

dhx4.attachEvent("onGridCreated", function(grid){
	grid._reset_math();
	grid.attachEvent("onClearAll", grid._reset_math);
	grid.attachEvent("onCellChanged",function(id,ind){
		if (this._mat_links[id]){ 
			var cell=this._mat_links[id][ind];
			if (cell){ 
				for (var i=0; i<cell.length; i++)
          if (cell[i].parentNode)
            this.cells5(cell[i]).setValue(this._calcSCL(cell[i]));
			}
		}
		if (!this._parsing && this._aggregators[ind]){
			var pid=this._h2.get[id].parent.id;
			if (pid!=0){
				var ed=this.cells(pid,ind);
				ed.setValue(this._calcSCL(ed.cell));
			}
		}
	})
	grid.attachEvent("onAfterRowDeleted",function(id,pid){ //will be called for each delete operation, may be optimized
		if (pid!=0)
			if (!this._parsing && this._aggregators.length){
				for (var ind=0; ind < this._aggregators.length; ind++) {
					if (this._aggregators[ind]){
							var ed=this.cells(pid,ind);
							ed.setValue(this._calcSCL(ed.cell));
					}
				};
			}
		return true;
	})
	grid.attachEvent("onXLE", grid._refresh_math);

});

dhtmlXGridObject.prototype._reset_math=function(){
  this._mat_links   = {};
  this._aggregators = [];
};
dhtmlXGridObject.prototype._refresh_math=function(){
  for (var i=0; i < this._aggregators.length; i++) {
    if (this._aggregators[i])
      this._h2.forEachChild(0,function(el){
        if (el.childs.length!=0){
          var ed=this.cells(el.id,i);
          ed.setValue(this._calcSCL(ed.cell));
        }
      },this);
  };
};

dhtmlXGridObject.prototype.refreshMath=function(status){
    this._mat_links = {};
    for (var i=0; i<this.getColumnsNum(); i++){
      if (this.getColType(i) == "math"){
        this.forEachRow(function(id){
          var cell = this.cells(id, i);
          cell.setValue(cell.cell.original || cell.getValue());
        });
      }
    }
};

/**
*	@desc: enable/disable serialization of math formulas
*	@param: status - true/false
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.enableMathSerialization=function(status){
    this._mathSerialization=dhx4.s2b(status);
}
/**
*	@desc: enable/disable rounding while math calculations
*	@param: digits - set hom many digits must be rounded, set 0 for disabling
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.setMathRound=function(digits){
	this._roundDl=digits;
    this._roundD=Math.pow(10,digits);
}
/**
*	@desc: enable/disable editing of math cells
*	@param: status - true/false
*	@type:  public
*   @edition: Professional
*/
dhtmlXGridObject.prototype.enableMathEditing=function(status){
    this._mathEdit=dhx4.s2b(status);
}

/**
*	@desc: calculate value of math cell
*	@param: cell - math cell
*	@returns: cell value
*	@type:  private
*   @edition: Professional
*/
dhtmlXGridObject.prototype._calcSCL=function(cell){ 
    if (!cell._code) return this.cells5(cell).getValue();
    try{
    	dhtmlx.agrid=this;
    	var z=eval(cell._code);
    } catch(e){ return ("#SCL"); }
    if (this._roundD)
        { 
        	var pre=Math.abs(z)<1?"0":"";
         	if (z<0) pre="-"+pre;
            z=Math.round(Math.abs(z)*this._roundD).toString();
            if (z==0) return 0;
            if (this._roundDl>0){
            	var n=z.length-this._roundDl;
            	if (n<0) {
            		z=("000000000"+z).substring(9+n);
            		n=0;
            	}
            	return (pre+z.substring(0,n)+"."+z.substring(n,z.length));
            }
          return pre+z;
      }
    return z;      
}

dhtmlXGridObject.prototype._countTotal=function(row,cell){ 
	var b=0;
	var z=this._h2.get[row];
	for (var i=0; i<z.childs.length; i++){
		if (!z.childs[i].buff) return b;	// dnd of item with childs, item inserted in hierarchy but not fully processed
		if (z.childs[i].buff._parser){
      b = 0;
			this._h2.forEachChild(row,function(el){
				if (el.childs.length==0){
          var value = parseFloat(this._get_cell_value(el.buff,cell),10);
          if (value)
					 b += value;
        }
			},this)
			return b;
		}
    var value = parseFloat(this._get_cell_value(z.childs[i].buff,cell),10);
    if (value)
		  b += value;
	}
	return b;
}

/**
*	@desc: compile pseudo code to correct javascript
*	@param: code - pseudo code
*	@param: cell - math cell
*	@returns: valid js code
*	@type:  private
*   @edition: Professional
*/
dhtmlXGridObject.prototype._compileSCL=function(code,cell,fix){ 
		if (code === null || code === window.undefined) return code;
        code=code.toString();
        if (code.indexOf("=")!=0 || !cell.parentNode) {
        	this._reLink([],cell);
        	if (fix) cell._code = cell.original = null;
            return code;
        }
        cell.original=code;
        
        var linked=null;
        code=code.replace("=","");
        if (code.indexOf("sum")!=-1){ 
            code=code.replace("sum","(dhtmlx.agrid._countTotal('"+cell.parentNode.idd+"',"+cell._cellIndex+"))");
            if (!this._aggregators) this._aggregators=[];
            this._aggregators[cell._cellIndex]="sum";
            cell._code=code;
        	return  this._parsing?"":this._calcSCL(cell);
        }
        if (code.indexOf("[[")!=-1){
          var test = /(\[\[([^\,]*)\,([^\]]*)]\])/g;
          dhtmlx.agrid=this;
          linked=linked||(new Array());
          code=code.replace(test,
              function ($0,$1,$2,$3){
                  if ($2=="-")
                      $2=cell.parentNode.idd;
                  if ($2.indexOf("#")==0)
                      $2=dhtmlx.agrid.getRowId($2.replace("#",""));
                      linked[linked.length]=[$2,$3];
                  return "(parseFloat(dhtmlx.agrid.cells(\""+$2+"\","+$3+").getValue(),10))";
              }
          );
        }
        
        if (code.indexOf(":")!=-1){ 
          var test = /:(\w+)/g;
          dhtmlx.agrid=this;
          var id=cell.parentNode.idd;
          linked=linked||(new Array());
          code=code.replace(test,
              function ($0,$1,$2,$3){
                  linked[linked.length]=[id,dhtmlx.agrid.getColIndexById($1)];
                  return '(parseFloat(dhtmlx.agrid.cells("'+id+'",dhtmlx.agrid.getColIndexById("'+$1+'")).getValue(),10))';
              }
          );
        }
        else{
          var test = /c([0-9]+)/g;
          dhtmlx.agrid=this;
          var id=cell.parentNode.idd;
          linked=linked||(new Array());
          code=code.replace(test,
              function ($0,$1,$2,$3){
                  linked[linked.length]=[id,$1];
                  return "(parseFloat(dhtmlx.agrid.cells(\""+id+"\","+$1+").getValue(),10))";
              }
          );
        }
        
        this._reLink(linked,cell);
        cell._code=code;
        return this._calcSCL(cell);
    }

/**
*	@desc: link math cells to it source cells
*	@param: ar - array of nodes for linking
*	@param: cell - math cell
*	@type:  private
*   @edition: Professional
*/
dhtmlXGridObject.prototype._reLink=function(ar,cell){
		if (!ar.length) return; // basically it would be good to clear unused math links, but it will require a symetric structure 
		for (var i=0; i<ar.length; i++){ 
			if (!this._mat_links[ar[i][0]]) this._mat_links[ar[i][0]]={};
			var t=this._mat_links[ar[i][0]];
			if (!t[ar[i][1]]) t[ar[i][1]]=[];
			t[ar[i][1]].push(cell);
		}
}

if (_isKHTML){
// replace callback support for safari.
 (function(){
   var default_replace = String.prototype.replace;
   String.prototype.replace = function(search,replace){
 // replace is not function
 if(typeof replace != "function"){
 return default_replace.apply(this,arguments)
 }
 var str = "" + this;
 var callback = replace;
 // search string is not RegExp
 if(!(search instanceof RegExp)){
 var idx = str.indexOf(search);
 return (
 idx == -1 ? str :
 default_replace.apply(str,[search,callback(search, idx, str)])
 )
 }
 var reg = search;
 var result = [];
 var lastidx = reg.lastIndex;
 var re;
 while((re = reg.exec(str)) != null){
 var idx  = re.index;
 var args = re.concat(idx, str);
 result.push(
 str.slice(lastidx,idx),
 callback.apply(null,args).toString()
 );
 if(!reg.global){
 lastidx += RegExp.lastMatch.length;
 break
 }else{
 lastidx = reg.lastIndex;
 }
 }
 result.push(str.slice(lastidx));
 return result.join("")
   }
 })();
 }
//(c)dhtmlx ltd. www.dhtmlx.com
;
///<jscompress sourcefile="dhtmlxgrid_mcol.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: add new column to the grid. Can be used after grid was initialized. At least one column should be in grid
*   @param: ind - index of column
*   @param: header - header content of column
*   @param: type - type of column
*   @param: width - width of column
*   @param: sort - sort type of column
*   @param: align - align of column
*   @param: valign - vertical align of column
*   @param: reserved - not used for now
*   @param: columnColor - background color of column
*   @type: public
*   @edition: Professional
*   @topic: 3
*/
dhtmlXGridObject.prototype.insertColumn=function(ind,header,type,width,sort,align,valign,reserved,columnColor){
	ind=parseInt(ind);
	if (ind>this._cCount) ind=this._cCount;
	if (!this._cMod) this._cMod=this._cCount;
	this._processAllArrays(this._cCount,ind-1,[(header||"&nbsp;"),(width||100),(type||"ed"),(align||"left"),(valign||""),(sort||"na"),(columnColor||""),"",this._cMod,(width||100)]);
	this._processAllRows("_addColInRow",ind);

	if (typeof(header)=="object")
		for (var i=1; i < this.hdr.rows.length; i++) {
			if (header[i-1]=="#rspan"){
         		var pind=i-1;
         		var found=false;
         		var pz=null;
         		while(!found){
            		var pz=this.hdr.rows[pind];
            		for (var j=0; j<pz.cells.length; j++)
               			if (pz.cells[j]._cellIndex==ind) {
                  			found=j;
                  			break;
		      		}
            		pind--;
	        	}
	        this.hdr.rows[pind+1].cells[j].rowSpan=(this.hdr.rows[pind].cells[j].rowSpan||1)+1;
			}
			else				
			this.setHeaderCol(ind,(header[i-1]||"&nbsp;"),i);
		}
	else
		this.setHeaderCol(ind,(header||"&nbsp;"));
	this.hdr.rows[0].cells[ind]
	this._cCount++;
	this._cMod++;
	this._master_row=null;
	this.setSizes();
}
/**
*   @desc: delete column
*   @param: ind - index of column
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.deleteColumn=function(ind){
	ind=parseInt(ind);
	if (this._cCount==0) return;
	if (!this._cMod) this._cMod=this._cCount;
	if (ind>=this._cCount) return;
	this._processAllArrays(ind,this._cCount-1,[null,null,null,null,null,null,null,null,null,null,null]);
	this._processAllRows("_deleteColInRow",ind);
	this._cCount--;
	this._master_row=null;
	this.setSizes();

}

/**
*   @desc: call method for all rows in all collections
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._processAllRows = function(method,oldInd,newInd){
	this[method](this.obj.rows[0],oldInd,newInd,0);

	var z=this.hdr.rows.length;
    for (var i=0; i<z; i++)
		this[method](this.hdr.rows[i],oldInd,newInd,i);
		
	if (this.ftr){
		var z=this.ftr.firstChild.rows.length;
	    for (var i=0; i<z; i++)
			this[method](this.ftr.firstChild.rows[i],oldInd,newInd,i);
	}

	this.forEachRow(function(id){
		if (this.rowsAr[id] && this.rowsAr[id].tagName=="TR")
			this[method](this.rowsAr[id],oldInd,newInd,-1);
	});			
	
}

/**
*   @desc: shift data in all arrays
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._processAllArrays = function(oldInd,newInd,vals){
	var ars=["hdrLabels","initCellWidth","cellType","cellAlign","cellVAlign","fldSort","columnColor","_hrrar","_c_order"];
	if (this.cellWidthPX.length) ars.push("cellWidthPX");
	if (this.cellWidthPC.length) ars.push("cellWidthPC");
	if (this._col_combos) ars.push("_col_combos");
    if (this._mCols) ars[ars.length]="_mCols";
    if (this.columnIds) ars[ars.length]="columnIds";
    if (this._maskArr) ars.push("_maskArr");
    if (this._drsclmW) ars.push("_drsclmW");
    if (this._RaSeCol) ars.push("_RaSeCol");
    if (this._hm_config) ars.push("_hm_config");
    if (this._drsclmn) ars.push("_drsclmn");

    if (this.clists) ars.push("clists");
    if (this._validators && this._validators.data) ars.push(this._validators.data);
    
    ars.push("combos");
    if (this._customSorts) ars.push("_customSorts");
    if (this._aggregators)  ars.push("_aggregators");
    var mode=(oldInd<=newInd);

	if (!this._c_order) {
		this._c_order=new Array();
		var l=this._cCount;
		for (var i=0; i<l; i++)
			this._c_order[i]=i;
	}

	for (var i=0; i<ars.length; i++)
		{
			var t=this[ars[i]]||ars[i];
			if (t){
				if (mode){
					var val=t[oldInd];
					for (var j=oldInd; j<newInd; j++)
						t[j]=t[j+1];
					t[newInd]=val;
				} else {
					var val=t[oldInd];
					for (var j=oldInd; j>(newInd+1); j--)
						t[j]=t[j-1];
					t[newInd+1]=val;
				}
				if (vals)
					t[newInd+(mode?0:1)]=vals[i];
			}
		}
}


/**
*   @desc: moves column of specified index to new position
*   @param: oldInd - current index of column
*   @param: newInd - new index of column
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.moveColumn = function(oldInd,newInd){
	newInd--;
    oldInd=parseInt(oldInd); newInd=parseInt(newInd);
	if (newInd<oldInd) var tInd=newInd+1;
	else var tInd=newInd;
	

	if (!this.callEvent("onBeforeCMove",[oldInd,tInd]))  return false;
	if (oldInd==tInd) return;

	
	//replace data
	this.editStop();
    this._processAllRows("_moveColInRow",oldInd,newInd);
    this._processAllArrays(oldInd,newInd);

	//sorting image
	if (this.fldSorted)
		this.setSortImgPos(this.fldSorted._cellIndex);

  /*	for (var i=0; i<this.hdrLabels.length; i++)
		this._c_revers[this._c_order[i]]=i;*/
	this.callEvent("onAfterCMove",[oldInd,tInd]);
};


/**
*   @desc: swap columns in collection
*   @param: cols - collection of collumns
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._swapColumns = function(cols){
	var z=new Array();
	for (var i=0; i<this._cCount; i++){
		var n=cols[this._c_order[i]];
		if (typeof(n)=="undefined") n="";
		z[i]=n;
		}
	return z;
}

/**
*   @desc: move data in the row
*   @param: row - row object
*   @param: oldInd - current index of column
*   @param: newInd - new index of column
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._moveColInRow = function(row,oldInd,newInd){


	var c=row.childNodes[oldInd];
	var ci=row.childNodes[newInd+1];
	if (!c) return;
	if (ci)
		row.insertBefore(c,ci);
	else
		row.appendChild(c);

	for (var i=0; i<row.childNodes.length; i++)
		row.childNodes[i]._cellIndex=row.childNodes[i]._cellIndexS=i;

};
/**
*   @desc: add column in row
*   @param: row - row object
*   @param: ind - current index of column
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._addColInRow = function(row,ind,old,mod){
	var cind=ind;
	if (row._childIndexes){
		if (row._childIndexes[ind-1]==row._childIndexes[ind] || !row.childNodes[row._childIndexes[ind-1]]){
			for (var i=row._childIndexes.length; i>=ind; i--)
			row._childIndexes[i]=i?(row._childIndexes[i-1]+1):0;
			row._childIndexes[ind]--;
			}
		else
		for (var i = row._childIndexes.length; i >= ind; i--)
			row._childIndexes[i]=i?(row._childIndexes[i-1]+1):0;
		var cind=row._childIndexes[ind];
	}
	var c=row.childNodes[cind];
	var z=document.createElement((mod)?"TD":"TH");
	if (mod) { z._attrs={}; } //necessary for code compressor
	else z.style.width=(parseInt(this.cellWidthPX[ind])||"100")+"px";
	if (c)
		row.insertBefore(z,c);
	else
		row.appendChild(z);

	if (this.dragAndDropOff && row.idd) this.dragger.addDraggableItem(row.childNodes[cind],this);
	
	for (var i=cind+1; i<row.childNodes.length; i++){
		row.childNodes[i]._cellIndex=row.childNodes[i]._cellIndexS=row.childNodes[i]._cellIndex+1;
	}
		
	if (row.childNodes[cind]) row.childNodes[cind]._cellIndex=row.childNodes[cind]._cellIndexS=ind;

	if (row.idd || typeof(row.idd)!="undefined"){
		this.cells3(row,ind).setValue("");
		z.align=this.cellAlign[ind];
		z.style.verticalAlign=this.cellVAlign[ind];
		z.bgColor=this.columnColor[ind];
		}
	else if (z.tagName=="TD"){
		if (!row.idd && this.forceDivInHeader) z.innerHTML="<div class='hdrcell'>&nbsp;</div>";
		else	z.innerHTML="&nbsp;";
	} 
};
/**
*   @desc: delete columns from row
*   @param: row - row object
*   @param: ind - current index of column
*   @type: private
*   @topic: 0
*/
dhtmlXGridObject.prototype._deleteColInRow = function(row,ind){
	var aind = ind; //logical index
	if (row._childIndexes) ind=row._childIndexes[ind];
	var c=row.childNodes[ind];
	if (!c) return;
	if (c.colSpan && c.colSpan>1 && c.parentNode.idd){
		var t=c.colSpan-1;
		var v=this.cells4(c).getValue();
		this.setColspan(c.parentNode.idd,c._cellIndex,1)
		if (t>1){
			var cind=c._cellIndex*1;
			this.setColspan(c.parentNode.idd,cind+1,t)
			this.cells(c.parentNode.idd,c._cellIndex*1+1).setValue(v)
			row._childIndexes.splice(cind,1)
			for (var i=cind; i < row._childIndexes.length; i++) 
				row._childIndexes[i]-=1;
				
		}
	} else if (row._childIndexes){
	    row._childIndexes.splice(aind,1);
	    for (var i=aind; i<row._childIndexes.length; i++) row._childIndexes[i]--;
	}
	if (c)
		row.removeChild(c);

	for (var i=ind; i<row.childNodes.length; i++)
		row.childNodes[i]._cellIndex=row.childNodes[i]._cellIndexS=row.childNodes[i]._cellIndex-1;
};


/**
*   @desc: enable move column functionality
*   @param: mode - true/false
*   @param: columns - list of true/false values, optional
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableColumnMove = function(mode,columns){
	this._mCol=dhx4.s2b(mode);
	if (typeof(columns)!="undefined")
		this._mCols=columns.split(",");
	if (!this._mmevTrue){
		dhtmlxEvent(this.hdr,"mousedown",this._startColumnMove);
		dhtmlxEvent(document.body,"mousemove",this._onColumnMove);
		dhtmlxEvent(document.body,"mouseup",this._stopColumnMove);
		this._mmevTrue=true;
	}
};

dhtmlXGridObject.prototype._startColumnMove = function(e){
	e=e||event;
	var el = e.target||e.srcElement;
//	var grid=globalActiveDHTMLGridObject;
	   	var zel=el;
	   	while(zel.tagName!="TABLE") zel=zel.parentNode;
		var grid=zel.grid;
		if (!grid) return; //somehow grid not found
		grid.setActive();
	if (!grid._mCol || e.button==2) return;
	
	el = grid.getFirstParentOfType(el,"TD")
    if(el.style.cursor!="default") return true;
	if ((grid)&&(!grid._colInMove)){
		grid.resized = null;
		if ((!grid._mCols)||(grid._mCols[el._cellIndex]=="true"))
	    	grid._colInMove=el._cellIndex+1;
	}
	grid._colInMovePos = {
		x: e.clientX, y: e.clientY
	};
	return true;
};
dhtmlXGridObject.prototype._onColumnMove = function(e){
	e=e||event;
	var grid=window.globalActiveDHTMLGridObject;
	if ((grid)&&(grid._colInMove)){
		var diff = Math.max(
			Math.abs(e.clientX - grid._colInMovePos.x),
			Math.abs(e.clientY - grid._colInMovePos.y)
		);
		if (diff < 20) return;


		if (grid._hideHContext) grid._hideHContext();
    	if (typeof(grid._colInMove)!="object"){
        	var z=document.createElement("DIV");
			z._aIndex=(grid._colInMove-1);
			z._bIndex=null;
			z.innerHTML=grid.getHeaderCol(z._aIndex);
			z.className="dhx_dragColDiv";
			z.style.position="absolute";
			document.body.appendChild(z);
            grid._colInMove=z;
		}
		
		var cor=[];
		cor[0]=(document.body.scrollLeft||document.documentElement.scrollLeft);
		cor[1]=(document.body.scrollTop||document.documentElement.scrollTop);
		
		
		grid._colInMove.style.left=e.clientX+cor[0]+8+"px";
		grid._colInMove.style.top=e.clientY+cor[1]+8+"px";
		
        var el = e.target||e.srcElement;
		while ((el)&&(typeof(el._cellIndexS)=="undefined"))
			el=el.parentNode;

		if (grid._colInMove._oldHe){
			grid._colInMove._oldHe.className=grid._colInMove._oldHe.className.replace(/columnTarget(L|R)/g,"");
			grid._colInMove._oldHe=null;
			grid._colInMove._bIndex=null;
			}
		if (el) {
			if (grid.hdr.rows[1]._childIndexes)
				var he=grid.hdr.rows[1].cells[grid.hdr.rows[1]._childIndexes[el._cellIndexS]];
			else
				var he=grid.hdr.rows[1].cells[el._cellIndexS];
			var z=e.clientX-(dhx4.absLeft(he)-grid.hdrBox.scrollLeft);
            if (z/he.offsetWidth>0.5){
				he.className+=" columnTargetR";
				grid._colInMove._bIndex=el._cellIndexS;
				}
			else {
				he.className+=" columnTargetL";
				grid._colInMove._bIndex=el._cellIndexS-1;
			}
			if (he.offsetLeft<(grid.objBox.scrollLeft+20))
				grid.objBox.scrollLeft=Math.max(0,he.offsetLeft-20);

			if ((he.offsetLeft+he.offsetWidth-grid.objBox.scrollLeft)>(grid.objBox.offsetWidth-20))
				grid.objBox.scrollLeft=Math.min(grid.objBox.scrollLeft+he.offsetWidth+20,grid.objBox.scrollWidth-grid.objBox.offsetWidth);	
				
            grid._colInMove._oldHe=he;
		}
		//prevent selection, or other similar reactions while column draged
		e.cancelBubble = true;  
        return false;  
	}
	return true;
};
dhtmlXGridObject.prototype._stopColumnMove = function(e){
	e=e||event;
	var grid=window.globalActiveDHTMLGridObject;
	if ((grid)&&(grid._colInMove)){
		if (typeof(grid._colInMove)=="object"){
			grid._colInMove.parentNode.removeChild(grid._colInMove);
			if (grid._colInMove._bIndex!=null)
				grid.moveColumn(grid._colInMove._aIndex,grid._colInMove._bIndex+1);

			if (grid._colInMove._oldHe)
				grid._colInMove._oldHe.className=grid._colInMove._oldHe.className.replace(/columnTarget(L|R)/g,"");
			grid._colInMove._oldHe=null;
			grid._colInMove.grid=null;
			grid.resized = true;
			}
        grid._colInMove=0;
	}
	return true;
};



//(c)dhtmlx ltd. www.dhtmlx.com


;
///<jscompress sourcefile="dhtmlxgrid_splt.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/*
    Limitation:
        a) Width of column in px
        b) Grid not autoresizable
        c) Initialize grid in visible state
*/

dhx4.attachEvent("onGridCreated", function (grid) {
    if (grid._split_later)
        grid.splitAt(grid._split_later);
});


/**
*   @desc:  split grid in two parts, with separate scrolling
*   @param:  ind - index of column to split after
*   @edition: Professional
*   @type:  public$
*/
dhtmlXGridObject.prototype.splitAt = function (ind) {
    if (!this.obj.rows[0]) return this._split_later = ind;
    ind = parseInt(ind);

    var leftBox = document.createElement("DIV");
    this.entBox.appendChild(leftBox);
    var rightBox = document.createElement("DIV");
    this.entBox.appendChild(rightBox);

    for (var i = this.entBox.childNodes.length - 3; i >= 0; i--)
        rightBox.insertBefore(this.entBox.childNodes[i], rightBox.firstChild);

    this.entBox.style.position = "relative";
    this.globalBox = this.entBox;
    this.entBox = rightBox; rightBox.grid = this;


    leftBox.style.cssText += "border:0px solid red !important;";
    rightBox.style.cssText += "border:0px solid red !important;";

    rightBox.style.top = "0px";
    rightBox.style.position = "absolute";

    leftBox.style.position = "absolute";
    leftBox.style.top = "0px";
    leftBox.style.left = "0px";
    leftBox.style.zIndex = 11;

    rightBox.style.height = leftBox.style.height = this.globalBox.clientHeight;


    this._fake = new dhtmlXGridObject(leftBox);

    this._fake.hwReport = this.hwReport;
    this._fake.__class = this.__class || [];
    this._fake.__attrs = this.__attrs || [];
    var setColumnLabel = this._fake.setColumnLabel;
    this._fake.setColumnLabel = function (c, label, ind, hdr) {
        setColumnLabel.apply(this, [c, label, ind, hdr]);
        var z = (hdr || this.hdr).rows[ind || 1];
        var col = (z._childIndexes ? z._childIndexes[c] : c);
        if (!z.cells[col]) return;
        if (!this.useImagesInHeader) {
            if (this.__class[c]) {
                z.cells[col].className = this.__class[c];
            }
            if (this.__attrs[c]) {
                z.cells[col]._attrs = this.__attrs[c];
                z.cells[col].firstChild._attrs = this.__attrs[c];

                var originCell = this.hwReport.getOriginCellById(this.__attrs[c].sid);
                if (originCell && originCell.getType() == "vmdlink") {
                    z.cells[col].grid = this;
                    z.cells[col].firstChild._cellType = originCell.getType();
                    var aeditor = this.cells4(z.cells[col].firstChild);

                    if (aeditor) aeditor.setValue(label);
                }
            }
        }
    }

    this.globalBox = this._fake.globalBox = this.globalBox;
    this._fake._fake = this;
    this._fake._realfake = true;

    //copy properties    
    this._treeC = this.cellType._dhx_find("tree");
    this._fake.delim = this.delim;
    this._fake.customGroupFormat = this.customGroupFormat;

    this._fake.setImagesPath(this._imgURL);
    this._fake.iconURL = this.iconURL;
    this._fake._customSorts = this._customSorts;
    this._fake.noHeader = this.noHeader;
    this._fake._enbTts = this._enbTts;
    this._fake._drsclmW = this._drsclmW;
    this._fake._htkebl = this._htkebl;
    this._fake.clists = this.clists;
    this._fake.fldSort = new Array();
    this._fake.selMultiRows = this.selMultiRows;
    this._fake.multiLine = this.multiLine;
    this._fake._key_events = this._key_events;
    this._fake.smartTabOrder = this.smartTabOrder;
    this._fake._RaSeCol = this._RaSeCol;

    if (this.multiLine || this._erspan) {
        this.attachEvent("onCellChanged", this._correctRowHeight);
        this.attachEvent("onRowAdded", this._correctRowHeight);
        var corrector = function () {
            this.forEachRow(function (id) {
                this._correctRowHeight(id);
            })
        };
        this.attachEvent("onPageChanged", corrector);
        this.attachEvent("onXLE", corrector);
        this.attachEvent("onResizeEnd", corrector);
        if (!this._ads_count) //in case of distribute parsing - use special event instead
            this.attachEvent("onAfterSorting", corrector);

        this.attachEvent("onFilterEnd", corrector);
        this.attachEvent("onDistributedEnd", corrector);

        //this._fake.attachEvent("onCellChanged",this._correctRowHeight);
    }
    this.attachEvent("onGridReconstructed", function () {
        this._fake.objBox.scrollTop = this.objBox.scrollTop;
    })

    this._fake.loadedKidsHash = this.loadedKidsHash;
    if (this._h2) this._fake._h2 = this._h2;
    this._fake._dInc = this._dInc;

    //collect grid configuraton
    var b_ha = [[], [], [], [], [], [], []];
    var b_ar = ["hdrLabels", "initCellWidth", "cellType", "cellAlign", "cellVAlign", "fldSort", "columnColor"];
    var b_fu = ["setHeader", "setInitWidths", "setColTypes", "setColAlign", "setColVAlign", "setColSorting", "setColumnColor"];

    this._fake.callEvent = function () {
        var result = true;
        this._fake._split_event = true;
        var hidden = (arguments[0] == "onScroll");
        if (arguments[0] == "onGridReconstructed" || hidden)
            this._fake.callEvent.apply(this, arguments);

        if (!hidden) result = this._fake.callEvent.apply(this._fake, arguments);
        this._fake._split_event = false;
        return result;
    }

    if (this._elmn)
        this._fake.enableLightMouseNavigation(true);

    if (this._cssEven || this._cssUnEven)
        this._fake.attachEvent("onGridReconstructed", function () {
            this._fixAlterCss();
        });

    this._fake._cssSP = this._cssSP;
    this._fake.isEditable = this.isEditable;
    this._fake._edtc = this._edtc;
    if (this._sst) this._fake.enableStableSorting(true);

    this._fake._sclE = this._sclE;
    this._fake._dclE = this._dclE;
    this._fake._f2kE = this._f2kE;
    this._fake._maskArr = this._maskArr;
    this._fake._dtmask = this._dtmask;
    this._fake.combos = this.combos;

    var width = 0;

    var m_w = this.globalBox.offsetWidth;
    for (var i = 0; i < ind; i++) {
        for (var j = 0; j < b_ar.length; j++) {
            if (this[b_ar[j]])
                b_ha[j][i] = this[b_ar[j]][i];
            if (typeof b_ha[j][i] == "string") b_ha[j][i] = b_ha[j][i].replace(new RegExp("\\" + this.delim, "g"), "\\" + this.delim);
        }
        if (_isFF) b_ha[1][i] = b_ha[1][i] * 1;
        if (this.cellWidthType == "%") {
            b_ha[1][i] = Math.round(parseInt(this[b_ar[1]][i]) * m_w / 100);
            width += b_ha[1][i];
        } else
            width += parseInt(this[b_ar[1]][i]);
        this.setColumnHidden(i, true);
    }


    for (var j = 0; j < b_ar.length; j++) {
        var str = b_ha[j].join(this.delim);

        if (b_fu[j] != "setHeader") {
            if (str != "")
                this._fake[b_fu[j]](str);
        } else
            this._fake[b_fu[j]](str, null, this._hstyles);
    }


    this._fake._strangeParams = this._strangeParams;
    this._fake._drsclmn = this._drsclmn;

    width = Math.min(this.globalBox.offsetWidth, width);
    rightBox.style.left = width + "px"; leftBox.style.width = width + "px";
    rightBox.style.width = Math.max(this.globalBox.offsetWidth - width, 0);

    if (this._ecspn) this._fake._ecspn = true;

    //    this._fake.setNoHeader(true);
    this._fake.init();
    if (this.dragAndDropOff)
        this.dragger.addDragLanding(this._fake.entBox, this);

    this._fake.objBox.style.overflow = "hidden";
    if (!dhtmlx.$customScroll)
        this._fake.objBox.style.overflowX = "scroll";
    else
        this._fake.objBox._custom_scroll_mode = "";

    this._fake._srdh = this._srdh || 20;
    this._fake._srnd = this._srnd;
    this._fake._cssEven = this._cssEven;
    this._fake._cssUnEven = this._cssUnEven;
    if (this.skin_name != this._fake.skin_name)
        this._fake.setSkin(this.skin_name);

    var selfmaster = this;
    function _on_wheel(e) {
        var cont = selfmaster.objBox;
        if (cont.scrollHeight - cont.offsetHeight > 2) {
            var dir = e.wheelDelta / -40;
            if (e.wheelDelta === window.undefined)
                dir = e.detail;
            cont.scrollTop += dir * 40;

            if (e.preventDefault)
                e.preventDefault();
        }
    }
    dhtmlxEvent(this._fake.objBox, "mousewheel", _on_wheel);
    dhtmlxEvent(this._fake.objBox, "DOMMouseScroll", _on_wheel);


    //inner methods


    function change_td(a, b) {
        //b.style.whiteSpace = "";
        var c = b.nextSibling;
        var cp = b.parentNode;
        a.parentNode.insertBefore(b, a);
        if (!c)
            cp.appendChild(a);
        else
            cp.insertBefore(a, c);
        var z = a.style.display;
        a.style.display = b.style.display;
        a._attrs = b._attrs;
        a.style.whiteSpace = b.style.whiteSpace;
        b.style.whiteSpace = "nowrap"; //防止单元格宽度为0时高度过高
        b.style.display = z;
    }
    function proc_hf(i, rows, mode, frows) {
        var that = this;
        var temp_header = (new Array(ind)).join(this.delim);
        var temp_rspan = [];
        if (i == 2) {
            for (var k = 0; k < ind; k++) {
                var r = rows[i - 1].cells[rows[i - 1]._childIndexes ? rows[i - 1]._childIndexes[k] : k];
                if (r.rowSpan && r.rowSpan > 1) {
                    temp_rspan[r._cellIndex] = r.rowSpan - 1;
                    frows[i - 1].cells[frows[i - 1]._childIndexes ? frows[i - 1]._childIndexes[k] : k].rowSpan = r.rowSpan;
                    r.rowSpan = 1;
                }
            }

            var rowHeight = _isIE ? rows[i - 1].offsetHeight : rows[i - 1].clientHeight;
            var frowHeight = _isIE ? frows[i - 1].offsetHeight : frows[i - 1].clientHeight;
            frows[i - 1].style.height = Math.max(rowHeight, frowHeight) + 'px';
            rows[i - 1].style.height = Math.max(rowHeight, frowHeight) + 'px';
            this.noHeaderResize = true;
        }

        for (i; i < rows.length; i++) {
            var temp_class = Array.apply(null, Array(ind)).map(function (item, index, array) {
                var oCell = that.hwReport.getOriginCellById((i - 1) + "_" + index);
                if (oCell) {
                    return oCell.getClassName();
                }
                return "";
            });
            this._fake.attachHeader(temp_header, null, mode, temp_class);
            frows = frows || this._fake.ftr.childNodes[0].rows;
            var max_ind = ind;
            var r_cor = 0;
            var colspan_ind = 1;
            for (var j = 0; j < max_ind; j += colspan_ind) {

                if (temp_rspan[j]) {
                    temp_rspan[j] = temp_rspan[j] - 1;
                    if (_isIE || /*(_isFF && _FFrv >= 1.9) ||*/ _isOpera) {
                        var td = document.createElement("TD");
                        if (_isFF) td.style.display = "none";
                        rows[i].insertBefore(td, rows[i].cells[0])
                    }

                    r_cor++;
                    colspan_ind = 1;
                    continue;
                }

                var a = frows[i].cells[j - r_cor];
                var b = rows[i].cells[j - (_isIE ? 0 : r_cor)];
                var t = b.rowSpan;

                change_td(a, b);
                if (t > 1) {
                    if (frows[i].cells[j - r_cor].colSpan > 1) {
                        for (var k = 1; k < frows[i].cells[j - r_cor].colSpan; k++)
                            temp_rspan[j + k] = t - 1;
                    }
                    temp_rspan[j] = t - 1;
                    b.rowSpan = t;
                }
                if (frows[i].cells[j - r_cor].colSpan > 1) {
                    rows[i].cells[j - r_cor].colSpan = frows[i].cells[j - r_cor].colSpan;
                    for (var k = 1; k < frows[i].cells[j - r_cor].colSpan; k++)
                        frows[i].removeChild(frows[i].cells[j - r_cor + 1]);
                }
                colspan_ind = frows[i].cells[j - r_cor].colSpan;
                r_cor += frows[i].cells[j - r_cor].colSpan - 1;
            }
            
            //if (frows[i].clientHeight != rows[i].clientHeight) {
            var rowHeight = _isIE ? rows[i].offsetHeight : rows[i].clientHeight;
            var frowHeight = _isIE ? frows[i].offsetHeight : frows[i].clientHeight;
            frows[i].style.height = Math.max(rowHeight, frowHeight) + 'px';
            rows[i].style.height = Math.max(rowHeight, frowHeight) + 'px';
            this.noHeaderResize = true;
            //}
        }
    }

    if (this.hdr.rows.length > 2)
        proc_hf.call(this, 2, this.hdr.rows, "_aHead", this._fake.hdr.rows);
    if (this.ftr) {
        proc_hf.call(this, 1, this.ftr.childNodes[0].rows, "_aFoot");
        this._fake.ftr.parentNode.style.bottom = (_isFF ? 2 : 1) + "px";
    }


    if (this.saveSizeToCookie) {
        this.saveSizeToCookie = function (name, cookie_param) {
            if (this._realfake)
                return this._fake.saveSizeToCookie.apply(this._fake, arguments);

            if (!name) name = this.entBox.id;
            var z = new Array();
            var n = "cellWidthPX";

            for (var i = 0; i < this[n].length; i++)
                if (i < ind)
                    z[i] = this._fake[n][i];
                else
                    z[i] = this[n][i];
            z = z.join(",")
            this.setCookie(name, cookie_param, 0, z);
            var z = (this.initCellWidth || (new Array)).join(",");
            this.setCookie(name, cookie_param, 1, z);

            return true;
        }
        this.loadSizeFromCookie = function (name) {
            if (!name) name = this.entBox.id;
            var z = this._getCookie(name, 1);

            if (!z) return
            this.initCellWidth = z.split(",");
            var z = this._getCookie(name, 0);
            var n = "cellWidthPX";
            this.cellWidthType = "px";

            var summ2 = 0;
            if ((z) && (z.length)) {
                z = z.split(",");
                for (var i = 0; i < z.length; i++)
                    if (i < ind) {
                        this._fake[n][i] = z[i];
                        summ2 += z[i] * 1;
                    }
                    else
                        this[n][i] = z[i];
            }

            this._fake.entBox.style.width = summ2 + "px";
            this._fake.objBox.style.width = summ2 + "px";
            var pa = this.globalBox.childNodes[1];
            pa.style.left = summ2 - (_isFF ? 0 : 0) + "px";
            if (this.ftr)
                this.ftr.style.left = summ2 - (_isFF ? 0 : 0) + "px";
            pa.style.width = this.globalBox.offsetWidth - summ2 + "px";

            this.setSizes();
            return true;
        }
        this._fake.onRSE = this.onRSE;
    }


    this.setCellTextStyleA = this.setCellTextStyle;
    this.setCellTextStyle = function (row_id, i, styleString) {
        if (i < ind) this._fake.setCellTextStyle(row_id, i, styleString);
        this.setCellTextStyleA(row_id, i, styleString);
    }
    this.setRowTextBoldA = this.setRowTextBold;
    this.setRowTextBold = function (row_id) {
        this.setRowTextBoldA(row_id);
        this._fake.setRowTextBold(row_id);
    }

    this.setRowColorA = this.setRowColor;
    this.setRowColor = function (row_id, color) {
        this.setRowColorA(row_id, color);
        this._fake.setRowColor(row_id, color);
    }

    this.setRowHiddenA = this.setRowHidden;
    this.setRowHidden = function (id, state) {
        this.setRowHiddenA(id, state);
        this._fake.setRowHidden(id, state);
    }

    this.setRowTextNormalA = this.setRowTextNormal;
    this.setRowTextNormal = function (row_id) {
        this.setRowTextNormalA(row_id);
        this._fake.setRowTextNormal(row_id);
    }


    this.getChangedRows = function (and_added) {
        var res = new Array();
        function test(row) {
            for (var j = 0; j < row.childNodes.length; j++)
                if (row.childNodes[j].wasChanged)
                    return res[res.length] = row.idd;
        }
        this.forEachRow(function (id) {
            var row = this.rowsAr[id];
            var frow = this._fake.rowsAr[id];
            if (row.tagName != "TR" || !frow || frow.tagName != "TR") return;
            if (and_added && row._added)
                res[res.length] = row.idd;
            else {
                if (!test(row)) test(frow);
            }
        });
        return res.join(this.delim);
    };
    this.setRowTextStyleA = this.setRowTextStyle;
    this.setRowTextStyle = function (row_id, styleString) {
        this.setRowTextStyleA(row_id, styleString);
        if (this._fake.rowsAr[row_id])
            this._fake.setRowTextStyle(row_id, styleString);
    }

    this.lockRowA = this.lockRow;
    this.lockRow = function (id, mode) { this.lockRowA(id, mode); this._fake.lockRow(id, mode); }

    this.getColWidth = function (i) {
        if (i < ind) return parseInt(this._fake.cellWidthPX[i]);
        else return parseInt(this.cellWidthPX[i]);
    };
    this.getColumnLabel = function (i) {
        return this._fake.getColumnLabel.apply(((i < ind) ? this._fake : this), arguments);
    };
    this.setColWidthA = this._fake.setColWidthA = this.setColWidth;
    this.setColWidth = function (i, value) {
        i = i * 1;
        if (i < ind) this._fake.setColWidthA(i, value);
        else this.setColWidthA(i, value);
        if ((i + 1) <= ind) this._fake._correctSplit(Math.min(this._fake.objBox.offsetWidth, this._fake.obj.offsetWidth));
    }
    this.adjustColumnSizeA = this.adjustColumnSize;
    this.setColumnLabelA = this.setColumnLabel;
    this.setColumnLabel = function (a, b, c, d) {
        var that = this;
        if (a < ind) that = this._fake;
        return this.setColumnLabelA.apply(that, [a, b, c, d]);
    }
    this.adjustColumnSize = function (aind, c) {
        if (aind < ind) {
            if (_isIE) this._fake.obj.style.tableLayout = "";
            this._fake.adjustColumnSize(aind, c);
            if (_isIE) this._fake.obj.style.tableLayout = "fixed";
            this._fake._correctSplit();
        }
        else return this.adjustColumnSizeA(aind, c);
    }

    var zname = "cells";
    this._bfs_cells = this[zname];
    this[zname] = function () {
        if (arguments[1] < ind) {
            return this._fake.cells.apply(this._fake, arguments);
        } else
            return this._bfs_cells.apply(this, arguments);
    }

    this._bfs_isColumnHidden = this.isColumnHidden;
    this.isColumnHidden = function () {
        if (parseInt(arguments[0]) < ind)
            return this._fake.isColumnHidden.apply(this._fake, arguments);
        else
            return this._bfs_isColumnHidden.apply(this, arguments);
    }


    this._bfs_setColumnHidden = this.setColumnHidden;
    this.setColumnHidden = function () {
        if (parseInt(arguments[0]) < ind) {
            this._fake.setColumnHidden.apply(this._fake, arguments);
            return this._fake._correctSplit();
        }
        else
            return this._bfs_setColumnHidden.apply(this, arguments);
    }

    var zname = "cells2";
    this._bfs_cells2 = this[zname];
    this[zname] = function () {
        if (arguments[1] < ind)
            return this._fake.cells2.apply(this._fake, arguments);
        else
            return this._bfs_cells2.apply(this, arguments);
    }

    var zname = "cells3";
    this._bfs_cells3 = this[zname];
    this[zname] = function (a, b) {
        if (arguments[1] < ind && this._fake.rowsAr[arguments[0].idd]) {
            //fall back for totally rowspanned row
            if (this._fake.rowsAr[a.idd] && this._fake.rowsAr[a.idd].childNodes.length == 0) return this._bfs_cells3.apply(this, arguments);
            arguments[0] = arguments[0].idd;
            return this._fake.cells.apply(this._fake, arguments);
        }
        else
            return this._bfs_cells3.apply(this, arguments);
    }

    var zname = "changeRowId";
    this._bfs_changeRowId = this[zname];
    this[zname] = function () {
        this._bfs_changeRowId.apply(this, arguments);
        if (this._fake.rowsAr[arguments[0]])
            this._fake.changeRowId.apply(this._fake, arguments);
    }
    this._fake.getRowById = function (id) {
        var row = this.rowsAr[id];
        if (!row && this._fake.rowsAr[id]) row = this._fake.getRowById(id);


        if (row) {
            if (row.tagName != "TR") {
                for (var i = 0; i < this.rowsBuffer.length; i++)
                    if (this.rowsBuffer[i] && this.rowsBuffer[i].idd == id)
                        return this.render_row(i);
                if (this._h2) return this.render_row(null, row.idd);
            }
            return row;
        }
        return null;
    }

    if (this.collapseKids) {
        //tree grid
        this._fake["_bfs_collapseKids"] = this.collapseKids;
        this._fake["collapseKids"] = function () {
            return this._fake["collapseKids"].apply(this._fake, [this._fake.rowsAr[arguments[0].idd]]);
        }

        this["_bfs_collapseKids"] = this.collapseKids;
        this["collapseKids"] = function () {
            var z = this["_bfs_collapseKids"].apply(this, arguments);
            this._fake._h2syncModel();
            if (!this._cssSP) this._fake._fixAlterCss();
        }


        this._fake["_bfs_expandKids"] = this.expandKids;
        this._fake["expandKids"] = function () {
            this._fake["expandKids"].apply(this._fake, [this._fake.rowsAr[arguments[0].idd]]);
            if (!this._cssSP) this._fake._fixAlterCss();
        }


        this["_bfs_expandAll"] = this.expandAll;
        this["expandAll"] = function () {
            this._bfs_expandAll();
            this._fake._h2syncModel();
            if (!this._cssSP) this._fake._fixAlterCss();
        }

        this["_bfs_collapseAll"] = this.collapseAll;
        this["collapseAll"] = function () {
            this._bfs_collapseAll();
            this._fake._h2syncModel();
            if (!this._cssSP) this._fake._fixAlterCss();
        }

        this["_bfs_expandKids"] = this.expandKids;
        this["expandKids"] = function () {
            var z = this["_bfs_expandKids"].apply(this, arguments);
            this._fake._h2syncModel();
            if (!this._cssSP) this._fake._fixAlterCss();
        }

        this._fake._h2syncModel = function () {
            if (this._fake.pagingOn) this._fake._renderSort();
            else this._renderSort();
        }
        this._updateTGRState = function (a) {
            return this._fake._updateTGRState(a);
        }
    }



    //split


    if (this._elmnh) {
        this._setRowHoverA = this._fake._setRowHoverA = this._setRowHover;
        this._unsetRowHoverA = this._fake._unsetRowHoverA = this._unsetRowHover;
        this._setRowHover = this._fake._setRowHover = function () {
            var that = this.grid;
            that._setRowHoverA.apply(this, arguments);
            var z = (_isIE ? event.srcElement : arguments[0].target);
            z = that._fake.rowsAr[that.getFirstParentOfType(z, 'TD').parentNode.idd];
            if (z) {
                that._fake._setRowHoverA.apply(that._fake.obj, [{ target: z.childNodes[0] }, arguments[1]]);
            }
        };
        this._unsetRowHover = this._fake._unsetRowHover = function () {
            if (arguments[1]) var that = this;
            else var that = this.grid;
            that._unsetRowHoverA.apply(this, arguments);
            that._fake._unsetRowHoverA.apply(that._fake.obj, arguments);
        };
        this._fake.enableRowsHover(true, this._hvrCss);
        this.enableRowsHover(false);
        this.enableRowsHover(true, this._fake._hvrCss);
    }

    this._updateTGRState = function (z) {
        if (!z.update || z.id == 0) return;
        if (this.rowsAr[z.id].imgTag)
            this.rowsAr[z.id].imgTag.src = this.iconTree + z.state + ".gif";
        if (this._fake.rowsAr[z.id] && this._fake.rowsAr[z.id].imgTag)
            this._fake.rowsAr[z.id].imgTag.src = this.iconTree + z.state + ".gif";
        z.update = false;
    }
    this.copy_row = function (row) {
        var x = row.cloneNode(true);
        for (var i = 0; i < x.childNodes.length; i++) {
            x.childNodes[i]._cellIndex = row.childNodes[i]._cellIndex;
        }
        x._skipInsert = row._skipInsert;
        x._locked = row._locked;
        var r_ind = ind;
        x._attrs = {};
        x._css = row._css;

        if (this._ecspn) {
            r_ind = 0;
            for (var i = 0; (r_ind < x.childNodes.length && i < ind) ; i += (x.childNodes[r_ind].colSpan || 1))
                r_ind++;
        }

        while (x.childNodes.length > r_ind)
            x.removeChild(x.childNodes[x.childNodes.length - 1]);
        var zm = r_ind;
        for (var i = 0; i < zm; i++) {

            if (this.dragAndDropOff)
                this.dragger.addDraggableItem(x.childNodes[i], this);
            x.childNodes[i].style.display = (this._fake._hrrar ? (this._fake._hrrar[i] ? "none" : "") : "");
            //x.childNodes[i]._cellIndex = i;
            //TODO - more universal solution
            x.childNodes[i].combo_value = arguments[0].childNodes[i].combo_value;
            x.childNodes[i]._clearCell = arguments[0].childNodes[i]._clearCell;
            x.childNodes[i]._cellType = arguments[0].childNodes[i]._cellType;
            x.childNodes[i]._brval = arguments[0].childNodes[i]._brval;
            x.childNodes[i].val = arguments[0].childNodes[i].val;
            x.childNodes[i]._combo = arguments[0].childNodes[i]._combo;
            x.childNodes[i]._disabled = arguments[0].childNodes[i]._disabled;
            x.childNodes[i]._attrs = arguments[0].childNodes[i]._attrs;
            x.childNodes[i].chstate = arguments[0].childNodes[i].chstate;
            if (row._attrs['style']) x.childNodes[i].style.cssText = row._attrs['style'] + ";" + x.childNodes[i].style.cssText;


            if (x.childNodes[i].colSpan > 1)
                x._childIndexes = arguments[0]._childIndexes;
        }

        if (this._h2 && this._treeC < ind) {
            var trow = this._h2.get[arguments[0].idd];
            x.imgTag = x.childNodes[this._treeC].childNodes[0].childNodes[trow.level];
            x.valTag = x.childNodes[this._treeC].childNodes[0].childNodes[trow.level + 2];
        }


        x.idd = row.idd;
        x.grid = this._fake;

        return x;
    }

    var zname = "_insertRowAt";
    this._bfs_insertRowAt = this[zname];
    this[zname] = function () {
        var r = this["_bfs_insertRowAt"].apply(this, arguments);
        arguments[0] = this.copy_row(arguments[0]);

        var r2 = this._fake["_insertRowAt"].apply(this._fake, arguments);
        if (r._fhd) {
            r2.parentNode.removeChild(r2);
            this._fake.rowsCol._dhx_removeAt(this._fake.rowsCol._dhx_find(r2));
            r._fhd = false;
        }

        return r;
    }
    /*
var quirks = (_isIE && document.compatMode=="BackCompat");

var isVScroll = this.parentGrid?false:(this.objBox.scrollHeight > this.objBox.offsetHeight);
var isHScroll = this.parentGrid?false:(this.objBox.scrollWidth > this.objBox.offsetWidth); 
var scrfix = _isFF?20:18;

var outerBorder=(this.entBox.offsetWidth-this.entBox.clientWidth)/2;
        
var gridWidth=this.entBox.clientWidth;
var gridHeight=this.entBox.clientHeight;
*/
    this._bfs_setSizes = this.setSizes;
    this.setSizes = function () {
        if (this._notresize) return;
        this._bfs_setSizes(this, arguments);

        this.sync_headers()
        if (this.sync_scroll() && this._ahgr) this.setSizes(); //if scrolls was removed - check once more to correct auto-height

        var height = this.dontSetSizes ? (this.entBox.offsetHeight + "px") : this.entBox.style.height;
        this._fake.entBox.style.height = height;

        this._fake.objBox.style.height = this.objBox.style.height;
        this._fake.hdrBox.style.height = this.hdrBox.style.height;

        this._fake.objBox.scrollTop = this.objBox.scrollTop;

        this._fake.setColumnSizes(this._fake.entBox.clientWidth);

        this.globalBox.style.width = parseInt(this.entBox.style.width) + parseInt(this._fake.entBox.style.width);
        if (!this.dontSetSizes)
            this.globalBox.style.height = height;

    }

    this.sync_scroll = this._fake.sync_scroll = function (end) {
        var old = this.objBox.style.overflowX;
        if (this.obj.offsetWidth <= this.objBox.offsetWidth) {
            if (!end) return this._fake.sync_scroll(true);
            this.objBox.style.overflowX = "hidden";
            this._fake.objBox.style.overflowX = "hidden";
        }
        else if (!dhtmlx.$customScroll) {
            this.objBox.style.overflowX = "scroll";
            this._fake.objBox.style.overflowX = "scroll";
        }
        return old != this.objBox.style.overflowX;
    }
    this.sync_headers = this._fake.sync_headers = function () {
        if (this.noHeader || (this._fake.hdr.scrollHeight == this.hdr.offsetHeight) || this.noHeaderResize) return;
        //	if (this.hdr.rows.length!=2){
        for (var i = 1; i < this.hdr.rows.length; i++) {
            var td = ind;
            while (!this.hdr.rows[i].childNodes[td]) td--;
            var ha = Math.min(this.hdr.rows[i].childNodes[td].scrollHeight + 2, this.hdr.rows[i].scrollHeight);
            var hb = this._fake.hdr.rows[i].scrollHeight;
            if (ha != hb)
                this._fake.hdr.rows[i].style.height = this.hdr.rows[i].style.height = Math.max(ha, hb) + "px";
            if (window._KHTMLrv) {
                var lindex = 0;
                while (this._fake._hrrar[lindex]) lindex++;
                this._fake.hdr.rows[i].childNodes[lindex].style.height = this.hdr.rows[i].childNodes[td].style.height = Math.max(ha, hb) + "px";
            }
        }
        this._fake.sync_headers;
        //	} else this._fake.hdr.style.height=this.hdr.offsetHeight+"px";
    }
    this._fake._bfs_setSizes = this._fake.setSizes;
    this._fake.setSizes = function () {
        if (this._fake._notresize) return;
        this._fake.setSizes();
    }

    var zname = "_doOnScroll";
    this._bfs__doOnScroll = this[zname];
    this[zname] = function () {
        this._bfs__doOnScroll.apply(this, arguments);
        this._fake.objBox.scrollTop = this.objBox.scrollTop;
        this._fake["_doOnScroll"].apply(this._fake, arguments);
    }

    var zname = "selectAll";
    this._bfs__selectAll = this[zname];
    this[zname] = function () {
        this._bfs__selectAll.apply(this, arguments);
        this._bfs__selectAll.apply(this._fake, arguments);
    }





    var zname = "doClick";
    this._bfs_doClick = this[zname];
    this[zname] = function () {
        this["_bfs_doClick"].apply(this, arguments);
        if (arguments[0].tagName == "TD") {
            var fl = (arguments[0]._cellIndex >= ind);
            if (!arguments[0].parentNode.idd) return;
            if (!fl)
                arguments[0].className = arguments[0].className.replace(/cellselected/g, "");
            //item selected but it left part not rendered yet
            if (!this._fake.rowsAr[arguments[0].parentNode.idd])
                this._fake.render_row(this.getRowIndex(arguments[0].parentNode.idd));
            arguments[0] = this._fake.cells(arguments[0].parentNode.idd, (fl ? 0 : arguments[0]._cellIndex)).cell;
            if (fl) this._fake.cell = null;
            this._fake["_bfs_doClick"].apply(this._fake, arguments);
            if (fl) this._fake.cell = this.cell;
            else this.cell = this._fake.cell;
            if (this._fake.onRowSelectTime) clearTimeout(this._fake.onRowSelectTime)
            if (fl) {
                arguments[0].className = arguments[0].className.replace(/cellselected/g, "");
                globalActiveDHTMLGridObject = this;
                this._fake.cell = this.cell;
            }
            else {
                this.objBox.scrollTop = this._fake.objBox.scrollTop;
            }
        }
    }
    this._fake._bfs_doClick = this._fake[zname];
    this._fake[zname] = function () {
        this["_bfs_doClick"].apply(this, arguments);
        if (arguments[0].tagName == "TD") {
            var fl = (arguments[0]._cellIndex < ind);
            if (!arguments[0].parentNode.idd) return;
            arguments[0] = this._fake._bfs_cells(arguments[0].parentNode.idd, (fl ? ind : arguments[0]._cellIndex)).cell;
            this._fake.cell = null;
            this._fake["_bfs_doClick"].apply(this._fake, arguments);
            this._fake.cell = this.cell;
            if (this._fake.onRowSelectTime) clearTimeout(this._fake.onRowSelectTime)
            if (fl) {
                arguments[0].className = arguments[0].className.replace(/cellselected/g, "");
                globalActiveDHTMLGridObject = this;
                this._fake.cell = this.cell;
                this._fake.objBox.scrollTop = this.objBox.scrollTop;
            }
        }
    }


    this.clearSelectionA = this.clearSelection;
    this.clearSelection = function (mode) {
        if (mode) this._fake.clearSelection();
        this.clearSelectionA();
    }


    this.moveRowUpA = this.moveRowUp;
    this.moveRowUp = function (row_id) {
        if (!this._h2)
            this._fake.moveRowUp(row_id);
        this.moveRowUpA(row_id);
        if (this._h2) this._fake._h2syncModel();
    }
    this.moveRowDownA = this.moveRowDown;
    this.moveRowDown = function (row_id) {
        if (!this._h2)
            this._fake.moveRowDown(row_id);
        this.moveRowDownA(row_id);
        if (this._h2) this._fake._h2syncModel();
    }



    this._fake.getUserData = function () { return this._fake.getUserData.apply(this._fake, arguments); }
    this._fake.setUserData = function () { return this._fake.setUserData.apply(this._fake, arguments); }

    this.getSortingStateA = this.getSortingState;
    this.getSortingState = function () {
        var z = this.getSortingStateA();
        if (z.length != 0) return z;
        return this._fake.getSortingState();
    }

    this.setSortImgStateA = this._fake.setSortImgStateA = this.setSortImgState;
    this.setSortImgState = function (a, b, c, d) {
        this.setSortImgStateA(a, b, c, d);
        if (b * 1 < ind) {
            this._fake.setSortImgStateA(a, b, c, d);
            this.setSortImgStateA(false);
        } else
            this._fake.setSortImgStateA(false);
    }


    this._fake.doColResizeA = this._fake.doColResize;
    this._fake.doColResize = function (ev, el, startW, x, tabW) {
        var a = -1;
        var z = 0;
        if (arguments[1]._cellIndex == (ind - 1)) {
            a = this._initalSplR + (ev.clientX - x);
            if (!this._initalSplF) this._initalSplF = arguments[3] + this.objBox.scrollWidth - this.objBox.offsetWidth;
            if (this.objBox.scrollWidth == this.objBox.offsetWidth && (this._fake.alter_split_resize || (ev.clientX - x) > 0)) {
                arguments[3] = (this._initalSplF || arguments[3]);
                z = this.doColResizeA.apply(this, arguments);
            }
            else
                z = this.doColResizeA.apply(this, arguments);
        }
        else {
            if (this.obj.offsetWidth < this.entBox.offsetWidth)
                a = this.obj.offsetWidth;
            z = this.doColResizeA.apply(this, arguments);
        }

        if (z !== false) {
            this._correctSplit(a);
            this.resized = this._fake.resized = 1;
        }
        return z;
    }

    this._fake.changeCursorState = function (ev) {
        var el = ev.target || ev.srcElement;
        if (el.tagName != "TD")
            el = this.getFirstParentOfType(el, "TD")
        if ((el.tagName == "TD") && (this._drsclmn) && (!this._drsclmn[el._cellIndex])) return;
        var check = (ev.layerX || 0) + (((!_isIE) && (ev.target.tagName == "DIV")) ? el.offsetLeft : 0);
        var pos = parseInt(this.getPosition(el, this.hdrBox));

        if (((el.offsetWidth - (ev.offsetX || (pos - check) * -1)) < (_isOpera ? 20 : 10)) || ((this.entBox.offsetWidth - (ev.offsetX ? (ev.offsetX + el.offsetLeft) : check) + this.objBox.scrollLeft - 0) < (_isOpera ? 20 : 10))) {
            el.style.cursor = "E-resize";
        } else
            el.style.cursor = "default";
        if (_isOpera) this.hdrBox.scrollLeft = this.objBox.scrollLeft;
    }

    this._fake.startColResizeA = this._fake.startColResize;
    this._fake.startColResize = function (ev) {
        var z = this.startColResizeA(ev);
        this._initalSplR = this.entBox.offsetWidth;
        this._initalSplF = null;
        if (this.entBox.onmousemove) {
            var m = this.entBox.parentNode;
            if (m._aggrid) return z;
            m._aggrid = m.grid; m.grid = this;
            this.entBox.parentNode.onmousemove = this.entBox.onmousemove;
            this.entBox.onmousemove = null;
        }
        return z;
    }

    this._fake.stopColResizeA = this._fake.stopColResize;
    this._fake.stopColResize = function (ev) {
        if (this.entBox.parentNode.onmousemove) {
            var m = this.entBox.parentNode; m.grid = m._aggrid; m._aggrid = null;
            this.entBox.onmousemove = this.entBox.parentNode.onmousemove;
            this.entBox.parentNode.onmousemove = null;
            if (this.obj.offsetWidth < this.entBox.offsetWidth)
                this._correctSplit(this.obj.offsetWidth);
        }
        return this.stopColResizeA(ev);
    }



    this.doKeyA = this.doKey;
    this._fake.doKeyA = this._fake.doKey;

    function inner_runner(index, rindex, master, ev) {
        var dir = ev.shiftKey ? -1 : 1;
        var end = ev.shiftKey ? -1 : master._cCount;
        var next = false;

        for (var i = index + dir; i != end; i += dir) {
            if (master.smartTabOrder) {
                next = master.cells2(rindex, i).isDisabled() ? false : i;
            } else
                next = i;

            if (next !== false) {
                var editmode = !master._key_events.k_other;
                master.selectCell(rindex, next, false, false, editmode, true);
                ev.cancelBubble = true;
                if (ev.preventDefault) ev.preventDefault();
                return true;
            }
        }
    }

    this._fake.doKey = this.doKey = function (ev) {
        if (!ev) return true;
        if (this._htkebl) return true;
        if ((ev.target || ev.srcElement).value !== window.undefined) {
            var zx = (ev.target || ev.srcElement);

            if ((!zx.parentNode) || (zx.parentNode.className.indexOf("editable") == -1))
                return true;
        }

        switch (ev.keyCode) {
            case 9:
                var master = this._realfake ? this._fake : this;
                if (!master.callEvent("onTab", [true])) return true;

                if (this.cell) {
                    var index = this.cell._cellIndex;

                    var rindex = master.getRowIndex(this.cell.parentNode.idd);
                    while (!inner_runner(index, rindex, master, ev)) {
                        rindex += (ev.shiftKey ? -1 : 1);
                        if (rindex < 0 || rindex >= master.rowsBuffer.length) return;
                        index = ev.shiftKey ? master._cCount : -1;
                    }
                    return;
                }
                break;
        }
        return this.doKeyA(ev);
    }


    this.editCellA = this.editCell;
    this.editCell = function () {
        if (this.cell && this.cell.parentNode.grid != this) return this._fake.editCell();
        return this.editCellA();
    }

    this.deleteRowA = this.deleteRow;
    this.deleteRow = function (row_id, node) {
        /*	if (!this._realfake)
                this._fake.loadedKidsHash=this.loadedKidsHash;*/

        if (this.deleteRowA(row_id, node) === false) return false;
        if (this._fake.rowsAr[row_id])
            this._fake.deleteRow(row_id);
    }

    this.clearAllA = this.clearAll;
    this.clearAll = function () {
        this.clearAllA();
        this._fake.clearAll();
    }
    this.editStopA = this.editStop;
    this.editStop = function (mode) {
        if (this._fake.editor)
            this._fake.editStop(mode);
        else
            this.editStopA(mode);
    };


    this.attachEvent("onAfterSorting", function (i, b, c) {
        if (i >= ind)
            this._fake.setSortImgState(false)
    });



    this._fake.sortField = function (a, b, c) {
        this._fake.sortField.call(this._fake, a, b, this._fake.hdr.rows[0].cells[a]);
        if (this.fldSort[a] != "na" && this._fake.fldSorted) {
            var mem = this._fake.getSortingState()[1];
            this._fake.setSortImgState(false);
            this.setSortImgState(true, arguments[0], mem)
        }
    }

    this.sortTreeRowsA = this.sortTreeRows;
    this._fake.sortTreeRowsA = this._fake.sortTreeRows;
    this.sortTreeRows = this._fake.sortTreeRows = function (col, type, order, ar) {
        if (this._realfake) return this._fake.sortTreeRows(col, type, order, ar)

        this.sortTreeRowsA(col, type, order, ar);
        this._fake._h2syncModel();

        this._fake.setSortImgStateA(false);
        this._fake.fldSorted = null;
    }

    /* SRND mode */
    this._fake._fillers = [];
    this._fake.rowsBuffer = this.rowsBuffer;
    this.attachEvent("onClearAll", function () {
        this._fake.rowsBuffer = this.rowsBuffer;
    })
    this._add_filler_s = this._add_filler;
    this._add_filler = function (a, b, c, e) {
        if (!this._fake._fillers) this._fake._fillers = [];
        if (this._realfake || !e) {
            var d;
            if (c && c.idd) d = this._fake.rowsAr[c.idd];
            else if (c && c.nextSibling) {
                d = {};
                d.nextSibling = this._fake.rowsAr[c.nextSibling.idd];
                d.parentNode = d.nextSibling.parentNode;
            } else if (this._fake._fillers.length) {
                d = this._fake._fillers[this._fake._fillers.length - 1][2];
            }
            this._fake._fillers.push(this._fake._add_filler(a, b, d));
        }

        return this._add_filler_s.apply(this, arguments);
    }
    this._add_from_buffer_s = this._add_from_buffer;
    this._add_from_buffer = function () {
        var res = this._add_from_buffer_s.apply(this, arguments);
        if (res != -1) {
            this._fake._add_from_buffer.apply(this._fake, arguments);
            if (this.multiLine) this._correctRowHeight(this.rowsBuffer[arguments[0]].idd);
        }
        return res;
    }
    this._fake.render_row = function (ind) {
        var row = this._fake.render_row(ind);

        if (row == -1) return -1;
        if (row) {
            return this.rowsAr[row.idd] = this.rowsAr[row.idd] || this._fake.copy_row(row);
        }
        return null;
    }
    this._reset_view_s = this._reset_view;
    this._reset_view = function () {
        this._fake._reset_view(true);
        this._fake._fillers = [];
        this._reset_view_s();
    }

    this.moveColumn_s = this.moveColumn;
    this.moveColumn = function (a, b) {
        if (b >= ind) return this.moveColumn_s(a, b);
    }


    this.attachEvent("onCellChanged", function (id, i, val) {
        if (this._split_event && i < ind && this.rowsAr[id]) {

            var cell = this._fake.rowsAr[id];
            if (!cell) return;
            var tcell;
            if (cell._childIndexes) {
                tcell = this.rowsAr[id].childNodes[cell._childIndexes[i]];
                cell = cell.childNodes[cell._childIndexes[i]];
            }
            else {
                tcell = this.rowsAr[id].childNodes[i];
                cell = cell.childNodes[i];
            }

            if (tcell._treeCell && tcell.firstChild.lastChild)
                tcell.firstChild.lastChild.innerHTML = val;
            else
                tcell.innerHTML = cell.innerHTML;
            tcell._clearCell = false;
            tcell.combo_value = cell.combo_value;
            tcell.chstate = cell.chstate;	//TODO - more universal solution
        }
    })





    this._fake.combos = this.combos;
    this.setSizes();
    if (this.rowsBuffer[0]) this._reset_view();
    this.attachEvent("onXLE", function () { this._fake._correctSplit() })
    this._fake._correctSplit();
}

dhtmlXGridObject.prototype._correctSplit = function (a) {
    a = a || (this.obj.scrollWidth - this.objBox.scrollLeft);
    a = Math.min(this.globalBox.offsetWidth, a);
    if (a > -1) {
        this.entBox.style.width = a + "px";
        this.objBox.style.width = a + "px";

        var outerBorder = (this.globalBox.offsetWidth - this.globalBox.clientWidth) / 2;
        this._fake.entBox.style.left = a + "px";
        this._fake.entBox.style.width = Math.max(0, this.globalBox.offsetWidth - a - (this.quirks ? 0 : 2) * outerBorder) + "px";
        if (this._fake.ftr)
            this._fake.ftr.parentNode.style.width = this._fake.entBox.style.width;
        if (_isIE) {
            var quirks = _isIE && !window.xmlHttpRequest;
            var outerBorder = (this.globalBox.offsetWidth - this.globalBox.clientWidth);
            this._fake.hdrBox.style.width = this._fake.objBox.style.width = Math.max(0, this.globalBox.offsetWidth - (quirks ? outerBorder : 0) - a) + "px";
        }
    }
}

dhtmlXGridObject.prototype._correctRowHeight = function (id, ind) {
    if (!this.rowsAr[id] || !this._fake.rowsAr[id]) return;

    var h = parseInt(this.rowsAr[id].style.height) || this.rowsAr[id].offsetHeight;
    var h2 = parseInt(this._fake.rowsAr[id].style.height) || this._fake.rowsAr[id].offsetHeight;
    var max = Math.max(h, h2) - (this.rowsAr[id].delta_fix || 0);
    if (!max) return;
    this.rowsAr[id].style.height = this._fake.rowsAr[id].style.height = Math.round(max) + "px";
    this.rowsAr[id].delta_fix = 0;//1;
    if (window._KHTMLrv) {
        var j = this._fake._cCount;
        var td;
        while (!td && j >= 0) {
            td = this.rowsAr[id].childNodes[j];
            j -= 1;
        }
        var td2 = this._fake.rowsAr[id].firstChild;
        if (td && td2) {
            //td.style.height = td2.style.height = max + "px";
        }
    }
}
//(c)dhtmlx ltd. www.dhtmlx.com

;
///<jscompress sourcefile="dhtmlxgrid_undo.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*	@desc: enable Undo/Redo functionality in grid
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.enableUndoRedo = function()
{ 
	var self = this;
	var func = function() {return self._onEditUndoRedo.apply(self,arguments);}
	this.attachEvent("onEditCell", func);
	var func2 = function(a,b,c) {return self._onEditUndoRedo.apply(self,[2,a,b,(c?1:0),(c?0:1)]);}		
	this.attachEvent("onCheckbox", func2);
	this._IsUndoRedoEnabled = true;
	this._UndoRedoData = [];
	this._UndoRedoPos = -1;
}
/**
*	@desc: disable Undo/Redo functionality in grid
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.disableUndoRedo = function()
{
	this._IsUndoRedoEnabled = false;
	this._UndoRedoData = [];
	this._UndoRedoPos = -1;
}

dhtmlXGridObject.prototype._onEditUndoRedo = function(stage, row_id, cell_index, new_value, old_value)
{
	if (this._IsUndoRedoEnabled && stage == 2 && old_value != new_value) {
	    if (this._UndoRedoPos !== -1 && this._UndoRedoPos != ( this._UndoRedoData.length-1 ) ) {
	        this._UndoRedoData = this._UndoRedoData.slice(0, this._UndoRedoPos+1);
	    } else if (this._UndoRedoPos === -1 && this._UndoRedoData.length > 0) {
	        this._UndoRedoData = [];
	    }

	    var obj = { old_value:old_value,
	                new_value:new_value,
	                row_id:row_id,
	                cell_index:cell_index
	    };
	    this._UndoRedoData.push(obj);
	    this._UndoRedoPos++;
	}
	return true;
}
/**
*	@desc: UnDo
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.doUndo = function()
{
	if (this._UndoRedoPos === -1)
		return false;
	var obj = this._UndoRedoData[this._UndoRedoPos--];
	var c=this.cells(obj.row_id, obj.cell_index);
	if (this.getColType(obj.cell_index)=="tree")
		c.setLabel(obj.old_value);
	else
		c.setValue(obj.old_value);

	this.callEvent("onUndo", [obj.row_id]);
}
/**
*	@desc: ReDo
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.doRedo = function()
{
	if (this._UndoRedoPos == this._UndoRedoData.length-1)
		return false;
	var obj = this._UndoRedoData[++this._UndoRedoPos];
	this.cells(obj.row_id, obj.cell_index).setValue(obj.new_value);

	this.callEvent("onUndo", [obj.row_id]);
}
/**
*	@desc: get length of available ReDo operations
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.getRedo = function()
{
	if (this._UndoRedoPos == this._UndoRedoData.length-1)
		return [];
	return this._UndoRedoData.slice(this._UndoRedoPos+1);
}
/**
*	@desc: get length of available UnDo operations
*	@type: public
*	@edition: Professional
*/
dhtmlXGridObject.prototype.getUndo = function()
{
	if (this._UndoRedoPos == -1)
		return [];
	return this._UndoRedoData.slice(0, this._UndoRedoPos+1);
}
//(c)dhtmlx ltd. www.dhtmlx.com
;
///<jscompress sourcefile="dhtmlxgrid_json.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype._process_json_row=function(r, data){
	r._attrs=data;
	for (var j = 0; j < r.childNodes.length; j++)r.childNodes[j]._attrs={
	};
	if (data.userdata)
		for (var a in data.userdata)
			this.setUserData(r.idd,a,data.userdata[a]);
			
	data = this._c_order?this._swapColumns(data.data):data.data;

	for (var i=0; i<data.length; i++)
		if (typeof data[i] == "object" && data[i] != null){
			r.childNodes[i]._attrs=data[i];
			if (data[i].type) r.childNodes[i]._cellType=data[i].type;
			data[i]=data[i].value;
		}
	this._fillRow(r, data);
	return r;
};


dhtmlXGridObject.prototype._process_js_row=function(r, data){
	r._attrs=data;
	for (var j = 0; j < r.childNodes.length; j++)
		r.childNodes[j]._attrs={};

	if (data.userdata)
		for (var a in data.userdata)
			this.setUserData(r.idd,a,data.userdata[a]);
			
	var arr = [];
	for (var i=0; i<this.columnIds.length; i++){
		arr[i] = data[this.columnIds[i]];
		if (typeof arr[i] == "object" && arr[i] != null){
			r.childNodes[i]._attrs=arr[i];
			if (arr[i].type) r.childNodes[i]._cellType=arr[i].type;
			arr[i]=arr[i].value;
		}
		if (!arr[i] && arr[i]!==0)
			arr[i]="";
	}

	this._fillRow(r, arr);
	return r;
};

dhtmlXGridObject.prototype.updateFromJSON = function(url, insert_new, del_missed, afterCall){
	if (typeof insert_new == "undefined")
		insert_new=true;
	this._refresh_mode=[
		true,
		insert_new,
		del_missed
	];
	
	this.load(url,afterCall,"json");
},
dhtmlXGridObject.prototype._refreshFromJSON = function(data){
		if (this._f_rowsBuffer) this.filterBy(0,"");
		reset = false;
		if (window.eXcell_tree){
			eXcell_tree.prototype.setValueX=eXcell_tree.prototype.setValue;
			eXcell_tree.prototype.setValue=function(content){
				var r=this.grid._h2.get[this.cell.parentNode.idd]
				if (r && this.cell.parentNode.valTag){
					this.setLabel(content);
				} else
					this.setValueX(content);
			};
		}
	
		var tree = this.cellType._dhx_find("tree");
		var pid = data.parent||0;
	
		var del = {
		};
	
		if (this._refresh_mode[2]){
			if (tree != -1)
				this._h2.forEachChild(pid, function(obj){
					del[obj.id]=true;
				}, this);
			else
				this.forEachRow(function(id){
					del[id]=true;
				});
		}
	
		var rows = data.rows;
	
		for (var i = 0; i < rows.length; i++){
			var row = rows[i];
			var id = row.id;
			del[id]=false;
	
			if (this.rowsAr[id] && this.rowsAr[id].tagName!="TR"){
				if (this._h2)
					this._h2.get[id].buff.data=row;
				else
					this.rowsBuffer[this.getRowIndex(id)].data=row;
				this.rowsAr[id]=row;
			} else if (this.rowsAr[id]){
					this._process_json_row(this.rowsAr[id], row, -1);
					this._postRowProcessing(this.rowsAr[id],true)
				} else if (this._refresh_mode[1]){
					var dadd={
						idd: id,
						data: row,
						_parser: this._process_json_row,
						_locator: this._get_json_data
					};
					
					var render_index = this.rowsBuffer.length;
					if (this._refresh_mode[1]=="top"){
						this.rowsBuffer.unshift(dadd);
						render_index = 0;
					} else
						this.rowsBuffer.push(dadd);
						
					if (this._h2){ 
						reset=true;
						(this._h2.add(id,pid)).buff=this.rowsBuffer[this.rowsBuffer.length-1];
					}
						
					this.rowsAr[id]=row;
					row=this.render_row(render_index);
					this._insertRowAt(row,render_index?-1:0)
				}
		}
				
		if (this._refresh_mode[2])
			for (id in del){
				if (del[id]&&this.rowsAr[id])
					this.deleteRow(id);
			}
	
		this._refresh_mode=null;
		if (window.eXcell_tree)
			eXcell_tree.prototype.setValue=eXcell_tree.prototype.setValueX;
			
		if (reset) this._renderSort();
		if (this._f_rowsBuffer) {
			this._f_rowsBuffer = null;
			this.filterByAll();
		}
	},

	dhtmlXGridObject.prototype._process_js=function(data){
		return this._process_json(data, "js");
	},

	dhtmlXGridObject.prototype._parseHeadJson=function(json){
		if (!json.head || !json.head.length) return;

		var headCol = json.head;
		var settings = json.settings;

		var awidthmet = "setInitWidths";
		var split = false;

		if (settings && settings.colwidth == "%")
			awidthmet="setInitWidthsP";
	
		if (settings && settings.splitat == "%")
			split=settings.splitat;

		//drop existing grid here, to prevent loss of initialization parameters
	    if (this.hdr.rows.length > 0) 
	    	this.clearAll(true);

		var sets = [
			[],
			[],
			[],
			[],
			[],
			[],
			[]
		];
	
		var attrs = ["value", "width", "type", "align", "sort","hidden", "id"];
		var calls = ["", awidthmet, "setColTypes", "setColAlign", "setColSorting", 
					"", "setColumnIds"];
	
		for (var i = 0; i < headCol.length; i++)
			for (var j = 0; j < attrs.length; j++)
				sets[j].push(headCol[i][attrs[j]]);

		this.setHeader(sets[0]);
		for (var i = 0; i < calls.length; i++)
			if (calls[i])
				this[calls[i]](sets[i].join(this.delim));
	
		for (var i = 0; i < headCol.length; i++){
			var options = headCol[i].options
			if (headCol[i].options)
				if (this.cellType[i] == "clist"){
					this.registerCList(i, options);
				} else {
					var combo = this.getCombo(i);
					for (var j = 0; j < options.length; j++)
						combo.put(options[j].id, options[j].value);
				}
		}
			
	
		this.init();

        var param=sets[5].join(this.delim);
        //preserving state of hidden columns, if not specified directly
		if (this.setColHidden && param.replace(/,/g,"")!="")
			this.setColHidden(param);

		if ((split)&&(this.splitAt))
			this.splitAt(split);
	};

	dhtmlXGridObject.prototype._process_json=function(data, mode){
		this._parsing=true;
		try {
			var data = data.responseText || data;
			if (typeof data == "string"){
				eval("dhtmlx.temp="+data+";");
				data = dhtmlx.temp;
			}
		} catch(e){
				dhx4.callEvent("onLoadXMLError", ["Incorrect JSON",
					(data.xmlDoc||data),
					this
				]);
				data = {rows:[]};
		}
			
		if (this._refresh_mode) return this._refreshFromJSON(data);				

		if (data.head)
			this._parseHeadJson(data);

		var cr = parseInt(data.pos||0);
		var total = parseInt(data.total_count||0);
		
		var reset = false;
		if (total){
			if (!this.rowsBuffer[total-1]){
				if (this.rowsBuffer.length)
					reset=true;
			this.rowsBuffer[total-1]=null;
			} 
			if (total<this.rowsBuffer.length){
				this.rowsBuffer.splice(total, this.rowsBuffer.length - total);
				reset = true;
			}
		}
			
		var userdata = mode === "js" ? data.userdata : data;
		for (var key in userdata){
			if (mode === "js" || key!="rows")
				this.setUserData("",key, userdata[key]);
		}

		if (mode == "js" && data.collections){
			for (var colkey in data.collections){
				var index = this.getColIndexById(colkey);
				var colrecs = data.collections[colkey];
				if (index !== window.undefined){
					if (this.cellType[index] == "clist"){
						colplaindata=[];
						for (var j=0; j<colrecs.length; j++)
							colplaindata.push(colrecs[j].label);
						this.registerCList(index, colplaindata);
					} else {
						var combo = this.getCombo(index);
						for (var j = 0; j < colrecs.length; j++)
							combo.put(colrecs[j].value, colrecs[j].label);
					}
				}
			}
		}
		
		if (this.isTreeGrid())
			return this._process_tree_json(data, null, null, mode);
			
		if (mode == "js"){
			if (data.data)
				data = data.data;
			for (var i = 0; i < data.length; i++){
				if (this.rowsBuffer[i+cr])
					continue;

				var row = data[i];
				var id  = row.id||(i+1);
				this.rowsBuffer[i+cr]={
					idd: id,
					data: row,
					_parser: this._process_js_row,
					_locator: this._get_js_data
				};

				this.rowsAr[id]=data[i];
			}
		} else {
			for (var i = 0; i < data.rows.length; i++){
				if (this.rowsBuffer[i+cr])
					continue;
				var id = data.rows[i].id;
				this.rowsBuffer[i+cr]={
					idd: id,
					data: data.rows[i],
					_parser: this._process_json_row,
					_locator: this._get_json_data
				};
	
				this.rowsAr[id]=data.rows[i];
			}
		}
		
		this.callEvent("onDataReady", []);
		if (reset && this._srnd){
			var h = this.objBox.scrollTop;
			this._reset_view();
			this.objBox.scrollTop = h;
		} else {
			this.render_dataset();
		}
		
		this._parsing=false;
}

dhtmlXGridObject.prototype._get_json_data=function(data, ind){
	var obj = data.data[ind];
	if (typeof obj == "object"){
		return obj?obj.value:"";
	} else
		return obj;
};

dhtmlXGridObject.prototype._process_tree_json=function(data,top,pid,mode){
	this._parsing=true;
	var main=false;
	if (!top){
		this.render_row=this.render_row_tree;
		main=true;
		top=data;
		pid=top.parent||0;
		if (pid=="0") pid=0;
		if (!this._h2)	 this._h2=this._createHierarchy();
		if (this._fake) this._fake._h2=this._h2;
	} 
	
	if (mode == "js"){
		if (top.data && !pid) 
			data = top.data;
		if (top.rows)
			top = top.rows;
		for (var i = 0; i < top.length; i++){
			var id = top[i].id;
			var row=this._h2.add(id,pid);
			row.buff={ idd:id, data:top[i], _parser: this._process_js_row, _locator:this._get_js_data };

			if (top[i].open)
			    row.state="minus";
				
			this.rowsAr[id]=row.buff;
		    this._process_tree_json(top[i],top[i],id,mode);
		}
	} else {
		if (top.rows) {
			for (var i = 0; i < top.rows.length; i++){
					var id = top.rows[i].id;
					var row=this._h2.add(id,pid);
					row.buff={ idd:id, data:top.rows[i], _parser: this._process_json_row, _locator:this._get_json_data };
					if (top.rows[i].open)
					    row.state="minus";
					
					this.rowsAr[id]=row.buff;
				    this._process_tree_json(top.rows[i],top.rows[i],id,mode);
			}
		}
	}
		
	if (main){ 
		
		if (pid!=0) this._h2.change(pid,"state","minus")
		this._updateTGRState(this._h2.get[pid]);
		this._h2_to_buff();
		
		this.callEvent("onDataReady", []);
		if (pid!=0 && (this._srnd || this.pagingOn))
			this._renderSort();
		else
			this.render_dataset();
		
		
	
		if (this._slowParse===false){
			this.forEachRow(function(id){
				this.render_row_tree(0,id)
			})
		}
		this._parsing=false;

		if (pid!=0 && !this._srnd)
		   this.callEvent("onOpenEnd",[pid,1]);	
	}
}	

;
///<jscompress sourcefile="dhtmlxgrid_keymap.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype.enableAccessKeyMap = function(){
/*
	keymap like MS Access offers
*/
this._select_ifpossible=function(){
	if (this.editor && this.editor.obj && this.editor.obj.select) this.editor.obj.select();
};
this._key_events={
			//ctrl-enter
			k13_1_0:function(){
				this.editStop();
			},
			//shift-enter
			k13_0_1:function(){
				this._key_events.k9_0_1.call(this);
			},
			//enter
			k13_0_0:function(){
				this._key_events.k9_0_0.call(this);
            },
            //tab
            k9_0_0:function(){
					this.editStop();
				if (!this.callEvent("onTab",[true])) return true;
				var z=this._getNextCell(null,1);
				if (z) {
					if (this.pagingOn) this.showRow(z.parentNode.idd);
					this.selectCell(z.parentNode,z._cellIndex,(this.row!=z.parentNode),false,true);
					this._still_active=true;
				}
				this._select_ifpossible();
            },
            //shift-tab
			k9_0_1:function(){
				this.editStop();
				if (!this.callEvent("onTab",[false])) return true;
				var z=this._getNextCell(null,-1);
				if (z) {
					this.selectCell(z.parentNode,z._cellIndex,(this.row!=z.parentNode),false,true);
					this._still_active=true;
				}
				this._select_ifpossible();
            },
            //f2 key
            k113_0_0:function(){
            	if (this._f2kE) this.editCell();
            },
            //space
            k32_0_0:function(){
            	var c=this.cells4(this.cell);
            	if (!c.changeState || (c.changeState()===false)) return false;
            },
            //escape
            k27_0_0:function(){
            	this.editStop(true);
            },
            //pageUp
            k33_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage-1);
            	else this.scrollPage(-1);            		
	        },
	        //pageDown
			k34_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage+1);
            	else this.scrollPage(1);
	        },
	        //left
			k37_0_0:function(){
				if (this.editor) return false;
            	if(this.isTreeGrid())
            		this.collapseKids(this.row);
            	else this._key_events.k9_0_1.call(this);
	        },
	        //right
			k39_0_0:function(){
				if (this.editor) return false;
				if(!this.editor && this.isTreeGrid())
            		this.expandKids(this.row);
            	else this._key_events.k9_0_0.call(this);
            },
            //ctrl left
			k37_1_0:function(){
				if (this.editor) return false;
				this.selectCell(this.row,0,false,false,true);
				this._select_ifpossible();
	        },
	        //ctrl right
			k39_1_0:function(){
				if (this.editor) return false;
				this.selectCell(this.row,this._cCount-1,false,false,true);
				this._select_ifpossible();
            },
            //ctrl up
			k38_1_0:function(){
			
				this.selectCell(this.rowsCol[0],this.cell._cellIndex,true,false,true);
				this._select_ifpossible();
	        },
	        //ctrl down
			k40_1_0:function(){
				this.selectCell(this.rowsCol[this.rowsCol.length-1],this.cell._cellIndex,true,false,true);
				this._select_ifpossible();
            },
            //shift up
			k38_0_1:function(){
				var rowInd = this.getRowIndex(this.row.idd);
				var nrow=this._nextRow(rowInd,-1);
				if (!nrow || nrow._sRow || nrow._rLoad) return false;
                this.selectCell(nrow,this.cell._cellIndex,true,false,true);
				this._select_ifpossible();
	        },
	        //shift down
			k40_0_1:function(){
				var rowInd = this.getRowIndex(this.row.idd);
				var nrow=this._nextRow(rowInd,1);
				if (!nrow || nrow._sRow || nrow._rLoad) return false;
                this.selectCell(nrow,this.cell._cellIndex,true,false,true);
                this._select_ifpossible();
            },   
            //ctrl shift up  
			k38_1_1:function(){
				var rowInd = this.getRowIndex(this.row.idd);
				for (var i = rowInd; i >= 0; i--){
					this.selectCell(this.rowsCol[i],this.cell._cellIndex,true,false,true);
				}
	        },
	        //ctrl shift down
			k40_1_1:function(){
				var rowInd = this.getRowIndex(this.row.idd);
				for (var i = rowInd+1; i <this.rowsCol.length; i++){
					this.selectCell(this.rowsCol[i],this.cell._cellIndex,true,false,true);
				}
            },    
            //down               
			k40_0_0:function(){
				if (this.editor && this.editor.combo)
					this.editor.shiftNext();
				else{
					if (!this.row.idd) return;
					var rowInd = rowInd=this.getRowIndex(this.row.idd)+1;
					if (this.rowsBuffer[rowInd]){
						var nrow=this._nextRow(rowInd-1,1);
						if (this.pagingOn && nrow) this.showRow(nrow.idd);
						this._Opera_stop=0;
                        this.selectCell(nrow,this.cell._cellIndex,true,false,true);
                    }
                    else {
                    	if (!this.callEvent("onLastRow", [])) return false;
                    	this._key_events.k34_0_0.apply(this,[]);
                	}
				}
				this._still_active=true;								
            },
            //home
            k36_0_0:function(){ 
            	return this._key_events.k37_1_0.call(this);
            },
            //end
            k35_0_0:function(){ 
            	return this._key_events.k39_1_0.call(this);
            },            
            //ctrl-home
            k36_1_0:function(){ 
            	if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[0],0,true,false,true);
				this._select_ifpossible();
            },
            //ctrl-end
            k35_1_0:function(){ 
            	if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[this.rowsCol.length-1],this._cCount-1,true,false,true);
				this._select_ifpossible();
            },  
            //padeup
            k33_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage-1);
            	else this.scrollPage(-1);            		
	        },
	        //pagedown
			k34_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage+1);
            	else this.scrollPage(1);
	        },  
	        //up                                
			k38_0_0:function(){
				if (this.editor && this.editor.combo)
					this.editor.shiftPrev();
				else{
				
					if (!this.row.idd) return;
					var rowInd = rowInd=this.getRowIndex(this.row.idd)+1;
					if (rowInd!=-1){
						var nrow=this._nextRow(rowInd-1,-1);
                        this._Opera_stop=0;
                        if (this.pagingOn && nrow) this.showRow(nrow.idd);
                        this.selectCell(nrow,this.cell._cellIndex,true,false,true);
                    }
					else this._key_events.k33_0_0.apply(this,[]);
				}
				this._still_active=true;
            }
		};

};
dhtmlXGridObject.prototype.enableExcelKeyMap = function(){
/*
	keymap like MS Excel offers
*/
this._key_events={
			k13_1_0:function(){
				this.editStop();
			},
			k13_0_1:function(){
				this.editStop();
				this._key_events.k38_0_0.call(this);
			},
			k13_0_0:function(){
				this.editStop();
				this.callEvent("onEnter",[(this.row?this.row.idd:null),(this.cell?this.cell._cellIndex:null)]);
				this._still_active=true;
				this._key_events.k40_0_0.call(this);
            },
            k9_0_0:function(){
				this.editStop();
				if (!this.callEvent("onTab",[true])) return true;
				if (this.cell && (this.cell._cellIndex+1)>=this._cCount) return;
				var z=this._getNextCell(null,1);
				if (z && this.row==z.parentNode){
					this.selectCell(z.parentNode,z._cellIndex,true);
					this._still_active=true;
				}
			},
			k9_0_1:function(){
				this.editStop();
				if (!this.callEvent("onTab",[false])) return true;
				if (this.cell && (this.cell._cellIndex==0)) return;
				var z=this._getNextCell(null,-1);
				if (z && this.row==z.parentNode) {
					this.selectCell(z.parentNode,z._cellIndex,true);
					this._still_active=true;
				}
            },
            k113_0_0:function(){
            	if (this._f2kE) this.editCell();
            },
            k32_0_0:function(){
            	var c=this.cells4(this.cell);
            	if (!c.changeState || (c.changeState()===false)) return false;
            },
            k27_0_0:function(){
            	this.editStop(true);
            	this._still_active=true;
            },
            k33_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage-1);
            	else this.scrollPage(-1);            		
	        },
			k34_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage+1);
            	else this.scrollPage(1);
	        },
			k37_0_0:function(){
				if (this.editor) return false;
            	if(this.isTreeGrid())
            		this.collapseKids(this.row);
            	else this._key_events.k9_0_1.call(this);
	        },
			k39_0_0:function(){
				if (this.editor) return false;
				if(!this.editor && this.isTreeGrid())
            		this.expandKids(this.row);
            	else this._key_events.k9_0_0.call(this);
            },
			k37_1_0:function(){
				if (this.editor) return false;
				this.selectCell(this.row,0,true);
	        },
			k39_1_0:function(){
				if (this.editor) return false;
				this.selectCell(this.row,this._cCount-1,true);
            }, 
			k38_1_0:function(){
				if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[0],this.cell._cellIndex,true);
	        },
			k40_1_0:function(){
				if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[this.rowsCol.length-1],this.cell._cellIndex,true);
            },
			k38_0_1:function(){
				if (this.editor || !this.rowsCol.length) return false;
				var rowInd = this.row.rowIndex;
				var nrow=this._nextRow(rowInd-1,-1);
				if (!nrow || nrow._sRow || nrow._rLoad) return false;
                this.selectCell(nrow,this.cell._cellIndex,true,true);
	        },
			k40_0_1:function(){
				if (this.editor || !this.rowsCol.length) return false;
				var rowInd = this.row.rowIndex;
				var nrow=this._nextRow(rowInd-1,1);
				if (!nrow || nrow._sRow || nrow._rLoad) return false;
                this.selectCell(nrow,this.cell._cellIndex,true,true);
            },     
			k38_1_1:function(){
				if (this.editor || !this.rowsCol.length) return false;
				var rowInd = this.row.rowIndex;
				for (var i = rowInd - 1; i >= 0; i--){
					this.selectCell(this.rowsCol[i],this.cell._cellIndex,true,true);
				}
	        },
			k40_1_1:function(){
				if (this.editor || !this.rowsCol.length) return false;
				var rowInd = this.row.rowIndex;
				for (var i = rowInd; i <this.rowsCol.length; i++){
					this.selectCell(this.rowsCol[i],this.cell._cellIndex,true,true);
				}
            },                   
			k40_0_0:function(){
				var master = this._realfake?this._fake:this;
				if (this.editor && this.editor.combo)
					this.editor.shiftNext();
				else{
					if (this.editor) return false;
					var rowInd = Math.max((master._r_select||0),this.getRowIndex(this.row.idd));
					var row = this._nextRow(rowInd, 1);

					if (row){
						master._r_select=null;
						this.selectCell(row, this.cell._cellIndex, true);
						if (master.pagingOn) master.showRow(row.idd);
					} else {
                    	if (!this.callEvent("onLastRow", [])) return false;
                    	this._key_events.k34_0_0.apply(this,[]);
                	}
				}
            },
            k36_0_0:function(){ //home
            	return this._key_events.k37_1_0.call(this);
            },
            k35_0_0:function(){ //ctrl-home
            	return this._key_events.k39_1_0.call(this);
            },            
            k36_1_0:function(){ //home
            	if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[0],0,true);
            },
            k35_1_0:function(){ //ctrl-end
            	if (this.editor || !this.rowsCol.length) return false;
				this.selectCell(this.rowsCol[this.rowsCol.length-1],this._cCount-1,true);
            },  
            k33_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage-1);
            	else this.scrollPage(-1);            		
	        },
			k34_0_0:function(){
            	if(this.pagingOn)
            		this.changePage(this.currentPage+1);
            	else this.scrollPage(1);
	        },                                  
			k38_0_0:function(){	
				var master = this._realfake?this._fake:this;
				if (this.editor && this.editor.combo)
					this.editor.shiftPrev();
				else{
					if (this.editor) return false;
					if (!this.row.idd) return;
					var rowInd = this.getRowIndex(this.row.idd)+1;
					if (rowInd != -1 && (!this.pagingOn || (rowInd!=1))){
						var nrow = this._nextRow(rowInd-1, -1);
						this.selectCell(nrow, this.cell._cellIndex, true);
						if (master.pagingOn && nrow) master.showRow(nrow.idd);
					} else {
						this._key_events.k33_0_0.apply(this,[]);
					}
				}
            },
            k_other:function(ev){ 
            	if (this.editor) return false;
            	if (!ev.ctrlKey && ev.keyCode>=40 && (ev.keyCode < 91 || (ev.keyCode >95 && ev.keyCode <111) || ev.keyCode > 187))
            		if (this.cell){
            			var c=this.cells4(this.cell);
            			if (c.isDisabled()) return false;
            			var t=c.getValue();
            			if (c.editable!==false) c.setValue("");
            			this.editCell();
            			if (this.editor) {
            				this.editor.val=t;
            				if (this.editor.obj && this.editor.obj.select)
            					this.editor.obj.select();
        				}
            			else c.setValue(t);
            		}
            }
		};

};
;
///<jscompress sourcefile="dhtmlxgrid_nxml.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: load grid from CSV file
*   @param: path - path to file
*   @param: afterCall - function which will be called after xml loading
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.loadCSVFile = function(path,afterCall){
    this.load(path,afterCall,"csv")
}

/**
*   @desc: enable mode, where ID for rows loaded from CSV autogenerated
*   @param: mode - true/false
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableCSVAutoID = function(mode){
   this._csvAID=dhx4.s2b(mode);
}
/**
*   @desc: enable recognizing first row in CSV as header
*   @param: mode - true/false
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableCSVHeader = function(mode){
   this._csvHdr=dhx4.s2b(mode);
}

/**
*   @desc: load grid from CSV string
*   @param: str - delimer used in CSV operations, comma by default ( only single char delimeters allowed )
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.setCSVDelimiter = function(str){
   this.csv.cell=str;
}
dhtmlXGridObject.prototype._csvAID = true;

/**
*   @desc: load grid from CSV string
*   @param: str - CSV  string
*   @type: public
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.loadCSVString = function(str){
   this.parse(str,"csv")
}

/**
*   @desc: serialize to CSV string
*   @type: public
*	@param: text only - force serialization of text values ( skip HTML elements ) )
*     @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.serializeToCSV = function(textmode){ 
    this.editStop()
    if (this._mathSerialization)
         this._agetm="getMathValue";
    else if (this._strictText || textmode)
    	this._agetm="getTitle";
    else this._agetm="getValue";

	var out=[];
	if (this._csvHdr){
		for (var j=1; j < this.hdr.rows.length; j++) {
			var a=[]; 
			for (var i=0; i<this._cCount; i++)
				if ((!this._srClmn)||(this._srClmn[i]))
					a.push(this.getColumnLabel(i,j-1));
    		out.push(this.csvParser.str(a,this.csv.cell, this.csv.row));
    	}
    }

    
    //rows collection
    var i=0;
    var leni=this.rowsBuffer.length;

   for(i; i<leni; i++){
		var temp=this._serializeRowToCVS(null,i)      	
		if (temp!="") out.push(temp);
  }

   return this.csvParser.block(out,this.csv.row);
}

/**
*   @desc: serialize TR to CSV
*   @param: r - TR or xml node (row)
*   @retruns: string - CSV representation of passed row
*   @type: private
*/
dhtmlXGridObject.prototype._serializeRowToCVS = function(r,i,start,end, clear){
    var out = new Array();
    if (!r){
	    r=this.render_row(i)
	    if (this._fake && !this._fake.rowsAr[r.idd]) this._fake.render_row(i);
	}
    

    if (!this._csvAID)
       out[out.length]=r.idd;

	start = start||0;
	
    end = end||this._cCount;
    //cells
    var changeFl=false;
    var ind=start;
    //rowspans before block selection
    while (r.childNodes[r._childIndexes ? r._childIndexes[start] : start]._cellIndex > ind && start) start--;
    
    
    for(var jj=start;ind<end;jj++){
        if (!r.childNodes[r._childIndexes ? r._childIndexes[jj] : jj]) break;
        var real_ind = r.childNodes[r._childIndexes ? r._childIndexes[jj] : jj]._cellIndex;
        if (((!this._srClmn)||(this._srClmn[real_ind])) && (!this._serialize_visible || !this._hrrar[real_ind])){
            var cvx = r.childNodes[r._childIndexes ? r._childIndexes[jj] : jj];

            var zx=this.cells(r.idd,real_ind);
            while (ind!=real_ind){
            	ind++;
            	out.push("")
            	if (ind>=end) break;
            }
            if (ind >= end) break;
            jj = ind;
            ind++;
        /*	if (zx.getText)
        		zxVal=zx.getText();
        	else*/
            if (zx.cell) {
                zxVal = zx[this._agetm]();
                if (clear) {
                    zx.setValue("");
                }
            }
            else zxVal = "";


		if ((this._chAttr)&&(zx.wasChanged()))
			changeFl=true;

            out[out.length]=((zxVal===null)?"":zxVal)
//#colspan:20092006{
            if ( this._ecspn && cvx.colSpan && cvx.colSpan >1 ){
                cvx=cvx.colSpan-1;
                for (var u=0; u<cvx; u++){
	                out[out.length] = "";
	                ind++;
                }
            }
//#}

 } else ind++;
    }
     if ((this._onlChAttr)&&(!changeFl)) return "";
      return this.csvParser.str(out,this.csv.cell, this.csv.row);
}

dhtmlXGridObject.prototype.toClipBoard=function(val){
    if (window.clipboardData)
      window.clipboardData.setData("Text",val);
   else
      (new Clipboard()).copy(val);

}
dhtmlXGridObject.prototype.fromClipBoard=function(){
   if (window.clipboardData)
      return window.clipboardData.getData("Text");
   else
      return (new Clipboard()).paste();
}

/**
*   @desc: copy value of cell to clipboard
*   @type: public
*   @param: rowId - id of row (optional, use selected row by default)
*   @param: cellInd - column index(optional, use selected cell by default)
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.cellToClipboard = function(rowId,cellInd){
    if ((!rowId)||(!cellInd && cellInd !== 0)){
       if (!this.selectedRows[0]) return;
       rowId=this.selectedRows[0].idd;
       cellInd=this.cell._cellIndex;
   }
   
   	var ed=this.cells(rowId,cellInd);
    this.toClipBoard(((ed.getLabel?ed.getLabel():ed.getValue())||"").toString());
}

/**
*   @desc: set value of cell from clipboard
*   @type: public
*     @edition: Professional
*   @param: rowId - id of row (optional, use selected row by default)
*   @param: cellInd - column index(optional, use selected cell by default)
*   @topic: 5
*/
dhtmlXGridObject.prototype.updateCellFromClipboard = function(rowId,cellInd){
    if ((!rowId)||(!cellInd)){
       if (!this.selectedRows[0]) return;
       rowId=this.selectedRows[0].idd;
       cellInd=this.cell._cellIndex;
   }
   	var ed=this.cells(rowId,cellInd);
    ed[ed.setImage?"setLabel":"setValue"](this.fromClipBoard());
}

/**
*   @desc: copy value of row to clipboard
*   @type: public
*     @edition: Professional
*   @param: rowId - id of row (optional, use selected row by default)
*   @topic: 5
*/
dhtmlXGridObject.prototype.rowToClipboard = function(rowId){
	var out="";
	if (this._mathSerialization)
		this._agetm="getMathValue";
	else if (this._strictText)
		this._agetm="getTitle";
	else 
		this._agetm="getValue";
    
  this._serialize_visible = !this._fake;

	if (rowId)
		out=this._serializeRowToCVS(this.getRowById(rowId));
	else {
   		var data = [];
		for (var i=0; i<this.selectedRows.length; i++){
			data[data.length] = this._serializeRowToCVS(this.selectedRows[i]);
			out = this.csvParser.block(data, this.csv.row);
		}
	}

  this._serialize_visible = false;
	this.toClipBoard(out);
}

/**
*   @desc: set value of row from clipboard
*   @type: public
*     @edition: Professional
*   @param: rowId - id of row (optional, use selected row by default)
*   @topic: 5
*/
dhtmlXGridObject.prototype.updateRowFromClipboard = function(rowId){
	var csv=this.fromClipBoard();
	if (!csv) return;
	if (rowId)
		var r=this.getRowById(rowId);
	else
		var r=this.selectedRows[0];
	if (!r) return;
	
	var parser = this.csvParser;
	csv=parser.unblock(csv,this.csv.cell, this.csv.row)[0];
	if (!this._csvAID) csv.splice(0,1);
	for (var i=0; i<csv.length; i++){
		var ed=this.cells3(r,i);
		ed[ed.setImage?"setLabel":"setValue"](csv[i]);
	}
}

dhtmlXGridObject.prototype.csvParser={
	block:function(data,row){
		return data.join(row);
	},
	unblock:function(str,cell,row){
		var data = (str||"").split(row);	
		for (var i=0; i < data.length; i++)
			data[i]=(data[i]||"").split(cell);
    var last = data.length-1;
    if (data[last].length == 1 && data[last][0]=="")
      data.splice(last,1);
		return data;
	},
	str:function(data,cell,row){
		return data.join(cell);
	}
};
dhtmlXGridObject.prototype.csvExtParser={
	_quote:RegExp('"',"g"),
	_quote_esc:RegExp("\"\"","g"),
	block:function(data,row){
		return data.join(row);
	},
	unblock:function(str,cell,row){ 
		var out = [[]];
		var ind = 0;
		if (!str) return out;

		var quote_start = /^[ ]*"/;
		var quote_end   = /"[ ]*$/;
		var row_exp  = new RegExp(".*"+row+".*$");
		
		var data = str.split(cell);
		for (var i=0; i<data.length; i++){
			if (data[i].match(quote_start)){
				var buff = data[i].replace(quote_start, "");
				while (!data[i].match(quote_end)) {
					i++;
					buff+=data[i];
				}
				out[ind].push(buff.replace(quote_end, "").replace(this._quote_esc,'"'));
			} else if (data[i].match(row_exp)){
        var row_pos = data[i].indexOf(row);
				out[ind].push(data[i].substr(0, row_pos));
				ind++;
				out[ind] = [];
				data[i]=data[i].substr(row_pos+1); i--;
			} else {
				if (data[i] || i!=data.length-1)
					out[ind].push(data[i]);
			}
		}

    var last = out.length-1;
    if (last>0 && !out[last].length)
      out.splice(last,1);
    
		return out;	
	},
	str:function(data,cell,row){
		for (var i=0; i < data.length; i++)
			data[i] = '"'+data[i].replace(this._quote, "\"\"")+'"';
		return data.join(cell);
	}
};

/**
*   @desc: add new row from clipboard
*   @type: public
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.addRowFromClipboard = function(){
   var csv=this.fromClipBoard();
   if (!csv) return;
   var z=this.csvParser.unblock(csv, this.csv.cell, this.csv.row);
   for (var i=0; i<z.length; i++)
      if (z[i]){
         csv=z[i];
         if (!csv.length) continue;
         if (this._csvAID)
         	this.addRow(this.getRowsNum()+2,csv);
         else{
         	if (this.rowsAr[csv[0]])
         		csv[0]=this.uid();
         	this.addRow(csv[0],csv.slice(1));
     		}
      }
}

/**
*   @desc: copy grid in CSV to clipboard
*   @type: public
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.gridToClipboard = function(){
   this.toClipBoard(this.serializeToCSV());
}

/**
*   @desc: init grid from CSV stored in clipboard
*   @type: public
*     @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.gridFromClipboard = function(){
   var csv=this.fromClipBoard();
   if (!csv) return;
   this.loadCSVString(csv);
}

/**
*   @desc: get grid as XML - php required
*   @param: path - path to server side code,optional
*   @type: private
*   @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.getXLS = function(path){
   if (!this.xslform){
      this.xslform=document.createElement("FORM");
      this.xslform.action=(path||"")+"xls.php";
      this.xslform.method="post";
      this.xslform.target=(_isIE?"_blank":"");
      document.body.appendChild(this.xslform);
      var i1=document.createElement("INPUT");
      i1.type="hidden";
      i1.name="csv";
      this.xslform.appendChild(i1);
      var i2=document.createElement("INPUT");
      i2.type="hidden";
      i2.name="csv_header";
      this.xslform.appendChild(i2);
   }
      var cvs = this.serializeToCSV();
      this.xslform.childNodes[0].value = cvs;
        var cvs_header = [];
        var l = this._cCount;
        for (var i=0; i<l; i++) {
         cvs_header.push(this.getHeaderCol(i));
        }
      cvs_header = cvs_header.join(',');
      this.xslform.childNodes[1].value = cvs_header;
       this.xslform.submit();
}

/**
*   @desc: generate print friendly view
*   @type: public
*   @edition: Professional
*   @topic: 5
*/
dhtmlXGridObject.prototype.printView = function(before,after){
	  var html="<style>TD { font-family:Arial; text-align:center; padding-left:2px;padding-right:2px; } \n td.filter input, td.filter select { display:none; }	\n  </style>";
	  var st_hr=null;
	  if (this._fake) {
	  	st_hr=[].concat(this._hrrar); 
	  	for (var i=0; i<this._fake._cCount; i++)
	  		this._hrrar[i]=null;
	  }
     var port = document.location.port;
     var hostname = document.location.hostname;
	   html+="<base  href='"+(document.location.protocol+"//"+hostname+(port?(":"+port):"")+document.location.pathname)+"'></base>";
	   if (!this.parentGrid) html+=(before||"");
       html += '<table width="100%" border="2px" cellpadding="0" cellspacing="0">';
       var row_length = Math.max(this.rowsBuffer.length,this.rowsCol.length); //paging and smartrendering
       var col_length = this._cCount;
      var width = this._printWidth();
      html += '<tr class="header_row_1">';
        for (var i=0; i<col_length; i++){
        	if (this._hrrar && this._hrrar[i]) continue;
         var hcell=this.hdr.rows[1].cells[this.hdr.rows[1]._childIndexes?this.hdr.rows[1]._childIndexes[parseInt(i)]:i];
         var colspan=(hcell.colSpan||1);
         var rowspan=(hcell.rowSpan||1);
         
         for (var j=1; j<colspan; j++)
         	width[i]+=width[j];
    	html += '<td rowspan="'+rowspan+'" width="'+width[i]+'%" style="background-color:lightgrey;" colspan="'+colspan+'">'+this.getHeaderCol(i)+'</td>';
         i+=colspan-1;
        }
      html += '</tr>';

	  	for (var i=2; i<this.hdr.rows.length; i++){
	  		if (_isIE){
	  			html+="<tr style='background-color:lightgrey' class='header_row_"+i+"'>";
	  			var cells=this.hdr.rows[i].childNodes;
	  			for (var j=0; j < cells.length; j++) 
	  				if (!this._hrrar || !this._hrrar[cells[j]._cellIndex]){
	  					html+=cells[j].outerHTML;
	  				}
	  			html+="</tr>";
	  			}
	  		else
				html+="<tr class='header_row_"+i+"' style='background-color:lightgrey'>"+(this._fake?this._fake.hdr.rows[i].innerHTML:"")+this.hdr.rows[i].innerHTML+"</tr>";
		}

       for (var i=0; i<row_length; i++) {
         html += '<tr>';
           if (this.rowsCol[i] && this.rowsCol[i]._cntr){
           	  html+=this.rowsCol[i].innerHTML.replace(/<img[^>]*>/gi,"")+'</tr>';
           	  continue;
           }
           if (this.rowsCol[i] && this.rowsCol[i].style.display=="none") continue;
           
           var row_id
           if (this.rowsCol[i])
           		row_id=this.rowsCol[i].idd;
           	else if (this.rowsBuffer[i]) 
           		row_id=this.rowsBuffer[i].idd;
           	else continue; //dyn loading 
           	
           for (var j=0; j<col_length; j++) {
           	   if (this._hrrar && this._hrrar[j]) continue;
           	   if(this.rowsAr[row_id] && this.rowsAr[row_id].tagName=="TR") {
	           	   var c=this.cells(row_id, j);
	           	   if (c._setState) var value="";
	           	   else if (c.getContent) value = c.getContent();
	           	   else if (c.getImage || c.combo) var value=c.cell.innerHTML;
	           	   else var value = c.getValue();
           	   } else 
	           	  var value=this._get_cell_value(this.rowsBuffer[i],j);
               var color = this.columnColor[j]?'background-color:'+this.columnColor[j]+';':'';
            var align = this.cellAlign[j]?'text-align:'+this.cellAlign[j]+';':'';
            var cspan =  c.getAttribute("colspan");
            html += '<td style="'+color+align+'" '+(cspan?'colSpan="'+cspan+'"':'')+'>'+(value===""?"&nbsp;":value)+'</td>';
            if (cspan) j+=cspan-1;
           }
         html += '</tr>';
         if (this.rowsCol[i] && this.rowsCol[i]._expanded){
         	 var sub=this.cells4(this.rowsCol[i]._expanded.ctrl);
         	 if (sub.getSubGrid)
         	 	html += '<tr><td colspan="'+col_length+'">'+sub.getSubGrid().printView()+'</td></tr>';
         	 else
         	 	html += '<tr><td colspan="'+col_length+'">'+this.rowsCol[i]._expanded.innerHTML+'</td></tr>';
         }
       }

	   if (this.ftr)
	  	for (var i=1; i<this.ftr.childNodes[0].rows.length; i++)
	  		html+="<tr style='background-color:lightgrey'>"+((this._fake)?this._fake.ftr.childNodes[0].rows[i].innerHTML:"")+this.ftr.childNodes[0].rows[i].innerHTML+"</tr>";
        		

      html += '</table>';
      if (this.parentGrid) return html;
      
      html+=(after||"");
      var d = window.open('', '_blank');
      d.document.write(html);
      d.document.write("<script>window.onerror=function(){return true;}</script>");
      d.document.close();
      if (this._fake) {
	  	this._hrrar=st_hr;
	  }
}
dhtmlXGridObject.prototype._printWidth=function(){
      var width = [];
      var total_width = 0;
      for (var i=0; i<this._cCount; i++) {
         var w = this.getColWidth(i);
         width.push(w);
         total_width += w;
      }
      var percent_width = [];
      var total_percent_width = 0;
      for (var i=0; i<width.length; i++) {
         var p = Math.floor((width[i]/total_width)*100);
         total_percent_width += p;
            percent_width.push(p);
      }
      percent_width[percent_width.length-1] += 100-total_percent_width;
      return percent_width;
   }
;
///<jscompress sourcefile="dhtmlxgrid_ext.js" />
/*
filename：dhtmlxgrid_ext_tb.js
creater：刘志伟
date created：2018.10.16
description：扩展grid对象
date modified：2018.10.16
modifier：刘志伟
version：
others：
copyright：Copyright @1999-2016, hwkj, All Rights Reserved
*/
/**
* 简单网格添加样式
*/
dhtmlXGridObject.prototype._build_master_row = function(){
    var t = document.createElement("DIV");
    var html = ["<table><tr>"];
	
    if (this.cellStyles && this.cellStyles.length > 0) {
        for (var i = 0; i < this._cCount; i++) html.push("<td " + (this.cellStyles[i] ? ("style='" + this.cellStyles[i] + "'") : "") + "></td>");
    }
    else {
        for (var i = 0; i < this._cCount; i++) html.push("<td></td>");
    }
    
    html.push("</tr></table>");
    t.innerHTML=html.join("");
    this._master_row=t.firstChild.rows[0];
},

dhtmlXGridObject.prototype.setColStyles = function (valueStr) {
    if (typeof valueStr === 'string') {
        this.cellStyles = dhtmlxArray(valueStr.split(this.delim));
    }
    else {
        this.cellStyles = valueStr;
    }
}

dhtmlXGridObject.prototype.setColClassName = function (classNameStr) {
    if (typeof classNameStr === 'string') {
        this.cellClassNames = dhtmlxArray(classNameStr.split(this.delim));
    }
    else {
        this.cellClassNames = classNameStr;
    }
}

dhtmlXGridObject.prototype.setColExtypeStore = function (vmdstores) {
    this.cellExtypeStores = vmdstores;
}

dhtmlXGridObject.prototype.setDataRowHeight = function (rowHeight) {
    this.dataRowHeight = rowHeight;
    if (rowHeight || rowHeight == 0) {
        //this._srnd = rowHeight;
        this._srdh = parseInt(rowHeight);
    }
}

/**
* 重写创建表头的方法，添加表头单元格的类
*/
dhtmlXGridObject.prototype.attachHeader = function (values, style, _type, _class, _attrs) {
    if (typeof (values) == "string")
        values = this._eSplit(values);

    if (typeof (style) == "string")
        style = style.split(this.delim);
    _type = _type || "_aHead";

    if (this.hdr.rows.length) {
        if (values)
            this._createHRow([
					values,
					style,
                    _class,
                    _attrs
            ], this[(_type == "_aHead") ? "hdr" : "ftr"]);

        else if (this[_type])
            for (var i = 0; i < this[_type].length; i++) this.attachHeader.apply(this, this[_type][i]);
    } else {
        if (!this[_type])
            this[_type] = new Array();
        this[_type][this[_type].length] = [
            values,
            style,
            _type,
            _class,
            _attrs
        ];
    }
};

/**
* 重写创建表头的方法，添加表头单元格的类
*/
dhtmlXGridObject.prototype._createHRow = function(data, parent){
    if (!parent){
        if (this.entBox.style.position!="absolute")
            this.entBox.style.position="relative";
        var z = document.createElement("DIV");
        z.className="c_ftr".substr(2);
        this.entBox.appendChild(z);
        var t = document.createElement("TABLE");
        t.cellPadding=t.cellSpacing=0;
			
        if (!_isIE || _isIE == 8){
            t.width="100%";
            t.style.paddingRight="20px";
        }
        t.style.marginRight="20px";
        t.style.tableLayout="fixed";
			
        z.appendChild(t);
        t.appendChild(document.createElement("TBODY"));
        this.ftr=parent=t;
			
        var hdrRow = t.insertRow(0);
        var thl = ((this.hdrLabels.length <= 1) ? data[0].length : this.hdrLabels.length);
			
        for (var i = 0; i < thl; i++){
            hdrRow.appendChild(document.createElement("TH"));
            hdrRow.childNodes[i]._cellIndex=i;
        }
			
        if (_isIE && _isIE<8)
            hdrRow.style.position="absolute";
        else
            hdrRow.style.height='auto';
    }
    var st1 = data[1];
    var cls1 = data[2]; //liuzhiwei 20181214 单元格类名
    var attrs = data[3]; //liuzhiwei 20190219 单元格属性
    var z = document.createElement("TR");
    parent.rows[0].parentNode.appendChild(z);
    if (!isNaN(window.judgedRowNum)) {
        judgedRowNum++;
    }
    for (var i = 0; i < data[0].length; i++){
        if (data[0][i] == "#cspan"){
            var pz = z.cells[z.cells.length-1];
            pz.colSpan=(pz.colSpan||1)+1;
            //表头定制
            if ( parent.parentNode.parentNode.parentNode.id == "subGridHeaderTop") {
                if (data[0][i] == "#cspan" && !(data[0][i - 1] == "#cspan")) {
                    this.setCheckBox(z, st1, i, "#master_checkbox");
                }
            }
            continue;
        }
			
        if ((data[0][i] == "#rspan")&&(parent.rows.length > 1)){
            var pind = parent.rows.length-2;
            var found = false;
            var pz = null;
            //修复同时合并行合并列的单元格显示的问题
            var rowspanJump = false;
				
            while (!found){
                var pz = parent.rows[pind];
					
                for (var j = 0; j < pz.cells.length; j++) {
                    if (pz.cells[j]._cellIndexS == i) {
                        found = j + 1;
                        break;
                    }
                    if ((i >= pz.cells[j]._cellIndexS) && (i < (pz.cells[j]._cellIndexS + pz.cells[j].colSpan))) {
                        rowspanJump = true;
                        break;
                    }
                }
                if (rowspanJump) {
                    break;
                }
                pind--;
            }
            if (rowspanJump) {
                continue;
            }
            pz=pz.cells[found-1];
            pz.rowSpan=(pz.rowSpan||1)+1;
            continue;
            //            data[0][i]="";
        }
			
        var w = document.createElement("TD");
        w._cellIndex=w._cellIndexS=i;
        if (this._hrrar && this._hrrar[i] && !_isIE)
            w.style.display='none';
			
        if (typeof data[0][i] == "object")
            w.appendChild(data[0][i]);
        else {
            if (this.forceDivInHeader)
                w.innerHTML="<div class='hdrcell'>"+(data[0][i]||"&nbsp;")+"</div>";
            else
                w.innerHTML=(data[0][i]||"&nbsp;");
				
            if ((data[0][i]||"").indexOf("#") != -1){
                var t = data[0][i].match(/(^|{)#([^}]+)(}|$)/);
					
                if (t){
                    var tn = "_in_header_"+t[2];
						
                    if (this[tn])
                        this[tn]((this.forceDivInHeader ? w.firstChild : w), i, data[0][i].split(t[0]));
                }
            }
        }
        if (st1)
            w.style.cssText = st1[i];
        //添加类名解析
        if (cls1 && cls1[i]) {
            w.className = cls1[i];
        }
        if (attrs && attrs[i]) {
            w._attrs = attrs[i];
            w.firstChild._attrs = attrs[i];

            var originCell = this.hwReport.getOriginCellById(attrs[i].sid);
            if (originCell && ["vmdlink", "vmdch"].indexOf(originCell.getType()) != -1) {
                w.grid = this;
                w.firstChild._cellType = originCell.getType();
                var aeditor = this.cells4(w.firstChild);
                w.idd = aeditor;

                if (aeditor) aeditor.setValue(data[0][i]);
            }
        }
        z.appendChild(w);
    }
    var self = parent;
		
    if (_isKHTML){
        if (parent._kTimer)
            window.clearTimeout(parent._kTimer);
        parent._kTimer=window.setTimeout(function(){
            parent.rows[1].style.display='none';
            window.setTimeout(function(){
                parent.rows[1].style.display='';
            }, 1);
        }, 500);
    }
};

dhtmlXGridObject.prototype._get_custom_json_data = function (data, ind) {
    return data.data[ind];
},

dhtmlXGridObject.prototype._process_custom_json = function (data) {
    this._parsing = true;
    try {
        var data = data.responseText || data;
        if (typeof data == "string") {
            eval("dhtmlx.temp=" + data + ";");
            data = dhtmlx.temp;
        }
    } catch (e) {
        dhx4.callEvent("onLoadXMLError", ["Incorrect JSON",
            (data.xmlDoc || data),
            this
        ]);
        data = { rows: [] };
    }

    var cr = parseInt(data.pos || 0);
    var total = parseInt(data.rowcount || 0);

    var reset = false;
    if (total) {
        if (!this.rowsBuffer[total - 1]) {
            if (this.rowsBuffer.length)
                reset = true;
            this.rowsBuffer[total - 1] = null;
        }
        if (total < this.rowsBuffer.length) {
            this.rowsBuffer.splice(total, this.rowsBuffer.length - total);
            reset = true;
        }
    }

    var userdata = data;
    for (var key in userdata) {
        if (key != "datas")
            this.setUserData("", key, userdata[key]);
    }

    if (data.datas) {
        for (var i = 0; i < data.datas.length; i++) {
            if (this.rowsBuffer[i + cr])
                continue;
            var id = data.datas[i].id || (i + cr + "");
            this.rowsBuffer[i + cr] = {
                idd: id,
                data: data.datas[i],
                _parser: this._process_custom_json_row,
                _locator: this._get_custom_json_data
            };

            this.rowsAr[id] = data.datas[i];
        }
    }
    this.rowSpanFlags = []; //
    this.callEvent("onDataReady", []);
    if (reset && this._srnd) {
        var h = this.objBox.scrollTop;
        this._reset_view();
        this.objBox.scrollTop = h;
    } else {
        this.render_dataset(cr);
    }

    this._parsing = false;
}

dhtmlXGridObject.prototype._process_custom_json_row = function (r, data, index) {
    for (var j = 0; j < r.childNodes.length; j++) r.childNodes[j]._attrs = {
    };
    if (data.userdata)
        for (var a in data.userdata)
            this.setUserData(r.idd, a, data.userdata[a]);

    var abbrkeys = this.getUserData(null, "abbrkeys");
    var reAbbrkeys;
    if(abbrkeys){
        reAbbrkeys = {};
        for (var key in abbrkeys) {
            if (abbrkeys.hasOwnProperty(key)) {
                reAbbrkeys[abbrkeys[key]] = key;
            }
        }
    }

    var vdata = [];
    var isFirstColSet = false; //一行数据中只有一列是第一列
    var isLastColSet = false; //一行数据中只有一列是最后一列
    var colspan = 1;
    var rowspan = 1;
    var hasSetFirstRow = this._hasSetFirstRow;
    for (var i = 0; i < data.length; i+=colspan) {
        if (typeof data[i] == "object" && data[i] != null) {
            if (reAbbrkeys) {
                for (var key in data[i]) {
                    if (data[i].hasOwnProperty(key) && reAbbrkeys[key]) {
                        data[i][reAbbrkeys[key]] = data[i][key];
                    }
                }
            }
            if (this.hwReport.fixedColCount
                && i < this.hwReport.fixedColCount
                && (i + parseInt(data[i].colspan)) > this.hwReport.fixedColCount
                && data[i + 1]) {
                data[i + 1].colspan = i + parseInt(data[i].colspan) - this.hwReport.fixedColCount;
                data[i + 1].data = data[i].data;
                data[i + 1].sid = data[i].sid;
                data[i].colspan = this.hwReport.fixedColCount - i;
            }
            colspan = parseInt(data[i].colspan || 1);
            rowspan = parseInt(data[i].rowspan || 1);
            var sid = data[i][(reAbbrkeys && reAbbrkeys["sid"]) || "sid"];
            var originCell = this.hwReport.getOriginCellById(sid);
            var align = originCell && this.hwReport.aligns.get(originCell.align);
            var isEscape = (align && align.escapelabel == "1") ? true : false;

            if (originCell) {
                var ignores = [];
                if (index > 0 && hasSetFirstRow) {
                    ignores.push("firstRow");
                }
                else if (originCell.rptRow.height > 0) {
                    this._hasSetFirstRow = true;
                }

                if (originCell.isFirstCol && !isFirstColSet) isFirstColSet = true;
                else ignores.push("firstCol");

                if (originCell.isLastCol && !isLastColSet) isLastColSet = true;
                else ignores.push("lastCol");

                data[i]['class'] = (data[i]['class'] || "") + " " + originCell.getClassName(ignores);
                data[i].style = (data[i].style || "") + ";" + originCell.getCSS(['border', 'font', 'align']);
                data[i].type = originCell.getType();
                data[i].disabled = originCell.getIsDisabled();
            }

            //将扩展出来的单元格放到原始单元格中
            if (originCell && (!this.rowSpanFlags[i] || this.rowSpanFlags[i].rowspan == 1)) {
                originCell.childs.push(r.idd + "_" + r.childNodes[i]._cellIndex);
                if(data[i].highlight){
                    this.hwReport.highlightCells = this.hwReport.highlightCells || [];
                    this.hwReport.highlightCells.push(r.idd + "_" + r.childNodes[i]._cellIndex);
                }
                for (var j = 0; j < colspan; j++) {
                    this.rowSpanFlags[i + j] = {
                        rowId: r.idd,
                        rowspan: rowspan
                    };
                }
            }
            else if (this.rowSpanFlags[i]) {
                this.rowSpanFlags[i].rowspan--;
            }
            else {
                this.rowSpanFlags[i] = {
                    rowId: r.idd,
                    rowspan: 1
                };
            }

            for (var j = 0; j < colspan; j++) {
                data[i + j]._cRowId = this.rowSpanFlags[i + j].rowId; //对应dom的行id
                data[i + j]._cIndex = i; //对应dom的列索引
                data[i + j]._sRowId = r.idd;//原始的行id
                data[i + j]._sIndex = i + j;//原始的列索引
                r.childNodes[i + j]._attrs = data[i + j];
                if (data[i + j].type) r.childNodes[i + j]._cellType = data[i + j].type;
                else r.childNodes[i + j]._cellType = "ro";
                r.childNodes[i + j]._disabled = data[i + j].disabled;
                vdata[i + j] = data[i + j].data ? this.hwReport.replaceToHtmltag(data[i + j].data, isEscape) : "";
            }
        }
        else {
            r.childNodes[i]._attrs = this.hwReport.getPatchCell(index, i);
            r.childNodes[i]._cellType = "ro";
            colspan = 1;
        }
    }

    r._attrs = data;
    this._fillRow(r, vdata);
    return r;
}

dhtmlXGridObject.prototype._process_store_row = function (row, data) {
    var result = [];
    for (var i = 0; i < this.columnIds.length; i++)
        result[i] = data[this.columnIds[i]];
    for (var j = 0; j < row.childNodes.length; j++) {
        var attrs = (this.cellAttrs && this.cellAttrs[j]) || {};
        row.childNodes[j].className = (this.cellClassNames && this.cellClassNames[j]) || "";
        row.childNodes[j]._attrs = attrs;
        var originCell = this.hwReport && this.hwReport.getOriginCellById(attrs.sid);
        row.childNodes[j]._disabled = originCell && originCell.getIsDisabled();
    }

    row._attrs = data;
    this._fillRow(row, result);
};

dhtmlXGridObject.prototype.render_row = function(ind){
    if (!this.rowsBuffer[ind])
        return -1;
		
    if (this.rowsBuffer[ind]._parser){
        var r = this.rowsBuffer[ind];
        if (this.rowsAr[r.idd] && this.rowsAr[r.idd].tagName=="TR")
            return this.rowsBuffer[ind]=this.rowsAr[r.idd];
        var row = this._prepareRow(r.idd);
        this.rowsBuffer[ind]=row;
        this.rowsAr[r.idd]=row;
			
        r._parser.call(this, row, r.data, ind);
        this._postRowProcessing(row);
        return row;
    }
    return this.rowsBuffer[ind];
},

dhtmlXGridObject.prototype.setColAttrs = function (attrs) {
    this.cellAttrs = [];
    for (var i = 0; i < attrs.length; i++)
        this.cellAttrs[i] = attrs[i];
}

dhtmlXGridObject.prototype.setColStyles = function (valueStr) {
    if (typeof valueStr === 'string') {
        this.cellStyles = dhtmlxArray(valueStr.split(this.delim));
    }
    else {
        this.cellStyles = valueStr;
    }
}

dhtmlXGridObject.prototype.setColClassName = function (classNameStr) {
    if (typeof classNameStr === 'string') {
        this.cellClassNames = dhtmlxArray(classNameStr.split(this.delim));
    }
    else {
        this.cellClassNames = classNameStr;
    }
}

dhtmlXGridObject.prototype.setColExtypeStore = function (vmdstores) {
    this.cellExtypeStores = vmdstores;
}

dhtmlXGridObject.prototype.setDataRowHeight = function (rowHeight) {
    this.dataRowHeight = rowHeight;
    if (rowHeight || rowHeight == 0) {
        //this._srnd = rowHeight;
        this._srdh = parseInt(rowHeight);
    }
}

dhtmlXGridObject.prototype.addRowCustom = function (newId, datas, ind) {
    if (ind == -1 || typeof ind == "undefined")
        ind = this.rowsBuffer.length;

    this.rowsBuffer._dhx_insertAt(ind, {
        idd: newId,
        data: datas,
        _parser: this._process_custom_json_row,
        _locator: this._get_custom_json_data
    });
    var row = this.render_row(ind);
    var r = this._insertRowAt(row, ind);

    if (!this.dragContext)
        this.callEvent("onRowAdded", [newId]);

    if (this.pagingOn)
        this.changePage(this.currentPage)

    if (this._srnd)
        this._update_srnd_view();

    r._added = true;

    if (this._srnd && !this._fillers)
        this._fillers = [];

    if (this._ahgr)
        this.setSizes();
    this.callEvent("onGridReconstructed", []);
    return r;
},

dhtmlXGridObject.prototype.isCheckedAll = function (col_ind) {
    for (var a in this.rowsAr) {
        if (this.rowsAr[a] && this.rowsAr[a].idd) {
            var cell = this.cells(this.rowsAr[a].idd, col_ind);
            if (cell.changeState && cell.getValue() == 0) {
                return false;
            }
        }
    }
    return true;
},

dhtmlXGridObject.prototype.setDisabled = function (fl) {
    this._disabled = fl == false ? false : true;
}

dhtmlXGridObject.prototype.getRowHeight = function (ind) {
    if (!this.rowsAr[ind])
        return -1;
    return this.rowsAr[ind].offsetHeight;
},

dhtmlXGridObject.prototype.getRowsHeight = function () {
    var heights = [];
    var hdrrows = this.noHeader ? [] : this.hdr.rows;
    for (var i = 1; i < hdrrows.length; i++) {
        heights.push(hdrrows[i].offsetHeight);
    }
    for (var i = 0; i < this.rowsBuffer.length; i++) {
        var r = this.rowsBuffer[i];
        if (this.rowsAr[r.idd] && this.rowsAr[r.idd].tagName == "TR") {
            heights.push(this.rowsAr[r.idd].parentNode ? this.rowsAr[r.idd].offsetHeight : this._srdh);
        }
        else {
            heights.push(this._srdh);
        }
    }
    return heights;
},

dhtmlXGridObject.prototype.getColsWidth = function () {
    if (this._fake) {
        return this._fake.cellWidthPX.concat(this.cellWidthPX.slice(this._fake.cellWidthPX.length)).map(function (value) { return parseInt(value) });
    }
    return this.cellWidthPX.map(function (value) {return parseInt(value) });
},


dhtmlXGridObject.prototype.forEachCellsA = function (rId, custom_code) {
    var t_cspan = 1;
    for (var j = 0; j < this._cCount; j += t_cspan) {
        var cellObj = this.cells(rId, j);
        t_cspan = cellObj.cell.colSpan;
        custom_code.apply(this, [cellObj, rId, j]);
    }
};
/**
* 循环遍历所有单元格
*/
dhtmlXGridObject.prototype.forEachCellsB = function (custom_code, startRowIndex, endRowIndex) {
    var temp_rspan = [];
    startRowIndex = startRowIndex || 0;
    endRowIndex = endRowIndex || this.rowsBuffer.length;
    for (var i = startRowIndex; i < endRowIndex; i++) {
        var t_cspan = 1;
        for (var j = 0; j < this._cCount; j += t_cspan) {
            if (temp_rspan[j]) {
                temp_rspan[j] = temp_rspan[j] - 1;
                t_cspan = 1;
                continue;
            }
            var cellObj = this.cells2(i, j);
            if (cellObj.cell.rowSpan > 1) {
                temp_rspan[j] = cellObj.cell.rowSpan - 1;
                if (cellObj.cell.colSpan > 1) {
                    for (var k = 1; k < cellObj.cell.colSpan; k++) {
                        temp_rspan[j + k] = cellObj.cell.rowSpan - 1;
                    }
                }
            }
            t_cspan = cellObj.cell.colSpan;
            custom_code.apply(this, [cellObj, i, j]);
        }
    }
};

dhtmlXGridObject.prototype.enabledSelecteStates = function (bool) {
    this.rowSelecteStates = dhx4.s2b(bool);
};

/**
* 分页组件工具栏下拉框添加高度
*/
dhtmlXGridObject.prototype._pgn_createToolBar = function () {
    this.aToolBar = new dhtmlXToolbarObject({
        parent: this._pgn_parentObj,
        skin: (this._pgn_skin_tlb || this.skin_name),
        icons_path: this.imgURL
    });
    if (!this._WTDef) this.setPagingWTMode(true, true, true, true);
    var self = this;
    this.aToolBar.attachEvent("onClick", function (val) {
        val = val.split("_");
        switch (val[0]) {
            case "leftabs":
                self.changePage(1);
                break;
            case "left":
                self.changePage(self.currentPage - 1);
                break;
            case "rightabs":
                self.changePage(99999);
                break;
            case "right":
                self.changePage(self.currentPage + 1);
                break;
            case "perpagenum":
                if (val[1] === this.undefined) return;
                self.rowsBufferOutSize = parseInt(val[1]);
                self.changePage();
                self.aToolBar.setItemText("perpagenum", val[1] + " " + self.i18n.paging.perpage);
                break;
            case "pages":
                if (val[1] === this.undefined) return;
                self.changePage(val[1]);
                self.aToolBar.setItemText("pages", self.i18n.paging.page + val[1]);
                break;
        }
    });
    // add buttons
    if (this._WTDef[0]) {
        this.aToolBar.addButton("leftabs", NaN, null, "ar_left_abs.gif", "ar_left_abs_dis.gif");
        this.aToolBar.addButton("left", NaN, null, "ar_left.gif", "ar_left_dis.gif");
    }
    if (this._WTDef[1]) {
        this.aToolBar.addText("results", NaN, this.i18n.paging.results);
        this.aToolBar.setWidth("results", "150");
        this.aToolBar.disableItem("results");
    }
    if (this._WTDef[0]) {
        this.aToolBar.addButton("right", NaN, null, "ar_right.gif", "ar_right_dis.gif");
        this.aToolBar.addButton("rightabs", NaN, null, "ar_right_abs.gif", "ar_right_abs_dis.gif");
    }
    if (this._WTDef[2]) {
        if (this.aToolBar.conf.skin == "dhx_terrace") this.aToolBar.addSeparator();
        this.aToolBar.addButtonSelect("pages", NaN, "select page", [], "paging_pages.gif", null, false, true, 10);
    }
    var arr;
    if (arr = this._WTDef[3]) {
        if (this.aToolBar.conf.skin == "dhx_terrace") this.aToolBar.addSeparator();
        this.aToolBar.addButtonSelect("perpagenum", NaN, "select size", [], "paging_rows.gif", null, false, true, 10);
        if (typeof arr != "object") arr = [5, 10, 15, 20, 25, 30];
        var w = { dhx_skyblue: 4, dhx_web: 0, dhx_terrace: 18 }[this.aToolBar.conf.skin];
        for (var k = 0; k < arr.length; k++) {
            this.aToolBar.addListOption("perpagenum", "perpagenum_" + arr[k], NaN, "button", "<span style='padding: 0px " + w + "px 0px 0px;'>" + arr[k] + " " + this.i18n.paging.perpage + "</span>", "paging_page.gif");
        }
    }

    //var td = document.createElement("TD"); td.width = "5"; this.aToolBar.tr.appendChild(td);
    //var td = document.createElement("TD"); td.width = "100%"; this.aToolBar.tr.appendChild(td);

    return this.aToolBar;
}

dhtmlXGridCellObject.prototype.doLayout = function () {

}

/**
* 创建带确认取消按钮的窗口
*/
dhtmlXWindows.prototype.createConfirmWindow = function (id, x, y, width, height, opts) {
    var r = {};
    if (arguments.length == 1 && typeof (id) == "object") {
        r = id;
    } else {
        r.id = id;
        r.left = x;
        r.top = y;
        r.width = width;
        r.height = height;
        if (typeof (r.id) == "undefined" || r.id == null) r.id = window.dhx4.newId();
        while (this.w[r.id] != null) r.id = window.dhx4.newId();
    }

    if (r.left == null) r.left = 0;
    if (r.top == null) r.top = 0;

    r.move = (r.move != null && window.dhx4.s2b(r.move) == false ? false : (r.deny_move != null && window.dhx4.s2b(r.deny_move) == true ? false : true));
    r.park = (r.park != null && window.dhx4.s2b(r.park) == false ? false : (r.deny_park != null && window.dhx4.s2b(r.deny_park) == true ? false : true));
    r.resize = (r.resize != null && window.dhx4.s2b(r.resize) == false ? false : (r.deny_resize != null && window.dhx4.s2b(r.deny_resize) == true ? false : true));
    r.keep_in_viewport = (r.keep_in_viewport != null && window.dhx4.s2b(r.keep_in_viewport));
    r.modal = (r.modal != null && window.dhx4.s2b(r.modal));
    r.center = (r.center != null && window.dhx4.s2b(r.center));
    r.text = (r.text != null ? r.text : (r.caption != null ? r.caption : "dhtmlxWindow"));
    r.header = (!(r.header != null && window.dhx4.s2b(r.header) == false));

    var t = document.createElement("DIV");
    t.className = "dhxwin_active";
    t.style.viosibility = "hidden";
    this.vp.appendChild(t);

    t._isWindow = true;
    t._idd = r.id;

    var h = document.createElement("DIV");
    h.className = "dhxwin_hdr";
    h.style.zIndex = 0;
    h.innerHTML = "<div class='dhxwin_icon'></div>" +
            "<div class='dhxwin_text'><div class='dhxwin_text_inside'>" + r.text + "</div></div>" +
            "<div class='dhxwin_btns'></div>";
    t.appendChild(h);

    h.onselectstart = function (e) {
        e = e || event;
        if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
        return false;
    }

    h.oncontextmenu = function (e) {
        e = e || event;
        e.cancelBubble = true;
        return false;
    }

    h._isWinHdr = true;
    h.firstChild._isWinIcon = true;

    var k = document.createElement("DIV");
    k.className = "dhxwin_brd";
    t.appendChild(k);

    var f = document.createElement("DIV");
    f.className = "dhxwin_ftr";
    f.style.zIndex = 0;
    f.innerHTML = "<div class='dhxwin_btns'></div>";
    t.appendChild(f);

    var fr_cover = document.createElement("DIV");
    fr_cover.className = "dhxwin_fr_cover";
    fr_cover.innerHTML = "<iframe class='dhxwin_fr_cover_inner' frameborder='0' border='0'></iframe><div class='dhxwin_fr_cover_inner'></div>";
    t.appendChild(fr_cover);

    this.w[r.id] = {
        win: t,
        hdr: h,
        ftr: f,
        brd: k,
        fr_cover: fr_cover,
        b: {},
        conf: {
            z_id: window.dhx4.newId(),
            actv: false,
            modal: false,
            maxed: false,
            parked: false,
            sticked: false,
            visible: true,
            header: true,
            footer: true,
            text: r.text,
            keep_in_vp: r.keep_in_viewport,
            allow_move: r.move,
            allow_park: r.park,
            allow_resize: r.resize,
            max_w: null,
            max_h: null,
            min_w: 80,
            min_h: 80
        }
    };

    // buttons, id=>visible
    var btns = {
        help: { title: "Help", visible: false },
        stick: { title: "Stick", visible: false },
        park: { title: "Park", visible: true },
        minmax: { title: "Min/Max", visible: true },
        close: { title: "Close", visible: true }
    };
    for (var a in btns) {
        var b = new dhtmlXWindowsButton(this, r.id, a, btns[a].title, false);
        if (btns[a].visible == false) b.hide();
        h.lastChild.appendChild(b.button);
        this.w[r.id].b[a] = b;
        b = null;
    }
    this._winAdjustTitle(r.id);

    this.w[r.id].win.style.zIndex = window.dhx4.zim.reserve(this.w[r.id].conf.z_id);

    var cell = new dhtmlXWindowsCell(r.id, this);
    this.w[r.id].win.insertBefore(cell.cell, fr_cover);
    this.w[r.id].cell = cell;

    if (typeof (window.addEventListener) == "function") {
        this.w[r.id].win.addEventListener("mousedown", this._winOnMouseDown, false);
        this.w[r.id].win.addEventListener("mouseup", this._winOnMouseDown, false);
        if (this.conf.dblclick_ev) this.w[r.id].win.addEventListener("dblclick", this._winOnMouseDown, false);
    } else {
        this.w[r.id].win.attachEvent("onmousedown", this._winOnMouseDown);
        this.w[r.id].win.attachEvent("onmouseup", this._winOnMouseDown);
        if (this.conf.dblclick_ev) this.w[r.id].win.attachEvent("ondblclick", this._winOnMouseDown);
    }

    // fr for IE6
    this._winInitFRM(r.id);

    this._winSetPosition(r.id, r.left, r.top);
    this._winSetSize(r.id, r.width, r.height);
    this._winMakeActive(r.id);

    if (r.center == true) this.w[r.id].cell.center();
    if (r.modal == true) this.w[r.id].cell.setModal(true);
    if (r.header == false) this.w[r.id].cell.hideHeader();

    f = t = h = k = fr_cover = cell = null;

    return this.w[r.id].cell;
}

if (window.dhtmlXCalendarObject) {
    dhtmlXCalendarObject.prototype.lang = "ch";
    dhtmlXCalendarObject.prototype.langData["ch"] =
        {
            dateformat: "%Y-%m-%d",
            hdrformat: "%F %Y",
            monthesFNames: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
            monthesSNames: ["一", "二", "三", "四", "五", "六", "七", "八", "九", "十", "十一", "十二"],
            daysFNames: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
            daysSNames: ["日", "一", "二", "三", "四", "五", "六"],
            weekstart: 1,
            weekname: "周",
            today: "今天",
            clear: "清除"
        }
}

/***********************************************************
******************一下是表头定制方法***********************
************************************************************/
/**
 *   @desc: fix hidden state for column in all rows
 *   @type: private
 */
dhtmlXGridObject.prototype._fixHiddenRowsAll=function(pb, ind, prop, state, index){
    index=index||"_cellIndex";
    var z = pb.rows.length;
    if (!this.hwReport || ind < this.hwReport.fixedColCount&&!this.userSetColumnHidden) {
	//if (!this.hwReport ) {
        for (var i = 0; i < z; i++) {
            var x = pb.rows[i].childNodes;

            if (x.length != this._cCount) {
                for (var j = 0; j < x.length; j++)
                    if (x[j][index] == ind) {
                        x[j].style[prop] = state;
                        break;
                    }
            } else
                x[ind].style[prop] = state;
        }
    } else {
        index = index || "_cellIndex";
        var z = pb.rows.length;

        for (var i = 0; i < z; i++) {
            var x = pb.rows[i].childNodes;
            if(this.hwReport.oldColWidths){
                if(ind<x.length)
                    x[ind].style["width"] = this.hwReport.oldColWidths[ind]+"px";
            }
            if (x.length != this._cCount) {
                for (var j = 0; j < x.length; j++)
                {
                    // 标题行设置
                    if(x.length==1&&x[j]["_cellIndex"]!=x[j]["_cellIndexS"]&&x[j]["_cellIndexS"]==0&&state==""){
                        x[j]["colSpan"]=x[j]["colSpan"]+1;
                    }
                    if (x[j][index] == ind) {
                        // 对于合并单元格的做出特殊处理
                        // 隐藏合并单元格的第一列 2017.8.2 lf
                        if(x[j]["colSpan"]>1&&state=="none")
                        {
                            if(pb&&pb.grid&&pb.grid._split_later&&pb.grid._split_later>ind)
                            {
                                if(f_width&&f_width==0){
                                    x[j]["colSpan"]=x[j]["colSpan"]-1;
                                    x[j].style[prop] = '';
                                }
                            }else{
                                x[j]["colSpan"]=x[j]["colSpan"]-1;
                                x[j].style[prop] = '';
                            }
                        }
                        else{
                            x[j].style[prop] = state;
                            if(state==''){
                                if(x[j+1])
                                {
                                    if(x[j+1][index]-x[j][index]>1)
                                    {
                                        // x[j]["colSpan"]=x[j+1][index]-x[j][index];
                                        if(i>1&&pb.rows[i-1]&&pb.rows[i-1].childNodes)
                                        {
                                            var pr=pb.rows[i-1].childNodes;
                                            if(pr.length==1){
                                                x[j]["colSpan"]=x[j+1][index]-x[j][index];
                                            }
                                            if(pr[j]&&pr[j][index]==x[j][index]&&pr[j+1]&&pr[j+1][index]==x[j+1][index]){
                                                x[j]["colSpan"]=x[j+1][index]-x[j][index];
                                            }else if(pr[j]==undefined&&pr[j+1]==undefined)
                                            {
                                                x[j]["colSpan"]=x[j+1][index]-x[j][index];
                                            }else if(pr[j]&&pr[j][index]<ind&&pr[j+1]&&pr[j+1][index]<ind)
                                            {
                                                x[j]["colSpan"]=x[j+1][index]-x[j][index];
                                            }
                                        }else
                                        {
                                            x[j]["colSpan"]=x[j+1][index]-x[j][index];
                                        }
                                    }
                                }else{
									if(j==x.length-1&&x[j]["_cellIndex"]!=x[j]["_cellIndexS"] ){
										x[j]["colSpan"]=x[j]["_cellIndex"]+1-x[j][index];
									}
								}
                            }
                        }
                    }
                    else{
                        // 隐藏列在合并单元格内部,不是合并单元格的第一个单元格  2017.8.3 lf
                        if(x[j]["colSpan"]>1&&state=="none")
                        {
                            if(x[j][index]<ind&&x[j][index]+x[j]["colSpan"]-1>=ind)
                            {
                                // 锁定列范围内。宽度为零另外处理，不为零只设置隐藏属性
                                if(pb&&pb.grid&&pb.grid._split_later&&pb.grid._split_later>ind)
                                {
                                    if(f_width&&f_width==0){
                                        x[j]["colSpan"]=x[j]["colSpan"]-1;
                                        x[j].style[prop] = '';
                                    }else
                                        x[j].style[prop] =state;
                                }
                                else{
                                    x[j]["colSpan"]=x[j]["colSpan"]-1;
                                    x[j].style[prop] = '';
                                }
                            }
                            else
                            {
                                if(x[j][index]<ind&&x[j+1])
                                {
                                    if(x[j+1][index]-x[j][index]>1&&x[j+1][index]>ind)
                                    {
                                        if(x[j]["colSpan"]>1)
                                        {
                                            if(pb&&pb.grid&&pb.grid._split_later&&pb.grid._split_later>ind)
                                            {
                                                if(f_width&&f_width==0){
                                                    x[j]["colSpan"]=x[j]["colSpan"]-1;
                                                    x[j].style[prop] = '';
                                                }
                                            }else{
                                                x[j]["colSpan"]=x[j]["colSpan"]-1;
                                                x[j].style[prop] = '';
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            if(x[j][index]<ind&&x[j+1])
                            {
                                if(x[j+1][index]-x[j][index]>1)
                                {
                                    if(state=='')
                                    {
                                        if(x[j+1][index]>ind) {
                                            // x[j]["colSpan"]=x[j+1][index]-x[j][index];
                                            if (i > 1 && pb.rows[i - 1] && pb.rows[i - 1].childNodes) {
                                                var pr = pb.rows[i - 1].childNodes;
                                                if (pr.length == 1) {
                                                    x[j]["colSpan"] = x[j + 1][index] - x[j][index];
                                                }
                                                if (pr[j] && pr[j][index] == x[j][index] && pr[j + 1] && pr[j + 1][index] == x[j + 1][index]) {
                                                    x[j]["colSpan"] = x[j + 1][index] - x[j][index];
                                                } else if (pr[j] == undefined && pr[j + 1] == undefined) {
                                                    x[j]["colSpan"] = x[j + 1][index] - x[j][index];
                                                } else if (pr[j] && pr[j][index] < ind && pr[j + 1] && pr[j + 1][index] < ind) {
                                                    x[j]["colSpan"] = x[j + 1][index] - x[j][index];
                                                }
                                            }
										}else if(x[j+1][index]==ind){	
											continue;	
										}
										x[j].style[prop] = '';
										if(j==x.length-1){
											if(x[j]["colSpan"]>1){
												if(x[j][index]+x[j]["colSpan"]-1<x.length-1){
													x[j]["colSpan"]=x.length-x[j][index];
												}
											}
										}
                                    }
                                    else
                                    {
                                        if(x[j][index]<ind&&x[j][index]+x[j+1][index]-x[j][index]-1>=ind)
                                            x[j].style[prop] = state;
                                    }
                                }
                            }
                            else if(x[j][index]<ind&&x[j+1]==undefined){
                                if(state=='')
                                {
                                    if (i > 1 && pb.rows[i - 1] && pb.rows[i - 1].childNodes) {
                                        var pr = pb.rows[i - 1].childNodes;
                                        if(pr.length==1){
                                            x[j]["colSpan"]= x[j]["colSpan"]+1;
                                        }
                                        else if(pr.lastChild&&(pr.lastChild[index]>ind||(pr.lastChild[index]<ind&&(pr.lastChild[index]+pr.lastChild["colSpan"]-1>ind)))){
                                            x[j]["colSpan"]= x[j]["colSpan"]+1;
                                        }
                                    }
                                    x[j].style[prop] = '';
                                }
                            }
                        }
                    }
                }

            } else{
                x[ind].style[prop] = state;
                /*  if(state=''&&this.hwReport.oldColWidths){
                 x[ind].style["width"] = this.hwReport.oldColWidths[ind];
                 }*/
            }

        }
    }
};
//重新设置表头行高度  字段选择
dhtmlXGridObject.prototype.changeHeaderHeight = function () {
    //非锁定列高度的重新设定
    if (this.hdr ) {
        var p=this.hdr.parentNode;
        if(p&&this.hdr.offsetHeight> p.offsetHeight){
            p.style.height=this.hdr.offsetHeight+"px";
        }
    }

    //锁定列高度的重新设定
    if (this._fake && !(this._fake.hdr.rows.length == 0)) { //含有锁定列的情况
        if (this._fake.hdr ) {
            var pn=this._fake.hdr.parentNode;
            if(pn&&this._fake.hdr.offsetHeight> pn.offsetHeight){
                pn.style.height=this._fake.hdr.offsetHeight+"px";
            }
        }
    }
}

//动态调用接口设置列隐藏或者不隐藏
dhtmlXGridObject.prototype.setColumnHiddenExp=function(ind, state){
	this.userSetColumnHidden=true;
	if(this._fake){
		this._fake.userSetColumnHidden=true;
	}
    this.setColumnHidden(ind, state);
	// 隐藏
	if(this._fake){
		this.setLockCellBorderClassExp(ind, state);
	}else{
		  this.setCellBorderClassExp(ind, state);
	}
}
// 返回隐藏的下一列
dhtmlXGridObject.prototype.hideColNextCol=function(ind,cellsobj){
	var isLock=true;
	if(this._fake){
		isLock=false;
	}
	var nextCol;
	if(this._cCount==cellsobj.length){
		nextCol=this.getNextColIndex(ind,isLock,cellsobj);
	}else{
		if(this._fake){
			var newFlag=true;
			for(var c=0;c<this._fake._cCount;c++){
				if(this._fake.cellWidthPX[c]>0){
					newFlag=false;
					ind=c;
					break;
				}
			}
			if(newFlag){
				for(var c=0;c<this._cCount;c++){
					if(this.cellWidthPX[c]>0){
						ind=c;
						newFlag=false;
						//return nextCol;
					}
				}
			}	
		}
		nextCol=this.getMergedGcellColIndex(ind,cellsobj);	   
	}
	return nextCol;
}
	dhtmlXGridObject.prototype.getMergedGcellColIndex=function(ind,cellsobj){
		var nextCol=ind;
        var newFlag=true;
		for(var c=0;c<ind;c++){
			if(this._fake){
				if(this._fake._cCount>c){
					if(this._fake.cellWidthPX[c]>0){
						nextCol=c;
						newFlag=false;
						break;
					}
				}else{
					if(this.cellWidthPX[c]>0){
						nextCol=c;
						newFlag=false;
						break;
					}
				}	
			}else{
				if(this.cellWidthPX[c]>0){
					nextCol=c;
					newFlag=false;
					break;
			    }
			}
		}
		if(newFlag){
			for(var i=0;i<cellsobj.length ;i++){
				if(cellsobj[i]._cellIndex<=ind){
					if(i+1<cellsobj.length&&cellsobj[i+1]._cellIndex>ind)
					{
						var flag=false;
						for(var j=cellsobj[i]._cellIndex;j<cellsobj[i+1]._cellIndex;j++){
							if(this._fake){
								if(j<this._fake._cCount){
									if(this._fake.cellWidthPX[j]>0){
										flag=true;
										break;
								    }
								}else{
									if(this.cellWidthPX[j]>0){
										flag=true;
										break;
									} 
								}
							}else{
								if(this.cellWidthPX[j]>0){
									flag=true;
									break;
								} 
							}   
						}
						if(flag){
						nextCol=i;	
						}else{
							for( var c=cellsobj[i+1]._cellIndex;c<this.cellWidthPX.length;c++){
								if(this._fake){
									if(c>this._fake._cCount){
										if(this._fake.cellWidthPX[c]>0){
											nextCol=this.getMergedGcellColIndex(c,cellsobj);
										    break;
										}	
									}else{
										if(this.cellWidthPX[c]>0){
											nextCol=this.getMergedGcellColIndex(c,cellsobj);
											break;
									  }
									}
								}
								else{
									if(this.cellWidthPX[c]>0){
										nextCol=this.getMergedGcellColIndex(c,cellsobj);
										break;
								  }
								}
							}
						}
					}
				}
			}
		}else{
			nextCol=this.getMergedGcellColIndex(nextCol,cellsobj);
		}
	return nextCol;
}
//获取隐藏列的下一列，以便设置边框
dhtmlXGridObject.prototype.getNextColIndex=function(ind,isLock,cellsobj){
		var nextCol;
		var flag=true;
	if(isLock){
		for(var c=0;c<ind;c++){
			if(this.cellWidthPX[c]>0){
				nextCol=c;
				flag=false;
				break;
			}
		}
		if(flag){
			nextCol=ind+1;
		}
		if(this.cellWidthPX&&this.cellWidthPX.length>nextCol){
			if(this.cellWidthPX[nextCol]==0)
				nextCol=this.hideColNextCol(nextCol,cellsobj);
		}
	}else{
		if(ind>=this._fake._cCount){
			flag=true;
			for(var c=0;c<ind;c++){
				if(this.cellWidthPX[c]>0){
					nextCol=c;
					flag=false;
					break;
				}
			}
			if(flag){
				nextCol=ind+1;
			}
			if(this.cellWidthPX&&this.cellWidthPX.length>nextCol){
				if(this.cellWidthPX[nextCol]==0)
					nextCol=this.hideColNextCol(nextCol,cellsobj);
			}
		}else{
			ind=this._fake._cCount;
			flag=true;
			for(var c=0;c<ind;c++){
				if(this._fake.cellWidthPX[c]>0){
					nextCol=c;
					flag=false;
					break;
				}
			}
			if(flag){
				nextCol=ind;
			}
			if(this._fake.cellWidthPX&&this._fake.cellWidthPX.length>nextCol){
				if(this._fake.cellWidthPX[nextCol]==0)
					nextCol=this.hideColNextCol(nextCol,cellsobj);
			}
		}
	}
	return nextCol;
}
 
// 动态隐藏后，设置最左边边框样式
dhtmlXGridObject.prototype.setCellBorderClassExp=function(ind,state){	
    // 添加c-first样式
    if(state){
		this.removeCFirstClass();
		if(this.cellWidthPX[0]>0&&ind>=0) return;
        for(var i=0;i<this.hdr.rows.length;i++){
            var rtr=this.hdr.rows[i];
            if(rtr.children&&rtr.children.length>0){
				var index=this.hideColNextCol(ind,rtr.children);
				if(this._fake&&this.hwReport.floatTitleContainer&&index==0){
					index=1;
				}
                vmd(rtr.children[index]).addClass('c-first');
            }
        }
        for(var i=0;i<this.obj.rows.length;i++){
            var rtr=this.obj.rows[i];
            if(rtr.children&&rtr.children.length>0){
				var index=this.hideColNextCol(ind,rtr.children);
                vmd(rtr.children[index]).addClass('c-first');
            }
        }
    }
    // 如果不是第一列，删除c-first样式
    else{
        this.removeCFirstClass();
		for(var c=0;c<this._cCount;c++){
			if(this.cellWidthPX[c]>0){
				ind=c;
				break;
			}
		}
		if(ind>=1)
		 ind=ind-1;
		this.setCellBorderClassExp(ind,true);
    }
}
// 动态隐藏后，设置最左边边框样式
dhtmlXGridObject.prototype.setLockCellBorderClassExp=function(ind,state){
    // 添加c-first样式
    if(state){
		this.removeCFirstClass();
        for(var i=0;i<this._fake.hdr.rows.length;i++){
            var rtr=this._fake.hdr.rows[i];
            if(rtr.children&&rtr.children.length>0){
				var index=this.hideColNextCol(ind,rtr.children);
				if(index>=this._fake._cCount){
					this.setCellBorderClassExp(index,false);
					continue;
				}
                vmd(rtr.children[index]).addClass('c-first');
            }
        }
        for(var i=0;i<this._fake.obj.rows.length;i++){
            var rtr=this._fake.obj.rows[i];
            if(rtr.children&&rtr.children.length>0){
				var index=this.hideColNextCol(ind,rtr.children);
				if(index>=this._fake._cCount){
					this.setCellBorderClassExp(index,false);
					continue;
				}
                vmd(rtr.children[index]).addClass('c-first');
            }
        }
    }
    // 如果不是第一列，删除c-first样式
    else{
        this.removeCFirstClass();
		var flag=true;
		for(var c=0;c<this._fake._cCount;c++){
			if(this._fake.cellWidthPX[c]>0){
				ind=c;
				flag=false;
				break;
			}
		}
		if(flag){
			this.setCellBorderClassExp(ind,true);
			return;
		}
		if(ind>=1)
		  ind=ind-1;
		this.setLockCellBorderClassExp(ind,true);
    }
}

dhtmlXGridObject.prototype.removeCFirstClass=function(){
	if(this._fake){
		for(var i=0;i<this._fake.hdr.rows.length;i++){
				var rtr=this._fake.hdr.rows[i];
				if(rtr.children&&rtr.children.length>0){
					for(var c=0;c<rtr.children.length;c++){
						if(c>0&&vmd(rtr.children[c]).hasClass('c-first')){
							vmd(rtr.children[c]).removeClass('c-first');
						}
					}
				}
		}
			for(var i=0;i<this._fake.obj.rows.length;i++){
				var rtr=this._fake.obj.rows[i];
				if(rtr.children&&rtr.children.length>0){
					for(var c=0;c<rtr.children.length;c++){
						if(c>0&&vmd(rtr.children[c]).hasClass('c-first')){
							vmd(rtr.children[c]).removeClass('c-first');
						}
					}
				}
			}
	}
	for(var i=0;i<this.hdr.rows.length;i++){
		var rtr=this.hdr.rows[i];
		if(rtr.children&&rtr.children.length>0){
			for(var c=0;c<rtr.children.length;c++){
				if(c>0&&vmd(rtr.children[c]).hasClass('c-first')){
				   vmd(rtr.children[c]).removeClass('c-first');
				 }
			} 
		}
	}
	for(var i=0;i<this.obj.rows.length;i++){
		var rtr=this.obj.rows[i];
		if(rtr.children&&rtr.children.length>0){
			for(var c=0;c<rtr.children.length;c++){
				if(c>0&&vmd(rtr.children[c]).hasClass('c-first')){
					vmd(rtr.children[c]).removeClass('c-first');
				}
			}
		}
	}
}
dhtmlXGridObject.prototype.configRefresh = function (configGrid) {
    hwDas.ajax({
        type: "get",
        url:vmd.virtualPath + "/" +configGrid.xmlModelXml,
        dataType: "json",
        success: function(res) {
            var host =vmdSettings.vmdReportIp ;
            var hwRao = new HwRao(host, "report");
			vmd.isCheckFileExist("/" +configGrid.configFile.rptHeaderPath,function(resultInfo){
				if(resultInfo&&resultInfo.hiddenFields&&resultInfo.hiddenFields.length>0)
				{
					res.main.body.columns.oldwidth=dhx4._copyObj(res.main.body.columns.width);
					res.main.body.columns.hiddenFields=resultInfo.hiddenFields;
					for(var i=0;i<resultInfo.hiddenFields.length;i++){
						res.main.body.columns.width[resultInfo.hiddenFields[i]]=0;
					}
				}
				configGrid.loadJSON(Ext.encode(res), function() {
					configGrid.headerdefine = res;
					configGrid.vmdreport.myMask.hide();
				})
				configGrid.vmdreport.myMask.hide();
			},true,vmd.virtualPath,function(){
				// 表头定制文件不存在
				configGrid.loadJSON(Ext.encode(res), function() {
					configGrid.headerdefine = res;
					configGrid.vmdreport.myMask.hide();
				})
				configGrid.vmdreport.myMask.hide();
				return true
			});
},
 error:function(){
    configGrid.vmdreport.myMask.hide();
    configGrid.vmdreport.loading = false;
    var msg="找不到模板文件，路径为："+configGrid.xmlModelXml;
    Ext.Msg.alert("错误信息", msg,
        function() {})
    return true
}
})
}
// 字段选择
dhtmlXGridObject.prototype.setCheckBox = function (z, st1, i, check) {

    var w = z.lastChild;
    w._cellIndex = w._cellIndexS = i - 1;
    w.innerHTML = "<div class='hdrcell'>" + w.innerText + "</div>";

    if (this._hrrar && this._hrrar[i] && !_isIE)
        w.style.display = 'none';

    if ((check || "").indexOf("#") != -1) {
        var t = check.match(/(^|{)#([^}]+)(}|$)/);

        if (t) {
            var tn = "_in_header_" + t[2];

            if (this[tn])
                this[tn](w.firstChild, i, check.split(t[0]));
        }
    }

    if (st1)
        w.style.cssText = st1[i-1];
}

/**
 * @param t
 * @param i
 * @param c
 字段选择
 */
dhtmlXGridObject.prototype._in_header_master_checkbox = function (t, i, c) {

    if (t.innerText == "#master_checkbox") {
        t.innerText = "";
    } else {
        t.innerText = t.innerText + "<br/>";
    }
    //20141222 add
    if (i < lockColNum) {
        t.innerHTML = c[0] + t.innerText + "<input type='checkbox' disabled/>" + c[1];
        // t.innerHTML = c[0] + t.innerText + "<input type='checkbox' />" + c[1];
    } else {
        t.innerHTML = c[0] + t.innerText + "<input type='checkbox'/>" + c[1];
    }
    //end
    //t.innerHTML = c[0] + t.innerText + "<input type='checkbox' />" + c[1];
    var self = this;

    t.getElementsByTagName("input")[0].onclick = function (e) {

        //行号
        var rowId = t.parentNode.parentNode.rowIndex;
        //alert(i);
        //列号
        //debugger
        //var colId = t.parentNode.outerHTML && t.parentNode.outerHTML.match(/_cellIndex="\d*"/)[0] && t.parentNode.outerHTML.match(/_cellIndex="\d*"/)[0].match(/\d\d*/)[0];
        var colId = t.parentNode._cellIndex;
        //是否选中
        var state = true;
        if (!this.checked) {
            state = false;
        }

        //判断是不是最后一行
        if (!(rowId == t.parentNode.parentNode.parentNode.childNodes[t.parentNode.parentNode.parentNode.childNodes.length - 1].rowIndex)) {
            if (state) {
                //选中
                self.setChecked(colId, t, rowId);
            } else {
                //未选中
                self.setNoChecked(colId, t, rowId);
            }
            //最后一行特殊处理
        } else {
            if (state) {
                //根据最后一行复选框设置第一行复选框选中
                self.setDisperseRelateColsChecked(colId, t, rowId);
            } else {
                //根据最后一行复选框设置第一行复选框未选中
                self.setDisperseRelateColsNoChecked(colId, t, rowId);
            }
        }
    }
}

// 字段选择
dhtmlXGridObject.prototype.setDisperseRelateColsChecked = function (colId, t, rowId) {

    //configGrid.hiddenFields.length;
    //debugger
    //求单元格范围
    var clickFakeRowObj = t.parentNode.parentNode;
    var fakeRowsObj = t.parentNode.parentNode.parentNode.childNodes;
    var realRowsObj =this.hwReport.headers;
	for(var i=0;i<realRowsObj.length;i++){
		var h=realRowsObj[i];
		if(typeof h[0]=="string"){
			var s=h[0].split(',');
			h[0]=s;
		}
	}
    var colsNum = 1, star = 0, end = 0;
    rowId = parseInt(rowId);
    colId = parseInt(colId);

    star = colId;
    end = star;

    //删除隐藏列
    this.delHiddenFields(colId);

    //debugger
    if (rowId == fakeRowsObj.length - 1) {
        var rowStar = 0, rowEnd = 0;
        //向前找找到本单元格开始坐标
        rowStar = this.getRowStar(rowId, star, realRowsObj);

        //向后找找到本单元格结束坐标
        rowEnd = this.getRowEnd(rowId, end, realRowsObj);



        var checkId = 0, checked = false;
        for (var a = rowStar; a <= rowEnd; a++) {
            if (fakeRowsObj[rowId].childNodes[a].getElementsByTagName("input")[0].checked) {
                checked = true;
            }
        }

        if (checked) {
            for (var d = 0; d <= rowEnd; d++) {
                //realRowsObj[rowId - 4][0][d].match(/[^#cspan|#rspan]*/gi)[0]
                if (realRowsObj[rowId -2][0][d].match(/^(?!#cspan|#rspan).*/i) &&
                    realRowsObj[rowId - 2][0][d].match(/^(?!#cspan|#rspan).*/i)[0]) {

                    if (d >= rowStar && d <= rowEnd) {
                        if(checkId<fakeRowsObj[rowId - 2].childNodes.length) {
                            if (fakeRowsObj[rowId - 2].childNodes[checkId].getElementsByTagName("input")[0]) {
                                fakeRowsObj[rowId - 2].childNodes[checkId].getElementsByTagName("input")[0].checked = true;
                            }
                        }
                    }
                    checkId++;
                }
            }
        } else {
            for (var d = 0; d <= rowEnd; d++) {
                if (realRowsObj[rowId -2][0][d].match(/[^#cspan|#rspan]*/gi) &&
                    realRowsObj[rowId - 2][0][d].match(/[^#cspan|#rspan]*/gi)[0]) {

                    if (d >= rowStar && d <= rowEnd) {
                        if (checkId < fakeRowsObj[rowId - 2].childNodes.length) {
                            fakeRowsObj[rowId - 2].childNodes[checkId].getElementsByTagName("input")[0].checked = false;
                        }
                    }
                    checkId++;
                }
            }
        }
    }

    //此复选框选中时上面行的复选框选中处理
    for (var i = rowId - 3; i >= 2; i--) {
        var rowStar = 0, rowEnd = 0;
        //向前找找到本单元格开始坐标
        for (var j = star; j >= 0; j--) {
            if (realRowsObj[i - 2][0][j].match(/#[^c]span|[^#cspan]*/) &&
                realRowsObj[i - 2][0][j].match(/#[^c]span|[^#cspan]*/)[0]) {
                rowStar = j;
                break;
            }
        }

        //向后找找到本单元格结束坐标
        //rowEnd = this.getRowEnd(rowId, end, realRowsObj);
        for (var j = end + 1; j < realRowsObj[i][0].length; j++) {
            if (realRowsObj[i - 2][0][j].match(/#[^c]span|[^#cspan]*/) &&
                realRowsObj[i - 2][0][j].match(/#[^c]span|[^#cspan]*/)[0]) {
                rowEnd = j - 1;
                break;
            } else {
                rowEnd = j;
            }
        }
        //最后一列单元格的情况
        if (end == realRowsObj[i][0].length - 1) {
            rowEnd = end;
        }
        var checkId = 0;
        for (var d = 0; d <= rowEnd; d++) {
            if (realRowsObj[i - 1][0][d].match(/[^#cspan|#rspan]*/gi) &&
                realRowsObj[i - 1][0][d].match(/[^#cspan|#rspan]*/gi)[0]) {
                if (d >= rowStar && d <= rowEnd) {
                    if (fakeRowsObj[i + 1].childNodes[checkId].getElementsByTagName("input")[0]) {
                        if (fakeRowsObj[i + 1].childNodes[checkId].getElementsByTagName("input")[0].checked) {
                            checked = true;
                        }
                    }
                }
                checkId++;
            }
        }

        if (checked) {
            var ch = 0, cellVal;
            for (var d = 0; d <= rowEnd; d++) {
                //start 20141220
                cellVal = realRowsObj[i - 2][0][d];
                if (realRowsObj[i - 2][0][d] == "") {
                    realRowsObj[i - 2][0][d] = "true";
                }
                //end
                if (realRowsObj[i - 2][0][d].match(/[^#cspan|#rspan]*/gi) &&
                    realRowsObj[i - 2][0][d].match(/[^#cspan|#rspan]*/gi)[0]) {

                    realRowsObj[i - 2][0][d] = cellVal;

                    if (d >= rowStar && d <= rowEnd) {
                        if (fakeRowsObj[i].childNodes[ch].getElementsByTagName("input")[0]) {
                            fakeRowsObj[i].childNodes[ch].getElementsByTagName("input")[0].checked = true;
                        }
                    }
                    ch++;
                }
            }
        } else {
            var ch = 0;
            for (var d = 0; d <= rowEnd; d++) {

                if (realRowsObj[i - 2][0][d].match(/[^#cspan|#rspan]*/gi) &&
                    realRowsObj[i - 2][0][d].match(/[^#cspan|#rspan]*/gi)[0]) {

                    if (d >= rowStar && d <= rowEnd) {
                        if (fakeRowsObj[i].childNodes[ch].getElementsByTagName("input")[0]) {
                            fakeRowsObj[i].childNodes[ch].getElementsByTagName("input")[0].checked = false;
                        }
                    }
                    ch++;
                }
            }
        }
    }
}

//字段选择
dhtmlXGridObject.prototype.setDisperseRelateColsNoChecked = function (colId, t, rowId) {
    //求单元格范围
    var clickFakeRowObj = t.parentNode.parentNode;
    var fakeRowsObj = t.parentNode.parentNode.parentNode.childNodes;
    var realRowsObj =this.hwReport.headers;
	for(var i=0;i<realRowsObj.length;i++){
		var h=realRowsObj[i];
		if(typeof h[0]=="string"){
			var s=h[0].split(',');
			h[0]=s;
		}
	}
    var colsNum = 1, star = 0, end = 0;
    rowId = parseInt(rowId);
    colId = parseInt(colId);

    star = colId;
    end = star;
    //添加隐藏列
    this.addHiddenFields(colId);

    if (rowId == fakeRowsObj.length - 1) {
        var rowStar, rowEnd;
        //向前找找到本单元格开始坐标
        for (var j = star; j >= 0; j--) {
//            if (realRowsObj[rowId - 4][0][j].match(/#[^c]span|[^#cspan]*/) &&
//                realRowsObj[rowId - 4][0][j].match(/#[^c]span|[^#cspan]*/)[0]) {
            if (realRowsObj[rowId - 2][0][j].match(/#[^c]span|[^#cspan]*/) &&
                realRowsObj[rowId - 2][0][j].match(/#[^c]span|[^#cspan]*/)[0]) {
                rowStar = j;
                break;
            }
        }
 
        //向后找找到本单元格结束坐标
        for (var b = end + 1; b < realRowsObj[rowId - 2][0].length; b++) {
            if (realRowsObj[rowId - 2][0][b].match(/#[^c]span|[^#cspan]*/) &&
                realRowsObj[rowId - 2][0][b].match(/#[^c]span|[^#cspan]*/)[0]) {
                rowEnd = b - 1;
                break;
            }
        }

        var checkId = 0, checked = false;
        for (var a = rowStar; a <= rowEnd; a++) {
            if (fakeRowsObj[rowId].childNodes[a].getElementsByTagName("input")[0].checked) {
                checked = true;
            }
        }

        if (checked) {
            for (var d = 0; d <= rowEnd; d++) {
                if (realRowsObj[rowId - 2][0][d].match(/^(?!#cspan|#rspan).*/i) &&
                    realRowsObj[rowId - 2][0][d].match(/^(?!#cspan|#rspan).*/i)[0]) {

                    if (d >= rowStar && d <= rowEnd) {
                        if (fakeRowsObj[rowId - 2].childNodes[checkId].getElementsByTagName("input")[0]) {
                            fakeRowsObj[rowId - 2].childNodes[checkId].getElementsByTagName("input")[0].checked = true;
                        }
                    }
                    checkId++;
                }
            }
        } else {
            for (var d = 0; d <= rowEnd; d++) {
                //realRowsObj[rowId - 4][0][d].match(/[^#cspan|#rspan]*/gi)
                if (realRowsObj[rowId - 2][0][d].match(/^(?!#cspan|#rspan).*/i) &&
                    realRowsObj[rowId -2][0][d].match(/^(?!#cspan|#rspan).*/i)[0]) {

                    if (d >= rowStar && d <= rowEnd) {
                        if(checkId<fakeRowsObj[rowId - 2].childNodes.length) {
                            if (fakeRowsObj[rowId - 2].childNodes[checkId].getElementsByTagName("input")[0]) {
                                fakeRowsObj[rowId - 2].childNodes[checkId].getElementsByTagName("input")[0].checked = false;
                            }
                        }
                    }
                    checkId++;
                }
            }
        }
    }
    //debugger
    //此复选框选中时上面行的复选框选中处理
    for (var i = rowId - 3; i >= 2; i--) {
        var rowStar, rowEnd;
        //向前找找到本单元格开始坐标
        for (var j = star; j >= 0; j--) {
            if (realRowsObj[i - 2][0][j].match(/[^#cspan|#rspan]*/gi) &&
                realRowsObj[i - 2][0][j].match(/[^#cspan|#rspan]*/gi)[0]) {
                rowStar = j;
                break;
            } 
        }
        //向后找找到本单元格结束坐标
        for (var b = end + 1; b < realRowsObj[i - 2][0].length; b++) {
            if (realRowsObj[i - 2][0][b].match(/[^#cspan|#rspan]*/gi) &&
                realRowsObj[i - 2][0][b].match(/[^#cspan|#rspan]*/gi)[0]) {
                rowEnd = b - 1;
                break;
            } else {
                rowEnd = b;
            }
        }
        //最后一列单元格的情况
        if (end == realRowsObj[i][0].length - 1) {
            rowEnd = end;
        }

        //debugger
        //var checked = false;
        var checkId = 0;
        for (var d = 0; d <= rowEnd; d++) {
            if (realRowsObj[i - 1][0][d].match(/^(?!#cspan|#rspan).*/i) &&
                realRowsObj[i - 1][0][d].match(/^(?!#cspan|#rspan).*/i)[0]) {
                if (d >= rowStar && d <= rowEnd) {
                    if(checkId<fakeRowsObj[i+1].childNodes.length) {
                        if (fakeRowsObj[i + 1].childNodes[checkId].getElementsByTagName("input")[0]) {
                            if (fakeRowsObj[i + 1].childNodes[checkId].getElementsByTagName("input")[0].checked) {
                                checked = true;
                            }
                        }
                    }
                }
                checkId++;
            }
        }

        //判断最后一行在范围内的复选框是否选中
        for (var a = rowStar; a <= rowEnd; a++) {
            if (fakeRowsObj[rowId].childNodes[a].getElementsByTagName("input")[0].checked) {
                checked = true;
            }
        }

        if (checked) {
            var ch = 0;
            for (var d = 0; d <= rowEnd; d++) {
                if (realRowsObj[i - 2][0][d].match(/[^#cspan|#rspan]*/gi) &&
                    realRowsObj[i - 2][0][d].match(/[^#cspan|#rspan]*/gi)[0]) {

                    if (d >= rowStar && d <= rowEnd) {
                        if (fakeRowsObj[i].childNodes[ch].getElementsByTagName("input")[0]) {
                            fakeRowsObj[i].childNodes[ch].getElementsByTagName("input")[0].checked = true;
                        }
                    }
                    ch++;
                }
            }
        } else {
            var ch = 0, cellVal;
            for (var d = 0; d <= rowEnd; d++) {
                cellVal = realRowsObj[i - 2][0][d];
                //start 追加 20141220
                if (realRowsObj[i - 2][0][d] == "") {
                    realRowsObj[i - 2][0][d] = "true";
                }
                //end
                if (realRowsObj[i - 2][0][d].match(/[^#cspan|#rspan]*/gi) &&
                    realRowsObj[i - 2][0][d].match(/[^#cspan|#rspan]*/gi)[0]) {

                    realRowsObj[i - 2][0][d] = cellVal;

                    if (d >= rowStar && d <= rowEnd) {
                        if (fakeRowsObj[i].childNodes[ch].getElementsByTagName("input")[0]) {
                            fakeRowsObj[i].childNodes[ch].getElementsByTagName("input")[0].checked = false;
                        }
                    }
                    ch++;
                }
            }
        }
    }
}

//字段选择
dhtmlXGridObject.prototype.setChecked = function (colId, t, rowId) {
    //求单元格范围
    var clickFakeRowObj = t.parentNode.parentNode;
    var fakeRowsObj = t.parentNode.parentNode.parentNode.childNodes;
    var realRowsObj =this.hwReport.headers;
	for(var i=0;i<realRowsObj.length;i++){
		var h=realRowsObj[i];
		if(typeof h[0]=="string"){
			var s=h[0].split(',');
			h[0]=s;
		}
	}
    var colsNum = 1, star = 0, end = 0;
    rowId = parseInt(rowId);
    colId = parseInt(colId);

    for (var i = colId + 1; i < realRowsObj[rowId - 2][0].length; i++) {
        if (realRowsObj[rowId - 2][0][i].match(/#cspan*/) &&
            realRowsObj[rowId - 2][0][i].match(/#cspan*/)[0]) {
            colsNum++;
        } else {
            break;
        }
    }

    star = colId;
    end = colId + colsNum - 1;

    //设置下面行的复选框全部选中或者不选中(除去最后一行)
    for (var i = rowId - 1; i < realRowsObj.length - 1; i++) {
        var checkId = 0;
        for (var j = star; j <= end; j++) {
            if (realRowsObj[i][0][j].match(/^(?!#cspan|#rspan).*/i) &&
                realRowsObj[i][0][j].match(/^(?!#cspan|#rspan).*/i)[0]) {

                if (fakeRowsObj[i + 2].childNodes[checkId].getElementsByTagName("input")[0]) {
                    fakeRowsObj[i + 2].childNodes[checkId].getElementsByTagName("input")[0].checked = true;
                }
                checkId++;
            } else {
                continue;
            }
        }
    }

    //设置最后一行范围内的复选框选中
    for (var i = star; i <= end; i++) {
        if (fakeRowsObj[fakeRowsObj.length - 1].childNodes[i].getElementsByTagName("input")[0]) {
            fakeRowsObj[fakeRowsObj.length - 1].childNodes[i].getElementsByTagName("input")[0].checked = true;
        }
        //删除隐藏列
        this.delHiddenFields(i);
    }

    //此复选框选中时上面行的复选框选中处理
    for (var i = rowId; i >= 2; i--) {
        var checkId = 0, rowStar, rowEnd;
        var cellVal;
        for (var j = star; j >= 0; j--) {
            //向前找找到本单元格开始坐标
            if (realRowsObj[i - 2][0][j].match(/[^#cspan|#rspan]*/gi) &&
                realRowsObj[i - 2][0][j].match(/[^#cspan|#rspan]*/gi)[0]) {
                rowStar = j;
                for (var a = 0; a <= rowStar; a++) {
                    //start add 20141220
                    cellVal = realRowsObj[i - 2][0][a];
                    if (realRowsObj[i - 2][0][a] == "") {
                        realRowsObj[i - 2][0][a] = "true";
                    }
                    //end
                    if (realRowsObj[i - 2][0][a].match(/[^#cspan|#rspan]*/gi) &&
                        realRowsObj[i - 2][0][a].match(/[^#cspan|#rspan]*/gi)[0]) {
                        //add
                        realRowsObj[i - 2][0][a] = cellVal;
                        //
                        checkId++;
                    }
                }
                if (fakeRowsObj[i].childNodes[checkId - 1].getElementsByTagName("input")[0]) {
                    fakeRowsObj[i].childNodes[checkId - 1].getElementsByTagName("input")[0].checked = true;
                }

                break;
            }
        }
    }
}

//字段选择
dhtmlXGridObject.prototype.setNoChecked = function (colId, t, rowId) {

    //求单元格范围
    var clickFakeRowObj = t.parentNode.parentNode;
    var fakeRowsObj = t.parentNode.parentNode.parentNode.childNodes;
    var realRowsObj =this.hwReport.headers;
	for(var i=0;i<realRowsObj.length;i++){
		var h=realRowsObj[i];
		if(typeof h[0]=="string"){
			var s=h[0].split(',');
			h[0]=s;
		}
	}
    var colsNum = 1, star = 0, end = 0;
    rowId = parseInt(rowId);
    colId = parseInt(colId);

    var lastRowNum = fakeRowsObj.length - 1;

    for (var i = colId + 1; i < realRowsObj[rowId - 2][0].length; i++) {
        if (realRowsObj[parseInt(rowId) - 2][0][i].match(/#cspan*/) &&
            realRowsObj[parseInt(rowId) - 2][0][i].match(/#cspan*/)[0]) {
            colsNum++;
        } else {
            break;
        }
    }

    star = colId;
    end = colId + colsNum - 1;

    //设置下面行的复选框全部选中或者不选中(除去最后一行)
    for (var i = rowId - 1; i < realRowsObj.length - 1; i++) {
        var checkId = 0;
        for (var j = star; j <= end; j++) {
            if (realRowsObj[i][0][j].match(/^(?!#cspan|#rspan).*/i) &&
                realRowsObj[i][0][j].match(/^(?!#cspan|#rspan).*/i)[0]) {

                if (fakeRowsObj[i + 2].childNodes[checkId].getElementsByTagName("input")[0]) {
                    fakeRowsObj[i + 2].childNodes[checkId].getElementsByTagName("input")[0].checked = false;
                }
                checkId++;
            } else {
                continue;
            }
        }
    }

    //设置最后一行范围内的复选框选中与不选中
    for (var i = star; i <= end; i++) {
        if (fakeRowsObj[fakeRowsObj.length - 1].childNodes[i].getElementsByTagName("input")[0]) {
            fakeRowsObj[fakeRowsObj.length - 1].childNodes[i].getElementsByTagName("input")[0].checked = false;
        }
        //添加隐藏列
        this.addHiddenFields(i);
    }

    //debugger

    //此复选框未选中时上面行的复选框选中与未选中处理
    for (var i = rowId - 1; i >= 2; i--) {
        var checkId = 0, rowStar, rowEnd;
        //向前找找到本单元格开始坐标
        for (var j = star; j >= 0; j--) {
            if (realRowsObj[i - 2][0][j].match(/[^#cspan|#rspan]*/gi) &&
                realRowsObj[i - 2][0][j].match(/[^#cspan|#rspan]*/gi)[0]) {
                rowStar = j;
                break;
            }
        }
        //向后找找到本单元格结束坐标
        for (var b = end; b < realRowsObj[i - 2][0].length; b++) {
            if (realRowsObj[i - 2][0][b].match(/[^#cspan|#rspan]*/gi) &&
                realRowsObj[i - 2][0][b].match(/[^#cspan|#rspan]*/gi)[0]) {
                rowEnd = b - 1;
                break;
            } else {
                rowEnd = b;
            }
        }

        var checked = false;
        for (var d = 0; d <= rowEnd; d++) {
            if (realRowsObj[i - 1][0][d].match(/[^#cspan|#rspan]*/gi) &&
                realRowsObj[i - 1][0][d].match(/[^#cspan|#rspan]*/gi)[0]) {
                if (d >= rowStar && d <= rowEnd) {
                    if (fakeRowsObj[i + 1].childNodes[checkId].getElementsByTagName("input")[0]) {
                        if (fakeRowsObj[i + 1].childNodes[checkId].getElementsByTagName("input")[0].checked) {
                            checked = true;
                        }
                    }
                }
                checkId++;
            }
        }

        //判断最后一行在范围内的复选框是否选中
        for (var a = rowStar; a <= rowEnd; a++) {

            if (fakeRowsObj[lastRowNum].childNodes[a].getElementsByTagName("input")[0].checked) {
                checked = true;
            }
        }

        //设置上面一行选中与未选中
        var ch = 0;
        if (checked) {
            for (var d = 0; d <= rowEnd; d++) {
                if (realRowsObj[i - 2][0][d].match(/[^#cspan|#rspan]*/gi) &&
                    realRowsObj[i - 2][0][d].match(/[^#cspan|#rspan]*/gi)[0]) {
                    if (d >= rowStar && d <= rowEnd) {
                        if (fakeRowsObj[i].childNodes[ch].getElementsByTagName("input")[0]) {
                            fakeRowsObj[i].childNodes[ch].getElementsByTagName("input")[0].checked = true;
                        }
                    }
                    ch++;
                }
            }
        } else {
            var cellVal;
            for (var d = 0; d <= rowEnd; d++) {
                //start 20141220
                cellVal = realRowsObj[i - 2][0][d];
                if (realRowsObj[i - 2][0][d] == "") {
                    realRowsObj[i - 2][0][d] = "true";
                }
                //end
                if (realRowsObj[i - 2][0][d].match(/[^#cspan|#rspan]*/gi) &&
                    realRowsObj[i - 2][0][d].match(/[^#cspan|#rspan]*/gi)[0]) {

                    realRowsObj[i - 2][0][d] = cellVal;

                    if (d >= rowStar && d <= rowEnd) {
                        fakeRowsObj[i].childNodes[ch].getElementsByTagName("input")[0].checked = false;
                    }
                    //fakeRowsObj[i].childNodes[ch].getElementsByTagName("input")[0].checked = false;
                    ch++;
                }
            }
        }
    }
}

//添加隐藏列信息字段选择
dhtmlXGridObject.prototype.addHiddenFields = function (colId) {
    var bool = false;
    //判断隐藏列是否为空
    if (hiddenFields) {
        for (var i = 0; i < hiddenFields.length; i++) {
            if (hiddenFields[i] == colId) {
                bool = true;
            }
        }
        if (!bool) {
            hiddenFields.push(colId);
        }
    } else {
        hiddenFields.push(colId);
    }

    //设置隐藏列
    if (gridHeaderBottom) {
        gridHeaderBottom.grid.setColumnHiddenForHeader(colId, true);
    }
}
/**
 * @param rowId
 * @param star
 * @param realRowsObj 字段选择
 */
dhtmlXGridObject.prototype.getRowStar = function (rowId, star, realRowsObj) {
    for (var j = star; j >= 0; j--) {
        if (realRowsObj[rowId - 3][0][j].match(/#[^c]span|[^#cspan]*/) &&
            realRowsObj[rowId - 3][0][j].match(/#[^c]span|[^#cspan]*/)[0]) {
            rowStar = j;
            return rowStar;
        }
    }
}

/**
 * @param rowId
 * @param end
 * @param realRowsObj 字段选择
 */
dhtmlXGridObject.prototype.getRowEnd = function (rowId, end, realRowsObj) {
    var num = 0, rowEnd, rowNumEnd;
    for (var i = rowId -3; i >= 0; i--) {
        for (var b = end; b < realRowsObj[i][0].length; b++) {
            //if (realRowsObj[i][0][b].match(/[^#rspan]|[^#cspan]*/) &&
            //    realRowsObj[i][0][b].match(/[^#rspan]|[^#cspan]*/)[0]) {

            if (realRowsObj[i][0][b].match(/#[^c]span|[^#cspan]*/) &&
                realRowsObj[i][0][b].match(/#[^c]span|[^#cspan]*/)[0]) {
                if (num == 0) {
                    rowEnd = b;
                    return rowEnd;
                } else {
                    rowNumEnd = b;
                    return rowNumEnd;
                }
            }
        }
        num++;
    }

    //for (var i = rowId - 4; i >= 0; i--) {
    //    for (var b = end + 1; b < realRowsObj[i][0].length; b++) {
    //        //if (realRowsObj[i][0][b].match(/[^#rspan]|[^#cspan]*/) &&
    //        //    realRowsObj[i][0][b].match(/[^#rspan]|[^#cspan]*/)[0]) {

    //        if (realRowsObj[i][0][b].match(/#[^c]span|[^#cspan]*/) &&
    //                realRowsObj[i][0][b].match(/#[^c]span|[^#cspan]*/)[0]) {
    //            if (num == 0) {
    //                rowEnd = b - 1;
    //                return rowEnd;
    //            } else {
    //                rowNumEnd = b - 1;
    //                return rowNumEnd;
    //            }
    //        }
    //    }
    //    num++;
    //}
}

//删除隐藏列信息  字段选择
dhtmlXGridObject.prototype.delHiddenFields = function (colId) {
    //debugger
    for (var i = 0; i < hiddenFields.length; i++) {
        if (hiddenFields[i] == colId) {
            hiddenFields.splice(i, 1);
        }
    }

    //设置显示列
    if (gridHeaderBottom) {
        gridHeaderBottom.grid.setColumnHiddenForHeader(colId, false);
    }
}
/**
 * 隐藏表头列
 * @param ind （隐藏列）
 * @param state （显示还是隐藏）
 * @returns {*}字段选择
 */
dhtmlXGridObject.prototype.setColumnHiddenForHeader = function (ind, state) {
    //debugger
    if (!this.hdr.rows.length) {
        if (!this._ivizcol)
            this._ivizcol = [];
        return this._ivizcol[ind] = state;
    }

    if ((this.fldSorted) && (this.fldSorted.cellIndex == ind) && (state))
        this.sortImg.style.display = "none";

    var f = convertStringToBoolean(state);

    if (f) {
        if (!this._hrrar)
            this._hrrar = new Array();

        else if (this._hrrar[ind])
            return;
        this._hrrar[ind] = "display:none;";
        this._hideShowColumnForHeader(ind, "none");
    } else {
        if ((!this._hrrar) || (!this._hrrar[ind]))
            return;
        this._hrrar[ind] = "";
        this._hideShowColumnForHeader(ind, "");
    }

    if ((this.fldSorted) && (this.fldSorted.cellIndex == ind) && (!state))
        this.sortImg.style.display = "inline";

    this.setSortImgPos();
    this.setSizes();
    this.callEvent("onColumnHidden", [ind, state])
}

function convertStringToBoolean(inputString){
    if (typeof (inputString) == "string")
        inputString=inputString.toLowerCase();

    switch (inputString){
        case "1":
        case "true":
        case "yes":
        case "y":
        case 1:
        case true:
            return true;
            break;

        default: return false;
    }
}
/**
 *   @desc: hide column
 *   @param: ind - column index
 *   @param: state - hide/show
 *   @edition: Professional
 *   @type:  private
 *字段选择
 */
dhtmlXGridObject.prototype._hideShowColumnForHeader = function (ind, state) {
    var hind = ind;

    if (this.hdr.rows[1] && (this.hdr.rows[1]._childIndexes) && (this.hdr.rows[1]._childIndexes[ind] != ind)) {
        hind = this.hdr.rows[1]._childIndexes[ind];
    }

    if (state == "none") {
        this.hdr.rows[0].cells[ind]._oldWidth = this.hdr.rows[0].cells[ind].style.width || (this.initCellWidth[ind] + "px");
        this.hdr.rows[0].cells[ind]._oldWidthP = this.cellWidthPC[ind];
        this.obj.rows[0].cells[ind].style.width = "0px";

        var t = { rows: [this.obj.rows[0]] }
        this.forEachRow(function (id) {
            if (this.rowsAr[id].tagName == "TR")
                t.rows.push(this.rowsAr[id])
        })
        this._fixHiddenRowsAll(t, ind, "display", "none");

        if (this.isTreeGrid())
            this._fixHiddenRowsAllTG(ind, "none");
        //  if ((_isOpera && _OperaRv < 9) || _isKHTML || (_isFF)) {
        //   if ((_isOpera && _OperaRv < 9) || _isKHTML ) {
        //   this._fixHiddenRowsAll(this.hdr, ind, "display", "none", "_cellIndexS");
        //   }
        if ((_isOpera && _OperaRv < 9) || _isKHTML || (_isFF)) {
            this._fixHiddenRowsAll(this.hdr, ind, "display", "none", "_cellIndexS");
        }else{
            this._fixHiddenRowsAll(this.hdr, ind, "display", "none");
        }
        if (this.ftr)
            this._fixHiddenRowsAll(this.ftr.childNodes[0], ind, "display", "none");
        this._fixHiddenRowsAll(this.hdr, ind, "whiteSpace", "nowrap", "_cellIndexS");

        if (!this.cellWidthPX.length && !this.cellWidthPC.length)
            this.cellWidthPX = [].concat(this.initCellWidth);

        if (this.cellWidthPX[ind])
            this.cellWidthPX[ind] = 0;

        if (this.cellWidthPC[ind])
            this.cellWidthPC[ind] = 0;
    } else {
        if (this.hdr.rows[0].cells[ind]._oldWidth) {
            var zrow = this.hdr.rows[0].cells[ind];

            if (_isOpera || _isKHTML || (_isFF))
                this._fixHiddenRowsAll(this.hdr, ind, "display", "", "_cellIndexS");

            if (this.ftr)
                this._fixHiddenRowsAll(this.ftr.childNodes[0], ind, "display", "");


            var t = { rows: [this.obj.rows[0]] }
            this.forEachRow(function (id) {
                if (this.rowsAr[id].tagName == "TR")
                    t.rows.push(this.rowsAr[id])
            })
            this._fixHiddenRowsAll(t, ind, "display", "");

            if (this.isTreeGrid())
                this._fixHiddenRowsAllTG(ind, "");

            this._fixHiddenRowsAll(this.hdr, ind, "whiteSpace", "normal", "_cellIndexS");

            if (zrow._oldWidthP)
                this.cellWidthPC[ind] = zrow._oldWidthP;

            if (zrow._oldWidth)
                this.cellWidthPX[ind] = parseInt(zrow._oldWidth);
        }
    }
    //debugger
    this.setSizeForHeader();
    if ((!_isIE) && (!_isFF)) {
        //dummy Opera/Safari fix
        this.obj.border = 1;
        this.obj.border = 0;
    }
}


/**
 * 设置表头样式（长，宽，高）字段选择
 */
dhtmlXGridObject.prototype.setSizeForHeader = function () {
    //drop processing if grid still not initialized
    if ((!this.hdr.rows[0])) return;

    //debugger
    var quirks = this.quirks = (_isIE && document.compatMode == "BackCompat");

    var outerBorder = (this.entBox.offsetWidth - this.entBox.clientWidth) / 2;

    if (!this.dontSetSizes) {
        if (this.globalBox) {
            var splitOuterBorder = (this.globalBox.offsetWidth - this.globalBox.clientWidth) / 2;
            if (this._delta_x && !this._realfake) {
                var ow = this.globalBox.clientWidth;
                this.globalBox.style.width = this._delta_x;
                this.entBox.style.width = Math.max(0, (this.globalBox.clientWidth + (quirks ? splitOuterBorder * 2 : 0)) - this._fake.entBox.clientWidth) + "px";
                if (ow != this.globalBox.clientWidth) {
                    this._fake._correctSplit(this._fake.entBox.clientWidth);
                }
            }
            if (this._delta_y && !this._realfake) {
                this.globalBox.style.height = this._delta_y;
                this.entBox.style.overflow = this._fake.entBox.style.overflow = "hidden";
                this.entBox.style.height = this._fake.entBox.style.height = this.globalBox.clientHeight + (quirks ? splitOuterBorder * 2 : 0) + "px";
            }
        } else {
            if (this._delta_x) {
                /*when placed directly in TD tag, container can't use native percent based sizes,
                 because table auto-adjust to show all content - too clever*/
                if (this.entBox.parentNode && this.entBox.parentNode.tagName == "TD") {
                    this.entBox.style.width = "1px";
                    this.entBox.style.width = parseInt(this._delta_x) * this.entBox.parentNode.clientWidth / 100 - outerBorder * 2 + "px";
                } else
                    this.entBox.style.width = this._delta_x;
            }
            if (this._delta_y)
                this.entBox.style.height = this._delta_y;
        }
    }

    //if we have container without sizes, wait untill sizes defined
    window.clearTimeout(this._sizeTime);
    if (!this.entBox.offsetWidth && (!this.globalBox || !this.globalBox.offsetWidth)) {
        this._sizeTime = window.setTimeout(function () {
            if (self.setSizes)
                self.setSizes();
        }, 250);
        return;
    }

    var border_x = ((!this._wthB) && ((this.entBox.cmp || this._delta_x) && (this.skin_name || "").indexOf("dhx") == 0 && !quirks) ? 2 : 0);
    var border_y = ((!this._wthB) && ((this.entBox.cmp || this._delta_y) && (this.skin_name || "").indexOf("dhx") == 0 && !quirks) ? 2 : 0);

    if (this._sizeFix) {
        border_x -= this._sizeFix;
        border_y -= this._sizeFix;
    }

    var isVScroll = this.parentGrid ? false : (this.objBox.scrollHeight > this.objBox.offsetHeight);

    var scrfix = dhtmlx.$customScroll ? 0 : 18;
    //debugger
    var gridWidth = this.entBox.clientWidth - (this.skin_h_correction || 0) * (quirks ? 0 : 1) - border_x;
    var gridWidthActive = this.entBox.clientWidth - (this.skin_h_correction || 0) - border_x;
    var gridHeight = this.entBox.clientHeight - border_y;
    var summ = this.setColumnSizes(gridWidthActive - (isVScroll ? scrfix : 0) - (this._correction_x || 0));
    var isHScroll = this.parentGrid ? false : ((this.objBox.scrollWidth > this.objBox.offsetWidth) || (this.objBox.style.overflowX == "scroll"));
    var headerHeight = this.hdr.clientHeight;
    var footerHeight = this.ftr ? this.ftr.clientHeight : 0;
    var newWidth = gridWidth;
    var newHeight = gridHeight - headerHeight - footerHeight;

    //if we have auto-width without limitations - ignore h-scroll
    if (this._awdth && this._awdth[0] && this._awdth[1] == 99999) isHScroll = 0;
    //auto-height
    if (this._ahgr) {
        if (this._ahgrMA)
            newHeight = this.entBox.parentNode.clientHeight - headerHeight - footerHeight;
        else
            newHeight = this.obj.offsetHeight + (isHScroll ? scrfix : 0) + (this._correction_y || 0);

        if (this._ahgrM) {
            if (this._ahgrF)
                newHeight = Math.min(this._ahgrM, newHeight + headerHeight + footerHeight) - headerHeight - footerHeight;
            else
                newHeight = Math.min(this._ahgrM, newHeight);

        }
        if (isVScroll && newHeight >= this.obj.scrollHeight + (isHScroll ? scrfix : 0)) {
            isVScroll = false;//scroll will be compensated;
            this.setColumnSizes(gridWidthActive - (this._correction_x || 0)); //correct auto-size columns
        }
    }

    //auto-width
    if ((this._awdth) && (this._awdth[0])) {
        //convert percents to PX, because auto-width with procents has no sense
        if (this.cellWidthType == '%') this.cellWidthType = "px";

        if (this._fake) summ += this._fake.entBox.clientWidth;	//include fake grid in math
        var newWidth = Math.min(Math.max(summ + (isVScroll ? scrfix : 0), this._awdth[2]), this._awdth[1]) + (this._correction_x || 0);
        this.objBox.style.overflowX = (!isVScroll && this.objBox.scrollWidth <= newWidth) ? "hidden" : "auto";
        if (this._fake) newWidth -= this._fake.entBox.clientWidth;
    }

    newHeight = Math.max(0, newHeight);//validate value for IE

    //FF3.1, bug in table rendering engine
    this._ff_size_delta = (this._ff_size_delta == 0.1) ? 0.2 : 0.1;
    if (!_isFF) this._ff_size_delta = 0;


    if (!this.dontSetSizes) {
        this.entBox.style.width = Math.max(0, newWidth + (quirks ? 2 : 0) * outerBorder + this._ff_size_delta) + "px";
        this.entBox.style.height = newHeight + (quirks ? 2 : 0) * outerBorder + headerHeight + footerHeight + "px";
    }
    //debugger
    this.objBox.style.height = newHeight + "px";
    this.hdrBox.style.height = headerHeight + "px";
    //alert(headerHeight);

    if (newHeight != gridHeight)
        this.doOnScroll(0, !this._srnd);
    var ext = this["setSizes_" + this.skin_name];
    if (ext) ext.call(this);

    this.setSortImgPos();
    //debugger
    //it possible that changes of size, has changed header height
    if (headerHeight == this.hdr.clientHeight && this._ahgr)
        this.setSizeForHeader(judge);
    this.callEvent("onSetSizes", []);
};

//设定复选框全选与全不选  字段选择
dhtmlXGridObject.prototype.setAllCheckBoxChecked = function () {

    var mode = arguments.length ? arguments[0] : 1;

    var checkbox = getCheckBox();
    var lastRowNodes = checkbox[checkbox.length - 1].parentNode.parentNode.parentNode.childNodes;
    //行数
    var rowsNum = checkbox[checkbox.length - 1].parentNode.parentNode.parentNode.parentNode.childNodes.length;

    var fakeRowsObj = checkbox[checkbox.length - 1].parentNode.parentNode.parentNode.parentNode.childNodes;
    var realRowsObj =this.hwReport.headers;
	for(var i=0;i<realRowsObj.length;i++){
		var h=realRowsObj[i];
		if(typeof h[0]=="string"){
			var s=h[0].split(',');
			h[0]=s;
		}
	}

    if (mode) {
        //for (var i = 0; i < $(":checkbox").length; i++) {
        //    $(":checkbox")[i].checked = true;
        //}

        //非最后一行复选框处理
        for (var i = 2; i < rowsNum; i++) {
            if(i-2>=realRowsObj.length)
                break;
            var checkId = 0,
                cellVal;
            for (var a = 0; a < lockColNum; a++) {
                //start 20141220
                cellVal = realRowsObj[i - 2][0][a];
                if (realRowsObj[i - 2][0][a] == "") {
                    realRowsObj[i - 2][0][a] = "true";
                }
                //end
                if (realRowsObj[i - 2][0][a].match(/^(?!#cspan|#rspan).*/i) &&
                    realRowsObj[i - 2][0][a].match(/^(?!#cspan|#rspan).*/i)[0]) {

                    realRowsObj[i - 2][0][a] = cellVal;
                    checkId++;
                } else {
                    continue;
                }
            }
            for (var b = lockColNum; b < lastRowNodes.length; b++) {
                if (realRowsObj[i - 2][0][b].match(/^(?!#cspan|#rspan).*/i) &&
                    realRowsObj[i - 2][0][b].match(/^(?!#cspan|#rspan).*/i)[0]) {

                    if (fakeRowsObj[i].childNodes[checkId].getElementsByTagName("input")[0]) {
                        fakeRowsObj[i].childNodes[checkId].getElementsByTagName("input")[0].checked = true;
                    }
                    checkId++;
                } else {
                    continue;
                }
            }
        }

        //最后一行复选框处理
        for (var i = 0; i < lastRowNodes.length; i++) {
            if (i < lockColNum) {
                continue;
            }
            lastRowNodes[i].getElementsByTagName("input")[0].checked = true;
        }

        for (var i = lockColNum; i < lastRowNodes.length; i++) {
            //删除隐藏列
            this.delHiddenFields(i);
        }
    } else {
        //for (var i = 0; i < $(":checkbox").length; i++) {
        //    $(":checkbox")[i].checked = false;
        //}

        //非最后一行复选框处理
        for (var i = 2; i < rowsNum; i++) {
            if(i-2>=realRowsObj.length)
                break;
            var checkId = 0,
                cellVal;
            for (var a = 0; a < lockColNum; a++) {
                //start 20141220
                cellVal = realRowsObj[i - 2][0][a];
                if (realRowsObj[i - 2][0][a] == "") {
                    realRowsObj[i - 2][0][a] = "true";
                }
                //end
                if (realRowsObj[i - 2][0][a].match(/^(?!#cspan|#rspan).*/i) &&
                    realRowsObj[i - 2][0][a].match(/^(?!#cspan|#rspan).*/i)[0]) {

                    realRowsObj[i - 2][0][a] = cellVal;
                    checkId++;
                } else {
                    continue;
                }
            }
            for (var b = lockColNum; b < lastRowNodes.length; b++) {
                if (realRowsObj[i - 2][0][b].match(/^(?!#cspan|#rspan).*/i) &&
                    realRowsObj[i - 2][0][b].match(/^(?!#cspan|#rspan).*/i)[0]) {

                    if (fakeRowsObj[i].childNodes[checkId].getElementsByTagName("input")[0]) {
                        fakeRowsObj[i].childNodes[checkId].getElementsByTagName("input")[0].checked = false;
                    }
                    checkId++;
                } else {
                    continue;
                }
            }
        }

        //最后一行复选框处理
        for (var i = 0; i < lastRowNodes.length; i++) {
            if (i < lockColNum) {
                continue;
            }
            lastRowNodes[i].getElementsByTagName("input")[0].checked = false;
        }

        for (var i = lockColNum; i < lastRowNodes.length; i++) {
            //添加隐藏列
            this.addHiddenFields(i);
        }
    }
}

//源文件修改
//dhtmlxgrid_splt.js
/*
1.360急速浏览器下如果一行都被上一行合并，tr中不添加td元素导致同步锁定列表头时陷入死循环的问题
这里又改回来了
  ——275行：if (_isIE || _isOpera) {  ==》if (_isIE || (_isFF && _FFrv >= 1.9) || _isOpera) {   
2.添加表头类名设置
 ——61行添加以下代码
    this._fake.hwReport = this.hwReport;
    this._fake.__class = this.__class || [];
    this._fake.__attrs = this.__attrs || [];
    var setColumnLabel = this._fake.setColumnLabel;
    this._fake.setColumnLabel = function (c, label, ind, hdr) {
        setColumnLabel.apply(this, [c, label, ind, hdr]);
        var z = (hdr || this.hdr).rows[ind || 1];
        var col = (z._childIndexes ? z._childIndexes[c] : c);
        if (!z.cells[col]) return;
        if (!this.useImagesInHeader) {
            if (this.__class[c]) {
                z.cells[col].className = this.__class[c];
            }
            if (this.__attrs[c]) {
                z.cells[col]._attrs = this.__attrs[c];
                z.cells[col].firstChild._attrs = this.__attrs[c];

                var originCell = this.hwReport.getOriginCellById(this.__attrs[c].sid);
                if (originCell.getType() == "vmdlink") {
                    z.cells[col].grid = this;
                    z.cells[col].firstChild._cellType = originCell.getType();
                    var aeditor = this.cells4(z.cells[col].firstChild);

                    if (aeditor) aeditor.setValue(label);
                }
            }
        }
    }
3.同步锁定列与非锁定列行高
  ——302添加以下代码
  if (frows[i].clientHeight != rows[i].clientHeight) {
    frows[i].style.height = Math.max(rows[i].clientHeight, frows[i].clientHeight) + 'px';
    rows[i].style.height = Math.max(rows[i].clientHeight, frows[i].clientHeight) + 'px';
  }
4.有锁定列时，滚动加载时第一屏和滚动加载的屏行高不一致：
    ——1180行
    this.rowsAr[id].style.height = this._fake.rowsAr[id].style.height = Math.round(max + 1) + "px";
    改成：
    this.rowsAr[id].style.height = this._fake.rowsAr[id].style.height = Math.round(max) + "px";
    ——1195行 注释掉
*/

//datastore.js
/*
1.添加菜单与dhtmlxDataStore的绑定
    ——3471行 if (window.dhtmlXMenuObject){...}
2.修改数据集序列化方法
    ——2337行，添加参数rule 添加代码
    else if (rule) {
			    for (var key in rule) {
			        el[key] = el[rule[key]];
			    }
			}
    ——3007行
     combo.addOption(this.serialize()); ==》combo.addOption(this.serialize(rule));
*/;
///<jscompress sourcefile="dhtmlxtreegrid.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

/**
*   @desc: switch current row state (collapse/expand) tree grid row
*   @param: obj - row object
*   @type: private
*/
dhtmlXGridObject.prototype._updateTGRState=function(z){ 
	if (!z.update || z.id==0) return;
	if (this.rowsAr[z.id].imgTag)
	this.rowsAr[z.id].imgTag.src=this.iconTree+z.state+".gif";
	z.update=false;
}


dhtmlXGridObject.prototype.doExpand=function(obj){  
	this.editStop();
    var row = obj.parentNode.parentNode.parentNode;
	var r=this._h2.get[row.idd];
	if (!this.callEvent("onOpen",[row.idd,(r.state=="plus"?-1:1)])) return;
    if(r.state=="plus")
      this.expandKids(row)
    else
   	  if((r.state=="minus")&&(!r._closeable))
          this.collapseKids(row)
}


dhtmlXGridObject.prototype._createHierarchy=function(){  
	if (!this._emptyLineImg)
		this._emptyLineImg =  "blank";

	return new dhtmlxHierarchy({ _emptyLineImg : this._emptyLineImg });
}

function dhtmlxHierarchy(config){
		var z={id:0, childs:[], level:-1, parent:null, index:0, state:config._emptyLineImg};
		this.order=[z];
		this.get={"0":z};

		this.swap=function(a,b){
			var p=a.parent;
			var z=a.index;
			p.childs[z]=b;
			p.childs[b.index]=a;
			a.index=b.index; b.index=z;
		}
		this.forEachChildF=function(id,funct,that,funct2){
			var z=this.get[id];
			for (var i=0; i<z.childs.length; i++){
				if (!funct.apply((that||this),[z.childs[i]])) continue;
				if (z.childs[i].childs.length) this.forEachChildF(z.childs[i].id,funct,that,funct2);
				if (funct2) funct2.call((that||this),z.childs[i]);
			}
		}
		this.forEachChild=function(id,funct,that){
				var z=this.get[id];
				for (var i=0; i<z.childs.length; i++){
					funct.apply((that||this),[z.childs[i]]);
					if (z.childs[i].childs.length) this.forEachChild(z.childs[i].id,funct,that);
				}
		}
		this.change=function(id,name,val){
			var z=this.get[id];
			if (z[name]==val) return;
				z[name]=val;
				z.update=true;
		}
		this.add=function(id,parentId){ 
			return this.addAfter(id,parentId);
		}
		this.addAfter=function(id,parentId,afterId,fix){  
			var z=this.get[parentId||0];
			if (afterId)
				var ind=this.get[afterId].index+(fix?0:1);
			else var ind=z.childs.length;
			
			var x={id:id, childs:[], level:z.level+1, parent:z, index:ind, state:config._emptyLineImg}
			if (z.state==config._emptyLineImg)  this.change(parentId,"state",(parentId==0?"minus":"plus"));
			
			if (afterId){
				for (var i=ind; i<z.childs.length; i++) z.childs[i].index++;
				z.childs=z.childs.slice(0,ind).concat([x]).concat(z.childs.slice(ind,z.childs.length));
			}else
				z.childs.push(x);
			this.get[id]=x;
			return x;
		}
		this.addBefore=function(id,parentId,beforeId){
			return this.addAfter(id,parentId,beforeId,true)
		}		
		this.remove=function(id){  
			var z=this.get[id||0];
			for (var i=0; i<z.childs.length; i++)
				this.deleteAll(z.childs[i].id)
			z.childs=[];	
			z.parent.childs=z.parent.childs.slice(0,z.index).concat(z.parent.childs.slice(z.index+1));				
			for (var i=z.index; i<z.parent.childs.length; i++)
				z.parent.childs[i].index--;
			delete this.get[id];
		}
		this.deleteAll=function(id){
			var z=this.get[id||0];
			for (var i=0; i<z.childs.length; i++)
				this.deleteAll(z.childs[i].id)
				
			z.childs=[];				
			delete this.get[id];
		}		
		
		return this;
	}

dhtmlXGridObject.prototype._getOpenLenght=function(id,start){
	
	var z=this._h2.get[id].childs;
	start+=z.length;
	for (var i=0; i<z.length; i++)
		if (z[i].childs.length && z[i].state=='minus')
			start+=this._getOpenLenght(z[i].id,0);
	return start;
}
/**
*   @desc: close row of treegrid (removes kids from dom)
*   @param: curRow - row to process kids of
*   @type: private
*/
dhtmlXGridObject.prototype.collapseKids=function(curRow){ 
	var r=this._h2.get[curRow.idd];
    if (r.state!="minus") return;
    if (!this.callEvent("onOpenStart",[curRow.idd,1])) return;

    var start = curRow.rowIndex;
    //why Safari doesn't support standards?
    if (start<0) start=this.rowsCol._dhx_find(curRow)+1;

   	this._h2.change(r.id,"state","plus");
   	this._updateTGRState(r);

    if (this._srnd || this.pagingOn){
    	this._h2_to_buff();
    	this._renderSort();
    } else {
    var len=this._getOpenLenght(this.rowsCol[start-1].idd,0);
    for (var i=0; i<len; i++)
    	this.rowsCol[start+i].parentNode.removeChild(this.rowsCol[start+i]);
    this.rowsCol.splice(start,len);
	}

    //if (this._cssEven && !this._cssSP)
    this.callEvent("onGridReconstructed",[]);

    this.setSizes();
    this._h2_to_buff();
    this.callEvent("onOpenEnd",[curRow.idd,-1]);
}



dhtmlXGridObject.prototype._massInsert=function(r,start,ind,skip){  
	var anew=[];
	var par=(_isKHTML?this.obj:this.obj.rows[0].parentNode)
	this._h2_to_buff();
	if (this._srnd || this.pagingOn) return this._renderSort();
	var len=this._getOpenLenght(r.id,0);
	for(var i=0;i<len;i++){
		var ra=this.render_row(ind+i);
		if (start)
			start.parentNode.insertBefore(ra,start);
		else
			par.appendChild(ra);
		anew.push(ra)
		}
	this.rowsCol=dhtmlxArray(this.rowsCol.slice(0,ind).concat(anew).concat(this.rowsCol.slice(ind)));
	
	return r.childs.length+anew.length;
}
/**
*   @desc: change parent of row, correct kids collections
*   @param: curRow - row to process
*   @type: private
*/
dhtmlXGridObject.prototype.expandKids=function(curRow,sEv){

	var r=this._h2.get[curRow.idd];
	if ((!r.childs.length)&&(!r._xml_await)) return;
	if (r.state!="plus") return;
    
    
    if (!r._loading && !sEv)
    	if (!this.callEvent("onOpenStart",[r.id,-1])) return;
        


   var start = this.getRowIndex(r.id)+1;
   if(r.childs.length){
        r._loading=false;
        this._h2.change(r.id,"state","minus")
        this._updateTGRState(r);
		var len=this._massInsert(r,this.rowsCol[start],start);
		
		//if (this._cssEven && !this._cssSP)
		this.callEvent("onGridReconstructed",[]);
			

   }else{	
        if (r._xml_await){
			r._loading=true;
			if (this.callEvent("onDynXLS",[r.id]))
				this.load(this.kidsXmlFile+""+(this.kidsXmlFile.indexOf("?")!=-1?"&":"?")+"id="+encodeURIComponent(r.id), this._data_type);
        }
   }
    this.setSizes();
    if (!r._loading)
    this.callEvent("onOpenEnd",[r.id,1]);
    this._fixAlterCss();
}

dhtmlXGridObject.prototype.kidsXmlFile = "";



/**
*   @desc: sorts treegrid by specified column
*   @param: col - column index
*   @param:   type - str.int.date
*   @param: order - asc.desc
*   @type: public
*   @edition: Professional
*   @topic: 2,3,5,9
*/
dhtmlXGridObject.prototype.sortTreeRows = function(col,type,order){
				var amet="getValue";
				if (this.cells5({parentNode:{grid:this}},this.getColType(col)).getDate){ //FIXME! move inside cells5 in 2.2
					amet="getDate";
					type="str";
				}		
					

	            this.forEachRow(function(id){
                	var z=this._h2.get[id];
                	if (!z) return;
                	
                	var label=this._get_cell_value(z.buff,col,amet);
                	if(type=='int'){
						   z._sort=parseFloat(label);
						   z._sort=isNaN(z._sort)?-99999999999999:z._sort;
                     }else
                        z._sort=label;
                	});
                	
				var self=this;
				var pos=1; var neg=-1;
				if (order=="des") { pos=-1; neg=1; }
					
				var funct=null;
				if (typeof type == "function")
					funct = function(a,b){
						return type(a._sort, b._sort, order, a.id, b.id);
					}
				else {
	                if(type=='cus')
    	                 funct=function(a,b){
                            return self._customSorts[col](a._sort,b._sort,order,a.id,b.id);
                         };
     	
                   if(type=='str')
                     funct=function(a,b){return (a._sort<b._sort?neg:(a._sort==b._sort?0:pos))}

                  if(type=='int')
                     funct=function(a,b){return (a._sort<b._sort?neg:(a._sort==b._sort?0:pos))}

                  if(type=='date')
                     funct=function(a,b){return (Date.parse(new Date(a._sort||"01/01/1900"))-Date.parse(new Date(b._sort||"01/01/1900")))*pos}
                  }
                  this._sortTreeRows(funct,0);
                  this._renderSort(0,true);

            this.callEvent("onGridReconstructed",[]);
               
}

dhtmlXGridObject.prototype._sortTreeRows = function(funct,id){
				var ar=this._h2.get[id].childs;
				if (this.rowsCol.stablesort)
					this.rowsCol.stablesort.call(ar,funct);
				else
					ar.sort(funct);
					
				for (var i=0; i<ar.length; i++){
					if (ar[i].childs.length) 
						this._sortTreeRows(funct,ar[i].id);
					ar[i].index=i;
				}
};
dhtmlXGridObject.prototype._renderSort = function(id,mode){ 
	this._h2_to_buff();
	var top=this.objBox.scrollTop;
	this._reset_view();
	this.objBox.scrollTop=top;
};

dhtmlXGridObject.prototype._fixAlterCssTGR = function(){ 
if (!this._realfake)	
	this._h2.forEachChild(0,function(x){
		if (x.buff.tagName=="TR"){
			var cs=(this._cssSP?(x.level%2):(x.index%2))?this._cssUnEven:this._cssEven;
			this.rowsAr[x.id].className=(cs + (this._cssSU?(" "+cs+"_"+x.level):""))+" "+(this.rowsAr[x.id]._css||"")+((this.rowsAr[x.id].className.indexOf("rowselected") != -1)?" rowselected":"");
		}
	},this);
}
dhtmlXGridObject.prototype.moveRowUDTG = function(id,dir){ 
	var x=this._h2.get[id];
	var p=x.parent.childs[x.index+dir]
	if ((!p) || (p.parent!=x.parent)) return;
	var state=[x.state,p.state];
	this.collapseKids(this.rowsAr[x.id]);
	this.collapseKids(this.rowsAr[p.id]);	
	var ind = this.rowsCol._dhx_find(this.rowsAr[id]);
	var bInd = this.rowsBuffer._dhx_find(this.rowsAr[id]);
	
	var nod=this.obj.rows[0].parentNode.removeChild(this.rowsCol[ind]);	
	var tar=this.rowsCol[ind+((dir==1)?2:dir)];
	if (tar)
		tar.parentNode.insertBefore(nod,tar);
	else
		this.obj.rows[0].parentNode.appendChild(nod);
	this.rowsCol._dhx_swapItems(ind,ind+dir)
	this.rowsBuffer._dhx_swapItems(bInd,bInd+dir);
	this._h2.swap(p,x);
	
	
	if (state[0]=="minus") this.expandKids(this.rowsAr[x.id]);
	if (state[1]=="minus") this.expandKids(this.rowsAr[p.id]);	
	
	this._fixAlterCss(Math.min(ind,ind+dir));
}

/**
*   @desc: TreeGrid cell constructor (only for TreeGrid package)
*   @param: cell - cell object
*   @type: public
*/
function eXcell_tree(cell){
   if (cell){
      this.cell = cell;
      this.grid = this.cell.parentNode.grid;
   }
   this.isDisabled = function(){ return this.cell._disabled||this.grid._edtc; }
   this.edit = function(){
        if ((this.er)||(this.grid._edtc)) return;
        this.er=this.cell.parentNode.valTag;
        this.val=this.getLabel();
        this.cell.atag=((!this.grid.multiLine)&&(_isKHTML||_isMacOS||_isFF)) ? "INPUT" : "TEXTAREA";
        this.er.innerHTML="<"+this.cell.atag+" class='dhx_combo_edit' type='text' style='height:"+(this.cell.offsetHeight-4)+"px;line-height:"+(this.cell.offsetHeight-6)+"px; width:100%; border:0px; margin:0px; padding:0px; overflow:hidden;'></"+this.cell.atag+">";
        this.er.childNodes[0].onmousedown = function(e){(e||event).cancelBubble = true}
        this.er.childNodes[0].onselectstart=function(e){  if (!e) e=event; e.cancelBubble=true; return true;  };
        this.er.className+=" editable";
        this.er.firstChild.onclick = function(e){(e||event).cancelBubble = true};
        this.er.firstChild.value=this.val;
        this.obj=this.er.firstChild;
		this.er.firstChild.style.width=Math.max(0,this.cell.offsetWidth-this.er.offsetLeft-2)+"px";
        this.er.firstChild.focus();
        if (_isIE)
			this.er.firstChild.focus();
    }
   this.detach = function(){
        if (!this.er) return;
            this.setLabel(this.er.firstChild.value);
            this.er.className=this.er.className.replace("editable","");
            var z=(this.val!=this.er.innerHTML);

			this.obj=this.er=null;
        return (z);
    }
   this.getValue = function(){
   		return this.getLabel();
   }

    
    /**
    *   @desc: get image of treegrid item
    *   @param: content - new text of label
    *   @type: private
    */
   this.setImage = function(url){
        this.cell.parentNode.imgTag.nextSibling.src=this.grid.iconURL+url;
        this.grid._h2.get[this.cell.parentNode.idd].image=url;
   }
   this.setIcon = function(icon){
		this.grid._h2.get[this.cell.parentNode.idd].icon = icon;
		this.cell.parentNode.imgTag.nextSibling.className = "dhx_treegrid_icon fa fa-"+icon;
   }
    /**
    *   @desc: set image of treegrid item
    *   @param: content - new text of label
    *   @type: private
    */
   this.getImage = function(){
   		return this.grid._h2.get[this.cell.parentNode.idd].image;
   }
   this.getIcon = function(){
   		return this.grid._h2.get[this.cell.parentNode.idd].icon;
   }

   /**
   *   @desc: sets text representation of cell ( setLabel doesn't triger math calculations as setValue do)
   *   @param: val - new value
   *   @type: public
   */
   this.setLabel = function(val){
                  this.setValueA(val);
            }

   /**
   *   @desc: sets text representation of cell ( setLabel doesn't triger math calculations as setValue do)
   *   @param: val - new value
   *   @type: public
   */
   this.getLabel = function(val){
     return this.cell.parentNode.valTag.innerHTML;
    }
}
    /**
    *   @desc: set value of grid item
    *   @param: val  - new value (for treegrid this method only used while adding new rows)
    *   @type: private
    */
	
eXcell_tree.prototype = new eXcell;
    /**
    *   @desc: set label of treegrid item
    *   @param: content - new text of label
    *   @type: private
    */
   eXcell_tree.prototype.setValueA = function(content){
   		this.cell.parentNode.valTag.innerHTML=content;
		this.grid.callEvent("onCellChanged",[this.cell.parentNode.idd,this.cell._cellIndex,content])
    }
	eXcell_tree.prototype.setValue = function(valAr){
		if (this.cell.parentNode.imgTag)
			return this.setLabel(valAr);
			
			
		if ((this.grid._tgc.iconTree==null)||(this.grid._tgc.iconTree!=this.grid.iconTree)){
			var _tgc={};
			_tgc.spacer="<img src='"+this.grid.iconTree+"blank.gif'  align='top' class='space'>";
			_tgc.imst="<img class='grid_collapse_icon' src='"+this.grid.iconTree;
			_tgc.imsti="<img style='padding-top:2px;'  src='"+(this.grid.iconURL||this.grid.iconTree);
			_tgc.imact="' align='top' onclick='this."+(_isKHTML?"":"parentNode.")+"parentNode.parentNode.parentNode.parentNode.grid.doExpand(this);event.cancelBubble=true;'>"
			_tgc.plus=_tgc.imst+"plus.gif"+_tgc.imact;
			_tgc.minus=_tgc.imst+"minus.gif"+_tgc.imact;
			_tgc.blank=_tgc.imst+"blank.gif"+_tgc.imact;
			_tgc.start="<div class='treegrid_cell' style='overflow:hidden; white-space : nowrap; line-height:23px; height:"+(_isIE?21:23)+"px;'>";
			
			_tgc.itemim="' align='top' "+(this.grid._img_height?(" height=\""+this.grid._img_height+"\""):"")+(this.grid._img_width?(" width=\""+this.grid._img_width+"\""):"")+" >";
			_tgc.itemne="<span id='nodeval'>";
			_tgc.close="</span></div>";
			this.grid._tgc=_tgc;
		}
		var _h2=this.grid._h2;
		var _tgc=this.grid._tgc;
				
		var rid=this.cell.parentNode.idd;
		var row=this.grid._h2.get[rid];
		
		if (this.grid.kidsXmlFile || this.grid._slowParse) { 
			row.has_kids=(row.has_kids||(this.cell.parentNode._attrs["xmlkids"]&&(row.state!="minus")));
			row._xml_await=!!row.has_kids;
		}
		
		
		row.image=row.image||(this.cell._attrs["image"]||"leaf.gif");
		row.icon=row.icon||(this.cell._attrs["icon"]||(this.grid.iconset?"file-o":""));

		row.label=valAr;
               
        var html=[_tgc.start];
		
        for(var i=0;i<row.level;i++)
        	html.push(_tgc.spacer);
        
       //if has children
        if(row.has_kids){
        	html.push(_tgc.plus);
        	row.state="plus"
        	}
        else
        	html.push(_tgc.imst+row.state+".gif"+_tgc.imact);
                        
		if (!row.icon){
			html.push(_tgc.imsti);
			html.push(row.image);
			html.push(_tgc.itemim);
		} else {
			html.push("<i class='dhx_treegrid_icon fa fa-"+row.icon+"'></i>");
		}
		html.push(_tgc.itemne);
		html.push(row.label);
		html.push(_tgc.close);
		
                    

		this.cell.innerHTML=html.join("");
		this.cell._treeCell=true;
		this.cell.parentNode.imgTag=this.cell.childNodes[0].childNodes[row.level];
		this.cell.parentNode.valTag=this.cell.childNodes[0].childNodes[row.level+2];
		if (_isKHTML) this.cell.vAlign="top";
		if (row.parent.id!=0 && row.parent.state=="plus") {
				this.grid._updateTGRState(row.parent,false);
				this.cell.parentNode._skipInsert=true;		
			}

		this.grid.callEvent("onCellChanged",[rid,this.cell._cellIndex,valAr]);
	}
    
dhtmlXGridObject.prototype._process_tree_xml=function(top,pid){
	this._parsing=true;
	var main=false;
	if (!pid){
		this.render_row=this.render_row_tree;
		main=true;
		
		pid=top.getAttribute("parent")||0;
		if (pid=="0") pid=0;
		if (!this._h2)	 this._h2= this._createHierarchy();
		if (this._fake) this._fake._h2=this._h2;
	} 

	var rows=dhx4.ajax.xpath(this.xml.row, top);
	this._open=this._open||[];
	for (var i=0; i < rows.length; i++) {
		var id=rows[i].getAttribute("id");
		if (!id) {
			id=this.uid();
			rows[i].setAttribute("id",id);
		}
		var row=this._h2.add(id,pid);
		row.buff={ idd:id, data:rows[i], _parser: this._process_xml_row, _locator:this._get_xml_data };
		if (rows[i].getAttribute("open")){
			row.state="minus";
			this._open.push(id);
		}
		
		this.rowsAr[id]=row.buff;
		this._process_tree_xml(rows[i],id);
	}
	if (main){ 
		if (!rows.length) this._h2.change(pid,"state",this._emptyLineImg);
		else if (pid!=0 && !this._srnd) {
			this._h2.change(pid,"state","minus");
		}
		for (var i=0; i < this._open.length; i++) {
			var r=this._h2.get[this._open[i]];
			if (!r.childs.length)
				r.state=this._emptyLineImg;
		};
		
		this._updateTGRState(this._h2.get[pid]);
		this._h2_to_buff();
		if (pid!=0 && this._srnd) this.openItem(pid);
		else {
			if (this.pagingOn)
				this._renderSort();
			else
				this.render_dataset();
		}

		if (this.kidsXmlFile){
			for (var i=0; i < this._open.length; i++) {
				var r=this._h2.get[this._open[i]];
				if (r._xml_await) 
					this.expandKids({idd:r.id});
			}
		}
		this._open=[];

		if (this._slowParse===false){
			this.forEachRow(function(id){
				this.render_row_tree(0,id)
			})
		}
		this._parsing=false;
		if (pid!=0 && !this._srnd) {
		    this.callEvent("onOpenEnd",[pid,1]);
		}
	}
}	
dhtmlXGridObject.prototype._h2_to_buff=function(top){
	if (!top){
		top=this._h2.get[0];
		this.rowsBuffer = new dhtmlxArray();
		if (this._fake && !this._realfake) this._fake.rowsBuffer = this.rowsBuffer;
	}
	for (var i=0; i < top.childs.length; i++) {
		this.rowsBuffer.push(top.childs[i].buff);
		if (top.childs[i].state == "minus")
			this._h2_to_buff(top.childs[i]);
	}
};
dhtmlXGridObject.prototype.render_row_tree=function(ind,id){ 
	if (id){
		var r=this._h2.get[id];
		r=r?r.buff:r;
	} else
	var r=this.rowsBuffer[ind];
	if (!r) 
		return -1;
	
	if (r._parser){
		if (this.rowsAr[r.idd] && this.rowsAr[r.idd].tagName=="TR")
			return this._h2.get[r.idd].buff=this.rowsBuffer[ind]=this.rowsAr[r.idd];
		var row=this._prepareRow(r.idd);
		this.rowsAr[r.idd]=row;

		if (!id)
			this.rowsBuffer[ind]=row;
		this._h2.get[r.idd].buff=row;	//treegrid specific
		
		r._parser.call(this,row,r.data);
		this._postRowProcessing(row);		
		
		return row;
		}
	return r;
}
    
    /**
    *   @desc: remove row from treegrid
    *   @param: node  - row object
    *   @type: private
    */
dhtmlXGridObject.prototype._removeTrGrRow=function(node,x){ 
		 if(x){
		     this._h2.forEachChild(x.id,function(x){
		     	this._removeTrGrRow(null,x);
	    		delete this.rowsAr[x.id];
    		},this);
    		return;
		 }
		 
		 var ind=this.getRowIndex(node.idd);
		 var x=this._h2.get[node.idd];
		 
		 
		 if (ind!=-1 && ind!==this.undefined){// in case of dnd we can receive delete command for some child item, which was not rendered yet
		 	var len=1;
		 	if (x && x.state=="minus") len+=this._getOpenLenght(x.id,0)
		 	for (var i=0; i<len; i++)
		 		if (this.rowsCol[i+ind])
            		this.rowsCol[i+ind].parentNode.removeChild(this.rowsCol[i+ind]);
            if (this._fake){
            	for (var i=0; i<len; i++)
            		if (this._fake.rowsCol[i+ind])
            			this._fake.rowsCol[i+ind].parentNode.removeChild(this._fake.rowsCol[i+ind]);
            	if (len>1)
            		this._fake.rowsCol.splice(ind+1,len-1);
        	}
            	
	         this.rowsCol.splice(ind,len);
	         this.rowsBuffer.splice(ind,len);
	         
	    }
	    
	    if (!x) return;
	    this._removeTrGrRow(null,x);
    		
    	delete this.rowsAr[x.id];
	
    	if (x.parent.childs.length==1){
    		this._h2.change(x.parent.id,"state",this._emptyLineImg);
    		this._updateTGRState(x.parent);
    	}
    	this._h2.remove(x.id);
      }




/**
*   @desc: expand row
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.openItem=function(rowId){
		var y=this._h2.get[rowId||0];
        var x=this.getRowById(rowId||0);
		if (!x) return;
        if (y.parent && y.parent.id!=0)
        	this.openItem(y.parent.id);
        this.expandKids(x);
}

dhtmlXGridObject.prototype._addRowClassic=dhtmlXGridObject.prototype.addRow;

    /**
    *   @desc: add new row to treeGrid
    *   @param: new_id  - new row id
    *   @param: text  - array of row label
    *   @param: ind  - position of row (set to null, for using parentId)
    *   @param: parent_id  - id of parent row
    *   @param: img  - img url for new row
    *   @param: child - child flag [optional]
    *   @type: public
    *   @edition: Professional
    */
dhtmlXGridObject.prototype.addRow=function(new_id,text,ind,parent_id,img,child){ 
	if (!this._h2) return this._addRowClassic(new_id,text,ind);
	parent_id=parent_id||0;
	var trcol=this.cellType._dhx_find("tree");
    if (typeof(text)=="string") text=text.split(this.delim);
    var row=this._h2.get[new_id];
    if (!row){
	    if (parent_id==0) ind=this.rowsBuffer.length;
	    else{
	    	ind=this.getRowIndex(parent_id)+1;
			if (this._h2.get[parent_id].state=="minus") 
				ind+=this._getOpenLenght(parent_id,0);
            else
				this._skipInsert=true;
            }
}
	row=row||this._h2.add(new_id,parent_id);
	row.image=img;
	row.has_kids=child;
    return row.buff=this._addRowClassic(new_id,text,ind);
}
    /**
    *   @desc: add new row to treeGrid, before some other row
    *   @param: new_id  - new row id
    *   @param: text  - array of row label
    *   @param: sibl_id  - id of row, related to which new one will be added
    *   @param: img  - img url for new row
    *   @param: child - child flag [optional]
    *   @type: public
    *   @edition: Professional
    */
dhtmlXGridObject.prototype.addRowBefore=function(new_id,text,sibl_id,img,child){
	var sb=this.rowsAr[sibl_id];
	if (!sb) return;
	if (!this._h2) return this.addRow(new_id,text,this.getRowIndex(sibl_id));
	var pid=this._h2.get[sibl_id].parent.id;

	var ind=this.getRowIndex(sibl_id);
	if (ind==-1) this._skipInsert=true;
	this._h2.addBefore(new_id,pid,sibl_id);
	return this.addRow(new_id,text,ind,this._h2.get[sibl_id].parent.id,img,child);
}
    /**
    *   @desc: add new row to treeGrid, after some other row
    *   @param: new_id  - new row id
    *   @param: text  - array of row label
    *   @param: sibl_id  - id of row, related to which new one will be added
    *   @param: img  - img url for new row
    *   @param: child - child flag [optional]
    *   @type: public
    *   @edition: Professional
    */
dhtmlXGridObject.prototype.addRowAfter=function(new_id,text,sibl_id,img,child){
	var sb=this.rowsAr[sibl_id];
	if (!sb) return;
	if (!this._h2) return this.addRow(new_id,text,this.getRowIndex(sibl_id)+1);
	var pid=this._h2.get[sibl_id].parent.id;

	var ind=this.getRowIndex(sibl_id);
	if (ind==-1) this._skipInsert=true;
	if (this._h2.get[sibl_id].state=="minus") ind+=this._getOpenLenght(sibl_id,0)+1;	
	else	ind++;
	
	this._h2.addAfter(new_id,pid,sibl_id);
	return this.addRow(new_id,text,ind,pid,img,child);
}





dhtmlXGridObject.prototype.enableSmartXMLParsing=function(mode) {
	this._slowParse=dhx4.s2b(mode);
};



    /**
    *   @desc: copy content between different rows
    *   @param: frRow  - source row object
    *   @param: from_row_id  - source row id
    *   @param: to_row_id  - target row id
    *   @type: private
    */
dhtmlXGridObject.prototype._copyTreeGridRowContent=function(frRow,from_row_id,to_row_id){
    var z=this.cellType._dhx_find("tree");
    for(i=0;i<frRow.cells.length;i++){
        if (i!=z)
           this.cells(to_row_id,i).setValue(this.cells(from_row_id,i).getValue())
        else
            this.cells(to_row_id,i).setValueA(this.cells(from_row_id,i).getValue())

    }
}

/**
*   @desc: collapse row
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.closeItem=function(rowId){
        var x=this.getRowById(rowId);
        if (!x) return;
        this.collapseKids(x);
}
/**
*   @desc: delete all childs of row in question
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.deleteChildItems=function(rowId){
        var z=this._h2.get[rowId];
        if (!z) return;
        while (z.childs.length)
            this.deleteRow(z.childs[0].id);
            
}
/**
*   @desc: get list of id of all nested rows
*   @param: rowId - id of row
*   @type:  public
*   @returns: list of id of all nested rows
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getAllSubItems=function(rowId){
        var str=[];
        var z=this._h2.get[rowId||0];
        if (z)
        for (var i=0; i<z.childs.length; i++){
            str.push(z.childs[i].id);
            if (z.childs[i].childs.length)
            str=str.concat(this.getAllSubItems(z.childs[i].id).split(this.delim));
            }

        return str.join(this.delim);
}

/**
*   @desc: get id of child item at specified position
*   @param: rowId - id of row
*   @param: ind - child node index
*   @type:  public
*   @returns: id of child item at specified position
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getChildItemIdByIndex=function(rowId,ind){
		var z=this._h2.get[rowId||0];
        if (!z) return null;
        return (z.childs[ind]?z.childs[ind].id:null);
}

/**
*   @desc: get real caption of tree col
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: real caption of tree col
*   @topic: 7
*/
dhtmlXGridObject.prototype.getItemText=function(rowId){
        return this.cells(rowId,this.cellType._dhx_find("tree")).getLabel();
}

/**
*   @desc: return open/close state of row
*   @param: rowId - id of row
*   @type:  public
*   @returns: open/close state of row
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getOpenState=function(rowId){
        var z=this._h2.get[rowId||0];
        if (!z) return;
        if (z.state=="minus") return true;
        return false;
}
/**
*   @desc: return id of parent row
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: id of parent row
*   @topic: 7
*/
dhtmlXGridObject.prototype.getParentId=function(rowId){
        var z=this._h2.get[rowId||0];
        if ((!z) || (!z.parent)) return null;
        return z.parent.id;
}
/**
*   @desc: return list of child row id, sparated by comma
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: list of child rows
*   @topic: 7
*/
dhtmlXGridObject.prototype.getSubItems=function(rowId){
      var str=[];
      var z=this._h2.get[rowId||0];
      if (z)
      	for (var i=0; i<z.childs.length; i++)
      		str.push(z.childs[i].id);
      return str.join(this.delim);
}


/**
*   @desc: expand all tree structure
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.expandAll=function(rowId){
	this._renderAllExpand(rowId||0);
	this._h2_to_buff();
	this._reset_view();
	this.setSizes();
	this.callEvent("onGridReconstructed",[]);
	if (this._redrawLines) this._redrawLines();
}
	
dhtmlXGridObject.prototype._renderAllExpand=function(z){
	var x=this._h2.get[z].childs;
	for (var i=0; i<x.length; i++){
		if (x[i].childs.length){
			this._h2.change(x[i].id,"state","minus")
			this._updateTGRState(x[i]);
			this._renderAllExpand(x[i].id)
		}
	}
}
/**
*   @desc: collapse all tree structure
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.collapseAll=function(rowId){
	this._h2.forEachChild((rowId||0),function(z){
		if (z && z.state=="minus"){
			z.state="plus";
			z.update=true;
			this._updateTGRState(z);
		}
	},this);
	this._h2_to_buff();
	this._reset_view();
	this.setSizes();
	this.callEvent("onGridReconstructed",[]);
	if (this._redrawLines) this._redrawLines();
}

/**
*   @desc: return children count
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @returns: children count
*   @topic: 7
*/
dhtmlXGridObject.prototype.hasChildren=function(rowId){
        var x=this._h2.get[rowId];
        if (x && x.childs.length) return x.childs.length;
        if (x._xml_await) return -1;
        return 0;
}


/**
*   @desc: enable/disable closing of row
*   @param: rowId - id of row
*   @param: status - true/false
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/

dhtmlXGridObject.prototype.setItemCloseable=function(rowId,status){
        var x=this._h2.get[rowId];
        if (!x) return;
        x._closeable=(!dhx4.s2b(status));
}
/**
*   @desc: set real caption of tree col
*   @param: rowId - id of row
*   @param: newtext - new text
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.setItemText=function(rowId,newtext){
	return this.cells(rowId,this.cellType._dhx_find("tree")).setLabel(newtext);
}


/**
*   @desc: set image of tree col
*   @param: rowId - id of row
*   @param: url - image url
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.setItemImage=function(rowId,url){
	this._h2.get[rowId].image=url; 
	this.rowsAr[rowId].imgTag.nextSibling.src=(this.iconURL||"")+url; 
}
dhtmlXGridObject.prototype.setItemIcon=function(rowId,icon){
	this._h2.get[rowId].icon = icon;
	this.rowsAr[rowId].imgTag.nextSibling.className = "dhx_treegrid_icon fa fa-"+icon;
}

/**
*   @desc: get image of tree col
*   @param: rowId - id of row
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.getItemImage=function(rowId){
	this.getRowById(rowId);
	return this._h2.get[rowId].image;  
}
dhtmlXGridObject.prototype.getItemIcon=function(rowId){
	this.getRowById(rowId);
	return this._h2.get[rowId].icon;
}


/**
*   @desc: set size of treegrid images
*   @param: width -  width of image
*   @param: height - height of image
*   @type:  public
*   @edition: Professional
*   @topic: 7
*/
dhtmlXGridObject.prototype.setImageSize=function(width,height){
        this._img_width=width;
        this._img_height=height;
}


dhtmlXGridObject.prototype._getRowImage=function(row){
	return this._h2.get[row.idd].image;    
        }


/**
*     @desc: set function called before tree node opened/closed
*     @param: func - event handling function
*     @type: public
*     @topic: 0,10
*     @event:  onOpenStart
*     @eventdesc: Event raised immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event not raised if node opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. -1 - item closed, 1 - item opened.
*     @eventreturn: true - confirm opening/closing; false - deny opening/closing;
*/
   dhtmlXGridObject.prototype.setOnOpenStartHandler=function(func){  this.attachEvent("onOpenStart",func); };
   
/**
*     @desc: set function called after tree node opened/closed
*     @param: func - event handling function
*     @type: public
*     @topic: 0,10
*     @event:  onOpenEnd
*     @eventdesc: Event raised immideatly after item in tree got command to open/close , and before item was opened//closed. Event also raised for unclosable nodes and nodes without open/close functionality - in that case result of function will be ignored.
            Event not raised if node opened by dhtmlXtree API.
*     @eventparam: ID of node which will be opened/closed
*     @eventparam: Current open state of tree item. -1 - item closed, 1 - item opened.
*/
   dhtmlXGridObject.prototype.setOnOpenEndHandler=function(func){  this.attachEvent("onOpenEnd",func);   };


    /**
*     @desc: enable/disable editor of tree cell ; enabled by default
*     @param: mode -  (boolean) true/false
*     @type: public
*     @topic: 0
*/
   dhtmlXGridObject.prototype.enableTreeCellEdit=function(mode){
        this._edtc=!dhx4.s2b(mode);
    };



/**
*   @desc: return level of treeGrid row
*   @param: rowId - id of row
*   @type:  public
*   @returns: level of treeGrid row
*   @topic: 7
*/
dhtmlXGridObject.prototype.getLevel=function(rowId){      
        var z=this._h2.get[rowId||0];
        if (!z) return -1;
        return z.level;
}

dhtmlXGridObject.prototype._fixHiddenRowsAllTG=function(ind,state){
  for (i in this.rowsAr){
     if ((this.rowsAr[i])&&(this.rowsAr[i].childNodes))
        this.rowsAr[i].childNodes[ind].style.display=state;
  }
}
//(c)dhtmlx ltd. www.dhtmlx.com

;
///<jscompress sourcefile="dhtmlxtreegrid_lines.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXGridObject.prototype._updateLine=function(z,row){ 
	row=row||this.rowsAr[z.id];
	if (!row) return;
	var im=row.imgTag;
	if (!im) return;
	if (z.state=="blank") return im.src=this.iconTree+"blank.gif";
	
		var n=1;
		if (z.index==0){
			if (z.level==0){
				if ((z.parent.childs.length-1)>z.index)
					n=3;
				else n=1;
			}
			else
			{
				if ((z.parent.childs.length-1)>z.index)
					n=3;
				else
					n=2;
			}
		}
		else
			if ((z.parent.childs.length-1)>z.index)
				n=3;
			else
				n=2;
			
		
		im.src=this.iconTree+z.state+n+".gif";
}
dhtmlXGridObject.prototype._updateParentLine=function(z,row){
		row=row||this.rowsAr[z.id];
		if (!row) return;
		var im=row.imgTag;
		if (!im) return;
		for (var i=z.level; i>0; i--){
			if (z.id==0) break;
			im=im.previousSibling;
			z=z.parent;
			if ((z.parent.childs.length-1)>z.index)
				im.src=this.iconTree+"line1.gif";
			else
				im.src=this.iconTree+"blank.gif";
		}
}

dhtmlXGridObject.prototype._renderSortA=dhtmlXGridObject.prototype._renderSort;
dhtmlXGridObject.prototype._renderSort=function(){
	this._renderSortA.apply(this,arguments);
	this._redrawLines(0)	
} 
dhtmlXGridObject.prototype._redrawLines=function(id){
		if (this._tgle)
			this._h2.forEachChild((id||0),function(z){
					this._updateLine(z);
					this._updateParentLine(z);
			},this);
	}
/**
*   @desc: enable lines in treeGrid 
*   @type: public
*   @edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.enableTreeGridLines=function(){
	this._emptyLineImg="line";

	
	this._updateTGRState=function(z,force){ 
		if (force || !z.update || z.id==0) return;
		if (this._tgle)
			this._updateLine(z,this.rowsAr[z.id]);
		z.update=false;
	}

	this._tgle=true;
	this.attachEvent("onXLE",function(a,b,id){
		this._redrawLines(id)
	});    
	
	this.attachEvent("onOpenEnd",function(id){
		this._redrawLines(id)
	});    
	
	
	this.attachEvent("onRowAdded",function(id){ 
		var z=this._h2.get[id];
		this._updateLine(z); 
		this._updateParentLine(z);
		if (z.index<(z.parent.childs.length-1)){
			z=z.parent.childs[z.index+1];
			this._updateLine(z);
			this._updateParentLine(z);
		}
		else if (z.index!=0){
			z=z.parent.childs[z.index-1];
			this._updateLine(z);
			this._updateParentLine(z);
			if (z.childs.length)
				this._h2.forEachChild(z.id,function(c_el){
					this._updateParentLine(c_el)
				},this)
		}
	});
	this.attachEvent("onOpen",function(id,state){ 
		if (state){ 
			var z=this._h2.get[id];
			for (var i=0; i < z.childs.length; i++) 
				this._updateParentLine(z.childs[i]);
		}
		return true;
	});
	this.attachEvent("onBeforeRowDeleted",function(id){
		var self=this;
		var z=this._h2.get[id];
		var w=null;
		if (z.index!=0)
			w=z.parent.childs[z.index-1];
		z=z.parent;
			
		window.setTimeout(function(){
			z  = self._h2.get[z.id];
			if (!z) return;
						
			self._updateLine(z);
			self._updateParentLine(z);
			
			if (w){
				self._updateLine(w);
				if (w.state=="minus")
				self._h2.forEachChild(w.id,function(z){
					self._updateParentLine(z);
				},self);
			}
		},1);
		return true;
	});
} 

//(c)dhtmlx ltd. www.dhtmlx.com

;
///<jscompress sourcefile="dhtmlxtreegrid_filter.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

//beware that function started from _in_header_ must not be obfuscated


/**
*   @desc: allows to define , which level of tree must be used for filtering
*   @type: public
*   @param: level - level value, -1 value means last one
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.setFiltrationLevel=function(level,show_lower,show_upper){
	this._tr_strfltr=level;
	this._tr_fltr_c=show_lower;
	this._tr_fltr_d=show_upper;
	this.refreshFilters();
}


/**
*   @desc: filter grid by mask
*   @type: public
*   @param: column - {number} zero based index of column
*   @param: value - {string} filtering mask
*   @param: preserve - {bool} filter current or initial state ( false by default )
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.filterTreeBy=function(column, value, preserve){
	var origin = this._h2;
	if (typeof this._tr_strfltr == "undefined") this._tr_strfltr=-1;
	if (this._f_rowsBuffer){
		if (!preserve){
			this._h2=this._f_rowsBuffer;
			if (this._fake) this._fake._h2=this._h2;
		}
	} else
		this._f_rowsBuffer=this._h2;	//backup copy
	
	//if (!this.rowsBuffer.length && preserve) return;
	var d=true;
	this.dma(true)
	this._fbf={};
	if (typeof(column)=="object")
		for (var j=0; j<value.length; j++)
			this._filterTreeA(column[j],value[j]);
	else
			this._filterTreeA(column,value);
	this._fbf=null;
	this.dma(false)
	this._fix_filtered_images(this._h2,origin);
	this._renderSort()
	this.callEvent("onGridReconstructed",[])
}
dhtmlXGridObject.prototype._filterTreeA=function(column,value){ 
	if (value=="") return;
	var d=true;
	if (typeof(value)=="function") d=false;
	else value=(value||"").toString().toLowerCase();
	
	var add_line=function(el,s,t){
			var z=t.get[el.parent.id];
			if (!z) z=add_line(el.parent,s,t)
			var t=temp.get[el.id];
			if (!t){
				t={id:el.id, childs:[], level:el.level, parent:z, index:z.childs.length, image:el.image, state:el.state, buff:el.buff, has_kids:el.has_kids, _xml_await:el._xml_await};
			z.childs.push(t);
			temp.get[t.id]=t;
			}
			return t;
	}
	var fbf=this._fbf;
	var temp = this._createHierarchy();
	var check; 
	var mode = this._tr_strfltr;
	var that=this;	
	var temp_c=function(el){
		for (var i=0; i < el.childs.length; i++) 
			that.temp(el.childs[i]);
	}
	switch(mode.toString()){
		case "-2": check=function(el){ if (fbf[el.id]) return false; temp_c(el); return true;}; break;
		case "-1": check=function(el){return !el.childs.length;}; break;
		default: check=function(el){return mode==el.level}; break;
	}
	this.temp=function(el){
		if (el.id!=0 && check(el)){
			if (d?(this._get_cell_value(el.buff,column).toString().toLowerCase().indexOf(value)==-1):(!value(this._get_cell_value(el.buff,column),el.id))){
				fbf[el.id]=true;
				if (this._tr_fltr_c) add_line(el.parent,this._h2,temp);
				return false;
			} else {
				add_line(el,this._h2,temp);
				if (el.childs && mode!=-2)
					this._h2.forEachChild(el.id,function(cel){
						add_line(cel,this._h2,temp);
					},this)
				return true;
			}
		} else {
			if (this._tr_fltr_d && this._tr_strfltr > el.level && el.id!=0) add_line(el,this._h2,temp);
			temp_c(el);
		}
	}

	
	this.temp(this._h2.get[0]);
	this._h2=temp;	
	if (this._fake) this._fake._h2=this._h2;
}

dhtmlXGridObject.prototype._fix_filtered_images=function(temp,origin){
		temp.forEachChild(0,function(el){
		if (!el.childs.length && !el.has_kids){
			if (el.state!=this._emptyLineImg){
				el.state=this._emptyLineImg;
				el.update=true;
				this._updateTGRState(el);
			}
		} else {
			if (el.buff.tagName=="TR"){
				var prev=origin.get[el.id];
				if (prev && prev.state!=this._emptyLineImg)
					el.state=prev.state;
				el.update=true;
				this._updateTGRState(el);
			}
		}
	},this)
}
/**
*   @desc: get all possible values in column
*   @type: public
*   @param: column - {number} zero based index of column
*   @returns: {array} array of all possible values in column
*	@edition: Professional
*   @topic: 0
*/
dhtmlXGridObject.prototype.collectTreeValues=function(column){
	if (typeof this._tr_strfltr == "undefined") this._tr_strfltr=-1;
	this.dma(true)
	this._build_m_order();		
	column=this._m_order?this._m_order[column]:column;
	var c={}; var f=[];
	var col=this._f_rowsBuffer||this._h2;
	col.forEachChild(0,function(el){
		if (this._tr_strfltr==-2 || (this._tr_strfltr==-1 && !el.childs.length) || (this._tr_strfltr==el.level)){
			var val=this._get_cell_value(el.buff,column);
			if (val) c[val]=true;
    	}
	},this);
	this.dma(false)
	
	var vals=this.combos[column];
	for (var d in c) 
		if (c[d]===true) f.push(vals?(vals.get(d)||d):d);
	
	return f.sort();			
}




dhtmlXGridObject.prototype._in_header_stat_tree_total=function(t,i,c){
	var calck=function(){
		var summ=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		this._h2.forEachChild(0,function(el){
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			summ+=isNaN(v)?0:v;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_total_leaf=function(t,i,c){
	var calck=function(){
		var summ=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			summ+=isNaN(v)?0:v;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_multi_total=function(t,i,c){
	var cols=c[1].split(":"); c[1]="";
	var calck=function(){
		var summ=0;
		this._h2.forEachChild(0,function(el){
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),cols[0]))*parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),cols[1]));
			summ+=isNaN(v)?0:v;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_multi_total_leaf=function(t,i,c){
	var cols=c[1].split(":"); c[1]="";
	var calck=function(){
		var summ=0;
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),cols[0]))*parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),cols[1]));
			summ+=isNaN(v)?0:v;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ*100)/100);
	}
	this._stat_in_header(t,calck,i,c,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_max=function(t,i,c){
	var calck=function(){
		var summ=-999999999;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		if (this.getRowsNum()==0) return "";
		this._h2.forEachChild(0,function(el){
			var d=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			if (!isNaN(d))
				summ=Math.max(summ,d);
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_min=function(t,i,c){
	var calck=function(){
		var summ=999999999;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		if (this.getRowsNum()==0) return "";
		this._h2.forEachChild(0,function(el){
			var d=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			if (!isNaN(d))
				summ=Math.min(summ,d);
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_average=function(t,i,c){
	var calck=function(){
		var summ=0; var count=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		this._h2.forEachChild(0,function(el){
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			summ+=isNaN(v)?0:v;
			count++;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ/count*100)/100);
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_max_leaf=function(t,i,c){
	var calck=function(){
		var summ=-999999999;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		if (this.getRowsNum()==0) return "";
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var d=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			if (!isNaN(d))
				summ=Math.max(summ,d);
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_min_leaf=function(t,i,c){
	var calck=function(){
		var summ=999999999;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		if (this.getRowsNum()==0) return "";
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var d=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			if (!isNaN(d))
				summ=Math.min(summ,d);
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):summ;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_average_leaf=function(t,i,c){
	var calck=function(){
		var summ=0; var count=0;
		this._build_m_order();
		var ii = this._m_order?this._m_order[i]:i;
		this._h2.forEachChild(0,function(el){
			if (el.childs.length) return;
			var v=parseFloat(this._get_cell_value((el.buff||this.rowsAr[el.id]),ii));
			summ+=isNaN(v)?0:v;
			count++;
		},this)
		return this._maskArr[i]?this._aplNF(summ,i):(Math.round(summ/count*100)/100);
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_count=function(t,i,c){
	var calck=function(){
		var count=0;
		this._h2.forEachChild(0,function(el){
			count++;
		},this)
		return count;
	}
	this._stat_in_header(t,calck,i,c);
}
dhtmlXGridObject.prototype._in_header_stat_tree_count_leaf=function(t,i,c){
	var calck=function(){
		var count=0;
		this._h2.forEachChild(0,function(el){
			if (!el.childs.length) count++;
		},this)
		return count;
	}
	this._stat_in_header(t,calck,i,c);
}

dhtmlXGridObject.prototype._stat_in_header=function(t,calck,i,c){
//	if (this._realfake) return this._fake._stat_in_header(t,calck,i,c);
	var that=this;
	var f=function(){
		this.dma(true)
		t.innerHTML=(c[0]?c[0]:"")+calck.call(this)+(c[1]?c[1]:"");
		this.dma(false)
		this.callEvent("onStatReady",[])
	}
	if (!this._stat_events) {
		this._stat_events=[];
		this.attachEvent("onClearAll",function(){ 
			if (!this.hdr.rows[1]){
				for (var i=0; i<this._stat_events.length; i++)
					for (var j=0; j < 4; j++) 
						this.detachEvent(this._stat_events[i][j]);
				this._stat_events=[];	
			}
		})
	}
	
	this._stat_events.push([
	this.attachEvent("onGridReconstructed",f),
	this.attachEvent("onXLE",f),
	this.attachEvent("onFilterEnd",f),
	this.attachEvent("onEditCell",function(stage,id,ind){
		if (stage==2 && ind==i) f.call(this);
		return true;
		})]);
	t.innerHTML="";
}
dhtmlXGridObject.prototype._build_m_order=function(){
	if (this._c_order){
		this._m_order=[]
		for (var i=0; i < this._c_order.length; i++) {
			this._m_order[this._c_order[i]]=i;
		};
	}
}


//(c)dhtmlx ltd. www.dhtmlx.com

;
///<jscompress sourcefile="dhtmlxform.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

function dhtmlXForm(parentObj, data, skin) {
	
	this.idef = {
		position:	"label-left",
		labelWidth:	"auto",
		labelHeight:	"auto",
		inputWidth:	"auto",
		inputHeight:	"auto",
		labelAlign:	"left",
		noteWidth:	"auto",
		offsetTop:	0,
		offsetLeft:	0,
		blockOffset:	20 // block only
	};
	this.idef_const = {
		offsetNested:	20 // sub_level
	};
	this.apos_css = {
		"label-left":	"dhxform_item_label_left",
		"label-right":	"dhxform_item_label_right",
		"label-top":	"dhxform_item_label_top",
		"label-bottom":	"dhxform_item_label_bottom", // new
		"absolute":	"dhxform_item_absolute"
	};
	this.align_css = {
		left:		"dhxform_label_align_left",
		center:		"dhxform_label_align_center",
		right:		"dhxform_label_align_right"
	};
	
	var that = this;
	
	// define skin
	
	// 1) skin 3rd arg [new]
	// 2) dhtmlx.skin
	// 3) autodetect skin
	// 4) default skyblue
	
	this.setSkin = function(skin) {
		this.skin = skin;
		this.cont.className = "dhxform_obj_"+this.skin;
		this.cont.style.fontSize = (skin=="material"?"14px":(skin=="dhx_terrace"?"13px":"12px"));
		this._updateBlocks();
		// update calendar skin
		this.forEachItem(function(id){
			var t = that.getItemType(id);
			if (typeof(that.items[t]) != "undefined" && typeof(that.items[t].setSkin) == "function") {
				that.doWithItem(id, "setSkin", skin);
			}
		});
	}
	
	this.skin = (skin||window.dhx4.skin||(typeof(dhtmlx)!="undefined"?dhtmlx.skin:null)||window.dhx4.skinDetect("dhx_form")||"material");
	
	this.separator = ",";
	this.live_validate = false;
	
	this._type = "checkbox";
	this._rGroup = "default";
	
	this._idIndex = {};
	this._indexId = [];
	
	this.cont = (typeof(parentObj)=="object"?parentObj:document.getElementById(parentObj));
	
	if (!parentObj._isNestedForm) {
		
		this._parentForm = true;
		
		this.cont.style.fontSize = (this.skin=="material"?"14px":(this.skin=="dhx_terrace"?"13px":"12px"));
		this.cont.className = "dhxform_obj_"+this.skin;
		
		this.setFontSize = function(fs) {
			this.cont.style.fontSize = fs;
			this._updateBlocks();
		}
		
		this.getForm = function() {
			return this;
		}
		
		this.cont.onkeypress = function(e) {
			e = (e||event);
			if (e.keyCode == 13) {
				var t = (e.target||e.srcElement);
				if (typeof(t.tagName) != "undefined" && String(t.tagName).toLowerCase() == "textarea" && !e.ctrlKey) return;
				that.callEvent("onEnter",[]);
			}
		}
		
	}
	
	this.b_index = null;
	this.base = [];
	this._prepare = function(ofsLeft, pos) {
		
		if (this.b_index == null) this.b_index = 0; else this.b_index++;
		
		// if pos specified, check all items inside all bases,
		var insBeforeBase = null; // base
		var insBeforeItem = null; // items from start to move next-items within single base
		
		if (pos != null) {
			if (pos < 0) pos = 0;
			var i = 0;
			for (var w=0; w<this.cont.childNodes.length; w++) { // bases sit here, 1 base = 1 newcolumn
				for (var q=0; q<this.cont.childNodes[w].childNodes.length; q++) { // items inside single base, i.e.between two nearest newcolumns/form_start/form_end
					if (insBeforeItem == null && this.cont.childNodes[w].childNodes[q]._isNestedForm != true) {
						if (i == pos) {
							insBeforeBase = this.cont.childNodes[w].nextSibling; // insert new column before this base
							insBeforeItem = this.cont.childNodes[w].childNodes[q]; // move all items within single base from this item to end of base to new column
						}
						i++;
					}
				}
			}
		}
		
		this.base[this.b_index] = document.createElement("DIV");
		this.base[this.b_index].className = "dhxform_base";
		
		if (typeof(ofsLeft) != "undefined") this.base[this.b_index].style.cssText += " margin-left:"+ofsLeft+"px!important;";
		
		// add block
		if (insBeforeBase != null) {
			this.cont.insertBefore(this.base[this.b_index], insBeforeBase);
			insBeforeBase = null;
		} else {
			this.cont.appendChild(this.base[this.b_index]);
		}
		
		// move items if any
		if (insBeforeItem != null) {
			while (insBeforeItem != null) {
				var t = insBeforeItem;
				insBeforeItem = insBeforeItem.nextSibling;
				this.base[this.b_index].appendChild(t);
				t = null;
			}
		}
	}
	
	
	this.setSizes = function() {
		/*
		for (var q=0; q<this.base.length; q++) {
			this.base.style.height = this.cont.offsetHeight+"px";
			this.base.style.overflow = "auto";
		}
		*/
	}
	
	this._mergeSettings = function(data) {
		
		var u = -1;
		var i = {type: "settings"};
		for (var a in this.idef) i[a] = this.idef[a];
		
		for (var q=0; q<data.length; q++) {
			if (typeof(data[q]) != "undefined" && data[q].type == "settings") {
				for (var a in data[q]) i[a] = data[q][a];
				u = q;
			}
		}
		data[u>=0?u:data.length] = i;
		return data;
	}
	
	this._genStr = function(w) {
		var s = "dhxId_";
		var z = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
		for (var q=0; q<w; q++) s += z.charAt(Math.floor(Math.random() * z.length));
		return s;
	}
	
	this.idPrefix = "dhxForm_"+this._genStr(12)+"_";
	
	this._rId = (this._parentForm?this._genStr(12)+"_":parentObj._rId);
	
	this.objPull = {};
	this.itemPull = {};
	this._ic = 0;
	
	this._addItem = function(type, id, data, sId, lp, pos, insertAfter) {
		
		// id-index
		if (this.items[type]._index) {
			this.getForm()._indexId.push(id);
			this.getForm()._idIndex[id] = {ind: this.getForm()._indexId.length-1};
		}
		
		if (!type) type = this._type;
		
		if (type == "list" && lp != null && this.itemPull[this.idPrefix+lp] != null && typeof(this.itemPull[this.idPrefix+lp]._addSubListNode) == "function") {
			var tr = this.itemPull[this.idPrefix+lp]._addSubListNode();
		} else {
			if (type == "newcolumn") {
				var tr = {};
			} else {
				if (this.b_index == null) this._prepare(); // form wasn't inited and item added via dyn funcs
				var insBeforeBase = this.base[this.b_index];
				var insBeforeItem = null;
				if (typeof(pos) != "undefined" && !isNaN(pos) && type != "list") {
					pos = Math.max(parseInt(pos), 0)+1;
					for (var w=0; w<this.cont.childNodes.length; w++) {
						for (var q=0; q<this.cont.childNodes[w].childNodes.length; q++) {
							if (insBeforeItem == null && this.cont.childNodes[w].childNodes[q]._isNestedForm != true) {
								pos--;
								if (pos == 0) {
									insBeforeItem = this.cont.childNodes[w].childNodes[q];
									insBeforeBase = this.cont.childNodes[w];
								}
							}
						}
					}
				} else if (type == "list") { //??
					for (var a in this.itemPull) {
						if (a == this.idPrefix+id) {
							insBeforeItem = this.itemPull[a].nextSibling;
							if (this.itemPull[a]._listBase != null && this.itemPull[a]._listBase.length > 0) {
								insBeforeItem = this.itemPull[a]._listBase[this.itemPull[a]._listBase.length-1];
							}
							
						}
					}
				}
				var tr = document.createElement("DIV");
				if (insertAfter == true && insBeforeItem != null) insBeforeItem = insBeforeItem.nextSibling;
				if (insBeforeItem != null) {
					insBeforeBase.insertBefore(tr, insBeforeItem);
				} else {
					insBeforeBase.appendChild(tr);
				}
			}
		}
		
		tr._idd = id;
		tr._rId = this._rId;
		
		if (typeof(tr.style) != "undefined") {
			// read from settings if not set
			if (typeof(data.offsetLeft) == "undefined" && this.idef.offsetLeft > 0) data.offsetLeft = this.idef.offsetLeft;
			if (typeof(data.offsetTop) == "undefined" && this.idef.offsetTop > 0) data.offsetTop = this.idef.offsetTop;
			//
			var k = "";
			if (typeof(data.offsetLeft) != "undefined") k += " padding-left:"+data.offsetLeft+"px!important;";
			if (typeof(data.offsetTop) != "undefined") k += " padding-top:"+data.offsetTop+"px!important;";
			tr.style.cssText += k;
		}
		
		if (type == "block") {
			if (isNaN(data.blockOffset)) data.blockOffset = this.idef.blockOffset;
		}
		
		if (type == "list") {
			
			if (typeof(tr._ofsNested) == "undefined") tr._ofsNested = this.idef_const.offsetNested;
			
			if (sId != null) tr._sId = sId;
			
			var listData = this.items[type].render(tr, this.skin);
			
			if (!this.itemPull[this.idPrefix+id]._listObj) this.itemPull[this.idPrefix+id]._listObj = [];
			if (!this.itemPull[this.idPrefix+id]._list) this.itemPull[this.idPrefix+id]._list = [];
			if (!this.itemPull[this.idPrefix+id]._listBase) this.itemPull[this.idPrefix+id]._listBase = [];
			
			(this.itemPull[this.idPrefix+id]._listObj).push(listData[0]);
			(this.itemPull[this.idPrefix+id]._list).push(listData[1]);
			(this.itemPull[this.idPrefix+id]._listBase).push(tr);
			
			listData[1].checkEvent = function(evName) {
				return that.checkEvent(evName);
			}
			listData[1].callEvent = function(evName, evData) {
				return that.callEvent(evName, evData);
			}
			listData[1].getForm = function() {
				return that.getForm();
			}
			listData[1]._initObj(this._mergeSettings(data));
			
			if (tr._inBlcok) tr.className += " in_block";
			
			return listData[1];
			
		}
		
		if (type == "newcolumn") {
			this._prepare(data.offset, pos);
			return;
		}
		
		if (type == "label" && this._ic++ == 0) data._isTopmost = true;
		
		data.position = this.apos_css[(!data.position||!this.apos_css[data.position]?this.idef.position:data.position)];
		tr.className = data.position+(typeof(data.className)=="string"?" "+data.className:"");
		
		if (!data.labelWidth) data.labelWidth = this.idef.labelWidth;
		if (!data.labelHeight) data.labelHeight = this.idef.labelHeight;
		
		if (typeof(data.wrap) != "undefined") data.wrap = window.dhx4.s2b(data.wrap);
			
		data.labelAlign = (this.align_css[data.labelAlign]?this.align_css[data.labelAlign]:this.align_css[this.idef.labelAlign]);
		
		data.inputWidth = (data.width?data.width:(data.inputWidth?data.inputWidth:this.idef.inputWidth));
		if (!data.inputHeight) data.inputHeight = this.idef.inputHeight;
		
		if (typeof(data.note) != "undefined") {
			if (data.note.length != null && data.note[0] != null) data.note = data.note[0]; // probably array from xml conversion
			if (typeof(data.note.width) == "undefined") data.note.width = this.idef.noteWidth;
			if (data.note.width == "auto") data.note.width = data.inputWidth;
		}
		
		tr.checkEvent = function(evName) {
			return that.checkEvent(evName);
		}
		tr.callEvent = function(evName, evData) {
			return that.callEvent(evName, evData);
		}
		tr.getForm = function() {
			return that.getForm();
		}
		tr._autoCheck = function(t) {
			that._autoCheck(t);
		}
		
		// convert r/o
		if (typeof(data.readonly) == "string") data.readonly = window.dhx4.s2b(data.readonly);
		if (typeof(data.autoStart) == "string") data.autoStart = window.dhx4.s2b(data.autoStart);
		if (typeof(data.autoRemove) == "string") data.autoRemove = window.dhx4.s2b(data.autoRemove);
		if (typeof(data.titleScreen) == "string") data.titleScreen = window.dhx4.s2b(data.titleScreen);
		if (typeof(data.info) == "string") data.info = window.dhx4.s2b(data.info);
		if (typeof(data.hidden) == "string") data.hidden = window.dhx4.s2b(data.hidden);
		if (typeof(data.checked) == "string") data.checked = window.dhx4.s2b(data.checked);
		
		// userdata
		if (typeof(data.userdata) != "undefined") {
			for (var a in data.userdata) this.getForm().setUserData(id,a,data.userdata[a]);
		}
		
		// validate
		if (data.validate) {
			if (typeof(data.validate != "undefined") && (typeof(data.validate) == "function" || typeof(window[data.validate]) == "function")) {
				tr._validate = [data.validate];
			} else {
				tr._validate = String(data.validate).split(this.separator);
			}
		}
		if (typeof(data.required) != "undefined") {
			if (typeof(data.required) == "string") data.required = window.dhx4.s2b(data.required);
			tr._required = (data.required==true);
		}
		if (tr._required) {
			if (!tr._validate) tr._validate = [];
			var p = false;
			for (q=0; q<tr._validate.length; q++) p = (p||(tr._validate[q]=="NotEmpty"));
			if (!p) tr._validate.push("NotEmpty");
		}
		
		tr._ll = (data.position == this.apos_css["label-left"] || data.position == this.apos_css["label-top"]);
		
		this.objPull[this.idPrefix+id] = this.items[type].render(tr, data);
		this.itemPull[this.idPrefix+id] = tr;
		
	}
	
	/*********************************************************************************************************************************************
		OBJECT INIT
	*********************************************************************************************************************************************/
	
	this._initObj = function(data, url) {
		
		if (typeof(data.data) != "undefined") {
			// data loading
			var id = null;
			if (typeof(url) != "undefined") {
				id = url.match(/(\?|\&)id\=([a-z0-9_\-]*)/i);
				if (id != null && id[0] != null) id = id[0].split("=")[1];
			}
			if (this.callEvent("onBeforeDataLoad", [id, window.dhx4._copyObj(data.data)]) === true) {
				this.formId = id;
				this._last_load_data = data;
				this.setFormData(data.data);
				this.resetDataProcessor("updated");
			}
			
			return;
		}
		
		// struct
		this._prepare();
		
		// search form settings
		for (var q=0; q<data.length; q++) {
			// add check for incorrect values:
			// position - allow only predefined, this.apos_css
			// labelAlign - allow only predefined, this.align_css
			// input/label top/left/width/height - numeric or auto
			if (typeof(data[q]) != "undefined" && data[q].type == "settings") for (var a in data[q]) this.idef[a] = data[q][a];
		}
		
		for (var q=0; q<data.length; q++) this._prepareItem(data[q]);
		
		this._autoCheck();
	}
	
	this._prepareItem = function(data, pos, insertAfter) {
		
		var type = (data!=null && data.type!=null ? data.type : "");
		
		if (this.items[type]) {
			
			if (!data.name) data.name = this._genStr(12);
			var id = data.name;
			if (this.objPull[this.idPrefix+id] != null || type=="radio") id = this._genStr(12);
			
			var obj = data;
			obj.label = obj.label||"";
			//obj.value = obj.value||"";
			obj.value = obj.value;
			obj.checked = window.dhx4.s2b(obj.checked);
			obj.disabled = window.dhx4.s2b(obj.disabled);
			obj.name = obj.name||this._genStr(12);
			obj.options = obj.options||[];
			obj.rows = obj.rows||"none";
			obj.uid = this._genStr(12);
			
			this._addItem(type, id, obj, null, null, pos, insertAfter);
			pos = null;
			
			if (this._parentEnabled === false) this._disableItem(id);
			
			for (var w=0; w<obj.options.length; w++) {
				if (obj.options[w].list != null) {
					if (!obj.options[w].value) obj.options[w].value = this._genStr();
					var subList = this._addItem("list", id, obj.options[w].list, obj.options[w].value, null);
					subList._subSelect = true;
					subList._subSelectId = obj.options[w].value;
				}
			}
			
			
			if (data.list != null) {
				if (!data.listParent) data.listParent = obj.name;//data[q].name;
				var subList = this._addItem("list", id, data.list, null, data.listParent);
			}
		}
	}
	
	/*********************************************************************************************************************************************
		XML
	*********************************************************************************************************************************************/
	
	this._xmlSubItems = {item: "list", option: "options", note: "note", userdata: "_userdata"};
	
	this._xmlToObject = function(xml, rootLevel) {
		
		if (typeof(rootLevel) == "undefined") rootLevel = true;
		
		if (rootLevel) {
			
			// try struct
			var xmlStruct = xml.getElementsByTagName("items");
			xmlStruct = (xmlStruct != null && xmlStruct[0] != null ? xmlStruct[0] : null);
			// try data
			var xmlData = xml.getElementsByTagName("data");
			xmlData = (xmlData != null && xmlData[0] != null ? xmlData[0] : null);
			
		} else {
			xmlStruct = xml;
		}
		
		var data = (rootLevel?[]:{});
		
		if (xmlStruct != null) {
			
			for (var q=0; q<xmlStruct.childNodes.length; q++) {
				
				if (typeof(xmlStruct.childNodes[q].tagName) != "undefined") {
					
					var tg = xmlStruct.childNodes[q].tagName;
					
					if (this._xmlSubItems[tg] != null) {
						
						var node = this._xmlSubItems[tg];
						if (typeof(data[node]) == "undefined") data[node] = [];
						
						var xn = xmlStruct.childNodes[q];
						
						// parse attributes
						var k = {};
						for (var w=0; w<xn.attributes.length; w++) {
							var attrName = xn.attributes[w].name;
							var attrValue = xn.attributes[w].value;
							k[attrName] = attrValue;
						}
						
						// parse custom data
						if (node == "note") k.text = xn.firstChild.nodeValue;
						
						// pasrse userdata value
						if (node == "_userdata") k.value = (xn.firstChild != null && xn.firstChild.nodeValue != null ? xn.firstChild.nodeValue : "");
						
						// parse nested items, merge with current
						var data2 = this._xmlToObject(xn, false);
						for (var a in data2) {
							if (a == "_userdata") {
								if (!k.userdata) k.userdata = {};
								for (var w=0; w<data2[a].length; w++) k.userdata[data2[a][w].name] = data2[a][w].value;
							} else {
								k[a] = data2[a];
							}
						}
						xn = null;
						if (rootLevel) data.push(k); else data[node].push(k);
						
					}
				}
			}
		}
		
		if (xmlData != null) {
			data = {data:{}};
			for (var q=0; q<xmlData.childNodes.length; q++) {
				if (typeof(xmlData.childNodes[q].tagName) != "undefined") {
					var name = xmlData.childNodes[q].tagName;
					var value = (xmlData.childNodes[q].firstChild!=null?xmlData.childNodes[q].firstChild.nodeValue:"");
					data.data[name] = value;
				}
			}
		}
		
		return data;
		
	}
	
	/*********************************************************************************************************************************************
		AUTOCHECK (Global enable/disable functionality)
	*********************************************************************************************************************************************/
	
	this._autoCheck = function(enabled) {
		if (this._locked === true) {
			enabled = false;
		} else {
			if (typeof(enabled) == "undefined") enabled = true;
		}
		for (var a in this.itemPull) {
			var isEnabled = (enabled&&(this.itemPull[a]._udis!==true));
			this[isEnabled?"_enableItem":"_disableItem"](this.itemPull[a]._idd);
			
			// id-index state
			if (this.getForm()._idIndex[this.itemPull[a]._idd] != null) {
				this.getForm()._idIndex[this.itemPull[a]._idd].enabled = isEnabled;
			}
			
			// nested forms
			var pEnabled = (isEnabled&&(typeof(this.itemPull[a]._checked)=="boolean"?this.itemPull[a]._checked:true));
			if (this.itemPull[a]._list) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) {
					var f = true;
					if (this.itemPull[a]._list[q]._subSelect == true) {
						f = false
						var v = this.getItemValue(this.itemPull[a]._idd);
						if (!(typeof(v) == "object" && typeof(v.length) == "number")) v = [v];
						for (var w=0; w<v.length; w++) f = (v[w]==this.itemPull[a]._list[q]._subSelectId)||f;
						this.itemPull[a]._listObj[q][f?"show":"hide"](this.itemPull[a]._listBase[q]);
					}
					this.itemPull[a]._list[q]._autoCheck(pEnabled&&f);
				}
			}
		}
	}
	
	/*********************************************************************************************************************************************
		PUBLIC API
	*********************************************************************************************************************************************/
	
	this.doWithItem = function(id, method, a, b, c, d) {
		// radio
		//console.log(method)
		
		if (typeof(id) == "object") {
			var group = id[0];
			var value = id[1];
			var item = null;
			var res = null;
			for (var k in this.itemPull) {
				if ((this.itemPull[k]._value == value || value === null) && this.itemPull[k]._group == group) return this.objPull[k][method](this.itemPull[k], a, b, c, d);
				if (this.itemPull[k]._list != null && !res) {
					for (var q=0; q<this.itemPull[k]._list.length; q++) {
						res = this.itemPull[k]._list[q].doWithItem(id, method, a, b, c);
					}
				}
			}
			if (res != null) {
				return res;
			} else {
				if (method == "getType") return this.doWithItem(id[0], "getType");
			}
		// checkbox, input, select, label
		} else {
			if (!this.itemPull[this.idPrefix+id]) {
				var res = null;
				for (var k in this.itemPull) {
					if (this.itemPull[k]._list && !res) {
						for (var q=0; q<this.itemPull[k]._list.length; q++) {
							if (res == null) res = this.itemPull[k]._list[q].doWithItem(id, method, a, b, c, d);
						}
					}
				}
				return res;
			} else {
				var line = this.objPull[this.idPrefix+id];
				if (line && line[method])
					return line[method](this.itemPull[this.idPrefix+id], a, b, c, d);
			}
		}
	}
	
	this._removeItem = function(id, value) {
		if (value != null) id = this.doWithItem([id, value], "destruct"); else this.doWithItem(id, "destruct");
		this._clearItemData(id);
	}
	
	this._clearItemData = function(id) {
		if (this.itemPull[this.idPrefix+id]) {
			id = this.idPrefix+id;
			try {
				this.objPull[id] = null;
				this.itemPull[id] = null;
				delete this.objPull[id];
				delete this.itemPull[id];
			} catch(e) {}
		} else {
			for (var k in this.itemPull) {
				if (this.itemPull[k]._list) {
					for (var q=0; q<this.itemPull[k]._list.length; q++) this.itemPull[k]._list[q]._clearItemData(id);
				}
			}
		}
	}
	
	this.isItem = function(id, value) {
		if (value != null) id = [id, value];
		return this.doWithItem(id, "isExist");
	}
	
	this.getItemType = function(id, value) {
		id = [id, (value||null)];
		return this.doWithItem(id, "getType");
	}

	/* iterator */
	this.forEachItem = function(handler) {
		for (var a in this.objPull) {
			if (this.objPull[a].t == "radio") {
				handler(this.itemPull[a]._group, this.itemPull[a]._value);
			} else {
				handler(String(a).replace(this.idPrefix,""));
			}
			if (this.itemPull[a]._list) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) this.itemPull[a]._list[q].forEachItem(handler);
			}
		}
	}
	
	/* text */
	this.setItemLabel = function(id, value, text) {
		if (text != null) id = [id, value]; else text = value;
		this.doWithItem(id, "setText", text);
	}
	
	this.getItemLabel = function(id, value) {
		if (value != null) id = [id, value];
		return this.doWithItem(id, "getText");
	}
	
	/* state */
	this._enableItem = function(id) {
		this.doWithItem(id, "enable");
	}
	
	this._disableItem = function(id) {
		this.doWithItem(id, "disable");
	}
	
	this._isItemEnabled = function(id) {
		return this.doWithItem(id, "isEnabled");
	}
	
	/* selection */
	this.checkItem = function(id, value) {
		if (value != null) id = [id, value];
		this.doWithItem(id, "check");
		this._autoCheck();
	}
	
	this.uncheckItem = function(id, value) {
		if (value != null) id = [id, value];
		this.doWithItem(id, "unCheck");
		this._autoCheck();
	}
	
	this.isItemChecked = function(id, value) {
		if (value != null) id = [id, value];
		return this.doWithItem(id, "isChecked");
	}
	
	this.getCheckedValue = function(id) {
		return this.doWithItem([id, null], "getChecked");
	}
	
	/* value */
	
	// get radio group by id
	this._getRGroup = function(id, val) {
		for (var a in this.itemPull) {
			if (this.itemPull[a]._group == id && (val == null || this.itemPull[a]._value == val)) return this.itemPull[a]._idd;
			if (this.itemPull[a]._list != null) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) {
					var r = this.itemPull[a]._list[q]._getRGroup(id, val);
					if (r != null) return r;
				}
			}
		}
		return null;
	}
	
	this.setItemValue = function(id, value) {
		this.resetValidateCss(id, value);
		if (this.getItemType(id) == "radio") {
			if (this._getRGroup(id, value) != null) this.checkItem(id, value); else this.uncheckItem(id, this.getCheckedValue(id));
			return null;
		}
		return this.doWithItem(id, "setValue", value);
	}
	
	this.getItemValue = function(id, param) {
		if (this.getItemType(id) == "radio") return this.getCheckedValue(id);
		return this.doWithItem(id, "getValue", param);
	}
	
	this.updateValues = function() {
		this._updateValues();
	}
	
	/* visibility */
	this.showItem = function(id, value) {
		if (value != null) id = [id,value];
		this.doWithItem(id, "show");
	}
	
	this.hideItem = function(id, value) {
		if (value != null) id = [id,value];
		this.doWithItem(id, "hide");
	}
	
	this.isItemHidden = function(id, value) {
		if (value != null) id = [id,value];
		return this.doWithItem(id, "isHidden");
	}
	
	/* options (select only) */
	this.getOptions = function(id) {
		return this.doWithItem(id, "getOptions");
	}
	
	/* width/height */
	this.setItemWidth = function(id, width) {
		this.doWithItem(id, "setWidth", width);
	}
	
	this.getItemWidth = function(id) {
		return this.doWithItem(id, "getWidth");
	}
	
	this.setItemHeight = function(id, height) { // textarea
		this.doWithItem(id, "setHeight", height);
	}
	
	this.setItemFocus = function(id, value) {
		if (value != null) id = [id,value];
		this.doWithItem(id, "setFocus");
	}
	
	/* validation */
	
	// required before validate and data sending for updating values for input, password
	// datasending call validation inside
	this._updateValues = function() {
		for (var a in this.itemPull) {
			if (this.objPull[a] && typeof(this.objPull[a].updateValue) == "function") {
				this.objPull[a].updateValue(this.itemPull[a]);
			}
			if (this.itemPull[a]._list) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) {
					this.itemPull[a]._list[q]._updateValues();
				}
			}
		}
	}
	
	// css
	this._getItemByName = function(id) {
		for (var a in this.itemPull) {
			if (this.itemPull[a]._idd == id) return this.itemPull[a];
			if (this.itemPull[a]._list != null) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) {
					var r = this.itemPull[a]._list[q]._getItemByName(id);
					if (r != null) return r;
				}
			}
		}
		return null;
	}
	this._resetValidateCss = function(item) {
		item.className = (item.className).replace(item._vcss,"");
		item._vcss = null;
	}
	this.setValidateCss = function(name, state, custom) {
		var item = this._getItemByName(name);
		if (!item) return;
		if (item._vcss != null) this._resetValidateCss(item);
		item._vcss = (typeof(custom)=="string"?custom:"validate_"+(state===true?"ok":"error"));
		item.className += " "+item._vcss;
	}
	this.resetValidateCss = function(name) {
		for (var a in this.itemPull) {
			if (this.itemPull[a]._vcss != null) this._resetValidateCss(this.itemPull[a]);
			if (this.itemPull[a]._list != null) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) this.itemPull[a]._list[q].resetValidateCss();
			}
		}
	}
	this._validateLoop = function(handler) { // same as forEach only omit radio button value
		for (var a in this.objPull) {
			handler(String(a).replace(this.idPrefix,""));
			if (this.itemPull[a]._list) {
				for (var q=0; q<this.itemPull[a]._list.length; q++) this.itemPull[a]._list[q]._validateLoop(handler);
			}
		}
	}
	// action
	this.validate = function(type) {
		
		if (this.callEvent("onBeforeValidate",[]) == false) return;
		
		var completed = true;
		
		this._validateLoop(function(name, value){
			var k = that.doWithItem(name, "_validate");
			if (typeof(k) != "boolean") k = true;
			completed = k && completed;
		}, true);
		
		this.callEvent("onAfterValidate",[completed]);
		return completed;
		
	}
	
	this.validateItem = function(name, value) {
		if (typeof(value) != "undefined") name = [name,value];
		return this.doWithItem(name,"_validate");
	}
	
	this.enableLiveValidation = function(state) {
		this.live_validate = (state==true);
	}
	
	
	/* readonly */
	
	this.setReadonly = function(id, state) {
		this.doWithItem(id, "setReadonly", state);
	}
	
	this.isReadonly = function(id) {
		return this.doWithItem(id, "isReadonly");
	}
	
	/* index */
	
	this.getFirstActive = function(withFocus) {
		for (var q=0; q<this._indexId.length; q++) {
			var k = true;
			if (withFocus == true) {
				var t = this.getItemType(this._indexId[q]);
				if (!dhtmlXForm.prototype.items[t].setFocus) k = false;
			}
			if (k && this._idIndex[this._indexId[q]].enabled) return this._indexId[q];
		}
		return null;
	}
	
	this.setFocusOnFirstActive = function() {
		var k = this.getFirstActive(true);
		if (k != null) this.setItemFocus(k);
	}
	
	/* enable/disable */
	
	this.enableItem = function(id, value) {
		if (value != null) id = [id,value];
		this.doWithItem(id, "userEnable");
		this._autoCheck();
	}
	
	this.disableItem = function(id, value) {
		if (value != null) id = [id,value];
		this.doWithItem(id, "userDisable");
		this._autoCheck();
	}
	
	this.isItemEnabled = function(id, value) {
		if (value != null) id = [id,value];
		return this.doWithItem(id, "isUserEnabled");
	}
	
	this.clear = function() {
		var usedRAs = {};
		this.formId = (new Date()).valueOf();//remove form id, so next operation will be insert
		this.resetDataProcessor("inserted");
		
		for (var a in this.itemPull) {
			var t = this.itemPull[a]._idd;
			// checkbox
			if (this.itemPull[a]._type == "ch") this.uncheckItem(t);
			// input/textarea
			if (this.itemPull[a]._type in {"ta":1,"editor":1,"calendar":1,"pw":1,"hd":1})
				this.setItemValue(t, "");
			// dhxcombo
			if (this.itemPull[a]._type == "combo") {
				this.itemPull[a]._apiChange = true;
				var combo = this.getCombo(t);
				combo.selectOption(0);
				combo = null;
				this.itemPull[a]._apiChange = false;
			}
			// select
			if (this.itemPull[a]._type == "se") {
				var opts = this.getOptions(t);
				if (opts.length > 0) opts[0].selected = true;
			}
			// radiobutton
			if (this.itemPull[a]._type == "ra") {
				var g = this.itemPull[a]._group;
				if (!usedRAs[g]) { this.checkItem(g, this.doWithItem(t, "_getFirstValue")); usedRAs[g] = true; }
			}
			// nested lists
			if (this.itemPull[a]._list) for (var q=0; q<this.itemPull[a]._list.length; q++) this.itemPull[a]._list[q].clear();
			// check for custom cell
			if (this["setFormData_"+this.itemPull[a]._type]) {
				this["setFormData_"+this.itemPull[a]._type](t,"");
			}
		}
		usedRAs = null;
		if (this._parentForm) this._autoCheck();
		
		// validate
		this.resetValidateCss();
		
	}
	
	this.unload = function() {
		
		window.dhx4._enableDataLoading(this, null, null, null, "clear");
		window.dhx4._eventable(this, "clear");
		
		for (var a in this.objPull) this._removeItem(String(a).replace(this.idPrefix,""));
		
		if (this._ccTm) window.clearTimeout(this._ccTm);
		this._formLS = null;
		
		for (var q=0; q<this.base.length; q++) {
			while (this.base[q].childNodes.length > 0) this.base[q].removeChild(this.base[q].childNodes[0]);
			if (this.base[q].parentNode) this.base[q].parentNode.removeChild(this.base[q]);
			this.base[q] = null;
		}
		this.base = null;
		
		this.cont.onkeypress = null;
		this.cont.className = "";
		this.cont = null;
		
		for (var a in this) this[a] = null;
		
		that = null;
		
	}
	
	for (var a in this.items) {
		
		this.items[a].t = a;
		
		if (typeof(this.items[a]._index) == "undefined") {
			this.items[a]._index = true;
		}
		
		if (!this.items[a].show) {
			this.items[a].show = function(item) {
				item.style.display = "";
				if (item._listObj) for (var q=0; q<item._listObj.length; q++) item._listObj[q].show(item._listBase[q]);
			}
		}
		
		if (!this.items[a].hide) {
			this.items[a].hide = function(item) {
				item.style.display = "none";
				if (item._listObj) for (var q=0; q<item._listObj.length; q++) item._listObj[q].hide(item._listBase[q]);
			}
		}
		
		if (!this.items[a].isHidden) {
			this.items[a].isHidden = function(item) {
				return (item.style.display == "none");
			}
		}
		
		if (!this.items[a].userEnable) {
			this.items[a].userEnable = function(item) {
				item._udis = false;
			}
		}
			
		if (!this.items[a].userDisable) {
			this.items[a].userDisable = function(item) {
				item._udis = true;
			}
		}
		
		if (!this.items[a].isUserEnabled) {
			this.items[a].isUserEnabled = function(item) {
				return (item._udis!==true);
			}
		}
		
		if (!this.items[a].getType) {
			this.items[a].getType = function() {
				return this.t;
			}
		}
		
		if (!this.items[a].isExist) {
			this.items[a].isExist = function() {
				return true;
			}
		}
		
		if (!this.items[a]._validate) {
			this.items[a]._validate = function(item) {
				
				if (!item._validate || !item._enabled) return true;
				
				if (item._type == "ch" || item._type == "ra") {
					var val = (this.isChecked(item)?this.getValue(item):0);
					if (item._type == "ra" && typeof(val) == "undefined") val = 0;
				} else {
					var val = this.getValue(item);
				}
				
				var r = true;
				
				for (var q=0; q<item._validate.length; q++) {
					
					var v = "is"+item._validate[q];
					
					if ((val == null || val.length == 0) && v != "isNotEmpty" && item._type != "container") {
						// field not required or empty (+ validate not set to NotEmpty)
					} else {
						var f = dhtmlxValidation[v];
						
						if (item._type == "container" && typeof(f) == "function") f = function(){return true;}
						
						if (typeof(f) != "function" && typeof(item._validate[q]) == "function") f = item._validate[q];
						if (typeof(f) != "function" && typeof(window[item._validate[q]]) == "function") f = window[item._validate[q]];
						r = ((typeof(f)=="function"?f(val,item._idd):new RegExp(item._validate[q]).test(val)) && r);
						f = null;
					}
				}
				
				if (!(item.callEvent("onValidate"+(r?"Success":"Error"),[item._idd,val,r])===false)) item.getForm().setValidateCss(item._idd, r);
				
				return r;
			}
		}
		
		
	}
	
	// lock/unlock form
	this._locked = false;
	this._doLock = function(state) {
		var t = (state===true?true:false);
		if (this._locked == t) return; else this._locked = t;
		this._autoCheck(!this._locked);
	}
	this.lock = function() {
		this._doLock(true);
	}
	this.unlock = function() {
		this._doLock(false);
	}
	this.isLocked = function() {
		return this._locked;
	}
	
	// date format for inputs
	this.setNumberFormat = function(id, format, g_sep, d_sep) {
		// return false if format incorrect and true if it successfuly applied
		return this.doWithItem(id, "setNumberFormat", format, g_sep, d_sep);
	}
	
	window.dhx4._enableDataLoading(this, "_initObj", "_xmlToObject", "items", {struct: true, data: true});
	window.dhx4._eventable(this);
	
	this.attachEvent("_onButtonClick", function(name, cmd){
		this.callEvent("onButtonClick", [name, cmd]);
	});
	
	this._updateBlocks = function() {
		this.forEachItem(function(id){
			if (that.getItemType(id) == "block" || that.getItemType(id) == "combo") {
				that.doWithItem(id,"_setCss",that.skin,that.cont.style.fontSize);
			}
		});
	}
	
	// copy init data to prevent init obj extension
	this._isObj = function(k) {
		return (k != null && typeof(k) == "object" && typeof(k.length) == "undefined");
	}
	this._copyObj = function(r) {
		if (this._isObj(r)) {
			var t = {};
			for (var a in r) {
				if (typeof(r[a]) == "object" && r[a] != null) t[a] = this._copyObj(r[a]); else t[a] = r[a];
			}
		} else {
			var t = [];
			for (var a=0; a<r.length; a++) {
				if (typeof(r[a]) == "object" && r[a] != null) t[a] = this._copyObj(r[a]); else t[a] = r[a];
			}
		}
		return t;
	}
	//
	
	if (data != null && typeof(data) == "object") {
		this._initObj(this._copyObj(data));
	};
	
	if (this._parentForm) {
		this._updateBlocks();
	}
	
	// ls for input change, affected: input, select, pwd, calendar, colorpicker
	this._ccActive = false;
	this._ccTm = null;
	
	return this;
	
};

dhtmlXForm.prototype.getInput = function(id) {
	return this.doWithItem(id, "getInput");
};

dhtmlXForm.prototype.getSelect = function(id) {
	return this.doWithItem(id, "getSelect");
};


dhtmlXForm.prototype.items = {};

/* checkbox */
dhtmlXForm.prototype.items.checkbox = {
	getInput: function(item) {
		return item.getElementsByTagName("INPUT")[0];
	},
	render: function(item, data) {
		
		item._type = "ch";
		item._enabled = true;
		item._checked = false;
		item._value = (typeof(data.value)=="undefined"?null:String(data.value));
		item._ro = (data.readonly==true);
		
		if (data._autoInputWidth !== false) data.inputWidth = 14;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "INPUT", "TEXT", true, true, "dhxform_textarea");
		
		item.childNodes[item._ll?1:0].className += " dhxform_img_node";
		
		var p = document.createElement("DIV");
		p.className = "dhxform_img chbx0";
		item.appendChild(p);
		
		if (!isNaN(data.inputLeft)) item.childNodes[item._ll?1:0].style.left = parseInt(data.inputLeft)+"px";
		if (!isNaN(data.inputTop)) item.childNodes[item._ll?1:0].style.top = parseInt(data.inputTop)+"px";
		
		item.childNodes[item._ll?1:0].appendChild(p);
		item.childNodes[item._ll?1:0].firstChild.value = String(data.value);
		
		item._updateImgNode = function(item, state) {
			var t = item.childNodes[item._ll?1:0].lastChild;
			t.className = (state?"dhxform_actv_c":"dhxform_img")+" "+(item._checked?"chbx1":"chbx0");
			item = t = null;
		}
		
		item._doOnFocus = function(item) {
			item.getForm().callEvent("onFocus",[item._idd]);
		}
		
		item._doOnBlur = function(item) {
			item.getForm().callEvent("onBlur",[item._idd]);
		}
		
		item._doOnKeyUpDown = function(evName, evObj) {
			this.callEvent(evName, [this.childNodes[this._ll?0:1].childNodes[0], evObj, this._idd]);
		}
		
		if (data.checked == true) this.check(item);
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		this.doAttachEvents(item);
		
		return this;
	},
	
	destruct: function(item) {
		item._doOnFocus = item._doOnBlur = item._updateImgNode = null;
		this.doUnloadNestedLists(item);
		this.doDestruct(item);
	},
	
	doAddLabel: function(item, data) {
		
		var t = document.createElement("DIV");
		t.className = "dhxform_label "+data.labelAlign;
		
		if (data.wrap == true) t.style.whiteSpace = "normal";
		
		if (item._ll) {
			item.insertBefore(t,item.firstChild);
		} else {
			item.appendChild(t);
		}
		
		if (typeof(data.tooltip) != "undefined") t.title = data.tooltip;
		
		t.innerHTML = "<div class='dhxform_label_nav_link' "+
				"onfocus='if(this.parentNode.parentNode._updateImgNode)this.parentNode.parentNode._updateImgNode(this.parentNode.parentNode,true);this.parentNode.parentNode._doOnFocus(this.parentNode.parentNode);' "+
				"onblur='if(this.parentNode.parentNode._updateImgNode)this.parentNode.parentNode._updateImgNode(this.parentNode.parentNode,false);this.parentNode.parentNode._doOnBlur(this.parentNode.parentNode);' "+
				"onkeypress='var e=event||window.arguments[0];if(e.keyCode==32||e.charCode==32){e.cancelBubble=true;if(e.preventDefault)e.preventDefault();else e.returnValue=false;_dhxForm_doClick(this,\"mousedown\");return false;}' "+
				"onkeyup='var e=event||window.arguments[0];this.parentNode.parentNode._doOnKeyUpDown(\"onKeyUp\",e);' "+
				"onkeydown='var e=event||window.arguments[0];this.parentNode.parentNode._doOnKeyUpDown(\"onKeyDown\",e);' "+
				(window.dhx4.isIPad?"ontouchstart='var e=event;e.preventDefault();_dhxForm_doClick(this,\"mousedown\");' ":"")+
				"role='link' tabindex='0'>"+data.label+(data.info?"<span class='dhxform_info'>[?]</span>":"")+(item._required?"<span class='dhxform_item_required'>*</span>":"")+'</div>';
		
		if (!isNaN(data.labelWidth)) t.firstChild.style.width = parseInt(data.labelWidth)+"px";
		if (!isNaN(data.labelHeight)) t.firstChild.style.height = parseInt(data.labelHeight)+"px";
		
		if (!isNaN(data.labelLeft)) t.style.left = parseInt(data.labelLeft)+"px";
		if (!isNaN(data.labelTop)) t.style.top = parseInt(data.labelTop)+"px";
		
	},
	
	doAddInput: function(item, data, el, type, pos, dim, css) {
		
		var p = document.createElement("DIV");
		p.className = "dhxform_control";
		
		if (item._ll) {
			item.appendChild(p);
		} else {
			item.insertBefore(p,item.firstChild);
		}
		
		var t = document.createElement(el);
		t.className = css;
		t.name = item._idd;
		t._idd = item._idd;
		t.id = data.uid;
		
		if (typeof(type) == "string") t.type = type;
		
		if (el == "INPUT" || el == "TEXTAREA") {
			t.onkeyup = function(e) {
				e = e||event;
				item.callEvent("onKeyUp",[this,e,this._idd]);
			};
			t.onkeydown = function(e) {
				e = e||event;
				item.callEvent("onKeyDown",[this,e,this._idd]);
			};
		}
		
		if (el == "SELECT" && data.type == "select" && item.getForm().skin == "material") {
			if (window.dhx4.isOpera || window.dhx4.isChrome) {
				t.className += " dhxform_arrow_fix_webkit";
			} else if (window.dhx4.isEdge) {
				t.className += " dhxform_arrow_fix_edge";
			} else if (window.dhx4.isFF) {
				t.className += " dhxform_fix_ff";
			}
		}
		
		p.appendChild(t);
		
		if (pos) {
			if (!isNaN(data.inputLeft)) p.style.left = parseInt(data.inputLeft)+"px";
			if (!isNaN(data.inputTop)) p.style.top = parseInt(data.inputTop)+"px";
		}
		
		var u = "";
		
		var dimFix = false;
		if (dim) {
			if (!isNaN(data.inputWidth)) { u += "width:"+parseInt(data.inputWidth)+"px;"; dimFix=true; }
			if (!isNaN(data.inputHeight)) u += "height:"+parseInt(data.inputHeight)+"px;";
		}
		if (typeof(data.style) == "string") u += data.style;
		t.style.cssText = u;
		
		if (data.maxLength) t.setAttribute("maxLength", data.maxLength);
		if (data.connector) t.setAttribute("connector",data.connector);
		
		var i = (dhtmlXForm.prototype.items[this.t] != null ? dhtmlXForm.prototype.items[this.t]._dimFix == true : false);
		if (dimFix && ({input: 1, password:1, select:1, multiselect:1, calendar:1, colorpicker:1}[this.t] == 1 || i)) {
			if (dhtmlXForm.prototype.items[this.t]._dim == null) dhtmlXForm.prototype.items[this.t]._dim = item.getForm()._checkDim(p, t);
			t.style.width = parseInt(t.style.width)-dhtmlXForm.prototype.items[this.t]._dim+"px";
		}
		
		if (typeof(data.note) == "object") {
			var note = document.createElement("DIV");
			note.className = "dhxform_note";
			note.style.width = (isNaN(data.note.width)?t.offsetWidth:parseInt(data.note.width))+"px";
			note._w = data.note.width;
			note.innerHTML = data.note.text;
			p.appendChild(note);
			note = null;
		}
		
		if (data.readonly) this.setReadonly(item, true);
		if (data.disabled == true) this.userDisable(item);
		if (data.hidden == true && this.t != "combo") this.hide(item);
		
	},
	
	doUnloadNestedLists: function(item) {
		
		if (!item._list) return;
		for (var q=0; q<item._list.length; q++) {
			item._list[q].unload();
			item._list[q] = null;
			item._listObj[q] = null;
			item._listBase[q].parentNode.removeChild(item._listBase[q]);
			item._listBase[q] = null;
		}
		item._list = null;
		item._listObj = null;
		item._listBase = null;
	},
	
	doDestruct: function(item) {
		
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		
		item._autoCheck = null;
		item._checked = null;
		item._enabled = null;
		item._idd = null;
		item._type = null;
		item._value = null;
		item._group = null;
		
		item.onselectstart = null;
		
		item.childNodes[item._ll?1:0].onmousedown = null;
		item.childNodes[item._ll?1:0].ontouchstart = null;
		
		item.childNodes[item._ll?0:1].onmousedown = null;
		item.childNodes[item._ll?0:1].ontouchstart = null;
		
		item.childNodes[item._ll?0:1].childNodes[0].onfocus = null;
		item.childNodes[item._ll?0:1].childNodes[0].onblur = null;
		item.childNodes[item._ll?0:1].childNodes[0].onkeypress = null;
		item.childNodes[item._ll?0:1].childNodes[0].onkeyup = null;
		item.childNodes[item._ll?0:1].childNodes[0].onkeydown = null;
		item.childNodes[item._ll?0:1].childNodes[0].onmousedown = null;
		item.childNodes[item._ll?0:1].childNodes[0].ontouchstart = null;
		item.childNodes[item._ll?0:1].removeChild(item.childNodes[item._ll?0:1].childNodes[0]);
		
		while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
		
		item.parentNode.removeChild(item);
		item = null;
		
	},
	
	doAttachEvents: function(item) {
		var that = this;
		// image click
		item.childNodes[item._ll?1:0][window.dhx4.isIPad?"ontouchstart":"onmousedown"] = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault();
			var t = (e.target||e.srcElement); // need to skip "note" if exists
			if (!this.parentNode._enabled || this.parentNode._ro || (typeof(t.className) != "undefined" && t.className == "dhxform_note")) {
				e.cancelBubble = true;
				if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
				return false;
			}
			that.doClick(this.parentNode);
		}
		// label click
		item.childNodes[item._ll?0:1].childNodes[0][window.dhx4.isIPad?"ontouchstart":"onmousedown"] = function(e) {
			e = e||event;
			if (e.preventDefault) e.preventDefault();
			// do not check if r/o here, allow item's be highlighted, check for r/o added into doClick
			if (!this.parentNode.parentNode._enabled) {
				e.cancelBubble = true;
				if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
				return false;
			}
			// check if "info" clicked (checkbox/radio only)
			var t = e.target||e.srcElement;
			if (typeof(t.className) != "undefined" && t.className == "dhxform_info") {
				this.parentNode.parentNode.callEvent("onInfo",[this.parentNode.parentNode._idd, e]);
				e.cancelBubble = true;
				if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
				return false;
			}
			that.doClick(this.parentNode.parentNode);
		}
	},
	
	doClick: function(item) {
		
		item.childNodes[item._ll?0:1].childNodes[0].focus();
		
		if (!item._enabled || item._ro) return;
		
		if (item.checkEvent("onBeforeChange")) if (item.callEvent("onBeforeChange", [item._idd, item._value, item._checked]) !== true) return;
		
		this.setChecked(item, !item._checked);
		item._autoCheck();
		item.callEvent("onChange", [item._idd, item._value, item._checked]);
	},
	
	doCheckValue: function(item) {
		if (item._checked && item._enabled) {
			item.childNodes[item._ll?1:0].firstChild.name = String(item._idd);
			item.childNodes[item._ll?1:0].firstChild.value = this.getValue(item);
		} else {
			item.childNodes[item._ll?1:0].firstChild.name = "";
			item.childNodes[item._ll?1:0].firstChild.value = "";
		}
	},
	
	setChecked: function(item, state) {
		item._checked = (state===true?true:false);
		//item.childNodes[item._ll?1:0].lastChild.className = "dhxform_img "+(item._checked?"chbx1":"chbx0");
		item.childNodes[item._ll?1:0].lastChild.className = item.childNodes[item._ll?1:0].lastChild.className.replace(/chbx[0-1]{1}/gi,"")+(item._checked?" chbx1":" chbx0");
		this.doCheckValue(item);
	},
	
	check: function(item) {
		this.setChecked(item, true);
	},
	
	unCheck: function(item) {
		this.setChecked(item, false);
	},
	
	isChecked: function(item) {
		return item._checked;
	},
	
	enable: function(item) {
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._enabled = true;
		item.childNodes[item._ll?0:1].childNodes[0].tabIndex = 0;
		item.childNodes[item._ll?0:1].childNodes[0].removeAttribute("disabled");
		this.doCheckValue(item);
	},
	
	disable: function(item) {
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._enabled = false;
		if (item._updateImgNode != null) item._updateImgNode(item, false); // clear focus on disable fix
		item.childNodes[item._ll?0:1].childNodes[0].tabIndex = -1;
		item.childNodes[item._ll?0:1].childNodes[0].setAttribute("disabled", "true");
		this.doCheckValue(item);
	},
	
	isEnabled: function(item) {
		return item._enabled;
	},
	
	setText: function(item, text) {
		item.childNodes[item._ll?0:1].childNodes[0].innerHTML = text+(item._required?"<span class='dhxform_item_required'>*</span>":"");
	},
	
	getText: function(item) {
		return item.childNodes[item._ll?0:1].childNodes[0].innerHTML.replace(/<span class=\"dhxform_item_required\">[^<]*<\/span>/g,"");
	},
	
	setValue: function(item, value) {
		this.setChecked(item,(value===true||parseInt(value)==1||value=="true"||item._value===value));
	},
	
	getValue: function(item, mode) {
		if (mode == "realvalue") return item._value;
		return ((typeof(item._value)=="undefined"||item._value==null)?(item._checked?1:0):item._value);
	},
	
	setReadonly: function(item, state) {
		item._ro = (state===true);
	},
	
	isReadonly: function(item) {
		return item._ro;
	},
	
	setFocus: function(item) {
		item.childNodes[item._ll?0:1].childNodes[0].focus();
	}
	
};

/* radio */
dhtmlXForm.prototype.items.radio = {
	
	input: {},
	
	r: {},
	
	firstValue: {},
	
	render: function(item, data, uid) {
		
		item._type = "ra";
		item._enabled = true;
		item._checked = false;
		item._group = data.name;
		item._value = data.value;
		item._uid = uid;
		item._ro = (data.readonly==true);
		item._rName = item._rId+item._group;
		
		this.r[item._idd] = item;
		
		data.inputWidth = 14;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "INPUT", "TEXT", true, true, "dhxform_textarea");
		
		item.childNodes[item._ll?1:0].className += " dhxform_img_node";
		
		// radio img
		var p = document.createElement("DIV");
		p.className = "dhxform_img rdbt0";
		item.appendChild(p);
		
		if (!isNaN(data.inputLeft)) item.childNodes[item._ll?1:0].style.left = parseInt(data.inputLeft)+"px";
		if (!isNaN(data.inputTop)) item.childNodes[item._ll?1:0].style.top = parseInt(data.inputTop)+"px";
		
		item.childNodes[item._ll?1:0].appendChild(p);
		
		// hidden input needed just to keep common logic, name-value should be empty to prevent sending to server from real form
		item.childNodes[item._ll?1:0].firstChild.name = "";
		item.childNodes[item._ll?1:0].firstChild.value = "";
		
		item._updateImgNode = function(item, state) {
			var t = item.childNodes[item._ll?1:0].lastChild;
			t.className = (state?"dhxform_actv_r":"dhxform_img")+" "+(item._checked?"rdbt1":"rdbt0");
			item = t = null;
		}
		
		item._doOnFocus = function(item) {
			item.getForm().callEvent("onFocus",[item._group, item._value]);
		}
		
		item._doOnBlur = function(item) {
			item.getForm().callEvent("onBlur",[item._group, item._value]);
		}
		
		item._doOnKeyUpDown = function(evName, evObj) {
			this.callEvent(evName, [this.childNodes[this._ll?0:1].childNodes[0], evObj, this._group, this._value]);
		}
		
		// input
		if (this.input[item._rName] == null) {
			var k = document.createElement("INPUT");
			k.type = "HIDDEN";
			k.name = data.name;
			k.firstValue = item._value;
			item.appendChild(k);
			this.input[item._rName] = k;
		}
		
		if (!this.firstValue[item._rName]) this.firstValue[item._rName] = data.value;
		
		if (data.checked == true) this.check(item);
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		this.doAttachEvents(item);
		
		return this;
	},
	
	destruct: function(item, value) {
		
		// check if any items will left to keep hidden input on page
		
		if (item.lastChild == this.input[item._rName]) {
			var done = false;
			for (var a in this.r) {
				if (!done && this.r[a]._group == item._group && this.r[a]._idd != item._idd) {
					this.r[a].appendChild(this.input[item._rName]);
					done = true;
				}
			}
			if (!done) {
				// remove hidden input
				this.input[item._rName].parentNode.removeChild(this.input[item._rName]);
				this.input[item._rName] = null;
				this.firstValue[item._rName] = null;
			}
		}
		
		this.r[item._idd] = null;
		delete this.r[item._idd];
		
		item._doOnFocus = item._doOnBlur = item._updateImgNode = null;
		this.doUnloadNestedLists(item);
		this.doDestruct(item);
		
		var id = item._idd;
		item = null;
		
		return id;
		
	},
	
	doClick: function(item) {
		
		item.childNodes[item._ll?0:1].childNodes[0].focus();
		
		if (!(item._enabled && !item._checked)) return;
		if (item._ro) return;
		
		var args = [item._group, item._value, true];
		if (item.checkEvent("onBeforeChange")) if (item.callEvent("onBeforeChange", args) !== true) return;
		this.setChecked(item, true);
		item.getForm()._autoCheck();
		item.callEvent("onChange", args);
		
	},
	
	doCheckValue: function(item) {
		var value = null;
		for (var a in this.r) {
			if (this.r[a]._checked && this.r[a]._group == item._group && this.r[a]._rId == item._rId) value = this.r[a]._value; // allow getChecked for disabled, v3.6.2
		}
		if (value != null && this.r[a]._enabled) {
			this.input[item._rName].name = String(item._group);
			this.input[item._rName].value = value;
		} else {
			this.input[item._rName].name = "";
			this.input[item._rName].value = "";
		}
		this.input[item._rName]._value = value;
	},
	
	setChecked: function(item, state) {
		state = (state===true);
		for (var a in this.r) {
			if (this.r[a]._group == item._group && this.r[a]._rId == item._rId) {
				var needCheck = false;
				if (this.r[a]._idd == item._idd) {
					if (this.r[a]._checked != state) { this.r[a]._checked = state; needCheck = true; }
				} else {
					if (this.r[a]._checked) { this.r[a]._checked = false; needCheck = true; }
				}
				if (needCheck) {
					var t = this.r[a].childNodes[this.r[a]._ll?1:0].childNodes[1];
					t.className = t.className.replace(/rdbt[0-1]{1}/gi,"")+(this.r[a]._checked?" rdbt1":" rdbt0");
					t = null;
				}
			}
		}
		this.doCheckValue(item);
	},
	
	getChecked: function(item) {
		return this.input[item._rName]._value;
	},
	
	_getFirstValue: function(item) {
		return this.firstValue[item._rName];
	},
	
	_getId: function(item) {
		return item._idd; // return inner id by name/value
	},
	
	setValue: function(item, value) {
		// this method will never called at all
	}
	
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,doDestruct:1,doUnloadNestedLists:1,doAttachEvents:1,check:1,unCheck:1,isChecked:1,enable:1,disable:1,isEnabled:1,setText:1,getText:1,getValue:1,setReadonly:1,isReadonly:1,setFocus:1})
		dhtmlXForm.prototype.items.radio[a] = dhtmlXForm.prototype.items.checkbox[a];
})();


/* select */
dhtmlXForm.prototype.items.select = {
	
	render: function(item, data) {
		
		item._type = "se";
		item._enabled = true;
		item._value = null;
		item._newValue = null;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "SELECT", null, true, true, "dhxform_select");
		this.doAttachEvents(item);
		
		this.doLoadOpts(item, data);
		if (data.connector != null) this.doLoadOptsConnector(item, data.connector);
		
		if (typeof(data.value) != "undefined" && data.value != null) {
			this.setValue(item, data.value);
		}
		
		return this;
	},
	
	destruct: function(item) {
		
		this.doUnloadNestedLists(item);
		
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		
		item._autoCheck = null;
		item._enabled = null;
		item._idd = null;
		item._type = null;
		item._value = null;
		item._newValue = null;
		
		item.onselectstart = null;
		
		item.childNodes[item._ll?1:0].childNodes[0].onclick = null;
		item.childNodes[item._ll?1:0].childNodes[0].onkeydown = null;
		item.childNodes[item._ll?1:0].childNodes[0].onchange = null;
		item.childNodes[item._ll?1:0].childNodes[0].onfocus = null;
		item.childNodes[item._ll?1:0].childNodes[0].onblur = null;
		item.childNodes[item._ll?1:0].childNodes[0].onkeyup = null;
		item.childNodes[item._ll?1:0].removeChild(item.childNodes[item._ll?1:0].childNodes[0]);
		
		while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
		
		item.parentNode.removeChild(item);
		item = null;
		
	},
	
	doAddLabel: function(item, data) {
		
		var j = document.createElement("DIV");
		j.className = "dhxform_label "+data.labelAlign;
		j.innerHTML = "<label for='"+data.uid+"'>"+
				data.label+
				(data.info?"<span class='dhxform_info'>[?]</span>":"")+
				(item._required?"<span class='dhxform_item_required'>*</span>":"")+
				"</label>";
		//
		if (data.wrap == true) j.style.whiteSpace = "normal";
		
		if (typeof(data.tooltip) != "undefined") j.title = data.tooltip;
		
		item.appendChild(j);
		
		if (typeof(data.label) == "undefined" || data.label == null || data.label.length == 0) j.style.display = "none";
		
		if (!isNaN(data.labelWidth)) j.style.width = parseInt(data.labelWidth)+"px";
		if (!isNaN(data.labelHeight)) j.style.height = parseInt(data.labelHeight)+"px";
		
		if (!isNaN(data.labelLeft)) j.style.left = parseInt(data.labelLeft)+"px";
		if (!isNaN(data.labelTop)) j.style.top = parseInt(data.labelTop)+"px";
		
		if (data.info) {
			j.onclick = function(e) {
				e = e||event;
				var t = e.target||e.srcElement;
				if (typeof(t.className) != "undefined" && t.className == "dhxform_info") {
					this.parentNode.callEvent("onInfo",[this.parentNode._idd, e]);
					e.cancelBubble = true;
					if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
					return false;
				}
			}
		}
	},
	
	doAttachEvents: function(item) {
		
		var t = item.childNodes[item._ll?1:0].childNodes[0];
		var that = this;
		
		t.onclick = function() {
			that.doOnChange(this);
		}
		t.onkeydown = function(e) {
			e = e||event;
			that.doOnChange(this);
			this.parentNode.parentNode.callEvent("onKeyDown",[this,e,this.parentNode.parentNode._idd]);
		}
		t.onchange = function() {
			that.doOnChange(this);
		}
		t.onkeyup = function(e) {
			e = e||event;
			this.parentNode.parentNode.callEvent("onKeyUp",[this,e,this.parentNode.parentNode._idd]);
		}
		t = null;
		
		this.doAttachChangeLS(item);
	},
	
	doAttachChangeLS: function(item) {
		
		var t = item.childNodes[item._ll?1:0].childNodes[0];
		t.onfocus = function() {
			var i = this.parentNode.parentNode;
			i.getForm()._ccActivate(i._idd, this, i.getForm().getItemValue(i._idd,true));
			i.getForm().callEvent("onFocus",[i._idd]);
			i = null;
		}
		t.onblur = function() {
			var i = this.parentNode.parentNode;
			i.getForm()._ccDeactivate(i._idd);
			i.getForm().callEvent("onBlur",[i._idd]);
			i = null;
		}
		t = null;
	},
	
	doValidate: function(item) {
		if (item.getForm().live_validate) this._validate(item);
	},
	
	doLoadOpts: function(item, data, callEvent) {
		var t = item.childNodes[item._ll?1:0].childNodes[0];
		var opts = data.options;
		var k = false;
		for (var q=0; q<opts.length; q++) {
			var t0 = opts[q].text||opts[q].label;
			if (!t0 || typeof(t0) == "undefined") t0 = "";
			var opt = new Option(t0, opts[q].value);
			if (typeof(opts[q].img_src) == "string") opt.setAttribute("img_src", opts[q].img_src);
			t.options.add(opt);
			// selected
			if (typeof(opts[q].selected) != "undefined" && window.dhx4.s2b(opts[q].selected) == true) {
				opt.selected = true;
				item._value = opts[q].value;
				k = true;
			}
			// cehcked (combo only)
			if (typeof(opts[q].checked) != "undefined" && window.dhx4.s2b(opts[q].checked) == true) {
				opt.setAttribute("checked", "1");
			}
			// images (combo only)
			if (typeof(opts[q].img) != "undefined") opt.setAttribute("img", opts[q].img);
			if (typeof(opts[q].img_dis) != "undefined") opt.setAttribute("img_dis", opts[q].img_dis);
			// cehcked (combo only)
			if (typeof(opts[q].css) != "undefined") opt.setAttribute("css", opts[q].css);
		}
		// if "selected" option was not specified, check selected in control
		if (!k && t.selectedIndex >= 0) item._value = t.options[t.selectedIndex].value;
		
		if (callEvent === true) item.callEvent("onOptionsLoaded", [item._idd]);
		// fix note if width set to auto
		this._checkNoteWidth(item);
	},
	
	doLoadOptsConnector: function(item, url) {
		
		var that = this;
		item._connector_working = true;
		
		window.dhx4.ajax.get(url, function(r) {
			
			r = r.xmlDoc.responseXML;
			if (r == null) return;
			
			var root = r.getElementsByTagName("data");
			if (root == null || root[0] == null) return;
			
			root = root[0];
			
			var opts = [];
			for (var q=0; q<root.childNodes.length; q++) {
				if (typeof(root.childNodes[q].tagName) != "undefined" && String(root.childNodes[q].tagName).toLowerCase() == "item") {
					var option = root.childNodes[q];
					opts.push({
						label: option.getAttribute("label"),
						value: option.getAttribute("value"),
						selected: (option.getAttribute("selected") != null)
					});
					option = null;
				}
			}
			
			that.doLoadOpts(item, {options:opts}, true);
			
			// try to set value if it was called while options loading was in progress
			
			item._connector_working = false;
			if (item._connector_value != null) {
				that.setValue(item, item._connector_value);
				item._connector_value = null;
			}
			
			that = item = null;
		});
	},
	
	doOnChange: function(sel) {
		var item = sel.parentNode.parentNode;
		item._newValue = (sel.selectedIndex>=0?sel.options[sel.selectedIndex].value:null);
		if (item._newValue != item._value) {
			if (item.checkEvent("onBeforeChange")) {
				if (item.callEvent("onBeforeChange", [item._idd, item._value, item._newValue]) !== true) {
					// restore last value
					for (var q=0; q<sel.options.length; q++) if (sel.options[q].value == item._value) sel.options[q].selected = true;
					return;
				}
			}
			item._value = item._newValue;
			item.callEvent("onChange", [item._idd, item._value]);
			if (item._type == "se" && item.getForm().live_validate) this._validate(item);
		}
		item._autoCheck();
	},
	
	setText: function(item, text) {
		if (!text) text = "";
		item.childNodes[item._ll?0:1].childNodes[0].innerHTML = text+(item._required?"<span class='dhxform_item_required'>*</span>":"");
		item.childNodes[item._ll?0:1].style.display = (text.length==0||text==null?"none":"");
	},
	
	getText: function(item) {
		return item.childNodes[item._ll?0:1].childNodes[0].innerHTML.replace(/<span class=\"dhxform_item_required\">[^<]*<\/span>/g,"");
	},
	
	enable: function(item) {
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._enabled = true;
		item.childNodes[item._ll?1:0].childNodes[0].removeAttribute("disabled");
	},
	
	disable: function(item) {
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._enabled = false;
		item.childNodes[item._ll?1:0].childNodes[0].setAttribute("disabled", true);
	},
	
	getOptions: function(item) {
		return item.childNodes[item._ll?1:0].childNodes[0].options;
	},
	
	setValue: function(item, val) {
		if (item._connector_working) { // attemp to set value while optins not yet loaded (connector used)
			item._connector_value = val;
			return;
		}
		var opts = this.getOptions(item);
		for (var q=0; q<opts.length; q++) {
			if (opts[q].value == val) {
				opts[q].selected = true;
				item._value = opts[q].value;
			}
		}
		if (item._list != null && item._list.length > 0) {
			item.getForm()._autoCheck();
		}
		
		item.getForm()._ccReload(item._idd, item._value); // selected option id
		
	},
	
	getValue: function(item) {
		var k = -1;
		var opts = this.getOptions(item);
		for (var q=0; q<opts.length; q++) if (opts[q].selected) k = opts[q].value;
		return k;
	},
	
	setWidth: function(item, width) {
		item.childNodes[item._ll?1:0].childNodes[0].style.width = width+"px";
	},
	
	getSelect: function(item) {
		return item.childNodes[item._ll?1:0].childNodes[0];
	},
	
	setFocus: function(item) {
		item.childNodes[item._ll?1:0].childNodes[0].focus();
	},
	
	_checkNoteWidth: function(item) {
		var t;
		if (item.childNodes[item._ll?1:0].childNodes[1] != null) {
			t = item.childNodes[item._ll?1:0].childNodes[1];
			if (t.className != null && t.className.search(/dhxform_note/gi) >= 0 && t._w == "auto") t.style.width = item.childNodes[item._ll?1:0].childNodes[0].offsetWidth+"px";
		}
		t = null;
	}
	
};
(function(){
	for (var a in {doAddInput:1,doUnloadNestedLists:1,isEnabled:1})
		dhtmlXForm.prototype.items.select[a] = dhtmlXForm.prototype.items.checkbox[a];
})();

/* multiselect */
dhtmlXForm.prototype.items.multiselect = {
	
	doLoadOpts: function(item, data, callEvent) {
		var t = item.childNodes[item._ll?1:0].childNodes[0];
		t.multiple = true;
		if (!isNaN(data.size)) t.size = Number(data.size);
		item._value = [];
		item._newValue = [];
		var opts = data.options;
		for (var q=0; q<opts.length; q++) {
			var opt = new Option(opts[q].text||opts[q].label, opts[q].value);
			t.options.add(opt);
			if (opts[q].selected == true || opts[q].selected == "true") {
				opt.selected = true;
				item._value.push(opts[q].value);
			}
		}
		if (callEvent === true) item.callEvent("onOptionsLoaded", [item._idd]);
		//
		this._checkNoteWidth(item);
	},
	
	doAttachEvents: function(item) {
		
		var t = item.childNodes[item._ll?1:0].childNodes[0];
		var that = this;
		
		t.onfocus = function() {
			that.doOnChange(this);
			var i = this.parentNode.parentNode;
			i.getForm().callEvent("onFocus",[i._idd]);
			i = null;
		}
		
		t.onblur = function() {
			that.doOnChange(this);
			var i = this.parentNode.parentNode;
			i.getForm().callEvent("onBlur",[i._idd]);
			i = null;
		}
		
		t.onclick = function() {
			that.doOnChange(this);
			var i = this.parentNode.parentNode;
			i._autoCheck();
			i = null;
		}
		
	},
	
	doOnChange: function(sel) {
		
		var item = sel.parentNode.parentNode;
		
		item._newValue = [];
		for (var q=0; q<sel.options.length; q++) if (sel.options[q].selected) item._newValue.push(sel.options[q].value);
		
		if ((item._value).sort().toString() != (item._newValue).sort().toString()) {
			if (item.checkEvent("onBeforeChange")) {
				if (item.callEvent("onBeforeChange", [item._idd, item._value, item._newValue]) !== true) {
					// restore last value
					var k = {};
					for (var q=0; q<item._value.length; q++) k[item._value[q]] = true;
					for (var q=0; q<sel.options.length; q++) sel.options[q].selected = (k[sel.options[q].value] == true);
					k = null;
					return;
				}
			}
			item._value = [];
			for (var q=0; q<item._newValue.length; q++) item._value.push(item._newValue[q]);
			item.callEvent("onChange", [item._idd, item._value]);
		}
		
		// check autocheck for multiselect
		item._autoCheck();
		
	},
	
	setValue: function(item, val) {
		
		var k = {};
		if (typeof(val) == "string") val = val.split(",");
		if (typeof(val) != "object") val = [val];
		for (var q=0; q<val.length; q++) k[val[q]] = true;
		
		var opts = this.getOptions(item);
		for (var q=0; q<opts.length; q++) opts[q].selected = (k[opts[q].value] == true);
		
		item._autoCheck();
	},
	
	getValue: function(item) {
		
		var k = [];
		
		var opts = this.getOptions(item);
		for (var q=0; q<opts.length; q++) if (opts[q].selected) k.push(opts[q].value);
		return k;
	}
};

(function() {
	for (var a in dhtmlXForm.prototype.items.select) {
		if (!dhtmlXForm.prototype.items.multiselect[a]) dhtmlXForm.prototype.items.multiselect[a] = dhtmlXForm.prototype.items.select[a];
	}
})();

/* input */
dhtmlXForm.prototype.items.input = {
	
	render: function(item, data) {
		
		var ta = (!isNaN(data.rows));
		
		item._type = "ta";
		item._enabled = true;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, (ta?"TEXTAREA":"INPUT"), (ta?null:"TEXT"), true, true, "dhxform_textarea");
		this.doAttachEvents(item);
		
		if (ta) item.childNodes[item._ll?1:0].childNodes[0].rows = Number(data.rows)+(window.dhx4.isIE6?1:0);
		
		if (typeof(data.numberFormat) != "undefined") {
			var a,b=null,c=null;
			if (typeof(data.numberFormat) != "string") {
				a = data.numberFormat[0];
				b = data.numberFormat[1]||null;
				c = data.numberFormat[2]||null;
			} else {
				a = data.numberFormat;
				if (typeof(data.groupSep) == "string") b = data.groupSep;
				if (typeof(data.decSep) == "string") c = data.decSep;
			}
			this.setNumberFormat(item, a, b, c, false);
		}
		
		this.setValue(item, data.value);
		
		return this;
		
	},
	
	doAttachEvents: function(item) {
		
		var node = item.childNodes[item._ll?1:0].childNodes[0];
		
		if (typeof(node.tagName) != "undefined" && {"input":1, "textarea":1, "select":1}[node.tagName.toLowerCase()] == 1) {
			
			var that = this;
			node.onfocus = function() {
				var i = this.parentNode.parentNode;
				if (i._df != null) this.value = i._value||"";
				i.getForm()._ccActivate(i._idd, this, this.value);
				i.getForm().callEvent("onFocus",[i._idd]);
				i = null;
			}
			node.onblur = function() {
				var i = this.parentNode.parentNode;
				i.getForm()._ccDeactivate(i._idd);
				that.updateValue(i, true);
				if (i.getForm().live_validate) that._validate(i);
				i.getForm().callEvent("onBlur",[i._idd]);
				i = null;
			}
			
		}
		node = null;
		
	},
	
	updateValue: function(item, foc) {
		
		var value = item.childNodes[item._ll?1:0].childNodes[0].value;
		
		var form = item.getForm();
		var in_focus = (form._ccActive == true && form._formLS != null && form._formLS[item._idd] != null);
		form = null;
		
		if (!in_focus && item._df != null && value == window.dhx4.template._getFmtValue(item._value, item._df)) return; // if item not in focus
		
		if (!foc && item._df != null && item._value == value && value == window.dhx4.template._getFmtValue(value, item._df)) return;
		
		var t = this;
		if (item._value != value) {
			if (item.checkEvent("onBeforeChange")) if (item.callEvent("onBeforeChange",[item._idd, item._value, value]) !== true) {
				// restore
				if (item._df != null) t.setValue(item, item._value); else item.childNodes[item._ll?1:0].childNodes[0].value = item._value;
				return;
			}
			// accepted
			if (item._df != null && foc) t.setValue(item, value); else item._value = value;
			item.callEvent("onChange",[item._idd, value]);
			return;
		}
		if (item._df != null && foc) this.setValue(item, item._value);
	},
	
	setValue: function(item, value) {
		
		// str only
		item._value = (typeof(value) != "undefined" && value != null ? value : "");
		
		var v = (String(item._value)||"");
		var k = item.childNodes[item._ll?1:0].childNodes[0];
		
		// check if formatting available
		if (item._df != null) v = window.dhx4.template._getFmtValue(v, item._df);
		
		if (k.value != v) {
			k.value = v;
			item.getForm()._ccReload(item._idd, v);
		}
		
		k = null;
	},
	
	getValue: function(item) {
		// update value if item have focus
		var f = item.getForm();
		if (f._formLS && f._formLS[item._idd] != null) this.updateValue(item);
		f = null;
		// str only
		return (typeof(item._value) != "undefined" && item._value != null ? item._value : "");
	},
	
	setReadonly: function(item, state) {
		item._ro = (state===true);
		if (item._ro) {
			item.childNodes[item._ll?1:0].childNodes[0].setAttribute("readOnly", "true");
		} else {
			item.childNodes[item._ll?1:0].childNodes[0].removeAttribute("readOnly");
		}
	},
	
	isReadonly: function(item) {
		if (!item._ro) item._ro = false;
		return item._ro;
	},
	
	getInput: function(item) {
		return item.childNodes[item._ll?1:0].childNodes[0];
	},
	
	setNumberFormat: function(item, format, g_sep, d_sep, refresh) {
		
		if (typeof(refresh) != "boolean") refresh = true;
		
		if (format == "") {
			item._df = null;
			if (refresh) this.setValue(item, item._value);
			return true;
		}
		
		if (typeof(format) != "string") return;
		
		var fmt = window.dhx4.template._parseFmt(format, g_sep, d_sep);
		if (fmt == false) return false; else item._df = fmt;
		
		if (refresh) this.setValue(item, item._value);
		
		return true;
		
	}
	
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,destruct:1,doUnloadNestedLists:1,setText:1,getText:1,enable:1,disable:1,isEnabled:1,setWidth:1,setFocus:1})
		dhtmlXForm.prototype.items.input[a] = dhtmlXForm.prototype.items.select[a];
})();


/* password */
dhtmlXForm.prototype.items.password = {
	
	render: function(item, data) {
		
		item._type = "pw";
		item._enabled = true;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "INPUT", "PASSWORD", true, true, "dhxform_textarea");
		this.doAttachEvents(item);
		
		this.setValue(item, data.value);
		
		return this;
		
	}
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,doAttachEvents:1,destruct:1,doUnloadNestedLists:1,setText:1,getText:1,setValue:1,getValue:1,updateValue:1,enable:1,disable:1,isEnabled:1,setWidth:1,setReadonly:1,isReadonly:1,setFocus:1,getInput:1})
		dhtmlXForm.prototype.items.password[a] = dhtmlXForm.prototype.items.input[a];
})();

/* file */
dhtmlXForm.prototype.items.file = {
	
	render: function(item, data) {
		
		item._type = "fl";
		item._enabled = true;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "INPUT", "FILE", true, false, "dhxform_textarea");
		
		var t = item.childNodes[item._ll ? 1 : 0].childNodes[0];
		var that = this;
		t.onfocus = function() {
			var i = this.parentNode.parentNode;
			i.getForm().callEvent("onFocus",[i._idd]);
			i = null;
		};
		t.onblur = function () {
			var i = this.parentNode.parentNode;
			if (i.getForm().live_validate) that._validate(i);
			i.getForm().callEvent("onBlur", [i._idd]);
			i = null;
		};
		t = null;
		
		item.childNodes[item._ll?1:0].childNodes[0].onchange = function() {
			item.callEvent("onChange", [item._idd, this.value]);
		}
		
		return this;
		
	},
	
	setValue: function(){},
	
	getValue: function(item) {
		return item.childNodes[item._ll?1:0].childNodes[0].value;
	}
	
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,destruct:1,doUnloadNestedLists:1,setText:1,getText:1,getInput:1,enable:1,disable:1,isEnabled:1,setWidth:1})
		dhtmlXForm.prototype.items.file[a] = dhtmlXForm.prototype.items.input[a];
})();

/* label */
dhtmlXForm.prototype.items.label = {
	
	_index: false,
	
	render: function(item, data) {
		
		item._type = "lb";
		item._enabled = true;
		item._checked = true;
		
		var t = document.createElement("DIV");
		t.className = "dhxform_txt_label2"+(data._isTopmost?" topmost":"");
		t.innerHTML = data.label;
		item.appendChild(t);
		
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		if (!isNaN(data.labelWidth)) t.style.width = parseInt(data.labelWidth)+"px";
		if (!isNaN(data.labelHeight)) t.style.height = parseInt(data.labelHeight)+"px";
		
		if (!isNaN(data.labelLeft)) t.style.left = parseInt(data.labelLeft)+"px";
		if (!isNaN(data.labelTop)) t.style.top = parseInt(data.labelTop)+"px";
		
		return this;
	},
	
	destruct: function(item) {
		
		this.doUnloadNestedLists(item);
		
		item._autoCheck = null;
		item._enabled = null;
		item._type = null;
		
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		
		item.onselectstart = null;
		item.parentNode.removeChild(item);
		item = null;
		
	},
	
	enable: function(item) {
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._enabled = true;
	},
	
	disable: function(item) {
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._enabled = false;
	},
	
	setText: function(item, text) {
		item.firstChild.innerHTML = text;
	},

	getText: function(item) {
		return item.firstChild.innerHTML;
	}
	
};

(function(){
	for (var a in {doUnloadNestedLists:1,isEnabled:1})
		dhtmlXForm.prototype.items.label[a] = dhtmlXForm.prototype.items.checkbox[a];
})();


/* button */
dhtmlXForm.prototype.items.button = {
	
	render: function(item, data) {
		
		item._type = "bt";
		item._enabled = true;
		item._name = data.name;
		
		item.className = String(item.className).replace("item_label_top","item_label_left").replace("item_label_right","item_label_left");
		
		item._doOnKeyUpDown = function(evName, evObj) {
			this.callEvent(evName, [this.childNodes[0].childNodes[0], evObj, this._idd]);
		}
		
		item.innerHTML = '<div class="dhxform_btn" role="link" tabindex="0" dir="ltr">'+
					'<div class="dhxform_btn_txt">'+data.value+'</div>'+
					'<div class="dhxform_btn_filler" disabled="true"></div>'+ // IE click w/o focus loss
				'</div>';
		
		if (!isNaN(data.width)) {
			var w = Math.max(data.width,10);
			if (dhtmlXForm.prototype.items[this.t]._dim == null) {
				item.firstChild.style.width = w+"px";
				dhtmlXForm.prototype.items[this.t]._dim = item.getForm()._checkDim(item, item.firstChild);
			}
			item.firstChild.style.width = w-dhtmlXForm.prototype.items[this.t]._dim+"px";
			item.firstChild.firstChild.className += " dhxform_btn_txt_autowidth";
		}
		
		
		
		if (!isNaN(data.inputLeft)) item.childNodes[0].style.left = parseInt(data.inputLeft)+"px";
		if (!isNaN(data.inputTop)) item.childNodes[0].style.top = parseInt(data.inputTop)+"px";
		
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		if (typeof(data.tooltip) != "undefined") item.firstChild.title = data.tooltip;
		
		// item onselectstart also needed once
		// will reconstructed!
		
		item.onselectstart = function(e){
			e = e||event;
			e.cancelBubble = true;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
		item.firstChild.onselectstart = function(e){
			e = e||event;
			e.cancelBubble = true;
			if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
			return false;
		}
		
		item.firstChild.onkeypress = function(e) {
			e = e||event
			if ((e.keyCode == 32 || e.charCode == 32 || e.keyCode == 13 || e.charCode == 13) && !this.parentNode._busy) {
				this.parentNode._busy = true;
				e.cancelBubble = true;
				if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
				_dhxForm_doClick(this.childNodes[0], ["mousedown", "mouseup"]);
				return false;
			}
		}
		
		item.firstChild.onfocus = function() {
			this.parentNode._doOnFocus(this.parentNode);
		}
		
		item.firstChild.onblur = function() {
			_dhxForm_doClick(this.childNodes[0], "mouseout");
			this.parentNode._doOnBlur(this.parentNode);
		}
		
		item.firstChild.onkeyup = function(e) {
			this.parentNode._doOnKeyUpDown("onKeyUp", e||event);
		}
		item.firstChild.onkeydown = function(e) {
			this.parentNode._doOnKeyUpDown("onKeyDown", e||event);
		}
		item.firstChild.onmouseover = function(){
			var t = this.parentNode;
			if (!t._enabled) return;
			this._isOver = true;
			this.className = "dhxform_btn dhxform_btn_over";
			t = null;
		}
		item.firstChild.onmouseout = function(){
			var t = this.parentNode;
			if (!t._enabled) return;
			this.className = "dhxform_btn";
			this._allowClick = false;
			this._pressed = false;
			this._isOver = false;
			t = null;
		}
		item.firstChild.ontouchstart = item.firstChild.onmousedown = function(e){
			e = e||event;
			if (e.type == "touchstart" && e.preventDefault) e.preventDefault();
			if (e.button >= 2) return; // ie=0/other=1
			if (this._pressed) return;
			var t = this.parentNode;
			if (!t._enabled) return;
			this.className = "dhxform_btn dhxform_btn_pressed";
			this._allowClick = true;
			this._pressed = true;
			t = null;
		}
		
		item.firstChild.ontouchend = item.firstChild.onmouseup = function(e){
			e = e||event;
			if (e.button >= 2) return;
			if (!this._pressed) return;
			var t = this.parentNode;
			if (!t._enabled) return;
			t._busy = false;
			this.className = "dhxform_btn"+(this._isOver?" dhxform_btn_over":"");
			if (this._pressed && this._allowClick) t.callEvent("_onButtonClick", [t._name, t._cmd]);
			this._allowClick = false;
			this._pressed = false;
			t = null;
		}
		
		item._doOnFocus = function(item) {
			item.getForm().callEvent("onFocus",[item._idd]);
		}
		
		item._doOnBlur = function(item) {
			item.getForm().callEvent("onBlur",[item._idd]);
		}
		
		return this;
	},
	
	destruct: function(item) {
		
		this.doUnloadNestedLists(item);
		
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		
		item._autoCheck = null;
		item._type = null;
		item._enabled = null;
		item._cmd = null;
		item._name = null;
		item._doOnFocus = null;
		item._doOnBlur = null;
		item._doOnKeyUpDown = null;
		
		item.onselectstart = null;
		
		item.firstChild.onselectstart = null;
		item.firstChild.onkeypress = null;
		item.firstChild.ontouchstart = null;
		item.firstChild.ontouchend = null;
		item.firstChild.onfocus = null;
		item.firstChild.onblur = null;
		item.firstChild.onkeyup = null;
		item.firstChild.onkeydown = null;
		item.firstChild.onmouseover = null;
		item.firstChild.onmouseout = null;
		item.firstChild.onmousedown = null;
		item.firstChild.onmouseup = null;
		
		while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
		
		item.parentNode.removeChild(item);
		item = null;
		
	},
	
	enable: function(item) {
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._enabled = true;
		item.childNodes[0].removeAttribute("disabled");
		item.childNodes[0].setAttribute("role", "link");
		item.childNodes[0].setAttribute("tabIndex", "0");
	},
	
	disable: function(item) {
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._enabled = false;
		item.childNodes[0].setAttribute("disabled", "true");
		item.childNodes[0].removeAttribute("role");
		item.childNodes[0].removeAttribute("tabIndex");
	},
	
	setText: function(item, text) {
		item.childNodes[0].childNodes[0].innerHTML = text;
	},

	getText: function(item) {
		return item.childNodes[0].childNodes[0].innerHTML;
	},
	
	setFocus: function(item) {
		item.childNodes[0].focus();
	}
	
};

(function(){
	for (var a in {doUnloadNestedLists:1,isEnabled:1})
		dhtmlXForm.prototype.items.button[a] = dhtmlXForm.prototype.items.checkbox[a];
})();

/* hidden item */
dhtmlXForm.prototype.items.hidden = {
	
	_index: false,
	
	render: function(item, data) {
		
		item.style.display = "none";
		
		item._name = data.name;
		item._type = "hd";
		item._enabled = true;
		
		var t = document.createElement("INPUT");
		t.type = "HIDDEN";
		t.name = data.name;
		t.value = (data.value||"")
		item.appendChild(t);
		
		return this;
	},
	
	destruct: function(item) {
		
		
		this.doUnloadNestedLists(item);
		
		while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
		
		item._autoCheck = null;
		item._name = null;
		item._type = null;
		item._enabled = null;
		item.onselectstart = null;
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		item.parentNode.removeChild(item);
		item = null;
		
	},
	
	enable: function(item) {
		item._enabled = true;
		item.childNodes[0].setAttribute("name", item._name);
	},
	
	disable: function(item) {
		item._enabled = false;
		item.childNodes[0].removeAttribute("name");
	},
	
	show: function() {
		
	},
	
	hide: function() {
		
	},
	
	isHidden: function() {
		return true;
	},
	
	setValue: function(item, val) {
		item.childNodes[0].value = val;
	},
	
	getValue: function(item) {
		return item.childNodes[0].value;
	},
	
	getInput: function(item) {
		return item.childNodes[0];
	}
	
};

(function(){
	for (var a in {doUnloadNestedLists:1,isEnabled:1})
		dhtmlXForm.prototype.items.hidden[a] = dhtmlXForm.prototype.items.checkbox[a];
})();

/* sub list */
dhtmlXForm.prototype.items.list = {
	
	_index: false,
	
	render: function(item, skin) {
		
		item._type = "list";
		item._enabled = true;
		item._isNestedForm = true;
		item.style.paddingLeft = item._ofsNested+"px";
		
		item.className = "dhxform_base_nested"+(item._custom_css||"");
		
		return [this, new dhtmlXForm(item, null, skin)];
	},
	
	destruct: function(item) {
		
		// linked to _listBase
		// automaticaly cleared when parent item unloaded
		
	}
};

/* fieldset */
dhtmlXForm.prototype.items.fieldset = {
	
	_index: false,
	
	render: function(item, data) {
		
		item._type = "fs";
		
		if (typeof(parseInt(data.inputWidth)) == "number") {
			// if (window.dhx4.isFF||window.dhx4.isOpera) data.inputWidth -= 12;
			// chrome-11/ie9 - ok
		}
		
		item._width = data.width;
		
		item._enabled = true;
		item._checked = true; // required for authoCheck
		
		item.className = "fs_"+data.position+(typeof(data.className)=="string"?" "+data.className:"");
		
		var f = document.createElement("FIELDSET");
		f.className = "dhxform_fs";
		var align = String(data.labelAlign).replace("align_","");
		f.innerHTML = "<legend class='fs_legend' align='"+align+"' style='text-align:"+align+"'>"+data.label+"</legend>";
		item.appendChild(f);
		
		if (!isNaN(data.inputLeft)) f.style.left = parseInt(data.inputLeft)+"px";
		if (!isNaN(data.inputTop)) f.style.top = parseInt(data.inputTop)+"px";
		if (data.inputWidth != "auto") {
			if (!isNaN(data.inputWidth)) {
				f.style.width = parseInt(data.inputWidth)+"px";
				var w = parseInt(f.style.width);
				if (f.offsetWidth > w) f.style.width = w+(w-f.offsetWidth)+"px";
			}
		}
		
		item._addSubListNode = function() {
			var t = document.createElement("DIV");
			t._custom_css = " dhxform_fs_nested";
			this.childNodes[0].appendChild(t);
			return t;
		}
		
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		return this;
	},
	
	destruct: function(item) {
		
		this.doUnloadNestedLists(item);
		
		item._checked = null;
		item._enabled = null;
		item._idd = null;
		item._type = null;
		item._width = null;
		
		item.onselectstart = null;
		
		item._addSubListNode = null;
		item._autoCheck = null;
		item.callEvent = null;
		item.checkEvent = null;
		item.getForm = null;
		
		while (item.childNodes.length > 0) item.removeChild(item.childNodes[0]);
		
		item.parentNode.removeChild(item);
		item = null;
	
	},
	
	setText: function(item, text) {
		item.childNodes[0].childNodes[0].innerHTML = text;
	},
	
	getText: function(item) {
		return item.childNodes[0].childNodes[0].innerHTML;
	},
	
	enable: function(item) {
		item._enabled = true;
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
	},
	
	disable: function(item) {
		item._enabled = false;
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
	},
	
	setWidth: function(item, width) {
		item.childNodes[0].style.width = width+"px";
		item._width = width;
	},
	
	getWidth: function(item) {
		return item._width;
	}
	
};

(function(){
	for (var a in {doUnloadNestedLists:1,isEnabled:1})
		dhtmlXForm.prototype.items.fieldset[a] = dhtmlXForm.prototype.items.checkbox[a];
})();


/* block */
dhtmlXForm.prototype.items.block = {
	
	_index: false,
	
	render: function(item, data) {
		
		item._type = "bl";
		
		item._width = data.width;
		
		item._enabled = true;
		item._checked = true; // required for authoCheck
		
		item.className = "block_"+data.position+(typeof(data.className)=="string"?" "+data.className:"");
		
		var b = document.createElement("DIV");
		b.className = "dhxform_obj_"+item.getForm().skin+" dhxform_block";
		b.style.fontSize = item.getForm().cont.style.fontSize;
		if (data.style) b.style.cssText = data.style;
		
		if (typeof(data.id) != "undefined") b.id = data.id;
		
		item.appendChild(b);
		
		if (!isNaN(data.inputLeft)) b.style.left = parseInt(data.inputLeft)+"px";
		if (!isNaN(data.inputTop)) b.style.top = parseInt(data.inputTop)+"px";
		if (data.inputWidth != "auto") if (!isNaN(data.inputWidth)) b.style.width = parseInt(data.inputWidth)+"px";
		
		if (!isNaN(data.blockOffset)) {
			item._ofsNested = data.blockOffset;
		}
		
		item._addSubListNode = function() {
			var t = document.createElement("DIV");
			t._inBlcok = true;
			if (typeof(this._ofsNested) != "undefined") t._ofsNested = this._ofsNested;
			this.childNodes[0].appendChild(t);
			return t;
		}
		
		if (data.hidden == true) this.hide(item);
		if (data.disabled == true) this.userDisable(item);
		
		return this;
	},
	
	_setCss: function(item, skin, fontSize) {
		item.firstChild.className = "dhxform_obj_"+skin+" dhxform_block";
		item.firstChild.style.fontSize = fontSize;
	}
};

(function(){
	for (var a in {enable:1,disable:1,isEnabled:1,setWidth:1,getWidth:1,doUnloadNestedLists:1,destruct:1})
		dhtmlXForm.prototype.items.block[a] = dhtmlXForm.prototype.items.fieldset[a];
})();

/* new column */
dhtmlXForm.prototype.items.newcolumn = {
	_index: false
};

/* template */
dhtmlXForm.prototype.items.template = {
	
	render: function(item, data) {
		
		var ta = (!isNaN(data.rows));
		
		item._type = "tp";
		item._enabled = true;
		
		if (data.format != null) {
			if (typeof(data.format) == "function") {
				item.format = data.format;
			} else if (typeof(data.format) == "string" && typeof(window[data.format]) == "function") {
				item.format = window[data.format];
			}
		}
		if (item.format == null) {
			item.format = function(name, value) { return value; }
		}
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "DIV", null, true, true, "dhxform_item_template");
		
		this.setValue(item, data.value||"");
		
		return this;
		
	},
	
	destruct: function(item) {
		item.format = null;
		this.d2(item);
		item = null;
	},
	
	setValue: function(item, value) {
		item._value = value;
		item.childNodes[item._ll?1:0].childNodes[0].innerHTML = item.format(item._idd, item._value);
	},
	
	getValue: function(item) {
		return item._value;
	},
	
	enable: function(item) {
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._enabled = true;
	},
	
	disable: function(item) {
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._enabled = false;
	}
	
};

(function(){
	dhtmlXForm.prototype.items.template.d2 = dhtmlXForm.prototype.items.input.destruct;
	for (var a in {doAddLabel:1,doAddInput:1,doUnloadNestedLists:1,setText:1,getText:1,isEnabled:1,setWidth:1})
		dhtmlXForm.prototype.items.template[a] = dhtmlXForm.prototype.items.select[a];
})();

//loading from UL list

dhtmlXForm.prototype._ulToObject = function(ulData, a) {
	var obj = [];
	for (var q=0; q<ulData.childNodes.length; q++) {
		if (String(ulData.childNodes[q].tagName||"").toLowerCase() == "li") {
			var p = {};
			var t = ulData.childNodes[q];
			for (var w=0; w<a.length; w++) if (t.getAttribute(a[w]) != null) p[String(a[w]).replace("ftype","type")] = t.getAttribute(a[w]);
			if (!p.label) try { p.label = t.firstChild.nodeValue; } catch(e){}
			var n = t.getElementsByTagName("UL");
			if (n[0] != null) p[(p.type=="select"?"options":"list")] = dhtmlXForm.prototype._ulToObject(n[0], a);
			// userdata
			for (var w=0; w<t.childNodes.length; w++) {
				if (String(t.childNodes[w].tagName||"").toLowerCase() == "userdata") {
					if (!p.userdata) p.userdata = {};
					p.userdata[t.childNodes[w].getAttribute("name")] = t.childNodes[w].firstChild.nodeValue;
				}
			}
			obj[obj.length] = p;
		}
		if (String(ulData.childNodes[q].tagName||"").toLowerCase() == "div") {
			var p = {};
			p.type = "label";
			try { p.label = ulData.childNodes[q].firstChild.nodeValue; } catch(e){}
			obj[obj.length] = p;
		}
	}
	return obj;
};

dhtmlXForm.prototype.setUserData = function(id, name, value, rValue) {
	if (typeof(rValue) != "undefined") { // radiobutton: name,value,ud_name,ud_value
		var k = this.doWithItem([id,name], "_getId");
		if (k != null) { id = k; name = value; value = rValue; }
	}
	if (!this._userdata) this._userdata = {};
	this._userdata[id] = (this._userdata[id]||{});
	this._userdata[id][name] = value;
};

dhtmlXForm.prototype.getUserData = function(id, name, rValue) {
	if (typeof(rValue) != "undefined") { // radiobutton: name,value,ud_name
		var k = this.doWithItem([id,name], "_getId");
		if (k != null) { id = k; name = rValue; }
	}
	if (this._userdata != null && typeof(this._userdata[id]) != "undefined" && typeof(this._userdata[id][name]) != "undefined") return this._userdata[id][name];
	return "";
};

dhtmlXForm.prototype.setRTL = function(state) {
	this._rtl = (state===true?true:false);
	if (this._rtl) {
		if (String(this.cont).search(/dhxform_rtl/gi) < 0) this.cont.className += " dhxform_rtl";
	} else {
		if (String(this.cont).search(/dhxform_rtl/gi) >= 0) this.cont.className = String(this.cont.className).replace(/dhxform_rtl/gi,"");
	}
};

_dhxForm_doClick = function(obj, evType) {
	if (typeof(evType) == "object") {
		var t = evType[1];
		evType = evType[0];
	}
	if (document.createEvent) {
		var e = document.createEvent("MouseEvents");
		e.initEvent(evType, true, false);
		obj.dispatchEvent(e);
	} else if (document.createEventObject) {
		var e = document.createEventObject();
		e.button = 1;
		obj.fireEvent("on"+evType, e);
	}
	if (t) window.setTimeout(function(){_dhxForm_doClick(obj,t);},100);
}

dhtmlXForm.prototype.setFormData = function(t) {
	for (var a in t) {
		var r = this.getItemType(a);
		switch (r) {
			case "checkbox":
				this[t[a]==true||parseInt(t[a])==1||t[a]=="true"||t[a]==this.getItemValue(a, "realvalue")?"checkItem":"uncheckItem"](a);
				break;
			case "radio":
				this.checkItem(a,t[a]);
				break;
			case "input":
			case "textarea":
			case "password":
			case "select":
			case "multiselect":
			case "hidden":
			case "template":
			case "combo":
			case "calendar":
			case "colorpicker":
			case "editor":
				this.setItemValue(a,t[a]);
				break;
			default:
				if (this["setFormData_"+r]) {
					// check for custom cell
					this["setFormData_"+r](a,t[a]);
				} else {
					// if item with specified name not found, keep value in userdata
					if (!this.hId) this.hId = this._genStr(12);
					this.setUserData(this.hId, a, t[a]);
				}
				break;
		}
	}
};

dhtmlXForm.prototype.getFormData = function(p0, only_fields) {
	
	var r = {};
	var that = this;
	for (var a in this.itemPull) {
		var i = this.itemPull[a]._idd;
		var t = this.itemPull[a]._type;
		if (t == "ch") r[i] = (this.isItemChecked(i)?this.getItemValue(i):0);
		if (t == "ra" && !r[this.itemPull[a]._group]) r[this.itemPull[a]._group] = this.getCheckedValue(this.itemPull[a]._group);
		if (t in {se:1,ta:1,pw:1,hd:1,tp:1,fl:1,calendar:1,combo:1,editor:1,colorpicker:1}) r[i] = this.getItemValue(i,p0);
		// check for custom cell
		if (this["getFormData_"+t]) r[i] = this["getFormData_"+t](i);
		// merge with files/uploader
		if (t == "up") {
			var r0 = this.getItemValue(i);
			for (var a0 in r0) r[a0] = r0[a0];
		}
		//
		if (this.itemPull[a]._list) {
			for (var q=0; q<this.itemPull[a]._list.length; q++) {
				var k = this.itemPull[a]._list[q].getFormData(p0,only_fields);
				for (var b in k) r[b] = k[b];
			}
		}
	}
	// collecr hId userdata
	if (!only_fields && this.hId && this._userdata[this.hId]) {
		for (var a in this._userdata[this.hId]) {
			if (!r[a]) r[a] = this._userdata[this.hId][a];
		}
	}
	return r;
};

dhtmlXForm.prototype.adjustParentSize = function() {
	
	var kx = 0;
	var ky = -1;
	for (var q=0; q<this.base.length; q++) {
		kx += this.base[q].firstChild.offsetWidth;
		if (this.base[q].offsetHeight > ky) ky = this.base[q].offsetHeight;
	}
	
	// check if layout
	var isLayout = false;
	try {
		isLayout = (this.cont.parentNode.parentNode.parentNode.parentNode._isCell==true);
		if (isLayout) var layoutCell = this.cont.parentNode.parentNode.parentNode.parentNode;
	} catch(e){};
	
	if (isLayout && typeof(layoutCell) != "undefined") {
		
		if (kx > 0) layoutCell.setWidth(kx+10);
		if (ky > 0) layoutCell.setHeight(ky+layoutCell.firstChild.firstChild.offsetHeight+5);
		
		isLayout = layoutCell = null;
		return;
	}
	
	// check if window
	var isWindow = false;
	try {
		isWindow = (this.cont.parentNode.parentNode.parentNode._isWindow == true);
		if (isWindow) {
			var winCell = this.cont.parentNode.parentNode;
			if (typeof(winCell.callEvent) == "function") {
				this.cont.style.display = "none";
				winCell.callEvent("_setCellSize", [kx+15,ky+15]);
				this.cont.style.display = "";
			}
		}
	} catch(e){};
	
};

// dataproc
dhtmlXForm.prototype.reset = function() {
	if (this.callEvent("onBeforeReset", [this.formId, this.getFormData()])) {
		if (this._last_load_data) this.setFormData(this._last_load_data);
		this.callEvent("onAfterReset", [this.formId]);
	}
};

dhtmlXForm.prototype.send = function(url, mode, callback, skipValidation) {
	
	if (typeof mode == "function") {
		callback = mode;
		mode = "post";
	} else {
		mode = (mode=="get"?"get":"post");
	}
	
	if (skipValidation !== true && !this.validate()) return;
	var formData = this.getFormData(true);
	
	var data = [];
	for (var key in formData) data.push(key+"="+encodeURIComponent(formData[key]));
	
	var afterload = function(loader) {
		if (callback) callback.call(this, loader, loader.xmlDoc.responseText);
	};
	
	if (mode == "get") {
		window.dhx4.ajax.get(url+(url.indexOf("?")==-1?"?":"&")+data.join("&"), afterload);
	} else {
		window.dhx4.ajax.post(url, data.join("&"), afterload);
	}
	
};

dhtmlXForm.prototype.save = function(url, type){};

dhtmlXForm.prototype.dummy = function(){};

dhtmlXForm.prototype._changeFormId = function(oldid, newid) {
	this.formId = newid;
};

dhtmlXForm.prototype._dp_init = function(dp) {
	
	dp._methods = ["dummy", "dummy", "_changeFormId", "dummy"];
	
	dp._getRowData = function(id, pref) {
		var data = this.obj.getFormData(true);
		data[this.action_param] = this.obj.getUserData(id, this.action_param);
		return data;
	};
	dp._clearUpdateFlag = function(){};
	
	dp.attachEvent("onAfterUpdate", function(sid, action, tid, tag){
		if (action == "inserted" || action == "updated" || action == "error" || action == "invalid")
			this.obj.resetDataProcessor("updated");
		if (action == "inserted" || action == "updated")
			this.obj._last_load_data = this.obj.getFormData(true);
					
		this.obj.callEvent("onAfterSave",[this.obj.formId, tag]);
		return true;
	});
	
	dp.autoUpdate = false;
	dp.setTransactionMode("POST", true);
	
	this.dp = dp;
	
	this.formId = (new Date()).valueOf();
	this.resetDataProcessor("inserted");
	
	this.save = function(){
		if (!this.callEvent("onBeforeSave", [this.formId, this.getFormData()])) return;
		if (!this.validate()) return;
		dp.sendData();
	};
};


dhtmlXForm.prototype.resetDataProcessor = function(mode){
	if (!this.dp) return;
	this.dp.updatedRows = []; this.dp._in_progress = [];
	this.dp.setUpdated(this.formId, true, mode);
};

// cc listener
dhtmlXForm.prototype._ccActivate = function(id, inp, val) {
	
	if (!this._formLS) this._formLS = {};
	if (!this._formLS[id]) this._formLS[id] = {input: inp, value: val};
	if (!this._ccActive) {
		this._ccActive = true;
		this._ccDo();
	}
	inp = null;
};

dhtmlXForm.prototype._ccDeactivate = function(id) {
	
	if (this._ccTm) window.clearTimeout(this._ccTm);
	this._ccActive = false;
	if (this._formLS != null && this._formLS[id] != null) {
		this._formLS[id].input = null;
		this._formLS[id] = null;
		delete this._formLS[id];
	}
};

dhtmlXForm.prototype._ccDo = function() {
	
	if (this._ccTm) window.clearTimeout(this._ccTm);
	
	for (var a in this._formLS) {
		
		var inp = this._formLS[a].input;
		
		if (String(inp.tagName).toLowerCase() == "select") {
			var v = "";
			if (inp.selectedIndex >= 0 && inp.selectedIndex < inp.options.length) v = inp.options[inp.selectedIndex].value;
		} else {
			var v = inp.value;
		}
		if (v != this._formLS[a].value) {
			this._formLS[a].value = v;
			this.callEvent("onInputChange",[inp._idd,v,this]);
		}
		inp = null;
		
	}
	
	if (this._ccActive) {
		var t = this;
		this._ccTm = window.setTimeout(function(){t._ccDo();t=null;},100);
	}
	
};
	
dhtmlXForm.prototype._ccReload = function(id, value) { // update item's value while item have focus
	if (this._formLS && this._formLS[id]) {
		this._formLS[id].value = value;
	}
};

dhtmlXForm.prototype._checkDim = function(formNode, inpObj) {
	
	var testNode = document.createElement("DIV");
	testNode.className = "dhxform_obj_"+this.skin;
	testNode.style.cssText += (dhx4.isIE6==true?"visibility:hidden;":"position:absolute;left:-2000px;top:-1000px;");
	document.body.appendChild(testNode);
	
	var pNode = formNode.parentNode;
	var sNode = formNode.nextSibling;
	testNode.appendChild(formNode);
	
	var w = parseInt(inpObj.style.width);
	var w2 = (dhx4.isFF || dhx4.isIE || dhx4.isChrome || dhx4.isOpera ? inpObj.offsetWidth : inpObj.clientWidth);
	var dim = w2-w;
	
	if (sNode != null) pNode.insertBefore(formNode, sNode); else pNode.appendChild(formNode);
	testNode.parentNode.removeChild(testNode);
	
	pNode = sNode = testNode = formNode = inpObj = null;
	
	return dim;
};

(function(){

var a = [
	"ftype", "name", "value", "label", "check", "checked", "disabled", "text", "rows", "select", "selected", "width", "style", "className",
	"labelWidth", "labelHeight", "labelLeft", "labelTop", "inputWidth", "inputHeight", "inputLeft", "inputTop", "position", "size"
];

dhtmlXForm.prototype.loadStructHTML = function(el){
	var el = typeof el === "string" ? document.getElementById(el) : el;
	this.loadStruct(this._ulToObject(el, a))
}
dhtmlXForm.prototype._autoload = function() {
	var k = document.getElementsByTagName("UL");
	var u = [];
	for (var q=0; q<k.length; q++) {
		if (k[q].className == "dhtmlxForm") {
			var formNode = document.createElement("DIV");
			u[u.length] = {nodeUL:k[q], nodeForm:formNode, data:dhtmlXForm.prototype._ulToObject(k[q], a), name:(k[q].getAttribute("name")||null)};
		}
	}
	for (var q=0; q<u.length; q++) {
		u[q].nodeUL.parentNode.insertBefore(u[q].nodeForm, u[q].nodeUL);
		var listObj = new dhtmlXForm(u[q].nodeForm, u[q].data);
		if (u[q].name !== null) window[u[q].name] = listObj;
		var t = (u[q].nodeUL.getAttribute("oninit")||null);
		u[q].nodeUL.parentNode.removeChild(u[q].nodeUL);
		u[q].nodeUL = null;
		u[q].nodeForm = null;
		u[q].data = null;
		u[q] = null;
		// oninit call
		if (t) { if (typeof(t) == "function") t(); else if (typeof(window[t]) == "function") window[t](); }
	}
	if (typeof(window.addEventListener) == "function") {
		window.removeEventListener("load", dhtmlXForm.prototype._autoload, false);
	} else {
		window.detachEvent("onload", dhtmlXForm.prototype._autoload);
	};
	
};

if (typeof(window.addEventListener) == "function") {
	window.addEventListener("load", dhtmlXForm.prototype._autoload, false);
} else {
	window.attachEvent("onload", dhtmlXForm.prototype._autoload);
};

})();


if (typeof(window.dhtmlXCellObject) != "undefined") {
	
	dhtmlXCellObject.prototype.attachForm = function(data) {
		
		this.callEvent("_onBeforeContentAttach",["form"]);
		
		var obj = document.createElement("DIV");
		obj.style.width = "100%";
		obj.style.height = "100%";
		obj.style.position = "relative";
		
		if (window.dhtmlx && dhtmlx.$customScroll) dhtmlx.CustomScroll.enable(obj); else obj.style.overflow = "auto";
		
		this._attachObject(obj);
		
		this.dataType = "form";
		this.dataObj = new dhtmlXForm(obj, data, this.conf.skin);
		obj = null;
		
		this.callEvent("_onContentAttach",[]);
		
		return this.dataObj;
		
	};
	
}

;
///<jscompress sourcefile="dhtmlxform_item_combo.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXForm.prototype.items.combo = {
	
	render: function(item, data) {
		
		item._type = "combo";
		item._enabled = true;
		item._value = null;
		item._newValue = null;
		
		var skin = item.getForm().skin;
		if (typeof(data.inputWidth) != "undefined" && skin == "material" && String(data.inputWidth).match(/^\d*$/) != null) {
			data.inputWidth = parseInt(data.inputWidth)+2;
		}
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "SELECT", null, true, true, "dhxform_select");
		this.doAttachEvents(item);
		this.doLoadOpts(item, data);
		
		// allow selection to prevent broking combo logic
		item.onselectstart = function(e){return true;}
		
		// item.childNodes[1].childNodes[0].opt_type = data.comboType||"";
		item.childNodes[item._ll?1:0].childNodes[0].setAttribute("mode", data.comboType||"");
		if (data.comboImagePath) item.childNodes[item._ll?1:0].childNodes[0].setAttribute("imagePath", data.comboImagePath);
		if (data.comboDefaultImage) item.childNodes[item._ll?1:0].childNodes[0].setAttribute("defaultImage", data.comboDefaultImage);
		if (data.comboDefaultImageDis) item.childNodes[item._ll?1:0].childNodes[0].setAttribute("defaultImageDis", data.comboDefaultImageDis);
		
		item._combo = new dhtmlXComboFromSelect(item.childNodes[item._ll?1:0].childNodes[0]);
		item._combo.setSkin(skin);
		item._combo._currentComboValue = item._combo.getSelectedValue();
		item._combo.getInput().id = data.uid;
		
		if (skin == "material") item._combo.list.className += " dhxform_obj_"+skin;
		
		var k = this;
		item._combo.attachEvent("onChange", function(){
			k.doOnChange(this);
		});
		
		if (data.connector) this.doLoadOptsConnector(item, data.connector);
		
		if (data.filtering) {
			item._combo.enableFilteringMode(true);
		} else if (data.serverFiltering) {
			item._combo.enableFilteringMode(true, data.serverFiltering, data.filterCache, data.filterSubLoad);
		}
		
		if (data.readonly == true) this.setReadonly(item, true);
		if (data.hidden == true) this.hide(item);
		
		if (data.style) item._combo.DOMelem_input.style.cssText += data.style;
		
		item._combo.attachEvent("onFocus", function(){
			var item = this.cont.parentNode.parentNode;
			var f = item.getForm();
			if ((f.skin == "dhx_terrace" || f.skin == "material") && this.cont.className.search(/combo_in_focus/) < 0) this.cont.className += " combo_in_focus";
			f.callEvent("onFocus", [item._idd]);
			f = item = null;
		});
		
		item._combo.attachEvent("onBlur", function(){
			var item = this.cont.parentNode.parentNode;
			var f = item.getForm();
			if ((f.skin == "dhx_terrace" || f.skin == "material") && this.cont.className.search(/combo_in_focus/) >= 0) this.cont.className = this.cont.className.replace(/\s{0,}combo_in_focus/gi,"");
			f.callEvent("onBlur", [item._idd]);
			f = item = null;
		});
		
		return this;
	},
	
	destruct: function(item) {
		
		// unload combo
		item.childNodes[item._ll?1:0].childNodes[0].onchange = null;
		
		item._combo._currentComboValue = null;
		item._combo.unload();
		item._combo = null;
		
		// unload item
		item._apiChange = null;
		this.d2(item);
		item = null;
		
	},
	
	doAttachEvents: function(item) {
		
		var that = this;
		
		item.childNodes[item._ll?1:0].childNodes[0].onchange = function() {
			that.doOnChange(this);
			that.doValidate(this.DOMParent.parentNode.parentNode);
		}
	},
	
	doValidate: function(item) {
		if (item.getForm().hot_validate) this._validate(item);
	},
	
	doOnChange: function(combo) {
		var item = combo.base.parentNode.parentNode.parentNode;
		if (item._apiChange) return;
		combo._newComboValue = combo.getSelectedValue();
		if (combo._newComboValue != combo._currentComboValue) {
			if (item.checkEvent("onBeforeChange")) {
				if (item.callEvent("onBeforeChange", [item._idd, combo._currentComboValue, combo._newComboValue]) !== true) {
					// restore last value
					// not the best solution, should be improved
					window.setTimeout(function(){combo.setComboValue(combo._currentComboValue);},1);
					return false;
				}
			}
			combo._currentComboValue = combo._newComboValue;
			item.callEvent("onChange", [item._idd, combo._currentComboValue]);
		}
		item._autoCheck();
	},
	
	doLoadOptsConnector: function(item, url) {
		var that = this;
		var i = item;
		item._connector_working = true;
		item._apiChange = true;
		item._combo.load(url, function(){
			// try to set value if it was called while options loading was in progress
			i.callEvent("onOptionsLoaded", [i._idd]);
			i._connector_working = false;
			if (i._connector_value != null) {
				that.setValue(i, i._connector_value);
				i._connector_value = null;
			}
			i._apiChange = false;
			that = i = null;
		});
	},
	
	enable: function(item) {
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		item._enabled = true;
		item._combo.enable();
	},
	
	disable: function(item) {
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		item._enabled = false;
		item._combo.disable();
	},
	
	getCombo: function(item) {
		return item._combo;
	},
	
	setValue: function(item, val) {
		if (item._connector_working) { // attemp to set value while optins not yet loaded (connector used)
			item._connector_value = val;
			return;
		}
		item._apiChange = true;
		item._combo.setComboValue(val);
		item._combo._currentComboValue = item._combo.getActualValue();
		item._apiChange = false;
	},
	
	getValue: function(item) {
		return item._combo.getActualValue();
	},
	
	setWidth: function(item, width) {
		item.childNodes[item._ll?1:0].childNodes[0].style.width = width+"px";
	},
	
	setReadonly: function(item, state) {
		if (!item._combo) return;
		item._combo_ro = state;
		item._combo.readonly(item._combo_ro);
	},

	isReadonly: function(item, state) {
		return item._combo_ro||false;
	},
	
	setFocus: function(item) {
		if (item._enabled) item._combo.setFocus();
	},
	
	_setCss: function(item, skin, fontSize) {
		// update font-size for input and list-options div
		item._combo.setFontSize(fontSize, fontSize);
	}
	
};

(function(){
	for (var a in {doAddLabel:1,doAddInput:1,doLoadOpts:1,doUnloadNestedLists:1,setText:1,getText:1,isEnabled:1,_checkNoteWidth:1})
		dhtmlXForm.prototype.items.combo[a] = dhtmlXForm.prototype.items.select[a];
})();

dhtmlXForm.prototype.items.combo.d2 = dhtmlXForm.prototype.items.select.destruct;

dhtmlXForm.prototype.getCombo = function(name) {
	return this.doWithItem(name, "getCombo");
};


;
///<jscompress sourcefile="dhtmlxform_item_container.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXForm.prototype.items.container = {
	
	render: function(item, data) {
		
		item._type = "container";
		item._enabled = true;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "DIV", null, true, true, "dhxform_container");
		
		return this;
		
	},
	
	getContainer: function(item) {
		return item.childNodes[item._ll?1:0].childNodes[0];
	},
	
	enable: function(item) {
		item._enabled = true;
		if (String(item.className).search("disabled") >= 0) item.className = String(item.className).replace(/disabled/gi,"");
		//
		item.callEvent("onEnable",[item._idd]);
	},
	
	disable: function(item) {
		item._enabled = false;
		if (String(item.className).search("disabled") < 0) item.className += " disabled";
		//
		item.callEvent("onDisable",[item._idd]);
	},
	
	doAttachEvents: function(){
		
	},
	
	setValue: function(){
		
	},
	
	getValue: function(){
		return null;
	}
	
};

dhtmlXForm.prototype.getContainer = function(name) {
	return this.doWithItem(name, "getContainer");
};

(function(){
	for (var a in dhtmlXForm.prototype.items.input) {
		if (!dhtmlXForm.prototype.items.container[a]) dhtmlXForm.prototype.items.container[a] = dhtmlXForm.prototype.items.input[a];
	}
})();

;
///<jscompress sourcefile="dhtmlxform_item_colorpicker.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

dhtmlXForm.prototype.items.colorpicker = {
	
	colorpicker: {}, // colorpicker instances
	
	render: function(item, data) {
		
		var t = this;
		
		item._type = "colorpicker";
		item._enabled = true;
		
		this.doAddLabel(item, data);
		this.doAddInput(item, data, "INPUT", "TEXT", true, true, "dhxform_textarea");
		
		item._value = (data.value||"");
		item.childNodes[item._ll?1:0].childNodes[0].value = item._value;
		
		var conf = {
			input: item.childNodes[item._ll?1:0].childNodes[0],
			custom_colors: (window.dhx4.s2b(data.enableCustomColors) == true),
			skin: item.getForm().skin
		};
		
		this.colorpicker[item._idd] = new dhtmlXColorPicker(conf);
		this.colorpicker[item._idd]._nodes[0].valueColor = null; // disable input's bg change
		this.colorpicker[item._idd].base.className += " dhtmlxcp_in_form";
		
		if (typeof(data.customColors) != "undefined") {
			this.colorpicker[item._idd].setCustomColors(data.customColors);
		}
		
		if (typeof(data.cpPosition) == "string") {
			this.colorpicker[item._idd].setPosition(data.cpPosition);
		}
		
		// select handler
		this.colorpicker[item._idd].attachEvent("onSelect", function(color){
			if (item._value != color) {
				// call some events
				if (item.checkEvent("onBeforeChange")) {
					if (item.callEvent("onBeforeChange",[item._idd, item._value, color]) !== true) {
						// do not allow set new value
						item.childNodes[item._ll?1:0].childNodes[0].value = item._value;
						return;
					}
				}
				// accepted
				item._value = color;
				t.setValue(item, color);
				item.callEvent("onChange", [item._idd, item._value]);
			}
		});
		this.colorpicker[item._idd].attachEvent("onHide", function(color){
			var i = item.childNodes[item._ll?1:0].childNodes[0];
			if (i.value != item._value) i.value = item._value;
			i = null;
		});
		
		
		item.childNodes[item._ll?1:0].childNodes[0]._idd = item._idd;
		
		return this;
		
	},
	
	getColorPicker: function(item) {
		return this.colorpicker[item._idd];
	},
	
	destruct: function(item) {
		
		// unload color picker instance
		if (this.colorpicker[item._idd].unload) this.colorpicker[item._idd].unload();
		this.colorpicker[item._idd] = null;
		try {delete this.colorpicker[item._idd];} catch(e){}
		
		// remove custom events/objects
		item.childNodes[item._ll?1:0].childNodes[0]._idd = null;
		
		// unload item
		this.d2(item);
		item = null;
	},
	
	setSkin: function(item, skin) {
		this.colorpicker[item._idd].setSkin(skin);
	}
	
};


(function(){
	for (var a in {doAddLabel:1,doAddInput:1,doUnloadNestedLists:1,setText:1,getText:1,enable:1,disable:1,isEnabled:1,setWidth:1,setReadonly:1,isReadonly:1,setValue:1,getValue:1,updateValue:1,setFocus:1,getInput:1})
		dhtmlXForm.prototype.items.colorpicker[a] = dhtmlXForm.prototype.items.input[a];
})();

dhtmlXForm.prototype.items.colorpicker.d2 = dhtmlXForm.prototype.items.input.destruct;


dhtmlXForm.prototype.getColorPicker = function(name) {
	return this.doWithItem(name, "getColorPicker");
};


;
///<jscompress sourcefile="datastore.js" />
/*
Product Name: dhtmlxSuite 
Version: 5.0.8 
Edition: Professional 
License: content of this file is covered by DHTMLX Commercial or Enterprise license. Usage without proper license is prohibited. To obtain it contact sales@dhtmlx.com
Copyright UAB Dinamenta http://www.dhtmlx.com
*/

(function(){

var dhx = {};

//check some rule, show message as error if rule is not correct
dhx.assert = function(test, message){
	if (!test){
		dhx.assert_error(message);
	}
};

dhx.assert_error = function(message){
	dhx.log("error",message);
	if (dhx.message && typeof message == "string")
		dhx.message({ type:"debug", text:message, expire:-1 });
	if (dhx.debug !== false)
		eval("debugger;");
};

//entry point for analitic scripts
dhx.assert_core_ready = function(){
	if (window.dhx_on_core_ready)	
		dhx_on_core_ready();
};

/*
	Common helpers
*/
dhx.codebase="./";
dhx.name = "Core";

//coding helpers
dhx.clone = function(source){
	var f = dhx.clone._function;
	f.prototype = source;
	return new f();
};
dhx.clone._function = function(){};

//copies methods and properties from source to the target
dhx.extend = function(base, source, force){
	dhx.assert(base,"Invalid mixing target");
	dhx.assert(source,"Invalid mixing source");

	if (base._dhx_proto_wait){
		dhx.PowerArray.insertAt.call(base._dhx_proto_wait, source,1);
		return base;
	}
	
	//copy methods, overwrite existing ones in case of conflict
	for (var method in source)
		if (!base[method] || force)
			base[method] = source[method];
		
	//in case of defaults - preffer top one
	if (source.defaults)
		dhx.extend(base.defaults, source.defaults);
	
	//if source object has init code - call init against target
	if (source.$init)	
		source.$init.call(base);
				
	return base;	
};

//copies methods and properties from source to the target from all levels
dhx.copy = function(source){
	dhx.assert(source,"Invalid mixing target");
	if(arguments.length>1){
		var target = arguments[0];
		source = arguments[1];
	} else 
		var target =  (dhx.isArray(source)?[]:{});

	for (var method in source){
		if(source[method] && typeof source[method] == "object" && !dhx.isDate(source[method])){
			target[method] = (dhx.isArray(source[method])?[]:{});
			dhx.copy(target[method],source[method]);
		}else{
			target[method] = source[method];
		}
	}

	return target;	
};


dhx.single = function(source){ 
	var instance = null;
	var t = function(config){
		if (!instance)
			instance = new source({});
			
		if (instance._reinit)
			instance._reinit.apply(instance, arguments);
		return instance;
	};
	return t;
};

dhx.protoUI = function(){
	if (dhx.debug_proto)
		dhx.log("UI registered: "+arguments[0].name);
		
	var origins = arguments;
	var selfname = origins[0].name;
	
	var t = function(data){
		if (!t)
			return dhx.ui[selfname].prototype;

		var origins = t._dhx_proto_wait;
		if (origins){
			var params = [origins[0]];
			
			for (var i=1; i < origins.length; i++){
				params[i] = origins[i];
				
				if (params[i]._dhx_proto_wait)
					params[i] = params[i].call(dhx, params[i].name);

				if (params[i].prototype && params[i].prototype.name)
					dhx.ui[params[i].prototype.name] = params[i];
			}
			dhx.ui[selfname] = dhx.proto.apply(dhx, params);
			if (t._dhx_type_wait)	
				for (var i=0; i < t._dhx_type_wait.length; i++)
					dhx.Type(dhx.ui[selfname], t._dhx_type_wait[i]);
				
			t = origins = null;	
		}
			
		if (this != dhx)
			return new dhx.ui[selfname](data);
		else 
			return dhx.ui[selfname];
	};
	t._dhx_proto_wait = Array.prototype.slice.call(arguments, 0);
	return dhx.ui[selfname]=t;
};

dhx.proto = function(){
	 
	if (dhx.debug_proto)
		dhx.log("Proto chain:"+arguments[0].name+"["+arguments.length+"]");

	var origins = arguments;
	var compilation = origins[0];
	var has_constructor = !!compilation.$init;
	var construct = [];
	
	dhx.assert(compilation,"Invalid mixing target");
		
	for (var i=origins.length-1; i>0; i--) {
		dhx.assert(origins[i],"Invalid mixing source");
		if (typeof origins[i]== "function")
			origins[i]=origins[i].prototype;
		if (origins[i].$init) 
			construct.push(origins[i].$init);
		if (origins[i].defaults){ 
			var defaults = origins[i].defaults;
			if (!compilation.defaults)
				compilation.defaults = {};
			for (var def in defaults)
				if (dhx.isUndefined(compilation.defaults[def]))
					compilation.defaults[def] = defaults[def];
		}
		if (origins[i].type && compilation.type){
			for (var def in origins[i].type)
				if (!compilation.type[def])
					compilation.type[def] = origins[i].type[def];
		}
			
		for (var key in origins[i]){
			if (!compilation[key])
				compilation[key] = origins[i][key];
		}
	}
	
	if (has_constructor)
		construct.push(compilation.$init);
	
	
	compilation.$init = function(){
		for (var i=0; i<construct.length; i++)
			construct[i].apply(this, arguments);
	};
	var result = function(config){
		this.$ready=[];
		dhx.assert(this.$init,"object without init method");
		this.$init(config);
		if (this._parseSettings)
			this._parseSettings(config, this.defaults);
		for (var i=0; i < this.$ready.length; i++)
			this.$ready[i].call(this);
	};
	result.prototype = compilation;
	
	compilation = origins = null;
	return result;
};
//creates function with specified "this" pointer
dhx.bind=function(functor, object){ 
	return function(){ return functor.apply(object,arguments); };  
};

//loads module from external js file
dhx.require=function(module, callback, master){
	if (typeof module != "string"){
		var count = module.length||0;
		var callback_origin = callback;

		if (!count){
			for (var file in module) count++;
			callback = function(){ count--; if (count === 0) callback_origin.apply(this, arguments); };
			for (var file in module)
				dhx.require(file, callback, master);
		} else {
			callback = function(){
				if (count){
					count--;
					dhx.require(module[module.length - count - 1], callback, master);
				} else 
					return callback_origin.apply(this, arguments);
				
			};
			callback();
		}
		return;
	}

	if (dhx._modules[module] !== true){
		if (module.substr(-4) == ".css") {
			var link = dhx.html.create("LINK",{  type:"text/css", rel:"stylesheet", href:dhx.codebase+module});
			document.head.appendChild(link);
			if (callback)
				callback.call(master||window);
			return;
		}

		var step = arguments[4];

		//load and exec the required module
		if (!callback){
			//sync mode
			dhx.exec( dhx.ajax().sync().get(dhx.codebase+module).responseText );
			dhx._modules[module]=true;
		} else {

			if (!dhx._modules[module]){	//first call
				dhx._modules[module] = [[callback, master]];

				dhx.ajax(dhx.codebase+module, function(text){
					dhx.exec(text);	//evaluate code
					var calls = dhx._modules[module];	//callbacks
					dhx._modules[module] = true;
					for (var i=0; i<calls.length; i++)
						calls[i][0].call(calls[i][1]||window, !i);	//first callback get true as parameter
				});
			} else	//module already loading
				dhx._modules[module].push([callback, master]);
		}
		
	}
};
dhx._modules = {};	//hash of already loaded modules

//evaluate javascript code in the global scoope
dhx.exec=function(code){
	if (window.execScript)	//special handling for IE
		window.execScript(code);
	else window.eval(code);
};

dhx.wrap = function(code, wrap){
	if (!code) return wrap;
	return function(){
		var result = code.apply(this, arguments);
		wrap.apply(this,arguments);
		return result;
	};
};

//check === undefined
dhx.isUndefined=function(a){
	return typeof a == "undefined";
};
//delay call to after-render time
dhx.delay=function(method, obj, params, delay){
	return window.setTimeout(function(){
		var ret = method.apply(obj,(params||[]));
		method = obj = params = null;
		return ret;
	},delay||1);
};

//common helpers

//generates unique ID (unique per window, nog GUID)
dhx.uid = function(){
	if (!this._seed) this._seed=(new Date).valueOf();	//init seed with timestemp
	this._seed++;
	return this._seed;
};
//resolve ID as html object
dhx.toNode = function(node){
	if (typeof node == "string") return document.getElementById(node);
	return node;
};
//adds extra methods for the array
dhx.toArray = function(array){ 
	return dhx.extend((array||[]),dhx.PowerArray, true);
};
//resolve function name
dhx.toFunctor=function(str){ 
	return (typeof(str)=="string") ? eval(str) : str; 
};
/*checks where an object is instance of Array*/
dhx.isArray = function(obj) {
	return Array.isArray?Array.isArray(obj):(Object.prototype.toString.call(obj) === '[object Array]');
};
dhx.isDate = function(obj){
	return obj instanceof Date;
};

//dom helpers

//hash of attached events
dhx._events = {};
//attach event to the DOM element
dhx.event=function(node,event,handler,master){
	node = dhx.toNode(node);
	
	var id = dhx.uid();
	if (master) 
		handler=dhx.bind(handler,master);	
		
	dhx._events[id]=[node,event,handler];	//store event info, for detaching
		
	//use IE's of FF's way of event's attaching
	if (node.addEventListener)
		node.addEventListener(event, handler, false);
	else if (node.attachEvent)
		node.attachEvent("on"+event, handler);

	return id;	//return id of newly created event, can be used in eventRemove
};

//remove previously attached event
dhx.eventRemove=function(id){
	
	if (!id) return;
	dhx.assert(this._events[id],"Removing non-existing event");
		
	var ev = dhx._events[id];
	//browser specific event removing
	if (ev[0].removeEventListener)
		ev[0].removeEventListener(ev[1],ev[2],false);
	else if (ev[0].detachEvent)
		ev[0].detachEvent("on"+ev[1],ev[2]);
		
	delete this._events[id];	//delete all traces
};


//debugger helpers
//anything starting from error or log will be removed during code compression

//add message in the log
dhx.log = function(type,message,details){
	if (arguments.length == 1){
		message = type;
		type = "log";
	}
	/*jsl:ignore*/
	if (window.console && console.log){
		type=type.toLowerCase();
		if (window.console[type])
			window.console[type](message||"unknown error");
		else
			window.console.log(type +": "+message);

		if (details) 
			window.console.log(details);
	}	
	/*jsl:end*/
};
//register rendering time from call point 
dhx.log_full_time = function(name){
	dhx._start_time_log = new Date();
	dhx.log("Timing start ["+name+"]");
	window.setTimeout(function(){
		var time = new Date();
		dhx.log("Timing end ["+name+"]:"+(time.valueOf()-dhx._start_time_log.valueOf())/1000+"s");
	},1);
};
//register execution time from call point
dhx.log_time = function(name){
	var fname = "_start_time_log"+name;
	if (!dhx[fname]){
		dhx[fname] = new Date();
		dhx.log("Info","Timing start ["+name+"]");
	} else {
		var time = new Date();
		dhx.log("Info","Timing end ["+name+"]:"+(time.valueOf()-dhx[fname].valueOf())/1000+"s");
		dhx[fname] = null;
	}
};
dhx.debug_code = function(code){
	code.call(dhx);
};
//event system
dhx.EventSystem={
	$init:function(){
		if (!this._evs_events){
			this._evs_events = {};		//hash of event handlers, name => handler
			this._evs_handlers = {};	//hash of event handlers, ID => handler
			this._evs_map = {};
		}
	},
	//temporary block event triggering
	blockEvent : function(){
		this._evs_events._block = true;
	},
	//re-enable event triggering
	unblockEvent : function(){
		this._evs_events._block = false;
	},
	mapEvent:function(map){
		dhx.extend(this._evs_map, map, true);
	},
	on_setter:function(config){
		if(config){
			for(var i in config){
				if(typeof config[i] == 'function')
					this.attachEvent(i, config[i]);
			}
		}
	},
	//trigger event
	callEvent:function(type,params){
		if (this._evs_events._block) return true;
		
		type = type.toLowerCase();
		var event_stack =this._evs_events[type.toLowerCase()];	//all events for provided name
		var return_value = true;

		if (dhx.debug)	//can slowdown a lot
			dhx.log("info","["+this.name+"] event:"+type,params);
		
		if (event_stack)
			for(var i=0; i<event_stack.length; i++){
				/*
					Call events one by one
					If any event return false - result of whole event will be false
					Handlers which are not returning anything - counted as positive
				*/
				if (event_stack[i].apply(this,(params||[]))===false) return_value=false;
			}
		if (this._evs_map[type] && !this._evs_map[type].callEvent(type,params))
			return_value =	false;
			
		return return_value;
	},
	//assign handler for some named event
	attachEvent:function(type,functor,id){
		dhx.assert(functor, "Invalid event handler for "+type);

		type=type.toLowerCase();
		
		id=id||dhx.uid(); //ID can be used for detachEvent
		functor = dhx.toFunctor(functor);	//functor can be a name of method

		var event_stack=this._evs_events[type]||dhx.toArray();
		//save new event handler
		event_stack.push(functor);
		this._evs_events[type]=event_stack;
		this._evs_handlers[id]={ f:functor,t:type };
		
		return id;
	},
	//remove event handler
	detachEvent:function(id){
		if(!this._evs_handlers[id]){
			return;
		}
		var type=this._evs_handlers[id].t;
		var functor=this._evs_handlers[id].f;
		
		//remove from all collections
		var event_stack=this._evs_events[type];
		event_stack.remove(functor);
		delete this._evs_handlers[id];
	},
	hasEvent:function(type){
		type=type.toLowerCase();
		return this._evs_events[type]?true:false;
	}
};

dhx.extend(dhx, dhx.EventSystem);

//array helper
//can be used by dhx.toArray()
dhx.PowerArray={
	//remove element at specified position
	removeAt:function(pos,len){
		if (pos>=0) this.splice(pos,(len||1));
	},
	//find element in collection and remove it 
	remove:function(value){
		this.removeAt(this.find(value));
	},	
	//add element to collection at specific position
	insertAt:function(data,pos){
		if (!pos && pos!==0) 	//add to the end by default
			this.push(data);
		else {	
			var b = this.splice(pos,(this.length-pos));
  			this[pos] = data;
  			this.push.apply(this,b); //reconstruct array without loosing this pointer
  		}
  	},  	
  	//return index of element, -1 if it doesn't exists
  	find:function(data){ 
  		for (var i=0; i<this.length; i++) 
  			if (data==this[i]) return i; 	
  		return -1; 
  	},
  	//execute some method for each element of array
  	each:function(functor,master){
		for (var i=0; i < this.length; i++)
			functor.call((master||this),this[i]);
	},
	//create new array from source, by using results of functor 
	map:function(functor,master){
		for (var i=0; i < this.length; i++)
			this[i]=functor.call((master||this),this[i]);
		return this;
	}, 
	filter:function(functor, master){
		for (var i=0; i < this.length; i++)
			if (!functor.call((master||this),this[i])){
				this.splice(i,1);
				i--;
			}
		return this;
	}
};

dhx.env = {};

// dhx.env.transform 
// dhx.env.transition
(function(){
	if (navigator.userAgent.indexOf("Mobile")!=-1) 
		dhx.env.mobile = true;
	if (dhx.env.mobile || navigator.userAgent.indexOf("iPad")!=-1 || navigator.userAgent.indexOf("Android")!=-1)
		dhx.env.touch = true;
	if (navigator.userAgent.indexOf('Opera')!=-1)
		dhx.env.isOpera=true;
	else{
		//very rough detection, but it is enough for current goals
		dhx.env.isIE=!!document.all;
		dhx.env.isFF=!document.all;
		dhx.env.isWebKit=(navigator.userAgent.indexOf("KHTML")!=-1);
		dhx.env.isSafari=dhx.env.isWebKit && (navigator.userAgent.indexOf('Mac')!=-1);
	}
	if(navigator.userAgent.toLowerCase().indexOf("android")!=-1)
		dhx.env.isAndroid = true;
	dhx.env.transform = false;
	dhx.env.transition = false;
	var options = {};
	options.names = ['transform', 'transition'];
	options.transform = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'msTransform'];
	options.transition = ['transition', 'WebkitTransition', 'MozTransition', 'OTransition', 'msTransition'];
	
	var d = document.createElement("DIV");
	for(var i=0; i<options.names.length; i++) {
		var coll = options[options.names[i]];
		
		for (var j=0; j < coll.length; j++) {
			if(typeof d.style[coll[j]] != 'undefined'){
				dhx.env[options.names[i]] = coll[j];
				break;
			}
		}
	}
    d.style[dhx.env.transform] = "translate3d(0,0,0)";
    dhx.env.translate = (d.style[dhx.env.transform])?"translate3d":"translate";

	var prefix = ''; // default option
	var cssprefix = false;
	if(dhx.env.isOpera){
		prefix = '-o-';
		cssprefix = "O";
	}
	if(dhx.env.isFF)
		prefix = '-Moz-';
	if(dhx.env.isWebKit)
		prefix = '-webkit-';
	if(dhx.env.isIE)
		prefix = '-ms-';

    dhx.env.transformCSSPrefix = prefix;

	dhx.env.transformPrefix = cssprefix||(dhx.env.transformCSSPrefix.replace(/-/gi, ""));
	dhx.env.transitionEnd = ((dhx.env.transformCSSPrefix == '-Moz-')?"transitionend":(dhx.env.transformPrefix+"TransitionEnd"));
})();


dhx.env.svg = (function(){
		return document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
})();


//html helpers
dhx.html={
	_native_on_selectstart:0,
	denySelect:function(){
		if (!dhx._native_on_selectstart)
			dhx._native_on_selectstart = document.onselectstart;
		document.onselectstart = dhx.html.stopEvent;
	},
	allowSelect:function(){
		if (dhx._native_on_selectstart !== 0){
			document.onselectstart = dhx._native_on_selectstart||null;
		}
		dhx._native_on_selectstart = 0;

	},
	index:function(node){
		var k=0;
		//must be =, it is not a comparation!
		/*jsl:ignore*/
		while (node = node.previousSibling) k++;
		/*jsl:end*/
		return k;
	},
	_style_cache:{},
	createCss:function(rule){
		var text = "";
		for (var key in rule)
			text+= key+":"+rule[key]+";";
		
		var name = this._style_cache[text];
		if (!name){
			name = "s"+dhx.uid();
			this.addStyle("."+name+"{"+text+"}");
			this._style_cache[text] = name;
		}
		return name;
	},
	addStyle:function(rule){
		var style = document.createElement("style");
		style.setAttribute("type", "text/css");
		style.setAttribute("media", "screen"); 
		/*IE8*/
		if (style.styleSheet)
			style.styleSheet.cssText = rule;
		else
			style.appendChild(document.createTextNode(rule));
		document.getElementsByTagName("head")[0].appendChild(style);
	},
	create:function(name,attrs,html){
		attrs = attrs || {};
		var node = document.createElement(name);
		for (var attr_name in attrs)
			node.setAttribute(attr_name, attrs[attr_name]);
		if (attrs.style)
			node.style.cssText = attrs.style;
		if (attrs["class"])
			node.className = attrs["class"];
		if (html)
			node.innerHTML=html;
		return node;
	},
	//return node value, different logic for different html elements
	getValue:function(node){
		node = dhx.toNode(node);
		if (!node) return "";
		return dhx.isUndefined(node.value)?node.innerHTML:node.value;
	},
	//remove html node, can process an array of nodes at once
	remove:function(node){
		if (node instanceof Array)
			for (var i=0; i < node.length; i++)
				this.remove(node[i]);
		else
			if (node && node.parentNode)
				node.parentNode.removeChild(node);
	},
	//insert new node before sibling, or at the end if sibling doesn't exist
	insertBefore: function(node,before,rescue){
		if (!node) return;
		if (before && before.parentNode)
			before.parentNode.insertBefore(node, before);
		else
			rescue.appendChild(node);
	},
	//return custom ID from html element 
	//will check all parents starting from event's target
	locate:function(e,id){
		if (e.tagName)
			var trg = e;
		else {
			e=e||event;
			var trg=e.target||e.srcElement;
		}
		
		while (trg){
			if (trg.getAttribute){	//text nodes has not getAttribute
				var test = trg.getAttribute(id);
				if (test) return test;
			}
			trg=trg.parentNode;
		}	
		return null;
	},
	//returns position of html element on the page
	offset:function(elem) {
		if (elem.getBoundingClientRect) { //HTML5 method
			var box = elem.getBoundingClientRect();
			var body = document.body;
			var docElem = document.documentElement;
			var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
			var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
			var clientTop = docElem.clientTop || body.clientTop || 0;
			var clientLeft = docElem.clientLeft || body.clientLeft || 0;
			var top  = box.top +  scrollTop - clientTop;
			var left = box.left + scrollLeft - clientLeft;
			return { y: Math.round(top), x: Math.round(left) };
		} else { //fallback to naive approach
			var top=0, left=0;
			while(elem) {
				top = top + parseInt(elem.offsetTop,10);
				left = left + parseInt(elem.offsetLeft,10);
				elem = elem.offsetParent;
			}
			return {y: top, x: left};
		}
	},
	//returns relative position of event
	posRelative:function(ev){
		ev = ev || event;
		if (!dhx.isUndefined(ev.offsetX))
			return { x:ev.offsetX, y:ev.offsetY };	//ie, webkit
		else
			return { x:ev.layerX, y:ev.layerY };	//firefox
	},
	//returns position of event
	pos:function(ev){
		ev = ev || event;
        if(ev.pageX || ev.pageY)	//FF, KHTML
            return {x:ev.pageX, y:ev.pageY};
        //IE
        var d  =  ((dhx.env.isIE)&&(document.compatMode != "BackCompat"))?document.documentElement:document.body;
        return {
                x:ev.clientX + d.scrollLeft - d.clientLeft,
                y:ev.clientY + d.scrollTop  - d.clientTop
        };
	},
	//prevent event action
	preventEvent:function(e){
		if (e && e.preventDefault) e.preventDefault();
		return dhx.html.stopEvent(e);
	},
	//stop event bubbling
	stopEvent:function(e){
		(e||event).cancelBubble=true;
		return false;
	},
	//add css class to the node
	addCss:function(node,name){
        node.className+=" "+name;
    },
    //remove css class from the node
    removeCss:function(node,name){
        node.className=node.className.replace(RegExp(" "+name,"g"),"");
    }
};

dhx.ready = function(code){
	if (this._ready) code.call();
	else this._ready_code.push(code);
};
dhx._ready_code = [];

//autodetect codebase folder
(function(){
	var temp = document.getElementsByTagName("SCRIPT");	//current script, most probably
	dhx.assert(temp.length,"Can't locate codebase");
	if (temp.length){
		//full path to script
		temp = (temp[temp.length-1].getAttribute("src")||"").split("/");
		//get folder name
		temp.splice(temp.length-1, 1);
		dhx.codebase = temp.slice(0, temp.length).join("/")+"/";
	}
	dhx.event(window, "load", function(){
		dhx4.callEvent("onReady",[]);
		dhx.delay(function(){
			dhx._ready = true;
			for (var i=0; i < dhx._ready_code.length; i++)
				dhx._ready_code[i].call();
			dhx._ready_code=[];
		});
	});
	
})();

dhx.locale=dhx.locale||{};


dhx.assert_core_ready();


dhx.ready(function(){
	dhx.event(document.body,"click", function(e){
		dhx4.callEvent("onClick",[e||event]);
	});
});


/*DHX:Depend core/bind.js*/
/*DHX:Depend core/dhx.js*/
/*DHX:Depend core/config.js*/
/*
	Behavior:Settings
	
	@export
		customize
		config
*/

/*DHX:Depend core/template.js*/
/*
	Template - handles html templates
*/

/*DHX:Depend core/dhx.js*/

(function(){

var _cache = {};
var newlines = new RegExp("(\\r\\n|\\n)","g");
var quotes = new RegExp("(\\\")","g");

dhx.Template = function(str){
	if (typeof str == "function") return str;
	if (_cache[str])
		return _cache[str];
		
	str=(str||"").toString();			
	if (str.indexOf("->")!=-1){
		str = str.split("->");
		switch(str[0]){
			case "html": 	//load from some container on the page
				str = dhx.html.getValue(str[1]);
				break;
			default:
				//do nothing, will use template as is
				break;
		}
	}
		
	//supported idioms
	// {obj.attr} => named attribute or value of sub-tag in case of xml
	str=(str||"").toString();		
	str=str.replace(newlines,"\\n");
	str=str.replace(quotes,"\\\"");

	str=str.replace(/\{obj\.([^}?]+)\?([^:]*):([^}]*)\}/g,"\"+(obj.$1?\"$2\":\"$3\")+\"");
	str=str.replace(/\{common\.([^}\(]*)\}/g,"\"+(common.$1||'')+\"");
	str=str.replace(/\{common\.([^\}\(]*)\(\)\}/g,"\"+(common.$1?common.$1.apply(this, arguments):\"\")+\"");
	str=str.replace(/\{obj\.([^}]*)\}/g,"\"+(obj.$1)+\"");
	str=str.replace("{obj}","\"+obj+\"");
	str=str.replace(/#([^#'";, ]+)#/gi,"\"+(obj.$1)+\"");

	try {
		_cache[str] = Function("obj","common","return \""+str+"\";");
	} catch(e){
		dhx.assert_error("Invalid template:"+str);
	}

	return _cache[str];
};


dhx.Template.empty=function(){	return "";	};
dhx.Template.bind =function(value){	return dhx.bind(dhx.Template(value),this); };


	/*
		adds new template-type
		obj - object to which template will be added
		data - properties of template
	*/
dhx.Type=function(obj, data){ 
	if (obj._dhx_proto_wait){
		if (!obj._dhx_type_wait)
			obj._dhx_type_wait = [];
				obj._dhx_type_wait.push(data);
		return;
	}
		
	//auto switch to prototype, if name of class was provided
	if (typeof obj == "function")
		obj = obj.prototype;
	if (!obj.types){
		obj.types = { "default" : obj.type };
		obj.type.name = "default";
	}
	
	var name = data.name;
	var type = obj.type;
	if (name)
		type = obj.types[name] = dhx.clone(data.baseType?obj.types[data.baseType]:obj.type);
	
	for(var key in data){
		if (key.indexOf("template")===0)
			type[key] = dhx.Template(data[key]);
		else
			type[key]=data[key];
	}

	return name;
};

})();
/*DHX:Depend core/dhx.js*/

dhx.Settings={
	$init:function(){
		/* 
			property can be accessed as this.config.some
			in same time for inner call it have sense to use _settings
			because it will be minified in final version
		*/
		this._settings = this.config= {}; 
	},
	define:function(property, value){
		if (typeof property == "object")
			return this._parseSeetingColl(property);
		return this._define(property, value);
	},
	_define:function(property,value){
		//method with name {prop}_setter will be used as property setter
		//setter is optional
		var setter = this[property+"_setter"];
		return this._settings[property]=setter?setter.call(this,value,property):value;
	},
	//process configuration object
	_parseSeetingColl:function(coll){
		if (coll){
			for (var a in coll)				//for each setting
				this._define(a,coll[a]);		//set value through config
		}
	},
	//helper for object initialization
	_parseSettings:function(obj,initial){
		//initial - set of default values
		var settings = {}; 
		if (initial)
			settings = dhx.extend(settings,initial);
					
		//code below will copy all properties over default one
		if (typeof obj == "object" && !obj.tagName)
			dhx.extend(settings,obj, true);	
		//call config for each setting
		this._parseSeetingColl(settings);
	},
	_mergeSettings:function(config, defaults){
		for (var key in defaults)
			switch(typeof config[key]){
				case "object": 
					config[key] = this._mergeSettings((config[key]||{}), defaults[key]);
					break;
				case "undefined":
					config[key] = defaults[key];
					break;
				default:	//do nothing
					break;
			}
		return config;
	},

	debug_freid_c_id:true,
	debug_freid_a_name:true
};
/*DHX:Depend core/datastore.js*/
/*DHX:Depend core/load.js*/
/* 
	ajax operations 
	
	can be used for direct loading as
		dhx.ajax(ulr, callback)
	or
		dhx.ajax().item(url)
		dhx.ajax().post(url)

*/

/*DHX:Depend core/dhx.js*/

dhx.ajax = function(url,call,master){
	//if parameters was provided - made fast call
	if (arguments.length!==0){
		var http_request = new dhx.ajax();
		if (master) http_request.master=master;
		return http_request.get(url,null,call);
	}
	if (!this.getXHR) return new dhx.ajax(); //allow to create new instance without direct new declaration
	
	return this;
};
dhx.ajax.count = 0;
dhx.ajax.prototype={
	master:null,
	//creates xmlHTTP object
	getXHR:function(){
		if (dhx.env.isIE)
		 return new ActiveXObject("Microsoft.xmlHTTP");
		else 
		 return new XMLHttpRequest();
	},
	/*
		send data to the server
		params - hash of properties which will be added to the url
		call - callback, can be an array of functions
	*/
	send:function(url,params,call){
		var x=this.getXHR();
		if (!dhx.isArray(call))
			call = [call];
		//add extra params to the url
		if (typeof params == "object"){
			var t=[];
			for (var a in params){
				var value = params[a];
				if (value === null || value === dhx.undefined)
					value = "";
				t.push(a+"="+encodeURIComponent(value));// utf-8 escaping
		 	}
			params=t.join("&");
		}
		if (params && this.request==='GET'){
			url=url+(url.indexOf("?")!=-1 ? "&" : "?")+params;
			params=null;
		}
		
		x.open(this.request,url,!this._sync);
		if (this.request === 'POST')
			x.setRequestHeader('Content-type','application/x-www-form-urlencoded');
		 
		//async mode, define loading callback
		 var self=this;
		 x.onreadystatechange= function(){
			if (!x.readyState || x.readyState == 4){
				if (dhx.debug_time) dhx.log_full_time("data_loading");	//log rendering time
				dhx.ajax.count++;
				if (call && self){
					for (var i=0; i < call.length; i++)	//there can be multiple callbacks
						if (call[i]){
							var method = (call[i].success||call[i]);
							if (x.status >= 400 || (!x.status && !x.responseText))
								method = call[i].error;
							if (method)
								method.call((self.master||self),x.responseText,x.responseXML,x);
						}
				}
				if (self) self.master=null;
				call=self=null;	//anti-leak
			}
		 };
		
		x.send(params||null);
		return x; //return XHR, which can be used in case of sync. mode
	},
	//GET request
	get:function(url,params,call){
		if (arguments.length == 2){
			call = params;
			params = null;
		}
		this.request='GET';
		return this.send(url,params,call);
	},
	//POST request
	post:function(url,params,call){
		this.request='POST';
		return this.send(url,params,call);
	},
	//PUT request
	put:function(url,params,call){
		this.request='PUT';
		return this.send(url,params,call);
	},
	//POST request
	del:function(url,params,call){
		this.request='DELETE';
		return this.send(url,params,call);
	}, 
	sync:function(){
		this._sync = true;
		return this;
	},
	bind:function(master){
		this.master = master;
		return this;
	}
};
/*submits values*/
dhx.send = function(url, values, method, target){
	var form = dhx.html.create("FORM",{
		"target":(target||"_self"),
		"action":url,
		"method":(method||"POST")
	},"");
	for (var k in values) {
		var field = dhx.html.create("INPUT",{"type":"hidden","name": k,"value": values[k]},"");
		form.appendChild(field);
	}
	form.style.display = "none";
	document.body.appendChild(form);
	form.submit();
	document.body.removeChild(form);
};


dhx.AtomDataLoader={
	$init:function(config){
		//prepare data store
		this.data = {}; 
		if (config){
			this._settings.datatype = config.datatype||"json";
			this.$ready.push(this._load_when_ready);
		}
	},
	_load_when_ready:function(){
		this._ready_for_data = true;
		
		if (this._settings.url)
			this.url_setter(this._settings.url);
		if (this._settings.data)
			this.data_setter(this._settings.data);
	},
	url_setter:function(value){
		if (!this._ready_for_data) return value;
		this.load(value, this._settings.datatype);	
		return value;
	},
	data_setter:function(value){
		if (!this._ready_for_data) return value;
		this.parse(value, this._settings.datatype);
		return true;
	},
	debug_freid_c_datatype:true,
	debug_freid_c_dataFeed:true,

	//loads data from external URL
	load:function(url,call){
		if (url.$proxy) {
			url.load(this, typeof call == "string" ? call : "json");
			return;
		}

		this.callEvent("onXLS",[]);
		if (typeof call == "string"){	//second parameter can be a loading type or callback
			//we are not using setDriver as data may be a non-datastore here
			this.data.driver = dhx.DataDriver[call];
			call = arguments[2];
		} else if (!this.data.driver)
			this.data.driver = dhx.DataDriver.json;

		//load data by async ajax call
		//loading_key - can be set by component, to ignore data from old async requests
		var callback = [{
			success: this._onLoad,
			error: this._onLoadError
		}];
		
		if (call){
			if (dhx.isArray(call))
				callback.push.apply(callback,call);
			else
				callback.push(call);
		}
			

		return dhx.ajax(url,callback,this);
	},
	//loads data from object
	parse:function(data,type){
		this.callEvent("onXLS",[]);
		this.data.driver = dhx.DataDriver[type||"json"];
		this._onLoad(data,null);
	},
	//default after loading callback
	_onLoad:function(text,xml,loader,key){
		var driver = this.data.driver;
		var data = driver.toObject(text,xml);
		if (data){
			var top = driver.getRecords(data)[0];
			this.data=(driver?driver.getDetails(top):text);
		} else 
			this._onLoadError(text,xml,loader);

		this.callEvent("onXLE",[]);
	},
	_onLoadError:function(text, xml, xhttp){
		this.callEvent("onXLE",[]);
		this.callEvent("onLoadError",arguments);
		dhx4.callEvent("onLoadError", [text, xml, xhttp, this]);
	},
	_check_data_feed:function(data){
		if (!this._settings.dataFeed || this._ignore_feed || !data) return true;
		var url = this._settings.dataFeed;
		if (typeof url == "function")
			return url.call(this, (data.id||data), data);
		url = url+(url.indexOf("?")==-1?"?":"&")+"action=get&id="+encodeURIComponent(data.id||data);
		this.callEvent("onXLS",[]);
		dhx.ajax(url, function(text,xml,loader){
			this._ignore_feed=true;
			var data = dhx.DataDriver.toObject(text, xml);
			if (data)
				this.setValues(data.getDetails(data.getRecords()[0]));
			else
				this._onLoadError(text,xml,loader);
			this._ignore_feed=false;
			this.callEvent("onXLE",[]);
		}, this);
		return false;
	}
};

/*
	Abstraction layer for different data types
*/

dhx.DataDriver={};
dhx.DataDriver.json={
	//convert json string to json object if necessary
	toObject:function(data){
		if (!data) data="[]";
		if (typeof data == "string"){
			try{
				eval ("dhx.temp="+data);
			} catch(e){
				dhx.assert_error(e);
				return null;
			}
			data = dhx.temp;
		}

		if (data.data){ 
			var t = data.data.config = {};
			for (var key in data)
				if (key!="data")
					t[key] = data[key];
			data = data.data;
		}
			
		return data;
	},
	//get array of records
	getRecords:function(data){
		if (data && !dhx.isArray(data))
		 return [data];
		return data;
	},
	//get hash of properties for single record
	getDetails:function(data){
		if (typeof data == "string")
			return { id:dhx.uid(), value:data };
		return data;
	},
	//get count of data and position at which new data need to be inserted
	getInfo:function(data){
		var cfg = data.config;
		if (!cfg) return {};

		return { 
		 _size:(cfg.total_count||0),
		 _from:(cfg.pos||0),
		 _parent:(cfg.parent||0),
		 _config:(cfg.config),
		 _key:(cfg.dhx_security)
		};
	},
	child:"data"
};

dhx.DataDriver.html={
	/*
		incoming data can be
		 - collection of nodes
		 - ID of parent container
		 - HTML text
	*/
	toObject:function(data){
		if (typeof data == "string"){
		 var t=null;
		 if (data.indexOf("<")==-1)	//if no tags inside - probably its an ID
			t = dhx.toNode(data);
		 if (!t){
			t=document.createElement("DIV");
			t.innerHTML = data;
		 }
		 
		 return t.getElementsByTagName(this.tag);
		}
		return data;
	},
	//get array of records
	getRecords:function(node){
		var data = [];
		for (var i=0; i<node.childNodes.length; i++){
			var child = node.childNodes[i];
			if (child.nodeType == 1)
				data.push(child);
		}
		return data;
	},
	//get hash of properties for single record
	getDetails:function(data){
		return dhx.DataDriver.xml.tagToObject(data);
	},
	//dyn loading is not supported by HTML data source
	getInfo:function(data){
		return { 
		 _size:0,
		 _from:0
		};
	},
	tag: "LI"
};

dhx.DataDriver.jsarray={
	//eval jsarray string to jsarray object if necessary
	toObject:function(data){
		if (typeof data == "string"){
		 eval ("dhx.temp="+data);
		 return dhx.temp;
		}
		return data;
	},
	//get array of records
	getRecords:function(data){
		return data;
	},
	//get hash of properties for single record, in case of array they will have names as "data{index}"
	getDetails:function(data){
		var result = {};
		for (var i=0; i < data.length; i++) 
		 result["data"+i]=data[i];
		 
		return result;
	},
	//dyn loading is not supported by js-array data source
	getInfo:function(data){
		return { 
		 _size:0,
		 _from:0
		};
	}
};

dhx.DataDriver.csv={
	//incoming data always a string
	toObject:function(data){
		return data;
	},
	//get array of records
	getRecords:function(data){
		return data.split(this.row);
	},
	//get hash of properties for single record, data named as "data{index}"
	getDetails:function(data){
		data = this.stringToArray(data);
		var result = {};
		for (var i=0; i < data.length; i++) 
		 result["data"+i]=data[i];
		 
		return result;
	},
	//dyn loading is not supported by csv data source
	getInfo:function(data){
		return { 
		 _size:0,
		 _from:0
		};
	},
	//split string in array, takes string surrounding quotes in account
	stringToArray:function(data){
		data = data.split(this.cell);
		for (var i=0; i < data.length; i++)
		 data[i] = data[i].replace(/^[ \t\n\r]*(\"|)/g,"").replace(/(\"|)[ \t\n\r]*$/g,"");
		return data;
	},
	row:"\n",	//default row separator
	cell:","	//default cell separator
};

dhx.DataDriver.xml={
	_isValidXML:function(data){
		if (!data || !data.documentElement)
			return null;
		if (data.getElementsByTagName("parsererror").length)
			return null;
		return data;
	},
	//convert xml string to xml object if necessary
	toObject:function(text,xml){
		if (this._isValidXML(data))
			return data;
		if (typeof text == "string")
			var data = this.fromString(text.replace(/^[\s]+/,""));
		else
			data = text;

		if (this._isValidXML(data))
			return data;
		return null;
	},
	//get array of records
	getRecords:function(data){
		return this.xpath(data,this.records);
	},
	records:"/*/item",
	child:"item",
	config:"/*/config",
	//get hash of properties for single record
	getDetails:function(data){
		return this.tagToObject(data,{});
	},
	//get count of data and position at which new data_loading need to be inserted
	getInfo:function(data){
		
		var config = this.xpath(data, this.config);
		if (config.length)
			config = this.assignTypes(this.tagToObject(config[0],{}));
		else 
			config = null;

		return { 
		 _size:(data.documentElement.getAttribute("total_count")||0),
		 _from:(data.documentElement.getAttribute("pos")||0),
		 _parent:(data.documentElement.getAttribute("parent")||0),
		 _config:config,
		 _key:(data.documentElement.getAttribute("dhx_security")||null)
		};
	},
	//xpath helper
	xpath:function(xml,path){
		if (window.XPathResult){	//FF, KHTML, Opera
		 var node=xml;
		 if(xml.nodeName.indexOf("document")==-1)
		 xml=xml.ownerDocument;
		 var res = [];
		 var col = xml.evaluate(path, node, null, XPathResult.ANY_TYPE, null);
		 var temp = col.iterateNext();
		 while (temp){ 
			res.push(temp);
			temp = col.iterateNext();
		}
		return res;
		}	
		else {
			var test = true;
			try {
				if (typeof(xml.selectNodes)=="undefined")
					test = false;
			} catch(e){ /*IE7 and below can't operate with xml object*/ }
			//IE
			if (test)
				return xml.selectNodes(path);
			else {
				//Google hate us, there is no interface to do XPath
				//use naive approach
				var name = path.split("/").pop();
				return xml.getElementsByTagName(name);
			}
		}
	},
	assignTypes:function(obj){
		for (var k in obj){
			var test = obj[k];
			if (typeof test == "object")
				this.assignTypes(test);
			else if (typeof test == "string"){
				if (test === "") 
					continue;
				if (test == "true")
					obj[k] = true;
				else if (test == "false")
					obj[k] = false;
				else if (test == test*1)
					obj[k] = obj[k]*1;
			}
		}
		return obj;
	},
	//convert xml tag to js object, all subtags and attributes are mapped to the properties of result object
	tagToObject:function(tag,z){
		z=z||{};
		var flag=false;
				
		//map attributes
		var a=tag.attributes;
		if(a && a.length){
			for (var i=0; i<a.length; i++)
		 		z[a[i].name]=a[i].value;
		 	flag = true;
	 	}
		//map subtags
		
		var b=tag.childNodes;
		var state = {};
		for (var i=0; i<b.length; i++){
			if (b[i].nodeType==1){
				var name = b[i].tagName;
				if (typeof z[name] != "undefined"){
					if (!dhx.isArray(z[name]))
						z[name]=[z[name]];
					z[name].push(this.tagToObject(b[i],{}));
				}
				else
					z[b[i].tagName]=this.tagToObject(b[i],{});	//sub-object for complex subtags
				flag=true;
			}
		}
		
		if (!flag)
			return this.nodeValue(tag);
		//each object will have its text content as "value" property
		z.value = z.value||this.nodeValue(tag);
		return z;
	},
	//get value of xml node 
	nodeValue:function(node){
		if (node.firstChild)
		 return node.firstChild.data;	//FIXME - long text nodes in FF not supported for now
		return "";
	},
	//convert XML string to XML object
	fromString:function(xmlString){
		try{
			if (window.DOMParser)		// FF, KHTML, Opera
				return (new DOMParser()).parseFromString(xmlString,"text/xml");
			if (window.ActiveXObject){	// IE, utf-8 only 
				var temp=new ActiveXObject("Microsoft.xmlDOM");
				temp.loadXML(xmlString);
				return temp;
			}
		} catch(e){
			dhx.assert_error(e);
			return null;
		}
		dhx.assert_error("Load from xml string is not supported");
	}
};

/*DHX:Depend core/dhx.js*/

/*
	Behavior:DataLoader - load data in the component
	
	@export
		load
		parse
*/
dhx.DataLoader=dhx.proto({
	$init:function(config){
		//prepare data store
		config = config || "";
		
		//list of all active ajax requests
		this._ajax_queue = dhx.toArray();

		this.data = new dhx.DataStore();
		this.data.attachEvent("onClearAll",dhx.bind(this._call_onclearall,this));
		this.data.attachEvent("onServerConfig", dhx.bind(this._call_on_config, this));
		this.data.feed = this._feed;

	},

	_feed:function(from,count,callback){
				//allow only single request at same time
				if (this._load_count)
					return this._load_count=[from,count,callback];	//save last ignored request
				else
					this._load_count=true;
				this._feed_last = [from, count];
				this._feed_common.call(this, from, count, callback);
	},
	_feed_common:function(from, count, callback){
		var url = this.data.url;
		if (from<0) from = 0;
		this.load(url+((url.indexOf("?")==-1)?"?":"&")+(this.dataCount()?("continue=true&"):"")+"start="+from+"&count="+count,[
			this._feed_callback,
			callback
		]);
	},
	_feed_callback:function(){
		//after loading check if we have some ignored requests
		var temp = this._load_count;
		var last = this._feed_last;
		this._load_count = false;
		if (typeof temp =="object" && (temp[0]!=last[0] || temp[1]!=last[1]))
			this.data.feed.apply(this, temp);	//load last ignored request
	},
	//loads data from external URL
	load:function(url,call){
		var ajax = dhx.AtomDataLoader.load.apply(this, arguments);
		this._ajax_queue.push(ajax);

		//prepare data feed for dyn. loading
		if (!this.data.url)
			this.data.url = url;
	},
	//load next set of data rows
	loadNext:function(count, start, callback, url, now){
		if (this._settings.datathrottle && !now){
			if (this._throttle_request)
				window.clearTimeout(this._throttle_request);
			this._throttle_request = dhx.delay(function(){
				this.loadNext(count, start, callback, url, true);
			},this, 0, this._settings.datathrottle);
			return;
		}

		if (!start && start !== 0) start = this.dataCount();
		this.data.url = this.data.url || url;

		if (this.callEvent("onDataRequest", [start,count,callback,url]) && this.data.url)
			this.data.feed.call(this, start, count, callback);
	},
	_maybe_loading_already:function(count, from){
		var last = this._feed_last;
		if(this._load_count && last){
			if (last[0]<=from && (last[1]+last[0] >= count + from )) return true;
		}
		return false;
	},
	//default after loading callback
	_onLoad:function(text,xml,loader){
		//ignore data loading command if data was reloaded 
		this._ajax_queue.remove(loader);

		var data = this.data.driver.toObject(text,xml);
		if (data) 
			this.data._parse(data);
		else
			return this._onLoadError(text, xml, loader);
		
		//data loaded, view rendered, call onready handler
		this._call_onready();

		this.callEvent("onXLE",[]);
	},
	removeMissed_setter:function(value){
		return this.data._removeMissed = value;
	},
	scheme_setter:function(value){
		this.data.scheme(value);
	},	
	dataFeed_setter:function(value){
		this.data.attachEvent("onBeforeFilter", dhx.bind(function(text, value){
			if (this._settings.dataFeed){

				var filter = {};				
				if (!text && !value) return;
				if (typeof text == "function"){
					if (!value) return;
					text(value, filter);
				} else 
					filter = { text:value };

				this.clearAll();
				var url = this._settings.dataFeed;
				var urldata = [];
				if (typeof url == "function")
					return url.call(this, value, filter);
				for (var key in filter)
					urldata.push("dhx_filter["+key+"]="+encodeURIComponent(filter[key]));
				this.load(url+(url.indexOf("?")<0?"?":"&")+urldata.join("&"), this._settings.datatype);
				return false;
			}
		},this));
		return value;
	},

	debug_freid_c_ready:true,
	debug_freid_c_datathrottle:true,
	
	_call_onready:function(){
		if (this._settings.ready && !this._ready_was_used){
			var code = dhx.toFunctor(this._settings.ready);
			if (code)
				dhx.delay(code, this, arguments);
			this._ready_was_used = true;
		}
	},
	_call_onclearall:function(){
		for (var i = 0; i < this._ajax_queue.length; i++)
			this._ajax_queue[i].abort();

		this._ajax_queue = dhx.toArray();
	},
	_call_on_config:function(config){
		this._parseSeetingColl(config);
	}
},dhx.AtomDataLoader);


/*
	DataStore is not a behavior, it standalone object, which represents collection of data.
	Call provideAPI to map data API

	@export
		exists
		idByIndex
		indexById
		get
		set
		refresh
		dataCount
		sort
		filter
		next
		previous
		clearAll
		first
		last
*/
dhx.DataStore = function(){
	this.name = "DataStore";
	
	dhx.extend(this, dhx.EventSystem);

	this.setDriver("json");	//default data source is an
	this.pull = {};						//hash of IDs
	this.order = dhx.toArray();		//order of IDs
	this._marks = {};
};

dhx.DataStore.prototype={
	//defines type of used data driver
	//data driver is an abstraction other different data formats - xml, json, csv, etc.
	setDriver:function(type){
		dhx.assert(dhx.DataDriver[type],"incorrect DataDriver");
		this.driver = dhx.DataDriver[type];
	},
	//process incoming raw data
	_parse:function(data,master){
		this.callEvent("onParse", [this.driver, data]);
		if (this._filter_order)
			this.filter();
			
		//get size and position of data
		var info = this.driver.getInfo(data);
		if (info._key)
			dhx.securityKey = info._key;
		if (info._config)
			this.callEvent("onServerConfig",[info._config]);

		//get array of records
		var recs = this.driver.getRecords(data);

		this._inner_parse(info, recs);

		//in case of tree store we may want to group data
		if (this._scheme_group && this._group_processing)
			this._group_processing(this._scheme_group);

		//optional data sorting
		if (this._scheme_sort){
			this.blockEvent();
			this.sort(this._scheme_sort);
			this.unblockEvent();
		}
		this.callEvent("onStoreLoad",[this.driver, data]);
		//repaint self after data loading
		this.refresh();
	},
	_inner_parse:function(info, recs){
		var from = (info._from||0)*1;
		var subload = true;
		var marks = false;

		if (from === 0 && this.order[0]){ //update mode
			if (this._removeMissed){
				//update mode, create kill list
				marks = {};
				for (var i=0; i<this.order.length; i++)
					marks[this.order[i]]=true;
			}
			
			subload = false;
			from = this.order.length;
		}

		var j=0;
		for (var i=0; i<recs.length; i++){
			//get hash of details for each record
			var temp = this.driver.getDetails(recs[i]);
			var id = this.id(temp); 	//generate ID for the record
			if (!this.pull[id]){		//if such ID already exists - update instead of insert
				this.order[j+from]=id;	
				j++;
			} else if (subload && this.order[j+from])
				j++;

			if(this.pull[id]){
				dhx.extend(this.pull[id],temp,true);//add only new properties
				if (this._scheme_update)
					this._scheme_update(this.pull[id]);
				//update mode, remove item from kill list
				if (marks)
					delete marks[id];
			} else{
				this.pull[id] = temp;
				if (this._scheme_init)
					this._scheme_init(temp);
			}
			
		}

		//update mode, delete items which are not existing in the new xml
		if (marks){
			this.blockEvent();
			for (var delid in marks)
				this.remove(delid);
			this.unblockEvent();
		}

		if (!this.order[info._size-1])
			this.order[info._size-1] = dhx.undefined;
	},
	//generate id for data object
	id:function(data){
		return data.id||(data.id=dhx.uid());
	},
	changeId:function(old, newid){
		//dhx.assert(this.pull[old],"Can't change id, for non existing item: "+old);
		if(this.pull[old])
			this.pull[newid] = this.pull[old];
		this.pull[newid].id = newid;
		this.order[this.order.find(old)]=newid;
		if (this._filter_order)
			this._filter_order[this._filter_order.find(old)]=newid;
		if (this._marks[old]){
			this._marks[newid] = this._marks[old];
			delete this._marks[old];
		}


		this.callEvent("onIdChange", [old, newid]);
		if (this._render_change_id)
			this._render_change_id(old, newid);
		delete this.pull[old];
	},
	//get data from hash by id
	item:function(id){
		return this.pull[id];
	},
	//assigns data by id
	update:function(id,data){
		if (dhx.isUndefined(data)) data = this.item(id);
		if (this._scheme_update)
			this._scheme_update(data);
		if (this.callEvent("onBeforeUpdate", [id, data]) === false) return false;
		this.pull[id]=data;
		this.callEvent("onStoreUpdated",[id, data, "update"]);
	},
	//sends repainting signal
	refresh:function(id){
		if (this._skip_refresh) return; 
		
		if (id)
			this.callEvent("onStoreUpdated",[id, this.pull[id], "paint"]);
		else
			this.callEvent("onStoreUpdated",[null,null,null]);
	},
	silent:function(code, master){
		this._skip_refresh = true;
		code.call(master||this);
		this._skip_refresh = false;
	},
	//converts range IDs to array of all IDs between them
	getRange:function(from,to){		
		//if some point is not defined - use first or last id
		//BEWARE - do not use empty or null ID
		if (from)
			from = this.indexById(from);
		else 
			from = (this.$min||this.startOffset)||0;
		if (to)
			to = this.indexById(to);
		else {
			to = Math.min(((this.$max||this.endOffset)||Infinity),(this.dataCount()-1));
			if (to<0) to = 0; //we have not data in the store
		}

		if (from>to){ //can be in case of backward shift-selection
			var a=to; to=from; from=a;
		}

		return this.getIndexRange(from,to);
	},
	//converts range of indexes to array of all IDs between them
	getIndexRange:function(from,to){
		to=Math.min((to||Infinity),this.dataCount()-1);
		
		var ret=dhx.toArray(); //result of method is rich-array
		for (var i=(from||0); i <= to; i++)
			ret.push(this.item(this.order[i]));
		return ret;
	},
	//returns total count of elements
	dataCount:function(){
		return this.order.length;
	},
	//returns truy if item with such ID exists
	exists:function(id){
		return !!(this.pull[id]);
	},
	//nextmethod is not visible on component level, check DataMove.move
	//moves item from source index to the target index
	move:function(sindex,tindex){
		dhx.assert(sindex>=0 && tindex>=0, "DataStore::move","Incorrect indexes");

		var id = this.idByIndex(sindex);
		var obj = this.item(id);
		
		this.order.removeAt(sindex);	//remove at old position
		//if (sindex<tindex) tindex--;	//correct shift, caused by element removing
		this.order.insertAt(id,Math.min(this.order.length, tindex));	//insert at new position
		
		//repaint signal
		this.callEvent("onStoreUpdated",[id,obj,"move"]);
	},
	scheme:function(config){
		this._scheme = {};
		this._scheme_init = config.$init;
		this._scheme_update = config.$update;
		this._scheme_serialize = config.$serialize;
		this._scheme_group = config.$group;
		this._scheme_sort = config.$sort;

		//ignore $-starting properties, as they have special meaning
		for (var key in config)
			if (key.substr(0,1) != "$")
				this._scheme[key] = config[key];
	},
	sync:function(source, filter, silent){
		if (typeof source == "string")
			source = $$("source");

		if (typeof filter != "function"){
			silent = filter;
			filter = null;
		}
		
		if (dhx.debug_bind){
			this.debug_sync_master = source; 
			dhx.log("[sync] "+this.debug_bind_master.name+"@"+this.debug_bind_master._settings.id+" <= "+this.debug_sync_master.name+"@"+this.debug_sync_master._settings.id);
		}

		this._backbone_source = false;
		if (source.name != "DataStore"){
			if (source.data && source.data.name == "DataStore")
				source = source.data;
			else
				this._backbone_source = true;
		}

		
		var	sync_logic = dhx.bind(function(mode, record, data){
			if (this._backbone_source){
				//ignore first call for backbone sync
				if (!mode) return; 
				//data changing
				if (mode.indexOf("change") === 0){
					if (mode == "change"){
						this.pull[record.id] = record.attributes;
						this.refresh(record.id);
						return;
					} else return;	//ignoring property change event
				}

				//we need to access global model, it has different position for different events
				if (mode == "reset")
					data = record;
				//fill data collections from backbone model
				this.order = []; this.pull = {};
				this._filter_order = null;
				for (var i=0; i<data.models.length; i++){
					var id = data.models[i].id;
					this.order.push(id);
					this.pull[id] = data.models[i].attributes;
				}
			} else {
				this._filter_order = null;
				this.order = dhx.toArray([].concat(source.order));
				this.pull = source.pull;
			}
			
			
			if (filter)
				this.silent(filter);
			
			if (this._on_sync)
				this._on_sync();
			if (dhx.debug_bind)
				dhx.log("[sync:request] "+this.debug_sync_master.name+"@"+this.debug_sync_master._settings.id + " <= "+this.debug_bind_master.name+"@"+this.debug_bind_master._settings.id);
			this.callEvent("onSyncApply",[]);
			if (!silent) 
				this.refresh();
			else
				silent = false;
		}, this);

		if (this._backbone_source)
			source.bind('all', sync_logic);
		else
			this._sync_events = [
				source.attachEvent("onStoreUpdated", sync_logic),
				source.attachEvent("onIdChange", dhx.bind(function(old, nid){ this.changeId(old, nid); }, this))
			];

		sync_logic();
	},
	//adds item to the store
	add:function(obj,index){
		//default values		
		if (this._scheme)
			for (var key in this._scheme)
				if (dhx.isUndefined(obj[key]))
					obj[key] = this._scheme[key];
		
		if (this._scheme_init)
			this._scheme_init(obj);
		
		//generate id for the item
		var id = this.id(obj);

		//in case of treetable order is sent as 3rd parameter
		var order = arguments[2]||this.order;
		
		//by default item is added to the end of the list
		var data_size = order.length;
		
		if (dhx.isUndefined(index) || index < 0)
			index = data_size; 
		//check to prevent too big indexes			
		if (index > data_size){
			dhx.log("Warning","DataStore:add","Index of out of bounds");
			index = Math.min(order.length,index);
		}
		if (this.callEvent("onBeforeAdd", [id, obj, index]) === false) return false;

		dhx.assert(!this.exists(id), "Not unique ID");
		
		this.pull[id]=obj;
		order.insertAt(id,index);
		if (this._filter_order){	//adding during filtering
			//we can't know the location of new item in full dataset, making suggestion
			//put at end by default
			var original_index = this._filter_order.length;
			//put at start only if adding to the start and some data exists
			if (!index && this.order.length)
				original_index = 0;

			this._filter_order.insertAt(id,original_index);
		}
		this.callEvent("onAfterAdd",[id,index]);
		//repaint signal
		this.callEvent("onStoreUpdated",[id,obj,"add"]);
		return id;
	},
	
	//removes element from datastore
	remove:function(id){
		//id can be an array of IDs - result of getSelect, for example
		if (dhx.isArray(id)){
			for (var i=0; i < id.length; i++)
				this.remove(id[i]);
			return;
		}
		if (this.callEvent("onBeforeDelete",[id]) === false) return false;
		
		dhx.assert(this.exists(id), "Not existing ID in remove command"+id);

		var obj = this.item(id);	//save for later event
		//clear from collections
		this.order.remove(id);
		if (this._filter_order) 
			this._filter_order.remove(id);
			
		delete this.pull[id];
		if (this._marks[id])
			delete this._marks[id];

		this.callEvent("onAfterDelete",[id]);
		//repaint signal
		this.callEvent("onStoreUpdated",[id,obj,"delete"]);
	},
	//deletes all records in datastore
	clearAll:function(){
		//instead of deleting one by one - just reset inner collections
		this.pull = {};
		this.order = dhx.toArray();
		//this.feed = null;
		this._filter_order = this.url = null;
		this.callEvent("onClearAll",[]);
		this.refresh();
	},
	//converts id to index
	idByIndex:function(index){
		if (index>=this.order.length || index<0)
			dhx.log("Warning","DataStore::idByIndex Incorrect index");
			
		return this.order[index];
	},
	//converts index to id
	indexById:function(id){
		var res = this.order.find(id);	//slower than idByIndex
		
		if (!this.pull[id])
			dhx.log("Warning","DataStore::indexById Non-existing ID: "+ id);
			
		return res;
	},
	//returns ID of next element
	next:function(id,step){
		return this.order[this.indexById(id)+(step||1)];
	},
	//returns ID of first element
	first:function(){
		return this.order[0];
	},
	//returns ID of last element
	last:function(){
		return this.order[this.order.length-1];
	},
	//returns ID of previous element
	previous:function(id,step){
		return this.order[this.indexById(id)-(step||1)];
	},
	/*
		sort data in collection
			by - settings of sorting
		
		or
		
			by - sorting function
			dir - "asc" or "desc"
			
		or
		
			by - property
			dir - "asc" or "desc"
			as - type of sortings
		
		Sorting function will accept 2 parameters and must return 1,0,-1, based on desired order
	*/
	sort:function(by, dir, as){
		var sort = by;	
		if (typeof by == "function")
			sort = {as:by, dir:dir};
		else if (typeof by == "string")
			sort = {by:by.replace(/#/g,""), dir:dir, as:as};

		
		var parameters = [sort.by, sort.dir, sort.as];
		if (!this.callEvent("onBeforeSort",parameters)) return;	
		
		this._sort_core(sort);
		
		//repaint self
		this.refresh();
		
		this.callEvent("onAfterSort",parameters);
	},
	_sort_core:function(sort){
		if (this.order.length){
			var sorter = this._sort._create(sort);
			//get array of IDs
			var neworder = this.getRange(this.first(), this.last());
			neworder.sort(sorter);
			this.order = neworder.map(function(obj){ 
				dhx.assert(obj, "Client sorting can't be used with dynamic loading");
				return this.id(obj);
			},this);
		}
	},
	/*
		Filter datasource
		
		text - property, by which filter
		value - filter mask
		
		or
		
		text  - filter method
		
		Filter method will receive data object and must return true or false
	*/
	_filter_reset:function(preserve){
		//remove previous filtering , if any
		if (this._filter_order && !preserve){
			this.order = this._filter_order;
			delete this._filter_order;
		}
	},
	_filter_core:function(filter, value, preserve){
		var neworder = dhx.toArray();
		for (var i=0; i < this.order.length; i++){
			var id = this.order[i];
			if (filter(this.item(id),value))
				neworder.push(id);
		}
		//set new order of items, store original
		if (!preserve ||  !this._filter_order)
			this._filter_order = this.order;
		this.order = neworder;
	},
	filter:function(text,value,preserve){
		if (!this.callEvent("onBeforeFilter", [text, value])) return;
		
		this._filter_reset(preserve);
		if (!this.order.length) return;
		
		//if text not define -just unfilter previous state and exit
		if (text){
			var filter = text;
			value = value||"";
			if (typeof text == "string"){
				text = text.replace(/#/g,"");
				if (typeof value == "function")
					filter = function(obj){
						return value(obj[text]);
					};
				else{
					value = value.toString().toLowerCase();
					filter = function(obj,value){	//default filter - string start from, case in-sensitive
						dhx.assert(obj, "Client side filtering can't be used with dynamic loading");
						return (obj[text]||"").toString().toLowerCase().indexOf(value)!=-1;
					};
				}
			}
			
			this._filter_core(filter, value, preserve, this._filterMode);
		}
		//repaint self
		this.refresh();
		
		this.callEvent("onAfterFilter", []);
	},
	/*
		Iterate through collection
	*/
	each:function(method,master){
		for (var i=0; i<this.order.length; i++)
			method.call((master||this), this.item(this.order[i]));
	},
	_methodPush:function(object,method){
		return function(){ return object[method].apply(object,arguments); };
	},

	addMark:function(id, mark, css, value){
		var obj = this._marks[id]||{};
		this._marks[id] = obj;
		if (!obj[mark]){
			obj[mark] = value||true;	
			if (css){
				this.item(id).$css = (this.item(id).$css||"")+" "+mark;
				this.refresh(id);
			}
		}
		return obj[mark];
	},
	removeMark:function(id, mark, css){
		var obj = this._marks[id];
		if (obj && obj[mark])
			delete obj[mark];
		if (css){
			var current_css = this.item(id).$css;
			if (current_css){
				this.item(id).$css = current_css.replace(mark, "");
				this.refresh(id);
			}
		}
	},
	hasMark:function(id, mark){
		var obj = this._marks[id];
		return (obj && obj[mark]);
	},
	/*
		map inner methods to some distant object
	*/
	provideApi:function(target,eventable){
		this.debug_bind_master = target;
			
		if (eventable){
			this.mapEvent({
				onbeforesort:	target,
				onaftersort:	target,
				onbeforeadd:	target,
				onafteradd:		target,
				onbeforedelete:	target,
				onafterdelete:	target,
				onbeforeupdate: target/*,
				onafterfilter:	target,
				onbeforefilter:	target*/
			});
		}
			
		var list = ["sort","add","remove","exists","idByIndex","indexById","item","update","refresh","dataCount","filter","next","previous","clearAll","first","last","serialize","sync","addMark","removeMark","hasMark"];
		for (var i=0; i < list.length; i++)
			target[list[i]] = this._methodPush(this,list[i]);
			
	},
	/*
		serializes data to a json object
	*/
	serialize: function (rule) {
		var ids = this.order;
		var result = [];
		for(var i=0; i< ids.length;i++) {
			var el = this.pull[ids[i]];
			if (this._scheme_serialize){
				el = this._scheme_serialize(el);
				if (el===false) continue;
			}
			else if (rule) {
			    for (var key in rule) {
			        el[key] = el[rule[key]] + "";
			    }
			}
			result.push(el);
		}
		return result;
	},

	_sort:{
		_create:function(config){
			return this._dir(config.dir, this._by(config.by, config.as));
		},
		_as:{
			"date":function(a,b){
				a=a-0; b=b-0;
				return a>b?1:(a<b?-1:0);
			},
			"int":function(a,b){
				a = a*1; b=b*1;
				return a>b?1:(a<b?-1:0);
			},
			"string_strict":function(a,b){
				a = a.toString(); b=b.toString();
				return a>b?1:(a<b?-1:0);
			},
			"string":function(a,b){
				if (!b) return 1;
				if (!a) return -1;
				
				a = a.toString().toLowerCase(); b=b.toString().toLowerCase();
				return a>b?1:(a<b?-1:0);
			}
		},
		_by:function(prop, method){
			if (!prop)
				return method;
			if (typeof method != "function")
				method = this._as[method||"string"];

			dhx.assert(method, "Invalid sorting method");
			return function(a,b){
				return method(a[prop],b[prop]);
			};
		},
		_dir:function(prop, method){
			if (prop == "asc" || !prop)
				return method;
			return function(a,b){
				return method(a,b)*-1;
			};
		}
	}
};




//UI interface
dhx.BaseBind = {
	debug_freid_ignore:{
		"id":true
	},
	
	bind:function(target, rule, format){
		if (typeof target == 'string')
			target = dhx.ui.get(target);
			
		if (target._initBindSource) target._initBindSource();
		if (this._initBindSource) this._initBindSource();

		
			
		if (!target.getBindData)
			dhx.extend(target, dhx.BindSource);
		if (!this._bind_ready){
			var old_render = this.render;
			if (this.filter){
				var key = this._settings.id;
				this.data._on_sync = function(){
					target._bind_updated[key] = false;
				};
			}
			this.render = function(){
				if (this._in_bind_processing) return;
				
				this._in_bind_processing = true;
				var result = this.callEvent("onBindRequest");
				this._in_bind_processing = false;
				
				return old_render.apply(this, ((result === false)?arguments:[]));
			};
			if (this.getValue||this.getValues)
				this.save = function(){
					if (this.validate && !this.validate()) return;
					target.setBindData((this.getValue?this.getValue:this.getValues()),this._settings.id);
				};
			this._bind_ready = true;
		}
		target.addBind(this._settings.id, rule, format);
		
		if (dhx.debug_bind)
			dhx.log("[bind] "+this.name+"@"+this._settings.id+" <= "+target.name+"@"+target._settings.id);

		var target_id = this._settings.id;
		//FIXME - check for touchable is not the best solution, to detect necessary event
		this.attachEvent(this.touchable?"onAfterRender":"onBindRequest", function(){
			return target.getBindData(target_id);
		});
		//we want to refresh list after data loading if it has master link
		//in same time we do not want such operation for dataFeed components
		//as they are reloading data as response to the master link
		if (!this._settings.dataFeed && this.loadNext)
			this.data.attachEvent("onStoreLoad", function(){
				target._bind_updated[target_id] = false;
			});

		if (this.isVisible(this._settings.id))
			this.refresh();
	},
	unbind:function(target){
		return this._unbind(target);
	},
	_unbind:function(target){
		target.removeBind(this._settings.id);
		var events = (this._sync_events||(this.data?this.data._sync_events:0));
		if (events && target.data)
			for (var i=0; i<events.length; i++)
				target.data.detachEvent(events[i]);
	}
};

//bind interface
dhx.BindSource = {
	$init:function(){
		this._bind_hash = {};		//rules per target
		this._bind_updated = {};	//update flags
		this._ignore_binds = {};
		
		//apply specific bind extension
		this._bind_specific_rules(this);
	},
	saveBatch:function(code){
		this._do_not_update_binds = true;
		code.call(this);
		this._do_not_update_binds = false;
		this._update_binds();
	},
	setBindData:function(data, key){
		if (key)
			this._ignore_binds[key] = true;

		if (dhx.debug_bind)
				dhx.log("[bind:save] "+this.name+"@"+this._settings.id+" <= "+"@"+key);
		if (this.setValue)
			this.setValue(data);
		else if (this.setValues)
			this.setValues(data);
		else {
			var id = this.getCursor();
			if (id){
				data = dhx.extend(this.item(id), data, true);
				this.update(id, data);
			}
		}
		this.callEvent("onBindUpdate", [data, key, id]);
		if (this.save)
			this.save();
		
		if (key)
			this._ignore_binds[key] = false;
	},
	//fill target with data
	getBindData:function(key, update){
		//fire only if we have data updates from the last time
		if (this._bind_updated[key]) return false;
		var target = dhx.ui.get(key);
		//fill target only when it visible
		if (target.isVisible(target._settings.id)){
			this._bind_updated[key] = true;
			if (dhx.debug_bind)
				dhx.log("[bind:request] "+this.name+"@"+this._settings.id+" => "+target.name+"@"+target._settings.id);
			this._bind_update(target, this._bind_hash[key][0], this._bind_hash[key][1]); //trigger component specific updating logic
			if (update && target.filter)
				target.refresh();
		}
	},
	//add one more bind target
	addBind:function(source, rule, format){
		this._bind_hash[source] = [rule, format];
	},
	removeBind:function(source){
		delete this._bind_hash[source];
		delete this._bind_updated[source];
		delete this._ignore_binds[source];
	},
	//returns true if object belong to "collection" type
	_bind_specific_rules:function(obj){
		if (obj.filter)
			dhx.extend(this, dhx.CollectionBind);
		else if (obj.setValue)
			dhx.extend(this, dhx.ValueBind);
		else
			dhx.extend(this, dhx.RecordBind);
	},
	//inform all binded objects, that source data was updated
	_update_binds:function(){
		if (!this._do_not_update_binds)
			for (var key in this._bind_hash){
				if (this._ignore_binds[key]) continue;
				this._bind_updated[key] = false;
				this.getBindData(key, true);
			}
	},
	//copy data from source to the target
	_bind_update_common:function(target, rule, data){
		if (target.setValue)
			target.setValue(data?data[rule]:data);
		else if (!target.filter){
			if (!data && target.clear)
				target.clear();
			else {
				if (target._check_data_feed(data))
					target.setValues(dhx.clone(data));
			}
		} else {
			target.data.silent(function(){
				this.filter(rule,data);
			});
		}
		target.callEvent("onBindApply", [data,rule,this]);
	}
};


//pure data objects
dhx.DataValue = dhx.proto({
	name:"DataValue",
	isVisible:function(){ return true; },
	$init:function(config){ 
		this.data = ""||config; 
		var id = (config&&config.id)?config.id:dhx.uid();
		this._settings = { id:id };
		dhx.ui.views[id] = this;
	},
	setValue:function(value){
		this.data = value;
		this.callEvent("onChange", [value]);
	},
	getValue:function(){
		return this.data;
	},
	refresh:function(){ this.callEvent("onBindRequest"); }
}, dhx.EventSystem, dhx.BaseBind);

dhx.DataRecord = dhx.proto({
	name:"DataRecord",
	isVisible:function(){ return true; },
	$init:function(config){
		this.data = config||{}; 
		var id = (config&&config.id)?config.id:dhx.uid();
		this._settings = { id:id };
		dhx.ui.views[id] = this;
	},
	getValues:function(){
		return this.data;
	},
	setValues:function(data){
		this.data = data;
		this.callEvent("onChange", [data]);
	},
	refresh:function(){ this.callEvent("onBindRequest"); }
}, dhx.EventSystem, dhx.BaseBind, dhx.AtomDataLoader, dhx.Settings);


dhx.DataCollection = dhx.proto({
	name:"DataCollection",
	isVisible:function(){ 
		if (!this.data.order.length && !this.data._filter_order && !this._settings.dataFeed) return false;
		return true; 
	},
	$init:function(config){
		this.data.provideApi(this, true);
		var id = (config&&config.id)?config.id:dhx.uid();
		this._settings.id =id;
		dhx.ui.views[id] = this;
		this.data.attachEvent("onStoreLoad", dhx.bind(function(){
			this.callEvent("onBindRequest",[]);
		}, this));
	},
	refresh:function(){ this.callEvent("onBindRequest",[]); }
}, dhx.DataLoader, dhx.EventSystem, dhx.BaseBind, dhx.Settings);




dhx.ValueBind={
	$init:function(){
		this.attachEvent("onChange", this._update_binds);
	},
	_bind_update:function(target, rule, format){
		var data = this.getValue()||"";
		if (format) data = format(data);
		
		if (target.setValue)
			target.setValue(data);
		else if (!target.filter){
			var pod = {}; pod[rule] = data;
			if (target._check_data_feed(data))
				target.setValues(pod);
		} else{
			target.data.silent(function(){
				this.filter(rule,data);
			});
		}
		target.callEvent("onBindApply", [data,rule,this]);
	}
};

dhx.RecordBind={
	$init:function(){
		this.attachEvent("onChange", this._update_binds);		
	},
	_bind_update:function(target, rule){
		var data = this.getValues()||null;
		this._bind_update_common(target, rule, data);
	}
};

dhx.CollectionBind={
	$init:function(){
		this._cursor = null;
		this.attachEvent("onSelectChange", function(data){
			var sel = this.getSelected();
			this.setCursor(sel?(sel.id||sel):null);
		});
		this.attachEvent("onAfterCursorChange", this._update_binds);		
		this.data.attachEvent("onStoreUpdated", dhx.bind(function(id, data, mode){
			if (id && id == this.getCursor() && mode != "paint")
				this._update_binds();
		},this));
		this.data.attachEvent("onClearAll", dhx.bind(function(){
			this._cursor = null;
		},this));
		this.data.attachEvent("onIdChange", dhx.bind(function(oldid, newid){
			if (this._cursor == oldid)
				this._cursor = newid;
		},this));
	},
	setCursor:function(id){
		if (id == this._cursor || (id !== null && !this.item(id))) return;
		
		this.callEvent("onBeforeCursorChange", [this._cursor]);
		this._cursor = id;
		this.callEvent("onAfterCursorChange",[id]);
	},
	getCursor:function(){
		return this._cursor;
	},
	_bind_update:function(target, rule){ 
		var data = this.item(this.getCursor())|| this._settings.defaultData || null;
		this._bind_update_common(target, rule, data);
	}
};	
/*DHX:Depend core/legacy_bind.js*/
/*DHX:Depend core/dhx.js*/
/*DHX:Depend core/bind.js*/

/*jsl:ignore*/

if (!dhx.ui)
	dhx.ui = {};

if (!dhx.ui.views){
	dhx.ui.views = {};
	dhx.ui.get = function(id){
		if (id._settings) return id;
		return dhx.ui.views[id];
	};
}

if (window.dhtmlx)
	dhtmlx.BaseBind = dhx.BaseBind;

dhtmlXDataStore = function(config){
	var obj = new dhx.DataCollection(config);
	var name = "_dp_init";
	obj[name]=function(dp){
		//map methods
		var varname = "_methods";
		dp[varname]=["dummy","dummy","changeId","dummy"];
		
		this.data._old_names = {
			"add":"inserted",
			"update":"updated",
			"delete":"deleted"
		};
		this.data.attachEvent("onStoreUpdated",function(id,data,mode){
			if (id && !dp._silent)
				dp.setUpdated(id,true,this._old_names[mode]);
		});
		
		
		varname = "_getRowData";
		//serialize item's data in URL
		dp[varname]=function(id,pref){
			var ev=this.obj.data.item(id);
			var data = { id:id };
			data[this.action_param] = this.obj.getUserData(id);
			if (ev)
				for (var a in ev){
						data[a]=ev[a];
				}
			
			return data;
		};

		this.changeId = function(oldid, newid){ 
			this.data.changeId(oldid, newid);	
			dp._silent = true;
			this.data.callEvent("onStoreUpdated", [newid, this.item(newid), "update"]);
			dp._silent = false;
		};	

		varname = "_clearUpdateFlag";
		dp[varname]=function(){};
		this._userdata = {};

	};
	obj.dummy = function(){};
	obj.setUserData=function(id,name,value){
		this._userdata[id]=value;
	};
	obj.getUserData=function(id,name){
		return this._userdata[id];
	};
	obj.dataFeed=function(obj){
		this.define("dataFeed", obj);
	};
	dhx.extend(obj, dhx.BindSource);
	return obj;
};

if (window.dhtmlXDataView)
	dhtmlXDataView.prototype._initBindSource=function(){
		this.isVisible = function(){
			if (!this.data.order.length && !this.data._filter_order && !this._settings.dataFeed) return false;
			return true;
		};
		var settings = "_settings";
		this._settings = this._settings || this[settings];
		if (!this._settings.id)
			this._settings.id = dhx.uid();
		this.unbind = dhx.BaseBind.unbind;
		this.unsync = dhx.BaseBind.unsync;
		dhx.ui.views[this._settings.id] = this;
	};

if (window.dhtmlXChart)
	dhtmlXChart.prototype._initBindSource=function(){
		this.isVisible = function(){
			if (!this.data.order.length && !this.data._filtered_state && !this._settings.dataFeed) return false;
			return true;
		};
		var settings = "_settings";
		this._settings = this._settings || this[settings];
		if (!this._settings.id)
			this._settings.id = dhx.uid();
		this.unbind = dhx.BaseBind.unbind;
		this.unsync = dhx.BaseBind.unsync;
		dhx.ui.views[this._settings.id] = this;
	};
	

dhx.BaseBind.unsync = function(target){
	return dhx.BaseBind._unbind.call(this, target);
}
dhx.BaseBind.unbind = function(target){
	return dhx.BaseBind._unbind.call(this, target);
}
dhx.BaseBind.legacyBind = function(){
	return dhx.BaseBind.bind.apply(this, arguments);
};
dhx.BaseBind.legacySync = function(source, rule){
	if (this._initBindSource) this._initBindSource();
	if (source._initBindSource) source._initBindSource();

	this.attachEvent("onAfterEditStop", function(id){
		this.save(id);
		return true;
	});

		
		

	this.attachEvent("onDataRequest", function(start, count){
		for (var i=start; i<start+count; i++)
			if (!source.data.order[i]){
				source.loadNext(count, start);
				return false;
			}
	});



	this.save = function(id){
		if (!id) id = this.getCursor();
		var sobj = this.item(id);
		var tobj = source.item(id);
		for (var key in sobj)
			if (key.indexOf("$")!==0)
				tobj[key] = sobj[key];
		source.refresh(id);
	};

	if (source && source.name == "DataCollection")
		return source.data.sync.apply(this.data, arguments);
	else
		return this.data.sync.apply(this.data, arguments);
};

if (window.dhtmlXForm){
	
	dhtmlXForm.prototype.bind = function(target){
		dhx.BaseBind.bind.apply(this, arguments);
		target.getBindData(this._settings.id);
	};
	dhtmlXForm.prototype.unbind = function(target){
		dhx.BaseBind._unbind.call(this,target);
	};

	dhtmlXForm.prototype._initBindSource = function(){
		if (dhx.isUndefined(this._settings)){
			this._settings = {
				id: dhx.uid(),
				dataFeed:this._server_feed
			};
			dhx.ui.views[this._settings.id] = this;
		}
	};
	dhtmlXForm.prototype._check_data_feed = function(data){
		if (!this._settings.dataFeed || this._ignore_feed || !data) return true;
		var url = this._settings.dataFeed;
		if (typeof url == "function")
			return url.call(this, (data.id||data), data);
		url = url+(url.indexOf("?")==-1?"?":"&")+"action=get&id="+encodeURIComponent(data.id||data);
		this.load(url);
		return false;
	};
	dhtmlXForm.prototype.setValues = dhtmlXForm.prototype.setFormData;
	dhtmlXForm.prototype.getValues = function(){
		return this.getFormData(false, true);
	};

	dhtmlXForm.prototype.dataFeed = function(value){
		if (this._settings)
			this._settings.dataFeed = value;
		else
			this._server_feed = value;
	};

	dhtmlXForm.prototype.refresh = dhtmlXForm.prototype.isVisible = function(value){
		return true;
	};
}
 
if (window.scheduler){
	if (!window.Scheduler)
		window.Scheduler = {};
	Scheduler.$syncFactory=function(scheduler){
		scheduler.sync = function(source, rule){
			if (this._initBindSource) this._initBindSource();
			if (source._initBindSource) source._initBindSource();

			var process = "_process_loading";
			var insync = function(ignore){
					scheduler.clearAll();
					var order = source.data.order;
					var pull = source.data.pull;
					var evs = [];
					for (var i=0; i<order.length; i++){
						if (rule && rule.copy)
							evs[i]=dhx.clone(pull[order[i]]);
						else
							evs[i]=pull[order[i]];
					}
					scheduler[process](evs);
					scheduler.callEvent("onSyncApply",[]);
			};
			this.save = function(id){
				if (!id) id = this.getCursor();
				var data = this.item(id);
				var olddat = source.item(id);

				if (this.callEvent("onStoreSave", [id, data, olddat])){
					dhx.extend(source.item(id),data, true);
					source.update(id);
				}
			};
			this.item = function(id){
				return this.getEvent(id);
			};
			this._sync_events=[
				source.data.attachEvent("onStoreUpdated", function(id, data, mode){ 
					insync.call(this);
				}),
				source.data.attachEvent("onIdChange", function(oldid, newid){
					scheduler.changeEventId(oldid, newid);
				})
			];
			this.attachEvent("onEventChanged", function(id){
				this.save(id);
			});
			this.attachEvent("onEventAdded", function(id, data){
				if (!source.data.pull[id])
				source.add(data);
			});
			this.attachEvent("onEventDeleted", function(id){
				if (source.data.pull[id])
					source.remove(id);
			});
			insync();
		};
		scheduler.unsync = function(target){
			dhx.BaseBind._unbind.call(this,target);
		}
		scheduler._initBindSource = function(){
			if (!this._settings)
				this._settings = { id:dhx.uid() };
		}
	}
	Scheduler.$syncFactory(window.scheduler);
}
if (window.dhtmlXCombo){
	dhtmlXCombo.prototype.bind = function(){
		dhx.BaseBind.bind.apply(this, arguments);
	};
	dhtmlXCombo.prototype.unbind = function(target){
		dhx.BaseBind._unbind.call(this,target);
	}
	dhtmlXCombo.prototype.unsync = function(target){
		dhx.BaseBind._unbind.call(this,target);
	}

	dhtmlXCombo.prototype.dataFeed = function(value){
		if (this._settings)
			this._settings.dataFeed = value;
		else
			this._server_feed = value;
	};

	dhtmlXCombo.prototype.filterByDataStore = function (functor, value) {
	    var data = this.datastore.serialize(this.rule).filter(function (item) {
	        if (functor(item, value)) return true;
	        return false;
	    });
	    this.clearAll(false);
	    this.addOption(data);
	}

	dhtmlXCombo.prototype.sync = function(source, rule){
		if (this._initBindSource) this._initBindSource();
		if (source._initBindSource) source._initBindSource();


		var combo = this;
		combo.rule = rule;
		combo.datastore = source;

		var insync = function(ignore){
		    combo.clearAll(combo._ishideList);
			combo.addOption(this.serialize(rule));

			combo.callEvent("onSyncApply",[]);
		};

		//source.data.attachEvent("onStoreLoad", insync);
		this._sync_events=[
			source.data.attachEvent("onStoreUpdated", function(id, data, mode){ 
				insync.call(this);
			}),
			source.data.attachEvent("onIdChange", function(oldid, newid){
				combo.changeOptionId(oldid, newid);
			})
		];


		insync.call(source);
	};

	dhtmlXCombo.prototype._initBindSource = function() { 
		if (dhx.isUndefined(this._settings)){
			this._settings = {
				id: dhx.uid(),
				dataFeed:this._server_feed
			};
			dhx.ui.views[this._settings.id] = this;

			this.data = { silent:dhx.bind(function(code){
				code.call(this);
			},this)};

			dhx4._eventable(this.data);

			this.attachEvent("onChange", function() {
				this.callEvent("onSelectChange", [this.getSelectedValue()]);
			});
			this.attachEvent("onXLE", function(){
				this.callEvent("onBindRequest",[]);
			});
		}
	};

	dhtmlXCombo.prototype.item = function(id) {
		return this.getOption(id);
	};

	dhtmlXCombo.prototype.getSelected = function() {
		return this.getSelectedValue();
	};
	dhtmlXCombo.prototype.isVisible = function() {
		if (!this.optionsArr.length && !this._settings.dataFeed) return false;
		return true;
	};
	dhtmlXCombo.prototype.refresh = function() {
		this.render(true);
	};
}

if (window.dhtmlXGridObject){
	dhtmlXGridObject.prototype.bind = function(source, rule, format) {
		dhx.BaseBind.bind.apply(this, arguments);
	};
	dhtmlXGridObject.prototype.unbind = function(target){
		dhx.BaseBind._unbind.call(this,target);
	}
	dhtmlXGridObject.prototype.unsync = function(target){
		dhx.BaseBind._unbind.call(this,target);
	}
	
	dhtmlXGridObject.prototype.dataFeed = function(value){
		if (this._settings)
			this._settings.dataFeed = value;
		else
			this._server_feed = value;
	};

	dhtmlXGridObject.prototype.filterByDataStore = function (functor, value) {
	    var data = this.datastore.serialize().filter(function (item) {
	        if (functor(item, value)) return true;
	        return false;
	    });
	    this.clearAll();

	    var parsing = "_parsing";
	    var parser = "_parser";
	    var locator = "_locator";
	    var parser_func = "_process_store_row";
	    var locator_func = "_get_store_data";
	    var count = data.length;
	    if (count) {
	        this[parsing] = true;
	        var repeat_map = {};
	        for (var i = 0; i < count; i++) {
	            var idd = (this.rule && this.rule.value && data[i][this.rule.value]);
	            if (!isNaN(repeat_map[idd])) {
	                repeat_map[idd]++;
	                idd = idd + "__" + repeat_map[idd] + "__";
	            }
	            else {
	                repeat_map[idd] = 1;
	            }
	            this.rowsBuffer[i] = {
	                idd: idd,
	                data: data[i]
	            };
	            this.rowsBuffer[i][parser] = this[parser_func];
	            this.rowsBuffer[i][locator] = this[locator_func];
	            this.rowsAr[idd] = data[i];
	        }
	        this.render_dataset();
	        this[parsing] = false;
	    }
	}

	dhtmlXGridObject.prototype.sync = function(source, rule){
		if (this._initBindSource) this._initBindSource();
		if (source._initBindSource) source._initBindSource();

		var grid = this;
		var parsing = "_parsing";
		var parser = "_parser";
		var locator = "_locator";
		var parser_func = "_process_store_row";
		var locator_func = "_get_store_data";
		this.datastore = source;
		this.rule = rule;
		this.save = function(id){
			if(typeof(id)=='object')
				return
			if (!id) id = this.getCursor();
			dhx.extend(source.item(id),this.item(id), true);
			source.update(id);
		};
		var insync = function(ignore){
			var cursor = grid.getCursor?grid.getCursor():null;

			var from = 0; 
			if (grid._legacy_ignore_next){
				from  = grid._legacy_ignore_next;
				grid._legacy_ignore_next = false;
			} else {
				grid.clearAll();
			}

			var count = this.dataCount();
			if (count){
			    grid[parsing] = true;
			    var repeat_map = {};
				for (var i = from; i < count; i++){
				    var id = this.order[i];
				    var idd = (rule && rule.value && this.pull[id][rule.value]) || id;
				    if (!isNaN(repeat_map[idd])) {
				        repeat_map[idd]++;
				        idd = idd + "__" + repeat_map[idd] + "__";
				    }
				    else {
				        repeat_map[idd] = 1;
				    }
					if (!id) continue;
					if (from && grid.rowsBuffer[i]) continue;
					grid.rowsBuffer[i]={
					    idd: idd,
						data: this.pull[id]
					};
					grid.rowsBuffer[i][parser] = grid[parser_func];
					grid.rowsBuffer[i][locator] = grid[locator_func];
					grid.rowsAr[idd] = this.pull[id];
				}
				if (!grid.rowsBuffer[count-1]){
					grid.rowsBuffer[count-1] = dhtmlx.undefined;
					grid.xmlFileUrl = grid.xmlFileUrl||this.url;
				}

				if (grid.pagingOn)
					grid.changePage();
				else {
					if (grid._srnd && grid._fillers)
						grid._update_srnd_view();
					else{
						grid.render_dataset();
						grid.callEvent("onXLE",[]);
					}
				}
				grid[parsing]=false;
			}

			if (cursor && grid.setCursor)
				grid.setCursor(grid.rowsAr[cursor]?cursor:null);

			grid.callEvent("onSyncApply",[]);
		};

		//source.data.attachEvent("onStoreLoad", insync);
		this._sync_events=[
			source.data.attachEvent("onStoreUpdated", function(id, data, mode){ 
				if (mode == "delete"){
					grid.deleteRow(id);
					grid.data.callEvent("onStoreUpdated",[id, data, mode]);
				} else if (mode == "update"){
					grid.callEvent("onSyncUpdate", [data, mode]);
					grid.update(id, data);
					grid.data.callEvent("onStoreUpdated",[id, data, mode]);
				} else if (mode == "add"){
					grid.callEvent("onSyncUpdate", [data, mode]);
					grid.add(id, data, this.indexById(id));
					grid.data.callEvent("onStoreUpdated",[id,data,mode]);
				} else insync.call(this);

			}),
			source.data.attachEvent("onStoreLoad", function(driver, data){
				grid.xmlFileUrl = source.data.url;
				grid._legacy_ignore_next = driver.getInfo(data)._from;
			}),
			source.data.attachEvent("onIdChange", function(oldid, newid){
				grid.changeRowId(oldid, newid);
			})
		];
		
		grid.attachEvent("onDynXLS", function(start, count){
			for (var i=start; i<start+count; i++)
				if (!source.data.order[i]){
					source.loadNext(count, start);
					return false;
				}
			grid._legacy_ignore_next = start;
			insync.call(source.data);
		});

		insync.call(source.data);
		grid.attachEvent("onEditCell", function(stage, id, ind, value, oldvalue){
			if (stage==2 && value != oldvalue)
				this.save(id);
			return true;
		});
		grid.attachEvent("onClearAll",function(){
			var name = "_f_rowsBuffer";
	    	this[name]=null; 
	    });
	
		if (rule && rule.sort)	
			grid.attachEvent("onBeforeSorting", function(ind, type, dir){
				if (type == "connector") return false;
				var id = this.getColumnId(ind);
				source.sort("#"+id+"#", (dir=="asc"?"asc":"desc"), (type=="int"?type:"string"));
				grid.setSortImgState(true, ind, dir);
				return false;
			});

		if (rule && rule.filter){
			grid.attachEvent("onFilterStart", function(cols, values){
				var name = "_con_f_used";
				if (grid[name] && grid[name].length)
					return false;

				source.data.silent(function(){
					source.filter();
					for (var i=0; i<cols.length; i++){
						if (values[i] == "") continue;
						var id = grid.getColumnId(cols[i]);
						source.filter("#"+id+"#", values[i], i!=0);
					}
				});

				source.refresh();
				return false;
			});
			grid.collectValues = function(index){
				var id = this.getColumnId(index);
				return (function(id){
					var values = [];
					var checks = {};
					this.data.each(function(obj){
						var value = obj[id];
						if (!checks[value]){
							checks[value] = true;
							values.push(value);
						}
					});
					values.sort();
					return values;
				}).call(source, id);
			};
		}

		if (rule && rule.select)
			grid.attachEvent("onRowSelect", function(id){
				source.setCursor(id);
			});

		grid.clearAndLoad = function(url){
			source.clearAll();
			source.load(url);
		};
		

				    
	};

	dhtmlXGridObject.prototype._initBindSource = function() { 
		if (dhx.isUndefined(this._settings)){
			this._settings = {
				id: dhx.uid(),
				dataFeed:this._server_feed
			};
			dhx.ui.views[this._settings.id] = this;

			this.data = { silent:dhx.bind(function(code){
				code.call(this);
			},this)};

			dhx4._eventable(this.data);
			var name = "_cCount";
			for (var i=0; i<this[name]; i++)
				if (!this.columnIds[i])
					this.columnIds[i] = "cell"+i;

			this.attachEvent("onSelectStateChanged", function(id) {
				this.callEvent("onSelectChange", [id]);
			});
			this.attachEvent("onSelectionCleared", function() {
				this.callEvent("onSelectChange", [null]);
			});
			this.attachEvent("onEditCell", function(stage,rId) {
				if (stage === 2 && this.getCursor) {
					if (rId && rId == this.getCursor())
						this._update_binds();
				}
				return true;
			});
			this.attachEvent("onXLE", function(){
				this.callEvent("onBindRequest",[]);
			});
		}
	};

	dhtmlXGridObject.prototype.item = function(id) {
		if (id === null) return null;
		var source = this.getRowById(id);
		if (!source) return null;
		
		var name = "_attrs";
		var data = dhx.copy(source[name]);
			data.id = id;
		var length = this.getColumnsNum();
		for (var i = 0; i < length; i++) {
			data[this.columnIds[i]] = this.cells(id, i).getValue();
		}
		return data;
	};

	dhtmlXGridObject.prototype.update = function(id,data){
		for (var i=0; i<this.columnIds.length; i++){
			var key = this.columnIds[i];
			if (!dhx.isUndefined(data[key]))
				this.cells(id, i).setValue(data[key]);
		}
		var name = "_attrs";
		var attrs = this.getRowById(id)[name];
		for (var key in data)
			attrs[key] = data[key];
		this.callEvent("onBindUpdate",[data, null, id]);
	};

	dhtmlXGridObject.prototype.add = function(id,data,index){
		var ar_data = [];
		for (var i=0; i<this.columnIds.length; i++){
			var key = this.columnIds[i];
			ar_data[i] = dhx.isUndefined(data[key])?"":data[key];
		}
		this.addRow(id, ar_data, index);
		var name = "_attrs";
		this.getRowById(id)[name] = dhx.copy(data);
	};

	dhtmlXGridObject.prototype.getSelected = function() {
		return this.getSelectedRowId();
	};
	dhtmlXGridObject.prototype.isVisible = function() {
		var name = "_f_rowsBuffer";
		if (!this.rowsBuffer.length && !this[name] && !this._settings.dataFeed) return false;
		return true;
	};
	dhtmlXGridObject.prototype.refresh = function() {
		this.render_dataset();
	};

	dhtmlXGridObject.prototype.filter = function(callback, master){
		//if (!this.rowsBuffer.length && !this._f_rowsBuffer) return;
		if (this._settings.dataFeed){
			var filter = {};
			if (!callback && !master) return;
			if (typeof callback == "function"){
				if (!master) return;
				callback(master, filter);
			} else  if (dhx.isUndefined(callback))
				filter = master;
			else
				filter[callback] = master;

			this.clearAll(); 
			var url = this._settings.dataFeed;
			if (typeof url == "function")
				return url.call(this, master, filter);

			var urldata = [];
			for (var key in filter)
				urldata.push("dhx_filter["+key+"]="+encodeURIComponent(filter[key]));

			this.load(url+(url.indexOf("?")<0?"?":"&")+urldata.join("&"));
			return false;
		}

		if (master === null) {
			return this.filterBy(0, function(){ return false; });
		}

		this.filterBy(0, function(value, id){
			return callback.call(this, id, master);
		});
	};
}


if (window.dhtmlXTreeObject){
	dhtmlXTreeObject.prototype.bind = function() {
		dhx.BaseBind.bind.apply(this, arguments);
	};
	dhtmlXTreeObject.prototype.unbind = function(target){
		dhx.BaseBind._unbind.call(this,target);
	}

	

	dhtmlXTreeObject.prototype.dataFeed = function(value){
		if (this._settings)
			this._settings.dataFeed = value;
		else
			this._server_feed = value;
	};

	dhtmlXTreeObject.prototype._initBindSource = function() {
		if (dhx.isUndefined(this._settings)){
			this._settings = {
				id: dhx.uid(),
				dataFeed:this._server_feed
			};
			dhx.ui.views[this._settings.id] = this;

			this.data = { silent:dhx.bind(function(code){
				code.call(this);
			},this)};

			dhx4._eventable(this.data);

			this.attachEvent("onSelect", function(id) {
				this.callEvent("onSelectChange", [id]);
			});
			this.attachEvent("onEdit", function(stage,rId) {
				if (stage === 2) {
					if (rId && rId == this.getCursor())
						this._update_binds();
				}
				return true;
			});
		}
	};

	dhtmlXTreeObject.prototype.item = function(id) {
		if (id === null) return null;
		return { id: id, text:this.getItemText(id)};
	};

	dhtmlXTreeObject.prototype.getSelected = function() {
		return this.getSelectedItemId();
	};
	dhtmlXTreeObject.prototype.isVisible = function() {
		return true;
	};
	dhtmlXTreeObject.prototype.refresh = function() {
		//dummy placeholder
	};

	dhtmlXTreeObject.prototype.filter = function(callback, master){
		//dummy placeholder, because tree doesn't support filtering
		if (this._settings.dataFeed){
			var filter = {};
			if (!callback && !master) return;
			if (typeof callback == "function"){
				if (!master) return;
				callback(master, filter);
			} else  if (dhx.isUndefined(callback))
				filter = master;
			else
				filter[callback] = master;

			this.deleteChildItems(0); 
			var url = this._settings.dataFeed;
			if (typeof url == "function")
				return url.call(this, [(data.id||data), data]);
			var urldata = [];
			for (var key in filter)
				urldata.push("dhx_filter["+key+"]="+encodeURIComponent(filter[key]));

			this.loadXML(url+(url.indexOf("?")<0?"?":"&")+urldata.join("&"));
			return false;
		}
	};

	dhtmlXTreeObject.prototype.update = function(id,data){
		if (!dhx.isUndefined(data.text))
			this.setItemText(id, data.text);
	};
}

if (window.dhtmlXMenuObject){
	dhtmlXMenuObject.prototype.bind = function(){
		dhx.BaseBind.bind.apply(this, arguments);
	};
	dhtmlXMenuObject.prototype.unbind = function(target){
		dhx.BaseBind._unbind.call(this,target);
	}
	dhtmlXMenuObject.prototype.unsync = function(target){
		dhx.BaseBind._unbind.call(this,target);
	}

	dhtmlXMenuObject.prototype.dataFeed = function(value){
		if (this._settings)
			this._settings.dataFeed = value;
		else
			this._server_feed = value;
	};

    /*
	 serializes data to a tree json object
	 */
	dhtmlXMenuObject.prototype.serializeTreeData = function (data) {
	    var rule = this.rule;
        var result = [], hash = {};
        for (var i = 0; i < data.length; i++) {
            var el = data[i];
            var itemid = el[rule['id'] || 'id'];
            hash[itemid] = {};//dhx.copy(el);
            for (var key in rule) {
                hash[itemid][key] = el[rule[key]] + ""
            }
        }
        for (var i = 0; i < data.length; i++) {
            var el = data[i];
            var itemid = el[rule['id'] || 'id'];
            var aVal = hash[itemid], hashVP = hash[aVal.pid];
            if (hashVP) {
                !hashVP["items"] && (hashVP["items"] = []);
                hashVP["items"].push(aVal);
                continue;
            }
            result.push(aVal);
        }
        return result;
	},

    dhtmlXMenuObject.prototype.filter = function (functor, value) {
        var data = this.datastore.serialize().filter(function (item) {
            if (functor(item, value)) return true;
            return false;
        });
        this.clearAll();
        this.loadStruct(this.serializeTreeData(data));
    }

	dhtmlXMenuObject.prototype.sync = function(source, rule){
		if (this._initBindSource) this._initBindSource();
		if (source._initBindSource) source._initBindSource();

		var menu = this;
		menu.rule = rule;
		menu.datastore = source;

		var insync = function(ignore){
			menu.clearAll();
			menu.loadStruct(menu.serializeTreeData(this.serialize()));

			menu.callEvent("onSyncApply",[]);
		};

		//source.data.attachEvent("onStoreLoad", insync);
		this._sync_events=[
			source.data.attachEvent("onStoreUpdated", function(id, data, mode){
				insync.call(this);
			}),
			source.data.attachEvent("onIdChange", function(oldid, newid){
				combo.changeOptionId(oldid, newid);
			})
		];


		insync.call(source);
	};

	dhtmlXMenuObject.prototype._initBindSource = function() {
		if (dhx.isUndefined(this._settings)){
			this._settings = {
				id: dhx.uid(),
				dataFeed:this._server_feed
			};
			dhx.ui.views[this._settings.id] = this;

			this.data = { silent:dhx.bind(function(code){
				code.call(this);
			},this)};

			dhx4._eventable(this.data);

			this.attachEvent("onChange", function() {
				this.callEvent("onSelectChange", [this.getSelectedValue()]);
			});
			this.attachEvent("onXLE", function(){
				this.callEvent("onBindRequest",[]);
			});
		}
	};

	dhtmlXMenuObject.prototype.item = function(id) {
		if (id === null) return null;
		return { id: id, text: this.getItemText(id) };
	};

	dhtmlXMenuObject.prototype.isVisible = function() {
		if (!this.optionsArr.length && !this._settings.dataFeed) return false;
		return true;
	};
}

if (window.dhtmlXTreeView) {
    dhtmlXTreeView.prototype.bind = function () {
        dhx.BaseBind.bind.apply(this, arguments);
    };
    dhtmlXTreeView.prototype.unbind = function (target) {
        dhx.BaseBind._unbind.call(this, target);
    };

    /*
 serializes data to a tree json object
 */
    dhtmlXTreeView.prototype.serializeTreeData = function (data) {
        var ids = data;
        var result = [];
        var idStr = this.rule.id
        var textStr = this.rule.text
        var pidStr = this.rule.pId
        hash = {}, id = idStr, text = textStr, pid = pidStr, i = 0, j = 0, len = ids.length;
        for (; i < len; i++) {
            // hash[a[i][id]] = a[i];
            ids[i] = {
                id: ids[i][id],
                text: ids[i][text] + "",
                pid: ids[i][pid],
                data: ids[i]
            }
            hash[ids[i]["id"]] = ids[i];
        }
        for (; j < len; j++) {
            var aVal = ids[j],
                hashVP = hash[aVal.pid];
            if (hashVP) {
                !hashVP["items"] && (hashVP["items"] = []);
                hashVP["items"].push(aVal);

            } else {
                result.push(aVal);

            }
        }
        return result;


    };
    dhtmlXTreeView.prototype.dataFeed = function (value) {
        if (this._settings)
            this._settings.dataFeed = value;
        else
            this._server_feed = value;
    };

    dhtmlXTreeView.prototype._initBindSource = function () {
        if (dhx.isUndefined(this._settings)) {
            this._settings = {
                id: dhx.uid(),
                dataFeed: this._server_feed
            };
            dhx.ui.views[this._settings.id] = this;

            this.data = {
                silent: dhx.bind(function (code) {
                    code.call(this);
                }, this)
            };

            dhx4._eventable(this.data);

            this.attachEvent("onSelect", function (id) {
                this.callEvent("onSelectChange", [id]);
            });
            this.attachEvent("onEdit", function (stage, rId) {
                if (stage === 2) {
                    if (rId && rId == this.getCursor())
                        this._update_binds();
                }
                return true;
            });
        }
    };

    dhtmlXTreeView.prototype.filterByDataStore = function (functor, value) {
        var data = this.datastore.serialize(this.rule).filter(function (item) {
            if (functor(item, value)) return true;
            return false;
        });
        this.clearAllNodes();
        this.loadStruct(this.serializeTreeData(data));
    }

    dhtmlXTreeView.prototype.sync = function (source, rule) {
        if (this._initBindSource) this._initBindSource();
        if (source._initBindSource) source._initBindSource();

        var tree = this;
        tree.rule = rule;
        tree.datastore = source;

        var insync = function (ignore) {
            tree.clearAllNodes();
            tree.loadStruct(tree.serializeTreeData(this.serialize()));

            tree.callEvent("onSyncApply", []);
        };

        //source.data.attachEvent("onStoreLoad", insync);
        this._sync_events = [
            source.data.attachEvent("onStoreUpdated", function (id, data, mode) {
                insync.call(this);
            }),
            source.data.attachEvent("onIdChange", function (oldid, newid) {
                combo.changeOptionId(oldid, newid);
            })
        ];

        insync.call(source);
    };

    dhtmlXTreeView.prototype.clearAllNodes = function () {
        for (var a in this.items) {
            if (this.items[a].pId == undefined) this._removeItem(a);
        }
    };
    
    dhtmlXTreeView.prototype.item = function (id) {
        if (id === null) return null;
        return {
            id: id,
            text: this.getItemText(id)
        };
    };

    dhtmlXTreeView.prototype.getSelected = function () {
        return this.getSelectedItemId();
    };
    dhtmlXTreeView.prototype.isVisible = function () {
        return true;
    };
    dhtmlXTreeView.prototype.refresh = function () {
        //dummy placeholder
    };

    dhtmlXTreeView.prototype.filter = function (callback, master) {
        //dummy placeholder, because tree doesn't support filtering
        if (this._settings.dataFeed) {
            var filter = {};
            if (!callback && !master) return;
            if (typeof callback == "function") {
                if (!master) return;
                callback(master, filter);
            } else if (dhx.isUndefined(callback))
                filter = master;
            else
                filter[callback] = master;

            this.deleteChildItems(0);
            var url = this._settings.dataFeed;
            if (typeof url == "function")
                return url.call(this, [(data.id || data), data]);
            var urldata = [];
            for (var key in filter)
                urldata.push("dhx_filter[" + key + "]=" + encodeURIComponent(filter[key]));

            this.loadXML(url + (url.indexOf("?") < 0 ? "?" : "&") + urldata.join("&"));
            return false;
        }
    };

    dhtmlXTreeView.prototype.update = function (id, data) {
        if (!dhx.isUndefined(data.text))
            this.setItemText(id, data.text);
    };
}


if (window.dhtmlXCheckBox) {
    dhtmlXCheckBox.prototype.bind = function () {
        dhx.BaseBind.bind.apply(this, arguments);
    };
    dhtmlXCheckBox.unbind = function (target) {
        dhx.BaseBind._unbind.call(this, target);
    }
    dhtmlXCheckBox.unsync = function (target) {
        dhx.BaseBind._unbind.call(this, target);
    }

    dhtmlXCheckBox.prototype.dataFeed = function (value) {
        if (this._settings)
            this._settings.dataFeed = value;
        else
            this._server_feed = value;
    };

    dhtmlXCheckBox.prototype.sync = function (source, rule, cellObj) {
        if (this._initBindSource) this._initBindSource();
        if (source._initBindSource) source._initBindSource();

        var checkbox = this;
        checkbox.rule = rule;
        checkbox.datastore = source;
        var insync = function (ignore) {
            checkbox.clearAll();
            var values = cellObj.getValue().split(",").map(function (v) { return dhx4.trim(v) });
            var ids = source.data.order;
            var result = [];
            for (var i = 0; i < ids.length; i++) {
                var el = source.data.pull[ids[i]];
                result.push({
                    id: ids[i],
                    text: el[rule.text] + "",
                    value: el[rule.value] + "",
                    checked: values.indexOf(el[rule.value]) == "-1" ? false : true
                });
            }
            checkbox.addOption(result, rule);
        };
        this._sync_events = [
			source.data.attachEvent("onStoreUpdated", function (id, data, mode) {
			    insync.call(this);
			}),
			source.data.attachEvent("onIdChange", function (oldid, newid) {
			    checkbox.changeOptionId(oldid, newid);
			})
        ];
        source.attachEvent("onXLE", function () { checkbox.callEvent("onXLE", []) });
        insync.call(source);
    };
    dhtmlXCheckBox.prototype._initBindSource = function () {
        if (dhx.isUndefined(this._settings)) {
            this._settings = {
                id: dhx.uid(),
                dataFeed: this._server_feed
            };
            dhx.ui.views[this._settings.id] = this;

            this.data = {
                silent: dhx.bind(function (code) {
                    code.call(this);
                }, this)
            };

            this.dhtmlxEventable(this.data);

            this.attachEvent("onChange", function () {
                this.callEvent("onSelectChange", [this.getSelectedValue()]);
            });
            this.attachEvent("onXLE", function () {
                this.callEvent("onBindRequest", []);
            });
        }
    };

    dhtmlXCheckBox.prototype.dhtmlxEventable = function (obj) {
        obj.attachEvent = function (name, catcher, callObj) {
            name = 'ev_' + name.toLowerCase();
            if (!this[name])
                this[name] = new this.eventCatcher(callObj || this);

            return (name + ':' + this[name].addEvent(catcher)); //return ID (event name & event ID)
        }
        obj.callEvent = function (name, arg0) {
            name = 'ev_' + name.toLowerCase();
            if (this[name])
                return this[name].apply(this, arg0);
            return true;
        }
        obj.checkEvent = function (name) {
            return (!!this['ev_' + name.toLowerCase()])
        }
        obj.eventCatcher = function (obj) {
            var dhx_catch = [];
            var z = function () {
                var res = true;
                for (var i = 0; i < dhx_catch.length; i++) {
                    if (dhx_catch[i] != null) {
                        var zr = dhx_catch[i].apply(obj, arguments);
                        res = res && zr;
                    }
                }
                return res;
            }
            z.addEvent = function (ev) {
                if (typeof (ev) != "function")
                    ev = eval(ev);
                if (ev)
                    return dhx_catch.push(ev) - 1;
                return false;
            }
            z.removeEvent = function (id) {
                dhx_catch[id] = null;
            }
            return z;
        }
        obj.detachEvent = function (id) {
            if (id != false) {
                var list = id.split(':');           //get EventName and ID
                this[list[0]].removeEvent(list[1]); //remove event
            }
        }
        obj.detachAllEvents = function () {
            for (var name in this) {
                if (name.indexOf("ev_") == 0) {
                    this.detachEvent(name);
                    this[name] = null;
                }
            }
        }
        obj = null;
    };

}


if (window.dhtmlXFileUpload) {

    dhtmlXFileUpload.prototype.serializeUploadData = function (data) {
        var result = [];
        for(var i = 0; i < data.length; i++){
            result.push({
                id: data[i].id,
                name: data[i][this.rule.name] || "",
                size: data[i][this.rule.size] || "",
                extend: data[i][this.rule.ext] || "",
                path: data[i][this.rule.path] || "",
                docid: data[i][this.rule.docid] || ""
            });
        }
        return result;
    };

    dhtmlXFileUpload.prototype.sync = function (source, rule) {
        if (this._initBindSource) this._initBindSource();
        if (source._initBindSource) source._initBindSource();
        var uploader = this;
        uploader.rule = rule;
        uploader.datastore = source;

        var insync = function (ignore) {
            //uploader.clear();
            var datas = uploader.serializeUploadData(this.serialize());
            uploader.setDatas(datas);
            uploader.addItems();
        };

        this._sync_events = [
			source.data.attachEvent("onStoreUpdated", function (id, data, mode) {
			    insync.call(this);
			})
        ];
        //如果数据集开始就有值，就会出现重复的图片
        insync.call(source);
    };
}
/*jsl:end*/


})();
;
