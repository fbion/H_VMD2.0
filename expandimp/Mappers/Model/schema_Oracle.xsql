<?xml version="1.0" encoding="utf-8" ?>
<mapper>
  <select id="table">
    select a.table_name as table_name, b.comments as  table_comment,table_type as table_type
    from user_tables a, user_tab_comments b
    where a.table_name = b.table_name
     <if type="isNotEmpty"  property="table_names" >
       <foreach property="table_names" separator = "','" open="('" close="')">
        and a.table_name  in {0}
      </foreach> 
    </if>
    <text>
       order by a.table_name
    </text>
  </select>
  <select id="view">
    select a.view_name table_name,
    b.comments as table_comment,
    b.table_type table_type,
    dbms_metadata.get_ddl(b.table_type, a.view_name) Ddl_Content
    from user_views a, user_tab_comments b
    where a.view_name = b.table_name
    <if type="isNotEmpty"  property="view_names" >
       <foreach property="view_names" separator = "','" open="('" close="')">
        and a.view_name  in {0}
      </foreach> 
    </if>
    <text>
    order by a.view_name
    </text>
  </select>
  <select id="tablecolumn">
    select a.table_name as table_name,
    b.column_name as column_name,
    b.comments as column_comment,
    a.data_type as data_type,
    case
    when a.data_type = 'NVARCHAR2' then
    a.data_length / 2
    else
    a.data_length
    end as column_size,
    a.data_precision as column_precision,
    a.data_scale as column_scale,
    a.nullable as nullable_ind,
    case
    when c.column_name is not null then
    'Y'
    ELSE
    null
    end as primary_key_ind,
    a.column_id as column_sequence,
    a.data_default as default_value_method
    from user_tab_columns a,
    user_col_comments b,
    (select c2.table_name, c1.column_name, c2.constraint_name
    from user_cons_columns c1, user_constraints c2
    where c1.constraint_name = c2.constraint_name
    and c2.constraint_type = 'P') c,
    user_tables d
    where a.table_name = b.table_name
    and a.column_name = b.column_name
    and a.table_name = d.table_name
    and a.table_name = c.table_name(+)
    and a.column_name = c.column_name(+)
    <if type="isNotEmpty"  property="table_names" >
       <foreach property="table_names" separator = "','" open="('" close="')">
        and a.table_name  in {0}
      </foreach> 
    </if>
    <text>
      order by a.table_name, a.column_id asc
    </text>
  </select>
  <select id="viewcolumn">
    select a.table_name as table_name,
    b.column_name as column_name,
    b.comments as column_comment,
    a.data_type as data_type,
    case
    when a.data_type = 'NVARCHAR2' then
    a.data_length / 2
    else
    a.data_length
    end as column_size,
    a.data_precision as column_precision,
    a.data_scale as column_scale,
    a.nullable as nullable_ind,
    a.column_id as column_sequence,
    a.data_default as default_value_method
    from user_tab_columns a,
    user_col_comments b,
    user_views d
    where a.table_name = b.table_name
    and a.column_name = b.column_name
    and a.table_name = d.view_name
     <if type="isNotEmpty"  property="view_names" >
       <foreach property="view_names" separator = "','" open="('" close="')">
        and a.table_name  in {0}
      </foreach> 
    </if>
    <text>
      order by a.table_name, a.column_id asc
    </text>
  </select>
  <select id="index">
    select distinct a.index_name as index_name,
    a.index_name as index_id,
    a.table_name as table_name,
    b.uniqueness as unique_ind,
    b.index_type as index_category
    from user_ind_columns a, user_indexes b
    where a.index_name = b.index_name
     <if type="isNotEmpty"  property="table_names" >
       <foreach property="table_names" separator = "','" open="('" close="')">
        and a.table_name  in {0}
      </foreach> 
    </if>
    <text>
        order by index_name
    </text>
 
  </select>
  <select id="indexcolumn">
    select a.index_name      as index_name,
    a.index_name as index_id,
    a.table_name      as table_name,
    a.column_name     as index_column,
    a.column_position as index_seq_no,
    b.uniqueness      as unique_ind,
    b.index_type      as index_category
    from user_ind_columns a, user_indexes b
    where a.index_name = b.index_name
      <if type="isNotEmpty"  property="table_names" >
       <foreach property="table_names" separator = "','" open="('" close="')">
        and a.table_name  in {0}
      </foreach> 
    </if>
    <text>
       order by index_name, column_position
    </text>
  </select>
  <select id="constraint">
   select a.constraint_name as constraint_name,
       a.table_name as table_name,
       case a.constraint_type
         when 'R' then
          'Foreign'
         when 'P' then
          'Primary'
         when 'U' then
          'Unique'
       end as constraint_type,
       a.r_constraint_name as referenced_constraint_name,
       b.table_name as referenced_table_name,
       a.delete_rule as delete_rule,
       b.constraint_type as constraint_type1
  from user_constraints a
  left join user_constraints b
    on a.r_constraint_name = b.constraint_name
 where a.constraint_type = 'R'
   <if type="isNotEmpty"  property="table_names" >
       <foreach property="table_names" separator = "','" open="('" close="')">
        and a.table_name  in {0}
      </foreach> 
    </if>
  </select>
  <select id="constraintcolumn">
  with w1 as
  (select t1.constraint_name,
          t1.table_name,
          t.constraint_type,
          t1.column_name,
          t.r_constraint_name,
          t1.position
     from user_cons_columns t1, user_constraints t
    where t1.constraint_name = t.constraint_name)
 select t.constraint_name   as constraint_name,
        t.table_name        as table_name,
        t.column_name      as  column_name,
        t.r_constraint_name as referenced_constraint_name,
        t1.table_name       as referenced_table_name,
        t1.column_name      as referenced_column_name,
        t.position          as constraint_seq_no
   from w1 t
   left join w1 t1
     on t.r_constraint_name = t1.constraint_name
    and t.position = t1.position
  where t.constraint_type = 'R'
    <if type="isNotEmpty"  property="table_names" >
       <foreach property="table_names" separator = "','" open="('" close="')">
        and t.table_name  in {0}
      </foreach> 
    </if>
  </select>
  <select id="procedure">
    select t.object_name procedure_id,
    nvl(procedure_name, object_name) as procedure_name,
    t.object_type procedure_type,
    dbms_metadata.get_ddl(t.object_type, t.object_name) ddl_content
    from user_procedures t
    <where>
      <if type="isNotEmpty"  property="procedure_names" >
       <foreach property="procedure_names" separator = "','" open="('" close="')">
          t.procedure_name  in {0}
      </foreach> 
    </if>
       </where>
    <text>
    order by t.object_type, t.object_name
    </text>
  </select>
</mapper>


 