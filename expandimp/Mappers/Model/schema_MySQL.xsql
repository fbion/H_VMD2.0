<?xml version="1.0" encoding="utf-8" ?>
<mapper>
  <select id="table">
    select upper(table_name) as table_name,  table_comment  as table_comment,'Table' as table_type
    from information_schema.tables where   table_type='BASE TABLE'  and table_schema=database()
    <if type="isNotEmpty"  property="table_names" >
      <foreach property="table_names" separator = "','" open="('" close="')">
        and table_name  in {0}
      </foreach>
    </if>
    <text>
      order by table_name
    </text>
  </select>
  <select id="view">
    select
    upper(a.table_name) as table_name,
    a.table_name as table_comment,
    'view' as table_type,
    concat('create or replace view ',a.table_name,' as (',a.view_definition,')') as ddl_content
    from
    information_schema.views a
    where table_schema = database()
    <if type="isNotEmpty"  property="view_names" >
      <foreach property="view_names" separator = "','" open="('" close="')">
        and a.table_name  in {0}
      </foreach>
    </if>
    <text>
      order by a.table_name
    </text>
  </select>
  <select id="tablecolumn">
    select
    upper(a.table_name) as table_name,
    column_name as column_name,
    column_comment as column_comment,
    upper(data_type) as data_type,
    character_maximum_length as column_size,
    numeric_precision as column_precision,
    numeric_scale as column_scale,
    case
    when is_nullable = 'YES' then
    'Y'
    else
    'N'
    end kz,
    case
    when column_key = 'pri' then
    'Y'
    else
    null
    end as primary_key_ind,
    ordinal_position as column_sequence,
    column_default as default_value_method
    from
    information_schema.columns a,information_schema.tables b
    where a.table_name=b.table_name   and a.table_schema=b.table_schema
    and a.table_schema = database() and   b.table_type='BASE TABLE'
    <if type="isNotEmpty"  property="table_names" >
    <foreach property="table_names" separator = "','" open="('" close="')">
      and a.table_name  in {0}
    </foreach>
  </if>
  <text>
    order by a.table_name, a.ordinal_position asc
  </text>
  </select>
  <select id="viewcolumn">
    select
    upper(a.table_name) as table_name,
    column_name as column_name,
    column_comment as column_comment,
    upper(data_type) as data_type,
    character_maximum_length as column_size,
    numeric_precision as column_precision,
    numeric_scale as column_scale,
    case
    when is_nullable = 'YES' then
    'Y'
    else
    'N'
    end kz,
    case
    when column_key = 'pri' then
    'Y'
    else
    null
    end as primary_key_ind,
    ordinal_position as column_sequence,
    column_default as default_value_method
    from
    information_schema.columns a,information_schema.tables b
    where a.table_name=b.table_name   and a.table_schema=b.table_schema
    and a.table_schema = database() and   b.table_type='VIEW'
    <if type="isNotEmpty"  property="view_names" >
      <foreach property="view_names" separator = "','" open="('" close="')">
        and a.table_name  in {0}
      </foreach>
    </if>
    <text>
      order by a.table_name, a.ordinal_position asc
    </text>
  </select>
  <select id="index">
    select distinct a.index_name as index_name,
    a.index_name as index_id,
    a.table_name as table_name,
    b.uniqueness as unique_ind,
    b.index_type as index_category
    from user_ind_columns a, user_indexes b
    where a.index_name = b.index_name
    <if type="isNotEmpty"  property="table_names" >
      <foreach property="table_names" separator = "','" open="('" close="')">
        and a.table_name  in {0}
      </foreach>
    </if>
    <text>
      order by index_name
    </text>

  </select>
  <select id="indexcolumn">
    select a.index_name      as index_name,
    a.index_name as index_id,
    a.table_name      as table_name,
    a.column_name     as index_column,
    a.column_position as index_seq_no,
    b.uniqueness      as unique_ind,
    b.index_type      as index_category
    from user_ind_columns a, user_indexes b
    where a.index_name = b.index_name
    <if type="isNotEmpty"  property="table_names" >
      <foreach property="table_names" separator = "','" open="('" close="')">
        and a.table_name  in {0}
      </foreach>
    </if>
    <text>
      order by index_name, column_position
    </text>
  </select>
  <select id="constraint">
    select a.constraint_name as constraint_name,
    a.table_name as table_name,
    case a.constraint_type
    when 'R' then
    'Foreign'
    when 'P' then
    'Primary'
    when 'U' then
    'Unique'
    end as constraint_type,
    a.r_constraint_name as referenced_constraint_name,
    b.table_name as referenced_table_name,
    a.delete_rule as delete_rule,
    b.constraint_type as constraint_type1
    from user_constraints a
    left join user_constraints b
    on a.r_constraint_name = b.constraint_name
    where a.constraint_type = 'R'
    <if type="isNotEmpty"  property="table_names" >
      <foreach property="table_names" separator = "','" open="('" close="')">
        and a.table_name  in {0}
      </foreach>
    </if>
  </select>
  <select id="constraintcolumn">
    with w1 as
    (select t1.constraint_name,
    t1.table_name,
    t.constraint_type,
    t1.column_name,
    t.r_constraint_name,
    t1.position
    from user_cons_columns t1, user_constraints t
    where t1.constraint_name = t.constraint_name)
    select t.constraint_name   as constraint_name,
    t.table_name        as table_name,
    t.column_name      as  column_name,
    t.r_constraint_name as referenced_constraint_name,
    t1.table_name       as referenced_table_name,
    t1.column_name      as referenced_column_name,
    t.position          as constraint_seq_no
    from w1 t
    left join w1 t1
    on t.r_constraint_name = t1.constraint_name
    and t.position = t1.position
    where t.constraint_type = 'R'
    <if type="isNotEmpty"  property="table_names" >
      <foreach property="table_names" separator = "','" open="('" close="')">
        and t.table_name  in {0}
      </foreach>
    </if>
  </select>
  <select id="procedure">
    select specific_name as procedure_id,
    name as procedure_name,
    type as procedure_type,
    convert(body_utf8 USING  utf8 ) as ddl_content
    from mysql.proc  t
    <where>
      db=database()
      <if type="isNotEmpty"  property="procedure_names" >
        <foreach property="procedure_names" separator = "','" open="('" close="')">
          and  t.name  in {0}
        </foreach>
      </if>
    </where>
    <text>
      order by t.type, t.name
    </text>
  </select>
</mapper>


 